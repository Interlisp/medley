(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)
(FILECREATED "15-Jun-90 14:09:54" {DSK}<usr>local>lde>lispcore>internal>library>DSKTEST.;2 62325  

      changes to%:  (VARS DSKTESTCOMS)
                    (FNS TESTEOFOP)

      previous date%: " 7-Dec-88 11:51:36" {DSK}<usr>local>lde>lispcore>internal>library>DSKTEST.;1
)


(* ; "
Copyright (c) 1984, 1985, 1986, 1987, 1988, 1990 by Venue & Xerox Corporation.  All rights reserved.
")

(PRETTYCOMPRINT DSKTESTCOMS)

(RPAQQ DSKTESTCOMS
       (
        (* ;; "This program is a file system tester.  It is suitable for testing any random-access filing device.  It is NOT intended for customer release.  DSKTEST is the entry function.")

        (FNS DSKTEST DELETETESTFILES)
        (FNS CHECKCONSISTENCY CHECKLENGTHANDCONTENTS CHOOSERANDOMFILEOPERATION DEFAULT.DSKFREEPAGESFN
             DEFAULT.DSKMINALLOCFN DEFAULT.DSKPAGESOVERHEADFN DOTESTFILEOP DSKFREEPAGES DSKMINALLOC 
             DSKPAGESOVERHEAD EXTENDTESTFILE FILEINFOFROMFILE GENERATEADDFILEOP GENERATECHANGEFILEOP
             GENERATEDELETEFILEOP GENERATEEOFPFILEOP GENERATEPEEKBINFILEOP GENERATEDELETEALLFILEOP 
             RANDOMELT RANDOMFILELENGTH RANDOMFILENAME RANDOMSTR RANDOMTESTFILE SORTBYCAR TESTFILEP 
             TESTEOFP TESTEOFOP TESTFILEPTR TESTPEEKBIN TRUNCATETESTFILE WORDIN WORDOUT DOUBLEWORDIN
             DOUBLEWORDOUT WRITETESTFILE WRITETESTFILELENGTH)
        (VARS (DSKFREEPAGESFN (FUNCTION DEFAULT.DSKFREEPAGESFN))
              (DSKPAGESOVERHEADFN (FUNCTION DEFAULT.DSKPAGESOVERHEADFN))
              (DSKMINALLOCFN (FUNCTION DEFAULT.DSKMINALLOCFN)))
        [VARS (MINTESTFILELENGTH 10)
              (FIRSTTESTWORD 48094)
              (SECONDTESTWORD 56187)
              (NUMBEROFTESTBYTES 5)
              (EXHAUSTIVETESTFLG)
              (DEFAULTREPLAYFILE '{PHYLUM}<LISPCORE>DLIONFS>REPLAY.LOG)
              (DONTCLOSEFILESFLG)
              (LEGALFILENAMECHARS '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g
                                      h i j k l m n o p q r s t u v w x y z 0 1 2 3 4 5 6 7 8 9))
              (LEGALFIRSTFILENAMECHARS '(A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d
                                           e f g h i j k l m n o p q r s t u v w x y z]
        (VARS (MINFILENAMELENGTH 1)
              (MAXFILENAMELENGTH 15)
              (MINFILEEXTENSIONLENGTH 0)
              (MAXFILEEXTENSIONLENGTH 6)
              (MAXVERSION 64000)
              TESTFILEPAGELENGTHS)
        (GLOBALVARS FIRSTTESTWORD SECONDTESTWORD MINTESTFILELENGTH NUMBEROFTESTBYTES 
               EXHAUSTIVETESTFLG DSKFREEPAGESFN DSKPAGESOVERHEADFN TESTFILEPAGELENGTHS)
        (RECORDS TESTFILEINFO TESTFILEOP)))



(* ;; 
"This program is a file system tester.  It is suitable for testing any random-access filing device.  It is NOT intended for customer release.  DSKTEST is the entry function."
)

(DEFINEQ

(DSKTEST
  [LAMBDA (HOST/DIR KEEPREPLAYFILEFLG NUMOPERATIONS CURRENTFILES? DSKTESTBACKUP LOGFILE REPLAYFILE)
                                                             (* ; "Edited  6-Dec-88 19:31 by jds")
                                                             (* ; 
                                                        "note: SOME OF THIS MAY NOT BE IMPLEMENTED")

    (* ;; "this is a tester for file systems.  Basically it adds, deletes, extends and truncates files of various names and versions checking the consistency of the file system after each operation.  A log is kept of the operations so that it can be replayed to duplicate problems that may arise.")

    (* ;; "the two variables DSKFREEPAGESFN and DSKPAGESOVERHEADFN should be set to functions that return the number of free pages available and the overhead for a file with a given number of pages.")

    (* ;; "CURRENTFILES?  controls what the tester does with current files.  NIL means that their existance will be checked each time but not their contents.  T means that the files will be copied into directory DSKTESTBACKUP {defaults is CORE} and their contents will be checked.  DELETE will delete all of the test files before the test starts but will leave non test files on the directory.  Files written by DSKTEST have a two word key plus length which marks them as DSKTEST files.  The rest of them is all the same byte.")

    (* ;; "EXHAUSTIVEFLG if non-NIL indicates that every pass through, the entire contents of each file is checked.  Otherwise NUMBEROFTESTBYTES random bytes are examined each time.")

    (* ;; "LOGFILE is where print of progress is put {default to T}.  If KEEPREPLAYFILEFLG is T, REPLAYFILE is where the log of event suitable for replaying is kept {default is DEFAULTREPLAYFILE }.  If KEEPREPLAYFILEFLG is a file name, events are taken from that file until the last one.  Before the last event, BREAK1 is called.")

    (* ;; "DONTCLOSEFILESFLG if non-NIL indicates that files should be left open.  This should be faster as it avoids opening and closing files.")
                                                             (* ; 
                       "TESTFILEPAGELENGTHS is a list of page lengths that the files will be near.")
    (COND
       ((NOT (DIRECTORYNAME HOST/DIR))
        (CL:ERROR "Can't connect to directory ~A." HOST/DIR)))
    (SETQ HOST/DIR (DIRECTORYNAME HOST/DIR))
    (RESETLST
        (PROG ((NUMBEROFOPERATIONSDONE 0)
               FILESINFO FILEOP X FROMREPLAYFILE STARTINGTIME)
              [COND
                 [LOGFILE (SETQ LOGFILE (OPENSTREAM LOGFILE 'OUTPUT]
                 (T (SETQ LOGFILE T)
                    (COND
                       ([SETQ X (WFROMDS (GETSTREAM T 'OUTPUT]
                                                             (* ; "stop page holding")
                        (RESETSAVE (WINDOWPROP X 'PAGEFULLFN (FUNCTION NILL))
                               (LIST 'WINDOWPROP X 'PAGEFULLFN NIL]
              (COND
                 ((EQ KEEPREPLAYFILEFLG T)
                  (COND
                     [REPLAYFILE (SETQ REPLAYFILE (OPENSTREAM REPLAYFILE 'OUTPUT]
                     (T (SETQ REPLAYFILE DEFAULTREPLAYFILE)))(* ; 
                                                     "create a replay file and save its full name.")
                  (SETQ REPLAYFILE (OPENSTREAM REPLAYFILE 'OUTPUT))
                  (CLOSEF REPLAYFILE))
                 (KEEPREPLAYFILEFLG                          (* ; "use replay file")
                        (COND
                           ((SETQ FROMREPLAYFILE (OPENSTREAM KEEPREPLAYFILEFLG 'INPUT))
                            (SETFILEPTR FROMREPLAYFILE 0))
                           (T (ERROR KEEPREPLAYFILEFLG "replay file not found")))
                                                             (* ; 
                                                  "set so that no replay will be made of this run.")
                        (SETQ KEEPREPLAYFILEFLG)))           (* ; 
                                                           "connect to the tested directory.")
                                                             (* ; 
                              "RESETSAVE (CNDIR HOST/DIR) (LIST (QUOTE CNDIR) (DIRECTORYNAME T T))")
              (COND
                 ((EQ CURRENTFILES? 'DELETE)
                  (printout LOGFILE "Deleting any test files ...." T)
                  (DELETETESTFILES HOST/DIR)
                  (printout LOGFILE T)))
              [COND
                 [(AND CURRENTFILES? (NEQ CURRENTFILES? 'DELETE))
                                                             (* ; 
                                                           "check their contents after every sweep")
                  (printout T "Not implemented to check old file contents yet.")

                  (* ;; "this should copy each file into the backup directory and set the copy as the contents of the file information for the non-test files.")

                  (SETQ FILESINFO (for FILE in (SORT (DIRECTORY HOST/DIR))
                                     collect (FILEINFOFROMFILE FILE]
                 (T (SETQ FILESINFO (for FILE in (SORT (DIRECTORY HOST/DIR))
                                       collect (FILEINFOFROMFILE FILE]
              (SETQ STARTINGTIME (DATE))
              (printout LOGFILE "Beginning initial check at " STARTINGTIME " ......")
              (CHECKCONSISTENCY FILESINFO HOST/DIR)
              (BLOCK)
              (printout LOGFILE "  done." T)
          LP  (SETQ NUMBEROFOPERATIONSDONE (ADD1 NUMBEROFOPERATIONSDONE))
              [COND
                 ((AND (NUMBERP NUMOPERATIONS)
                       (GREATERP NUMBEROFOPERATIONSDONE NUMOPERATIONS))
                  (RETURN (LIST (SUB1 NUMBEROFOPERATIONSDONE)
                                'operations% done.]          (* ; "choose a new file operation")
              [COND
                 [FROMREPLAYFILE                             (* ; 
                                                           "getting events from the replay file")
                        (SETQ FILEOP (READ FROMREPLAYFILE))
                        (SKIPSEPRS FROMREPLAYFILE)
                        (COND
                           ((EOFP FROMREPLAYFILE)
                            (CLOSEF FROMREPLAYFILE)
                            (SETQ FROMREPLAYFILE)
                            (BREAK1 T T "Before last event on replay file"]
                 (T (SETQ FILEOP (CHOOSERANDOMFILEOPERATION FILESINFO HOST/DIR]
              [COND
                 (KEEPREPLAYFILEFLG                          (* ; 
                                                "put op on REPLAYFILE and make sure it gets there.")
                        (PROG [(STRM (OPENSTREAM REPLAYFILE 'APPEND]
                              (PRINT FILEOP STRM)
                              (CLOSEF STRM]
              (printout LOGFILE ".......... start=" STARTINGTIME "   time=" (DATE)
                     T)
              (PRINT FILEOP LOGFILE)
              (SETQ FILESINFO (DOTESTFILEOP FILEOP FILESINFO HOST/DIR LOGFILE))
              (printout LOGFILE "Consistency check after operation " NUMBEROFOPERATIONSDONE " .....")
              (BLOCK)
              [COND
                 ((NOT DONTCLOSEFILESFLG)

                  (* ;; "All files dshould be closed at this point:")

                  (for FILE in FILESINFO when (for OPENFILE in (OPENP)
                                                             thereis (EQ (FULLNAME OPENFILE)
                                                                             (fetch (TESTFILEINFO
                                                                                         
                                                                                     TESTFILEFULLNAME
                                                                                         )
                                                                                of FILE)))
                     do (HELP "File open that shouldn't be:" (fetch (TESTFILEINFO 
                                                                                   TESTFILEFULLNAME)
                                                                    of FILE]
              (CHECKCONSISTENCY FILESINFO HOST/DIR)
              (printout LOGFILE "  done." T)
              (GO LP)))])

(DELETETESTFILES
  [LAMBDA (HOST/DIR CHECKENTIRECONTENTSFLG)                  (* hts%: "22-Oct-84 16:27")
                                                             (* deletes any TEST files from 
                                                             directory HOST/DIR)
    (for FILE in (DIRECTORY HOST/DIR) when (TESTFILEP FILE (NOT CHECKENTIRECONTENTSFLG))
       do (if (OPENP FILE)
              then (CLOSEF FILE))
          (PRINT (DELFILE FILE)
                 T])
)
(DEFINEQ

(CHECKCONSISTENCY
  [LAMBDA (FILESINFO HOST/DIR)                               (* ; "Edited  2-Nov-87 13:55 by jds")
          
          (* ;; "checks that the state of the currently connected directory (or HOST/DIR, if given) is exactly the same as FILESINFO.")

    (PROG [(DIRFILES (SORT (DIRECTORY HOST/DIR]
          (for DIRFILE in DIRFILES as FILEINFO in FILESINFO
             do (BLOCK)
                [COND
                   ((NEQ (U-CASE DIRFILE)
                         (U-CASE (fetch (TESTFILEINFO TESTFILEFULLNAME) of FILEINFO)))
                                                             (* ; 
                                              "something is wrong with the directory.  Find out what")

                    (COND
                       ((FASSOC (U-CASE DIRFILE)
                               (MEMB FILEINFO FILESINFO))    (* ; "this file shows up later")

                        (ERROR "FILE MISSING .. " (fetch (TESTFILEINFO TESTFILEFULLNAME) of FILEINFO)
                               ))
                       (T (ERROR "NEW FILE HAS APPEARED .. " DIRFILE]
                (CHECKLENGTHANDCONTENTS FILEINFO])

(CHECKLENGTHANDCONTENTS
  [LAMBDA (FILEINFO)                                         (* ; "Edited  4-Nov-87 11:24 by jds")
          
          (* ;; "checks the length and contents of a file from its in core representation.")

    (PROG ((STRM (OPENSTREAM (fetch (TESTFILEINFO TESTFILEFULLNAME) of FILEINFO)
                        'INPUT))
           (FILELENGTH (fetch (TESTFILEINFO FILELENGTH) of FILEINFO))
           (STARTBYTE (fetch (TESTFILEINFO STARTBYTE) of FILEINFO))
           (PERIOD (fetch (TESTFILEINFO PERIOD) of FILEINFO)))
          (COND
             ([NOT (EQP FILELENGTH (GETFILEINFO STRM 'LENGTH]
              (ERROR "FILE has wrong length ... " FILEINFO)))
          [COND
             ((AND STARTBYTE PERIOD (IGEQ FILELENGTH MINTESTFILELENGTH))
          
          (* ;; "test files contain at least enough bytes to hold keys and stuff.  Maybe should have a special test for zero length files.")

              (COND
                 ((OR (NEQ (WORDIN STRM)
                           FIRSTTESTWORD)
                      (NEQ (WORDIN STRM)
                           SECONDTESTWORD)
                      (NOT (EQP FILELENGTH (DOUBLEWORDIN STRM)))
                      (NEQ (BIN STRM)
                           STARTBYTE)
                      (NEQ (BIN STRM)
                           PERIOD))
                  (ERROR "FIRST 10 bytes of file is wrong .. " FILEINFO)))
              [COND
                 ((IGREATERP FILELENGTH MINTESTFILELENGTH)   (* ; 
                                                         "only bother checking if we have data bytes")

                  (COND
                     ((EQ 1 (RAND 1 7))
          
          (* ;; "SCAN ENTIRE FILE once in about every seven tests.")

                      (bind READBYTE (CURVALUE _ STARTBYTE)
                            (BLOCKCOUNT _ 0) for COMPUTEDBYTE from STARTBYTE
                         to (IPLUS STARTBYTE FILELENGTH (IMINUS MINTESTFILELENGTH)
                                   -1) by 1 when [PROGN (COND
                                                           ((ZEROP (SETQ BLOCKCOUNT
                                                                    (IMOD (ADD1 BLOCKCOUNT)
                                                                          100)))
                                                            (BLOCK)))
                                                        (PROG1 (NEQ (SETQ READBYTE (\BIN STRM))
                                                                    CURVALUE)
                                                               (SETQ CURVALUE (IMOD (ADD1 CURVALUE)
                                                                                    PERIOD]
                         do (printout LOGFILE "FILE HAS WRONG BYTE .. " T "should have "
                                   (IMOD COMPUTEDBYTE PERIOD)
                                   " but read " READBYTE " from file" T "at location "
                                   (SUB1 (GETFILEPTR STRM))
                                   T)
                            (ERROR "FILE HAS WRONG BYTE .. " FILEINFO)))
                     (T 

(* ;;; "SPOT CHECK FILE")

                        [bind SPOT COMPUTEDBYTE READBYTE to 7
                           do (BLOCK)
                              (SETQ SPOT (RAND MINTESTFILELENGTH (SUB1 FILELENGTH)))
                              (SETQ COMPUTEDBYTE (PLUS (MINUS MINTESTFILELENGTH)
                                                       SPOT STARTBYTE))
                              (SETFILEPTR STRM SPOT)
                              (COND
                                 ((NEQ (SETQ READBYTE (\BIN STRM))
                                       (IMOD COMPUTEDBYTE PERIOD))
                                  (printout LOGFILE "FILE HAS WRONG BYTE .. " T "should have "
                                         (IMOD COMPUTEDBYTE PERIOD)
                                         " but read " READBYTE " from file" T "at location "
                                         (SUB1 (GETFILEPTR STRM))
                                         T)
                                  (ERROR "FILE HAS WRONG BYTE .. " FILEINFO]
                        (SETFILEPTR STRM FILELENGTH]
              (OR (EOFP STRM)
                  (ERROR "FILE doesn't get EOFP ... " FILEINFO]
          (OR DONTCLOSEFILESFLG (CLOSEF STRM])

(CHOOSERANDOMFILEOPERATION
  [LAMBDA (FILESINFO HOST/DIR)                               (* ; "Edited  2-Nov-87 12:25 by jds")
          
          (* ;; "chooses a random file operation add delete setlength on a random file and return a TESTFILEOP record for it.")

    (COND
       [FILESINFO (PROG ((RANDNUM (RAND 1 300)))
                        (RETURN (COND
                                   ((ILEQ RANDNUM 75)        (* ; "add a file")

                                    (GENERATEADDFILEOP FILESINFO NIL HOST/DIR))
                                   ((ILEQ RANDNUM 125)       (* ; "Change the length of a file")

                                    (GENERATECHANGEFILEOP FILESINFO HOST/DIR))
                                   ((ILEQ RANDNUM 175)       (* ; "delete a file")

                                    (GENERATEDELETEFILEOP FILESINFO NIL HOST/DIR))
                                   ((ILEQ RANDNUM 225)       (* ; "do EOFP test")

                                    (GENERATEEOFPFILEOP FILESINFO HOST/DIR))
                                   ((ILEQ RANDNUM 295)       (* ; "do PEEKBIN test")

                                    (GENERATEPEEKBINFILEOP FILESINFO HOST/DIR))
                                   (T                        (* ; "delete all files once in a while")

                                      (GENERATEDELETEALLFILEOP]
       (T                                                    (* ; "add a file")

          (GENERATEADDFILEOP FILESINFO NIL HOST/DIR])

(DEFAULT.DSKFREEPAGESFN
  [LAMBDA (HOST/DIR)                                     (* mjs "17-Apr-86 14:59")
    (SELECTQ (FILENAMEFIELD HOST/DIR 'HOST)
        (DSK (SELECTQ (MACHINETYPE)
                 ((DORADO) 
                      (DISKFREEPAGES HOST))
                 ((DANDELION DOVE) 
                      (DISKFREEPAGES HOST/DIR))
                 (MAIKO 500)
                 (SHOULDNT)))
        (FLOPPY (FLOPPY.FREE.PAGES))
        (PCDISK                                              (* remember to strip trailing colon 
                                                           off of device name!!)
                (VPCDISK.FREEPAGES (SUBATOM (FILENAMEFIELD HOST/DIR 'DEVICE)
                                          1 -2)))
        MAX.SMALLP])

(DEFAULT.DSKMINALLOCFN
  [LAMBDA (HOST/DIR)                                     (* mjs "22-Jan-86 12:18")
                                                             (* Default minimum-allocation unit 
                                                           function)
    (SELECTQ (FILENAMEFIELD HOST/DIR 'HOST)
        (DSK (SELECTQ (MACHINETYPE)
                 ((DANDELION DOVE)                           (* DLIONFS allocates 25 at a crackj.)
                      25)
                 ((DOLPHIN DORADO) 
                      1)
                 (MAIKO 1)
                 (SHOULDNT)))
        (FLOPPY 1)
        1])

(DEFAULT.DSKPAGESOVERHEADFN
  [LAMBDA (HOST/DIR NEWFILELENGTH)                       (* mjs "22-Jan-86 12:18")
                                                             (* default overhead function)
    (SELECTQ (FILENAMEFIELD HOST/DIR 'HOST)
        (DSK (SELECTQ (MACHINETYPE)
                 ((DANDELION DOVE) 

         (* * 11 is 5 for worst-case btree split on file, 5 for split on directory, 1 
       for leaderpage; NEWFILELENGTH and \LFrunSize for maximum length file will 
       attain during allocation; and \LFrunSize for possible directory extension.)

                      (PLUS 11 NEWFILELENGTH \LFrunSize \LFrunSize))
                 ((DOLPHIN DORADO) 
                      (IPLUS NEWFILELENGTH 5))
                 (MAIKO (IPLUS NEWFILELENGTH 5))
                 (SHOULDNT)))
        (FLOPPY (IPLUS NEWFILELENGTH 5))
        (IPLUS NEWFILELENGTH 5])

(DOTESTFILEOP
  [LAMBDA (FILEOP FILEINFOLST HOST/DIR LOGFILE)          (* ; "Edited  7-Dec-88 06:03 by jds")

    (* ;; "performs a TESTFILEOPERATION and updates the incore idea about what the directory should now look like.  Returns the changed FILEINFOLST.")
                                                             (* ; 
                                                     "operation can be add, delete or changelength")
    (SELECTQ (fetch (TESTFILEOP TESTOPERATION) of FILEOP)
        (ADD [PROG ((FULLFILE (fetch (TESTFILEOP TESTOPFILENAME) of FILEOP))
                    (BYTELEN (fetch (TESTFILEOP TESTOPFILELENGTH) of FILEOP))
                    (STARTBYTE (fetch (TESTFILEOP STARTBYTE) of FILEOP))
                    (PERIOD (fetch (TESTFILEOP PERIOD) of FILEOP))
                    (OLDDISKFREEPAGES (DSKFREEPAGES HOST/DIR)))
                   (COND
                      ((SETQ FULLFILE (WRITETESTFILE FULLFILE BYTELEN STARTBYTE PERIOD))
                       (BLOCK))
                      (T (ERROR "file wasn't written. " FILEOP)))
                   (COND
                      ((EQ FULLFILE T)
                       (HELP)))
                   (RETURN (SORTBYCAR (CONS (create TESTFILEINFO
                                                       TESTFILEFULLNAME _ FULLFILE
                                                       FILELENGTH _ BYTELEN
                                                       STARTBYTE _ STARTBYTE
                                                       PERIOD _ PERIOD
                                                       TESTFILEORIGNAME _ (fetch (TESTFILEOP
                                                                                      TESTOPFILENAME)
                                                                             of FILEOP))
                                                FILEINFOLST])
        (DELETE (PROG ((DELFILEINFO (fetch (TESTFILEOP TESTOPFILENAME) of FILEOP)))
                      (COND
                         ((DELFILE (fetch (TESTFILEINFO TESTFILEFULLNAME) of DELFILEINFO))
                          (BLOCK))
                         (T (ERROR "file won't delete" DELFILEINFO)))
                      (RETURN (REMOVE DELFILEINFO FILEINFOLST))))
        (DELETEALL (for F in FILEINFOLST unless (PROGN (BLOCK)
                                                                   (DELFILE (fetch (TESTFILEINFO
                                                                                        
                                                                                     TESTFILEFULLNAME
                                                                                        )
                                                                               of F)))
                      do (ERROR "file won't delete" F))
                   NIL)
        (CHANGELENGTH (PROG ((TESTFILE (fetch (TESTFILEINFO TESTFILEFULLNAME)
                                          of (fetch (TESTFILEOP TESTOPFILENAME) of FILEOP
                                                        )))
                             (NEWLENGTH (fetch (TESTFILEOP TESTOPFILELENGTH) of FILEOP))
                             (OLDDISKFREEPAGES (DSKFREEPAGES HOST/DIR))
                             NOWLENGTH CHANGEFILEINFO XFILEINFO)
                            (COND
                               ((SETQ CHANGEFILEINFO (for FILEINFO in FILEINFOLST
                                                        thereis (EQ (fetch (TESTFILEINFO
                                                                                    TESTFILEFULLNAME)
                                                                           of FILEINFO)
                                                                        TESTFILE)))

                                (* ;; "look for the one on FILEINFOLST that has the same name as this one may have been read in from the replay file and not be EQ.")

                                NIL)
                               (T (ERROR "changing a file that is not on file information list." 
                                         CHANGEFILEINFO)
                                  (RETURN)))
                            (COND
                               ((IGREATERP NEWLENGTH (SETQ NOWLENGTH (fetch (TESTFILEINFO 
                                                                                       FILELENGTH)
                                                                        of CHANGEFILEINFO)))
                                                             (* ; "extend the file")
                                (EXTENDTESTFILE TESTFILE (fetch (TESTFILEINFO STARTBYTE)
                                                                of CHANGEFILEINFO)
                                       (fetch (TESTFILEINFO PERIOD) of CHANGEFILEINFO)
                                       NOWLENGTH NEWLENGTH)
                                (BLOCK))
                               (T                            (* ; "truncate the file.")
                                  (TRUNCATETESTFILE TESTFILE NEWLENGTH)))
                            (replace (TESTFILEINFO FILELENGTH) of CHANGEFILEINFO with
                                                                                         NEWLENGTH)
                            (RETURN FILEINFOLST)))
        (EOFP (PROG ((TESTFILE (fetch (TESTFILEINFO TESTFILEFULLNAME) of (fetch
                                                                                  (TESTFILEOP 
                                                                                       TESTOPFILENAME
                                                                                         )
                                                                                    of FILEOP)))
                     (NEWLENGTH (fetch (TESTFILEOP TESTOPFILELENGTH) of FILEOP))
                     (OLDDISKFREEPAGES (DSKFREEPAGES HOST/DIR))
                     NOWLENGTH CHANGEFILEINFO XFILEINFO)
                    (COND
                       ((SETQ CHANGEFILEINFO (for FILEINFO in FILEINFOLST
                                                thereis (EQ (fetch (TESTFILEINFO 
                                                                                  TESTFILEFULLNAME)
                                                                   of FILEINFO)
                                                                TESTFILE)))

                        (* ;; "look for the one on FILEINFOLST that has the same name as this one may have been read in from the replay file and not be EQ.")

                        NIL)
                       (T (ERROR "changing a file that is not on file information list." 
                                 CHANGEFILEINFO)
                          (RETURN)))
                    (TESTEOFP TESTFILE (fetch (TESTFILEINFO STARTBYTE) of CHANGEFILEINFO)
                           (fetch (TESTFILEINFO PERIOD) of CHANGEFILEINFO)
                           NEWLENGTH LOGFILE)
                    (replace (TESTFILEINFO FILELENGTH) of CHANGEFILEINFO with NEWLENGTH)
                    (RETURN FILEINFOLST)))
        (PEEKBIN (PROG ((TESTFILE (fetch (TESTFILEINFO TESTFILEFULLNAME)
                                     of (fetch (TESTFILEOP TESTOPFILENAME) of FILEOP)))
                        CHANGEFILEINFO)
                       (COND
                          ((SETQ CHANGEFILEINFO (for FILEINFO in FILEINFOLST
                                                   thereis (EQ (fetch (TESTFILEINFO 
                                                                                     TESTFILEFULLNAME
                                                                                     ) of 
                                                                                             FILEINFO
                                                                          )
                                                                   TESTFILE)))

                           (* ;; "look for the one on FILEINFOLST that has the same name as this one may have been read in from the replay file and not be EQ.")

                           NIL)
                          (T (ERROR "changing a file that is not on file information list." 
                                    CHANGEFILEINFO)
                             (RETURN)))
                       (TESTPEEKBIN TESTFILE NIL LOGFILE)
                       (RETURN FILEINFOLST)))
        (ERROR "unknown file operation" FILEOP])

(DSKFREEPAGES
  [LAMBDA (HOST/DIR)                                         (* hts%: "29-Apr-84 16:23")
          
          (* returns the number of free pages in the connected directory if it knows how.)

    (APPLY* DSKFREEPAGESFN HOST/DIR])

(DSKMINALLOC
  [LAMBDA (HOST/DIR)                                         (* mjs "22-Jan-86 12:18")
          
          (* Calls the device dependent function that gives the minimum %# of pages the 
          file system will allocate at a crack.)

    (APPLY* DSKMINALLOCFN HOST/DIR])

(DSKPAGESOVERHEAD
  [LAMBDA (HOST/DIR NEWFILELENGTH)                           (* mjs "22-Jan-86 12:18")
          
          (* calls the device dependent function that gives the overhead per file)

    (APPLY* DSKPAGESOVERHEADFN HOST/DIR NEWFILELENGTH])

(EXTENDTESTFILE
  [LAMBDA (FILENAME STARTBYTE PERIOD OLDLENGTH NEWLENGTH)(* ; "Edited  7-Dec-88 05:59 by jds")

    (* ;; "extends a file by writing CONTENTS byte to it until it has length LONGERLENGTH.")

    (COND
       ((OPENP FILENAME)                                     (* ; 
                                                           "file may be open already for read.")
        (CLOSEF FILENAME)))
    (PROG [(STRM (OPENSTREAM FILENAME 'BOTH]
          (COND
             ((NULL STRM)
              (ERROR "file that it supposed to exist won't open for extending." FILENAME)))
                                                             (* ; 
                                                      "update the length count stored in the file.")
          (WRITETESTFILELENGTH STRM NEWLENGTH)
          (SETFILEPTR STRM OLDLENGTH)
          [for BYTE from (IPLUS STARTBYTE OLDLENGTH (IMINUS MINTESTFILELENGTH))
             to (IPLUS STARTBYTE NEWLENGTH (IMINUS MINTESTFILELENGTH)
                           -1) do (BOUT STRM (IMOD BYTE PERIOD))
                                     (COND
                                        ((ZEROP (IMOD BYTE 100))
                                         (BLOCK]
          (OR DONTCLOSEFILESFLG (CLOSEF STRM])

(FILEINFOFROMFILE
  [LAMBDA (FILE)                                             (* hts%: "22-Oct-84 15:44")
                                                             (* returns a TESTFILEINFO record of 
                                                             information about FILE.)
          
          (* keep track of test files differently because contents can be represented as 
          a single byte.)

    (if (EQ FILE T)
        then (HELP "FILE IS T!!?"))
    (PROG ((CONTENTS (TESTFILEP FILE NIL T)))
          (RETURN (create TESTFILEINFO
                         TESTFILEFULLNAME _ FILE
                         FILELENGTH _ (GETFILEINFO FILE 'LENGTH)
                         STARTBYTE _ (CAR CONTENTS)
                         PERIOD _ (CDR CONTENTS])

(GENERATEADDFILEOP
  [LAMBDA (FILEINFOLST STOPIFCANTFLG HOST/DIR)               (* edited%: "13-Aug-85 11:28")
    (PROG ((LENGTH (RANDOMFILELENGTH HOST/DIR))
           (PERIOD (RAND 1 255)))
          (RETURN (COND
                     (LENGTH (create TESTFILEOP
                                    TESTOPERATION _ 'ADD
                                    TESTOPFILENAME _ (RANDOMFILENAME HOST/DIR)
                                    TESTOPFILELENGTH _ LENGTH
                                    STARTBYTE _ (RAND 0 PERIOD)
                                    PERIOD _ PERIOD))
                     (STOPIFCANTFLG (ERROR "probably out of disk space."))
                     (T (GENERATEDELETEFILEOP FILEINFOLST T HOST/DIR])

(GENERATECHANGEFILEOP
  [LAMBDA (FILEINFOLST HOST/DIR)                             (* hts%: "29-Apr-84 16:29")
    (PROG ((FILETOCHANGE (RANDOMTESTFILE FILEINFOLST))
           (LENGTH (RANDOMFILELENGTH HOST/DIR)))
          (RETURN (COND
                     ((NULL FILETOCHANGE)                    (* create a file instead)
                      (GENERATEADDFILEOP FILEINFOLST T HOST/DIR))
                     ((NULL LENGTH)                          (* if can't change the length, try 
                                                             deleting a file.)
                      (GENERATEDELETEFILEOP FILEINFOLST T HOST/DIR))
                     (T (create TESTFILEOP
                               TESTOPERATION _ 'CHANGELENGTH
                               TESTOPFILENAME _ FILETOCHANGE
                               TESTOPFILELENGTH _ LENGTH])

(GENERATEDELETEFILEOP
  [LAMBDA (FILEINFOLST STOPIFNONEFLG HOST/DIR)               (* hts%: "22-Oct-84 16:54")
                                                             (* generates a delete file operation.)
          
          (* if it can't, it generates an file operation to ADD unless STOPIFNONEFLG is T)

    (PROG ((FILETODEL (RANDOMTESTFILE FILEINFOLST)))
          (RETURN (COND
                     (FILETODEL (create TESTFILEOP
                                       TESTOPERATION _ 'DELETE
                                       TESTOPFILENAME _ FILETODEL))
                     (STOPIFNONEFLG (ERROR "No file to delete"))
                     (T (GENERATEADDFILEOP FILEINFOLST T HOST/DIR])

(GENERATEEOFPFILEOP
  [LAMBDA (FILEINFOLST HOST/DIR)                             (* AJB "31-Jul-86 15:46")
    (PROG ((FILETOCHANGE (RANDOMTESTFILE FILEINFOLST))
           (LENGTH (RANDOMFILELENGTH HOST/DIR)))
          (RETURN (COND
                     ((NULL FILETOCHANGE)                    (* create a file instead)
                      (GENERATEADDFILEOP FILEINFOLST T HOST/DIR))
                     ((NULL LENGTH)                          (* if can't change the length, try 
                                                             deleting a file.)
                      (GENERATEDELETEFILEOP FILEINFOLST T HOST/DIR))
                     (T (create TESTFILEOP
                               TESTOPERATION _ 'EOFP
                               TESTOPFILENAME _ FILETOCHANGE
                               TESTOPFILELENGTH _ LENGTH])

(GENERATEPEEKBINFILEOP
  [LAMBDA (FILEINFOLST HOST/DIR)                             (* AJB " 1-Aug-86 10:14")
    (PROG ((FILETOCHANGE (RANDOMTESTFILE FILEINFOLST)))
          (RETURN (COND
                     ((NULL FILETOCHANGE)                    (* create a file instead)
                      (GENERATEADDFILEOP FILEINFOLST T HOST/DIR))
                     ((NULL LENGTH)                          (* if can't change the length, try 
                                                             deleting a file.)
                      (GENERATEDELETEFILEOP FILEINFOLST T HOST/DIR))
                     (T (create TESTFILEOP
                               TESTOPERATION _ 'PEEKBIN
                               TESTOPFILENAME _ FILETOCHANGE])

(GENERATEDELETEALLFILEOP
  [LAMBDA NIL                                                (* hts%: " 5-Jun-84 08:58")
    (create TESTFILEOP
           TESTOPERATION _ 'DELETEALL])

(RANDOMELT
  [LAMBDA (LST)                                              (* rrb "27-Mar-84 09:59")
                                                             (* returns a random element of a list.)
    (CAR (NTH LST (RAND 1 (LENGTH LST])

(RANDOMFILELENGTH
  [LAMBDA (HOST/DIR)                                         (* ; "Edited  2-Nov-87 12:27 by jds")
          
          (* ;; "returns a random file length.  (In bytes) that's guaranteed to fit in the file system in its current state.")

    (PROG ((NPAGES (RANDOMELT TESTFILEPAGELENGTHS))
           (DSKPAGES (DSKFREEPAGES HOST/DIR))
           (MINALLOC (DSKMINALLOC HOST/DIR))
           FILEOVERHEAD)                                     (* ; 
                                         "checks that there are enough free pages to store the file.")

          [COND
             ((ILEQ DSKPAGES (IPLUS MINALLOC (DSKPAGESOVERHEAD HOST/DIR MINALLOC)))
          
          (* ;; "There is no room for this file under any conditions -- there aren't enough pages to allocate a minimum-sized file")

              (RETURN NIL))
             ((IGREATERP (IPLUS NPAGES (SETQ FILEOVERHEAD (DSKPAGESOVERHEAD HOST/DIR NPAGES)))
                     DSKPAGES)
          
          (* ;; "There is room for A file.  Now pick a file size that will fit.  FILEOVERHEAD should be a high estimate of the overhead for the file, since the new NPAGES will be lower than the prior number.")

              (SETQ NPAGES (IDIFFERENCE DSKPAGES FILEOVERHEAD]
                                                             (* ; 
                                          "weight to return a length around an even number of pages.")

          (RETURN (IMAX MINTESTFILELENGTH (IPLUS (ITIMES NPAGES BYTESPERPAGE)
                                                 (SELECTQ (RAND 0 3)
                                                     (0 0)
                                                     (1 1)
                                                     (2 -1)
                                                     (RAND -511 512])

(RANDOMFILENAME
  [LAMBDA (HOST/DIR)                                         (* mjs "18-Apr-86 08:27")
                                                             (* generates a random file name.)
    (U-CASE (PACK* HOST/DIR (COND
                               [(EQ 'PCDISK (FILENAMEFIELD HOST/DIR 'HOST))
                                (PACKFILENAME 'NAME (RANDOMSTR (RAND 1 6))
                                       'EXTENSION
                                       (RANDOMSTR (RAND 0 3]
                               (T (PACKFILENAME 'NAME (RANDOMSTR (RAND MINFILENAMELENGTH 
                                                                       MAXFILENAMELENGTH))
                                         'EXTENSION
                                         (RANDOMSTR (RAND MINFILEEXTENSIONLENGTH 
                                                          MAXFILEEXTENSIONLENGTH))
                                         'VERSION
                                         (SELECTQ (RAND 0 1)
                                             (0              (* give an explicit extension)
                                                (RAND 1 MAXVERSION))
                                             NIL])

(RANDOMSTR
  [LAMBDA (NCHARS)                                           (* rrb "27-Mar-84 09:38")
                                                             (* returns a random string NCHARS 
                                                             long.)
    (PACK (CONS [CAR (NTH LEGALFIRSTFILENAMECHARS (RAND 1 (LENGTH LEGALFIRSTFILENAMECHARS]
                (bind (%#LEGALFILENAMECHARS _ (LENGTH LEGALFILENAMECHARS)) for I from 1
                   to (SUB1 NCHARS) collect (CAR (NTH LEGALFILENAMECHARS (RAND 1 %#LEGALFILENAMECHARS
                                                                               ])

(RANDOMTESTFILE
  [LAMBDA (FILEINFOLST)                                      (* hts%: "22-Oct-84 16:10")
          
          (* chooses a random test file from FILEINFOLST.
          This avoids deleting not test files.)

    (PROG ((NTESTFILES (for FILE in FILEINFOLST when (SMALLP (fetch (TESTFILEINFO STARTBYTE)
                                                                of FILE)) sum 1))
           NFILE)
          (RETURN (if (NEQ NTESTFILES 0)
                      then (SETQ NFILE (RAND 1 NTESTFILES))
                           (for FILE in FILEINFOLST when (SMALLP (fetch (TESTFILEINFO STARTBYTE)
                                                                    of FILE))
                              do (if (ZEROP (SETQ NFILE (SUB1 NFILE)))
                                     then (RETURN FILE])

(SORTBYCAR
  [LAMBDA (LST)                                          (* ; "Edited  6-Dec-88 22:54 by jds")
                                                             (* sorts a list by its CARs)
    (SORT LST (FUNCTION (LAMBDA (A B)
                          (ALPHORDER (U-CASE (CAR A))
                                 (U-CASE (CAR B])

(TESTFILEP
  [LAMBDA (FILE HINTONLYFLG RETURNCONTENTSFLG)               (* ; "Edited  3-Nov-87 16:26 by jds")
          
          (* ;; "determines if a file is a test file.")

    (PROG ((STRM (OPENSTREAM FILE 'INPUT))
           FILELENGTH STARTBYTE PERIOD)
          (SETQ FILELENGTH (GETFILEINFO STRM 'LENGTH))
          (RETURN (PROG1 [COND
                            ((ILESSP FILELENGTH MINTESTFILELENGTH)
          
          (* ;; "test files contain at least enough bytes to hold keys and stuff.  Maybe should have a special test for zero length files.")

                             NIL)
                            ((AND (EQ (WORDIN STRM)
                                      FIRSTTESTWORD)
                                  (EQ (WORDIN STRM)
                                      SECONDTESTWORD)
                                  (EQP FILELENGTH (DOUBLEWORDIN STRM)))
                             (COND
                                (HINTONLYFLG                 (* ; 
                                                   "if asking about hint only, don't check contents.")

                                       (COND
                                          (RETURNCONTENTSFLG (CONS (BIN STRM)
                                                                   (BIN STRM)))
                                          (T FILE)))
                                (T (SETQ STARTBYTE (BIN STRM))
                                   (SETQ PERIOD (BIN STRM))
                                   (bind (RUNNINGVALUE _ STARTBYTE) for COMPUTEDBYTE from STARTBYTE
                                      to (IPLUS STARTBYTE FILELENGTH -1 (IMINUS MINTESTFILELENGTH))
                                      when (PROG1 (NEQ (BIN STRM)
                                                       RUNNINGVALUE)
                                                  (SETQ RUNNINGVALUE (IMOD (ADD1 RUNNINGVALUE)
                                                                           PERIOD)))
                                      do (RETURN NIL) finally (RETURN (COND
                                                                         (RETURNCONTENTSFLG
                                                                          (CONS STARTBYTE PERIOD))
                                                                         (T FILE]
                         (CLOSEF STRM])

(TESTEOFP
  [LAMBDA (FILENAME STARTBYTE PERIOD NEWLENGTH LOGFILE)  (* ; "Edited  7-Dec-88 06:04 by jds")

    (* ;; "Test the EOFP method for this file device.")

    (COND
       ((OPENP FILENAME)                                     (* ; 
                                                           "file may be open already for read.")
        (CLOSEF FILENAME)))
    (LET* [(STRM (OPENSTREAM FILENAME 'BOTH))
           (OLDLENGTH (GETFILEINFO STRM 'LENGTH]
          (COND
             ((NULL STRM)
              (CL:WARN "file ~A won't open for end of file tests." FILENAME)))
          [COND
             [(SETFILEINFO STRM 'LENGTH NEWLENGTH)
              (COND
                 ((NOT (= (\GETEOFPTR STRM)
                          NEWLENGTH))
                  (CL:FORMAT LOGFILE "Changing file ~A to NEWLENGTH ~D didn't change EOFPTR.
" FILENAME NEWLENGTH)
                  (CL:WARN "Changing file ~A to NEWLENGTH ~D didn't change EOFPTR.
" FILENAME NEWLENGTH)))
              (SETFILEPTR STRM NEWLENGTH)
              (WRITETESTFILELENGTH STRM NEWLENGTH)
              (CLOSEF STRM)
              [COND
                 ((NOT (EQP (GETFILEINFO FILENAME 'LENGTH)
                            NEWLENGTH))
                  (CL:FORMAT LOGFILE "Changing file ~A to NEWLENGTH ~D didn't take; length still ~D"
                         FILENAME NEWLENGTH (GETFILEINFO FILENAME 'LENGTH))
                  (CL:WARN "Changing file ~A to NEWLENGTH ~D didn't take; length still ~D" FILENAME 
                         NEWLENGTH (GETFILEINFO FILENAME 'LENGTH]
              (SETQ STRM (OPENSTREAM FILENAME 'BOTH))
              (COND
                 ((NOT (EQP (GETFILEINFO FILENAME 'LENGTH)
                            NEWLENGTH))
                  (CL:FORMAT LOGFILE 
                         "Re-opening file ~A after changing to NEWLENGTH ~D lost new length.
" FILENAME NEWLENGTH)
                  (CL:WARN "Re-opening file ~A after changing to NEWLENGTH ~D lost new length.
" FILENAME NEWLENGTH)))
              (TESTFILEPTR STRM NEWLENGTH LOGFILE)
              (SETFILEINFO STRM 'LENGTH NEWLENGTH)
              (CLOSEF STRM)
              (COND
                 ((NOT (EQP (GETFILEINFO FILENAME 'LENGTH)
                            NEWLENGTH))
                  (CL:WARN "Changing file ~A to NEWLENGTH ~D the second time didn't take either.
" FILENAME NEWLENGTH]
             (T (SETQ NEWLENGTH (GETFILEINFO STRM 'LENGTH]
          (SETQ STRM (OPENSTREAM FILENAME 'INPUT))
          [for I from 0 to (SUB1 NEWLENGTH) do (COND
                                                                  ((EOFP STRM)
                                                                   (ERROR "EARLY EOF" I)))
                                                              (BIN STRM)
             finally (COND
                            ((NOT (EOFP STRM))
                             (ERROR "EOFP not true at end of file"]
          (TESTEOFOP STRM NEWLENGTH (FUNCTION ZERO)
                 0 LOGFILE)
          (TESTEOFOP STRM NEWLENGTH (FUNCTION NILL)
                 NIL LOGFILE)
          (CLOSEF STRM)
          (EXTENDTESTFILE FILENAME STARTBYTE PERIOD OLDLENGTH NEWLENGTH])

(TESTEOFOP
  [LAMBDA (STREAM FILESIZE FN EOFVALUE LOGFILE)          (* ; "Edited 15-Jun-90 14:04 by jds")

    (* ;; 
  "Test ENDOFSTREAMOP, using FN as the function to call (THAT FUNCTION SHOULD RETURN EOFVALUE)")

    (PRINTOUT LOGFILE %,, %,, "Testing with ENDOFSTREAMOP set to " FN T)
    (SETFILEPTR STREAM 0)
    (replace (STREAM ENDOFSTREAMOP) of STREAM with FN)
    (for I from 0 to (SUB1 FILESIZE) do (COND
                                                           ((EOFP STREAM)
                                                            (ERROR "Early EOF at" I)))
                                                       (BIN STREAM)
       finally (COND
                      ((NOT (EOFP STREAM))
                       (ERROR "EOFP NIL at EOF.")))
             (OR (EQ EOFVALUE (BIN STREAM))
                 (ERROR "End-of-stream value not returned right from function " FN))
             (OR (EOFP STREAM)
                 (ERROR "EOFP is NIL after a BIN at EOF"])

(TESTFILEPTR
  [LAMBDA (STRM FILESIZE LOGFILE)                        (* ; "Edited  7-Dec-88 11:42 by jds")

(* ;;; "Test setting fileptr past EOF")

    (PRINTOUT LOGFILE .TAB 5 "Testing FILEPTR" T)
    (PRINTOUT LOGFILE .TAB 10 "FILESIZE = " FILESIZE T)
    (bind BYTE for FILEPTR in '(8192 512 4096 8191 513 4097 8193 511 4095)
       do (PRINTOUT LOGFILE .TAB 10 "Setting EOF and FILEPTR to " FILESIZE T)
             (SETFILEINFO STRM 'LENGTH FILESIZE)
             (SETFILEPTR STRM FILESIZE)
             (COND
                ((NOT (EOFP STRM))
                 (CL:WARN "EOFP not set at ~D " FILESIZE)))
             (PRINTOUT LOGFILE .TAB 10 "FILESIZE extended by " FILEPTR T)
             (SETFILEPTR STRM (IPLUS FILESIZE FILEPTR))
             [COND
                ((CL:/= (IPLUS FILESIZE FILEPTR)
                        (GETFILEPTR STRM))
                 (CL:WARN "FILEPOS wrong after SETFILEPTR; is ~D, should be ~D.
" (GETFILEPTR STRM)
                        (IPLUS FILESIZE FILEPTR]
             (BOUT STRM 6)
             [COND
                ((CL:/= (IPLUS FILESIZE FILEPTR 1)
                        (GETFILEPTR STRM))
                 (CL:WARN "FILEPOS wrong after BOUT; is ~D, should be ~D.
" (GETFILEPTR STRM)
                        (IPLUS FILESIZE FILEPTR 1]
             (SETFILEPTR STRM FILESIZE)
             (PRINTOUT LOGFILE .TAB 10 "Testing new allocated area = zero" T)
             [for I from FILESIZE to (IPLUS FILESIZE FILEPTR -1)
                do (COND
                          ((NEQ (BIN STRM)
                                0)
                           (CL:WARN "Newly-allocated area not zeroed.")
                           (RETURN]
             (PRINTOUT LOGFILE .TAB 10 "Testing new EOF and last byte written" T)
             (COND
                ((EOFP STRM)
                 (CL:WARN "Early EOF; before BINning file's last byte.
")))
             (COND
                ((NEQ (SETQ BYTE (BIN STRM))
                      6)
                 (CL:WARN "BIN didn't return what was just BOUTed; was ~D, should be 6.
" BYTE)))
             (COND
                ((EOFP STRM))
                (T (CL:WARN "EOFP false after BINning file's final byte.")))
       finally (SETFILEINFO STRM 'LENGTH FILESIZE)
             (SETFILEPTR STRM FILESIZE])

(TESTPEEKBIN
  [LAMBDA (FILE DONT.TRY.HARD.FLG LOGFILE)               (* ; "Edited  3-Nov-88 11:23 by jds")

    (* ;; "Test the various cases of PEEKBIN")

    (PROG ((STRM (OPENSTREAM FILE 'INPUT 'OLD))
           STRMLEN)
          (RESETLST
              (RESETSAVE NIL (LIST 'CLOSEF? STRM))
              (SETQ STRMLEN (GETEOFPTR STRM))
              [for PTR in (APPEND [LIST 0 STRMLEN (IMAX (SUB1 STRMLEN)
                                                                0)
                                                (ADD1 STRMLEN)
                                                (IPLUS (RAND 1 10)
                                                       (IMIN 16777200 (ITIMES (RAND 2 5)
                                                                             STRMLEN]
                                         (for X from -1 to STRMLEN by 512
                                            when (IGREATERP X 0) collect X)
                                         (for X from 0 to STRMLEN by 512 collect
                                                                                         X)
                                         (for X from 1 to STRMLEN by 512 collect
                                                                                         X)
                                         (for X from 1 to 5 collect (RAND 0 STRMLEN))
                                         ) bind C.PEEK.NIL C.PEEK.T C.BIN PTR2 PTR3
                 do (SETFILEPTR STRM PTR)
                       (SETQ C.PEEK.NIL (NLSETQ (\PEEKBIN STRM)))
                       (SETQ PTR2 (GETFILEPTR STRM))
                       [COND
                          ((NOT DONT.TRY.HARD.FLG)
                           (COND
                              ((NOT (EQUAL PTR PTR2))
                               (PRINTOUT LOGFILE "\PEEKBIN moving file ptr!" T]
                       (SETQ C.PEEK.T (NLSETQ (\PEEKBIN STRM T)))
                       (SETQ PTR3 (GETFILEPTR STRM))
                       [COND
                          ((NOT DONT.TRY.HARD.FLG)
                           (COND
                              ((NOT (EQUAL PTR PTR3))
                               (PRINTOUT LOGFILE "\PEEKBIN moving file ptr!" T]
                       (SETQ C.BIN (NLSETQ (BIN STRM)))
                       (COND
                          [(IGEQ PTR STRMLEN)                (* ; "at EOS")
                           [COND
                              ((NOT DONT.TRY.HARD.FLG)
                               (COND
                                  ((NOT (AND (EQUAL C.PEEK.NIL NIL)
                                             (EQUAL C.PEEK.T '(NIL))
                                             (EQUAL C.BIN NIL)))
                                   (PRINTOUT LOGFILE "\PEEKBIN or BIN not working correctly at EOS" T
                                          ]
                           (COND
                              ((NOT DONT.TRY.HARD.FLG)
                               (COND
                                  ((NOT (EQUAL (GETFILEPTR STRM)
                                               PTR))
                                   (PRINTOUT LOGFILE "BIN moving fileptr at eos" T]
                          (T                                 (* ; "before EOS")
                             (COND
                                ((NOT (AND (EQUAL C.PEEK.NIL C.PEEK.T)
                                           (EQUAL C.PEEK.T C.BIN)))
                                 (PRINTOUT LOGFILE "\PEEKBIN and BIN not returning same value!" T)))
                             (COND
                                ((NOT (EQUAL (GETFILEPTR STRM)
                                             (ADD1 PTR)))
                                 (PRINTOUT LOGFILE "BIN not moving ptr correctly!" T]
              (CLOSEF? STRM))])

(TRUNCATETESTFILE
  [LAMBDA (FILENAME NEWLENGTH)                           (* ; "Edited  3-Nov-87 13:43 by jds")
                                                             (* ; "truncates a test file")
    [COND
       ((OPENP FILENAME)                                     (* ; 
                                                           "file may be open already for read.")
        (CLOSEF (OPENP FILENAME]
    (PROG [(STRM (OPENSTREAM FILENAME 'BOTH]
          (COND
             ((NULL STRM)
              (ERROR "file that it supposed to exist won't open for truncation." FILENAME)))
          (WRITETESTFILELENGTH STRM NEWLENGTH)
          (SETFILEPTR STRM NEWLENGTH)
          (SETFILEINFO STRM 'LENGTH NEWLENGTH)
          (CLOSEF STRM)
          (COND
             ((CL:/= (GETFILEINFO FILENAME 'LENGTH)
                     NEWLENGTH)
              (CL:WARN "changing file ~A to NEWLENGTH ~D didn't take" FILENAME NEWLENGTH])

(WORDIN
  [LAMBDA (STRM)                                             (* rrb "27-Mar-84 14:37")
                                                             (* read two bytes from a stream)
    (LOGOR (LLSH (\BIN STRM)
                 8)
           (\BIN STRM])

(WORDOUT
  [LAMBDA (STRM WORD)                                        (* bouts two bytes onto stream)
    (\BOUT STRM (LRSH WORD 8))
    (\BOUT STRM (LOGAND WORD 255])

(DOUBLEWORDIN
  [LAMBDA (FILE)                                             (* jds " 3-JAN-83 16:08")
    (IPLUS (LLSH (\BIN FILE)
                 24)
           (LLSH (\BIN FILE)
                 16)
           (LLSH (\BIN FILE)
                 8)
           (\BIN FILE])

(DOUBLEWORDOUT
  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))
    (\BOUT FILE (LOGAND 255 NUMBER])

(WRITETESTFILE
  [LAMBDA (NAME LENGTH STARTBYTE PERIOD)                     (* ; "Edited  4-Nov-87 11:21 by jds")
          
          (* ;; "writes a test file of length LENGTH with contents CONTENTBYTE")

    (PROG [(STRM (OPENSTREAM NAME 'OUTPUT]
          (OR STRM (RETURN NIL))
          (COND
             ((ILESSP LENGTH MINTESTFILELENGTH)
              (ERROR "test files must have a minimum length " MINTESTFILELENGTH)))
          (WORDOUT STRM FIRSTTESTWORD)
          (WORDOUT STRM SECONDTESTWORD)
          (DOUBLEWORDOUT STRM LENGTH)
          (BOUT STRM STARTBYTE)
          (BOUT STRM PERIOD)
          [bind (CURRENTBYTE _ STARTBYTE)
                BLOCKCOUNT _ 0 for COMPUTEDBYTE from STARTBYTE to (IPLUS STARTBYTE LENGTH
                                                                         (IMINUS MINTESTFILELENGTH)
                                                                         -1)
             do (BOUT STRM CURRENTBYTE)
                (SETQ CURRENTBYTE (IMOD (ADD1 CURRENTBYTE)
                                        PERIOD))
                (COND
                   ((ZEROP (SETQ BLOCKCOUNT (IMOD (ADD1 BLOCKCOUNT)
                                                  100)))
                    (BLOCK]
          (CLOSEF STRM)
          (RETURN (FULLNAME STRM])

(WRITETESTFILELENGTH
  [LAMBDA (STRM NEWLENGTH)                               (* ; "Edited  3-Nov-88 10:45 by jds")
                                                             (* ; 
                                                      "update the length count stored in the file.")
    (SETFILEPTR STRM 4)
    (DOUBLEWORDOUT STRM NEWLENGTH])
)

(RPAQ DSKFREEPAGESFN (FUNCTION DEFAULT.DSKFREEPAGESFN))

(RPAQ DSKPAGESOVERHEADFN (FUNCTION DEFAULT.DSKPAGESOVERHEADFN))

(RPAQ DSKMINALLOCFN (FUNCTION DEFAULT.DSKMINALLOCFN))

(RPAQQ MINTESTFILELENGTH 10)

(RPAQQ FIRSTTESTWORD 48094)

(RPAQQ SECONDTESTWORD 56187)

(RPAQQ NUMBEROFTESTBYTES 5)

(RPAQQ EXHAUSTIVETESTFLG NIL)

(RPAQQ DEFAULTREPLAYFILE {PHYLUM}<LISPCORE>DLIONFS>REPLAY.LOG)

(RPAQQ DONTCLOSEFILESFLG NIL)

(RPAQQ LEGALFILENAMECHARS
       (A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u
          v w x y z 0 1 2 3 4 5 6 7 8 9))

(RPAQQ LEGALFIRSTFILENAMECHARS
       (A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j k l m n o p q r s t u
          v w x y z))

(RPAQQ MINFILENAMELENGTH 1)

(RPAQQ MAXFILENAMELENGTH 15)

(RPAQQ MINFILEEXTENSIONLENGTH 0)

(RPAQQ MAXFILEEXTENSIONLENGTH 6)

(RPAQQ MAXVERSION 64000)

(RPAQQ TESTFILEPAGELENGTHS
       (1 2 3 5 7 8 11 13 16 17 19 21 23 24 29 31 34 37 41 43 47 64 55 78 89 128 129 255 256 257 333
          512 837 1024 1997 2048 3333 4096 5432 8192 11321 16384 19997 32768 43210 65535))
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS FIRSTTESTWORD SECONDTESTWORD MINTESTFILELENGTH NUMBEROFTESTBYTES EXHAUSTIVETESTFLG 
       DSKFREEPAGESFN DSKPAGESOVERHEADFN TESTFILEPAGELENGTHS)
)
(DECLARE%: EVAL@COMPILE

(RECORD TESTFILEINFO (TESTFILEFULLNAME FILELENGTH STARTBYTE PERIOD TESTFILEORIGNAME))

(RECORD TESTFILEOP (
                        (* ;; "Describes one DSKTEST file operation, for the log and for replay.")

                        TESTOPERATION                        (* ; 
                            "Operation to be performed.  One of: ADD DELETE CHANGELENGTH DELETEALL")
                        TESTOPFILENAME                       (* ; 
                                                           "File name of the file operated on")
                        TESTOPFILELENGTH                     (* ; "New length for the file")
                        STARTBYTE                            (* ; "%"Random%" data start < PERIOD")
                        PERIOD                               (* ; "%"Random%" data period < 256")
                        ))
)
(PUTPROPS DSKTEST COPYRIGHT ("Venue & Xerox Corporation" 1984 1985 1986 1987 1988 1990))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (2943 12078 (DSKTEST 2953 . 11544) (DELETETESTFILES 11546 . 12076)) (12079 59900 (
CHECKCONSISTENCY 12089 . 13302) (CHECKLENGTHANDCONTENTS 13304 . 17796) (CHOOSERANDOMFILEOPERATION 
17798 . 19365) (DEFAULT.DSKFREEPAGESFN 19367 . 20152) (DEFAULT.DSKMINALLOCFN 20154 . 20803) (
DEFAULT.DSKPAGESOVERHEADFN 20805 . 21709) (DOTESTFILEOP 21711 . 30611) (DSKFREEPAGES 30613 . 30872) (
DSKMINALLOC 30874 . 31180) (DSKPAGESOVERHEAD 31182 . 31453) (EXTENDTESTFILE 31455 . 32765) (
FILEINFOFROMFILE 32767 . 33586) (GENERATEADDFILEOP 33588 . 34342) (GENERATECHANGEFILEOP 34344 . 35248)
 (GENERATEDELETEFILEOP 35250 . 35987) (GENERATEEOFPFILEOP 35989 . 36881) (GENERATEPEEKBINFILEOP 36883
 . 37672) (GENERATEDELETEALLFILEOP 37674 . 37866) (RANDOMELT 37868 . 38122) (RANDOMFILELENGTH 38124 . 
40003) (RANDOMFILENAME 40005 . 41255) (RANDOMSTR 41257 . 41921) (RANDOMTESTFILE 41923 . 42826) (
SORTBYCAR 42828 . 43181) (TESTFILEP 43183 . 45623) (TESTEOFP 45625 . 48865) (TESTEOFOP 48867 . 49898) 
(TESTFILEPTR 49900 . 52243) (TESTPEEKBIN 52245 . 56179) (TRUNCATETESTFILE 56181 . 57146) (WORDIN 57148
 . 57425) (WORDOUT 57427 . 57602) (DOUBLEWORDIN 57604 . 57889) (DOUBLEWORDOUT 57891 . 58181) (
WRITETESTFILE 58183 . 59529) (WRITETESTFILELENGTH 59531 . 59898)))))
STOP
