;; Function To Be Tested: delete-if-not;;;; Source:        CLtL    Section 14.3: Modifying Sequences        Page: 254;;;; Created By:    Karin M. Sye;;;; Creation Date: Sept. 22 ,1986;;;; Last Update:   Nov. 5 ,1986;;;; Filed As:      {eris}<lispcore>cml>test>14-3-delete-if-not.test;;;;;; Syntax:                delete-if-not TEST SEQUENCE &KEY :FROM-END :START :END :COUNT :KEY;;;; Function Description:  delete-if-not returns a sequence of the same kind as the argument SEQUENCE that has the same ;;					elements except that those in the subsequence delimited by :START and :END and not satisfying;;				     TEST have  been deleted.;;;; Argument(s):           TEST        - a function of one argument;;					SEQUENCE    -;;					:FROM-END   - nil or non-nil;;					:START :END - integer indices into the SEQUENCE, with :START <= :END;;					:COUNT      - an integer which limits the number of elements deleted from SEQUENCE;;					:KEY        - a function of one argument that will extract from an element the part;;							    to be tested in place of the whole element.;;;; Returns:               a sequence    ;;(do-test "test delete-if-not 0"		(let ((a '#(1 3 4 2 5 6 3 20 6 8 5 6 7 4 3 2 4 6 7 5) ) b c)		  (setf b (copy-seq a) c (copy-seq b) )		  (and	(equalp (delete-if-not #'evenp a) '#(4 2  6 20 6 8 6  4 2 4 6 ) )				(equalp (delete-if-not #'evenp b :count 5) '#(4 2 6 20 6 8 6 7 4 3 2 4 6 7 5) )				(equalp (delete-if-not #'evenp c :count 5 :from-end t) '#(1 3 4 2 5 6 3 20 6 8 6 4 2 4 6 ) )		  )		))(do-test "test delete-if-not 1"	(let ((a "aN inteGeR WhICH liMitS thE NumbEr oF eLemenTs reMoved FrOm SeQuenCE")  b c)		(setq b (copy-seq a) c (copy-seq b))		(and (equal (delete-if-not #'(lambda (x) (or (char= #\space x) (lower-case-p x))) a :start 20)				 "aN inteGeR WhICH liMit th umbr o eemens reoved rm euen")			(equal (delete-if-not #'(lambda (x) (or (char= #\space x) (lower-case-p x))) b  :end 40)				"a intee h liit th umbr o eemenTs reMoved FrOm SeQuenCE")			(equal (delete-if-not #'(lambda (x) (or (char= #\space x) (lower-case-p x))) c :start 5 :end 50)				"aN intee h liit th umbr o eemens reoved FrOm SeQuenCE")		)	))(do-test "test delete-if-not 2"	(let ((a '("ikjlkmop" "jnmdkpmn" "abcmnppkkn" "zxyuvmnog" "tyhfgwsjkkh" "olkdewskddc" "ppmmnnllkkplm")) b c )		(setf b (copy-seq a) c (copy-seq a))		(and (equal (delete-if-not #'(lambda (x) (find #\p x)) a :key #'(lambda (y) (subseq (reverse y) 0 3)))				  '("ikjlkmop" "jnmdkpmn"  "ppmmnnllkkplm"))			(equal (delete-if-not #'(lambda (x) (find #\p x)) b :key #'(lambda (y) (subseq (reverse y) 0 3))													 :from-end t :count 2)				  '("ikjlkmop" "jnmdkpmn" "abcmnppkkn" "zxyuvmnog"  "ppmmnnllkkplm"))			(equal (delete-if-not #'(lambda (x) (find #\k x)) c :key #'(lambda (y) (subseq y 2 5)) :count 3)				  '("ikjlkmop" "jnmdkpmn"  "olkdewskddc" "ppmmnnllkkplm"))  		)	))(do-test "test delete-if-not  3"	(let ((a (make-array 11 :initial-contents '( #c(2 10) #c(3 -5) #c(1 9) #c(10 20) #c(-5 42)									    #c(40 2) #c(-20 31) #c(-1 -2) #c(2 34) #c(9 21) #c( 2 4)))  ) b c d)		(setf b (copy-seq a) c (copy-seq a) d (copy-seq a))		(and			(equalp (delete-if-not #'(lambda (x) (> (+ (realpart x) (imagpart x)) 30)) a							  :start 2 :end 7 :from-end nil :count 3 :key #'identity)				  (vector #c(2 10) #c(3 -5)  #c(-5 42) #c(40 2) #c(-1 -2) #c(2 34) #c(9 21) #c( 2 4)))			(equalp (delete-if-not #'(lambda (x) (> (+ (realpart x) (imagpart x)) 30)) b							  :start 2 :end 7 :from-end 'non-nil :count 3 :key #'identity)				   (vector #c(2 10) #c(3 -5) #c(-5 42) #c(40 2) #c(-1 -2) #c(2 34) #c(9 21) #c( 2 4)))			(equalp (delete-if-not #'oddp c :start 1 :end 9 :count 3 :key #'realpart)				   (vector #c(2 10) #c(3 -5) #c(1 9)  #c(-5 42) #c(-1 -2) #c(2 34) #c(9 21) #c( 2 4)))			(equalp (delete-if-not #'minusp d :start 1 :end 9 :count 4 :key #'realpart)				   (vector #c(2 10) #c(-5 42) #c(-20 31) #c(-1 -2) #c(2 34) #c(9 21) #c( 2 4)))		)	))(do-test "test delete-if-not 4"	(let ((a '((3 . 2.4) (5 . -5) (10 . 2.3) (-1 . -2.0) (9 . 9.0) (20 . 12) (23 . 33.3) (5 . 15) (2 . 222))  ) b c d)		(setf b (copy-seq a) c (copy-seq a) d (copy-seq a))		(and	(equal (delete-if-not #'floatp a :start 1 :end 8 :key #'cdr :count 2)				  '((3 . 2.4) (10 . 2.3) (-1 . -2.0) (9 . 9.0)  (23 . 33.3) (5 . 15) (2 . 222))  )			(equal (delete-if-not #'floatp b :start 1 :end 8 :key #'cdr :count 2 :from-end t)				  '((3 . 2.4) (5 . -5) (10 . 2.3) (-1 . -2.0) (9 . 9.0)  (23 . 33.3)  (2 . 222))  )					(equal (delete-if-not #'oddp c :start 2 :end 8 :key #'first :count 1 :from-end t)				  '((3 . 2.4) (5 . -5) (10 . 2.3) (-1 . -2.0)  (9 . 9.0) (23 . 33.3) (5 . 15) (2 . 222))  )			(equal (delete-if-not #'oddp d :start 2 :end 8 :key #'first :count 1 )				  '((3 . 2.4) (5 . -5)  (-1 . -2.0) (9 . 9.0) (20 . 12) (23 . 33.3) (5 . 15) (2 . 222))  )		)	))STOP