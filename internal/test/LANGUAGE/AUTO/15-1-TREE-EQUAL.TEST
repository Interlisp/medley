;; Function To Be Tested: TREE-EQUAL;;;; Source: Guy L Steele's CLTL;; Section: 15.1 Conses;; Page: 264;;;; Created By:    Kelly Roach;;;; Creation Date: June 27,1986;;;; Last Update:   June 27,1986;;			   July 1, 1986 Sye / create test cases;;			   July 21, 1986  Masinter, comment out case where "list-length" was used as tree-equal test function;;;; Filed As:      {ERIS}<LISPCORE>CML>TEST>15-1-TREE-EQUAL.TEST;;;;;; Syntax:        (TREE-EQUAL X Y &KEY TEST TEST-NOT);;;; Function Description:;; This is a predicate that is true if X and Y are;; isomorphic trees with identical leaves, that is, if X and Y;; are atoms that satisfy the test (by default EQL),;; or if they are both conses and their CAR's are TREE-EQUAL;; and their CDR's are TREE-EQUAL.;; Thus TREE-EQUAL recursively compares conses (but not any other objects;; that have components).  See function EQUAL, which does recursively;; compare certain other structured objects, such as strings.;; ;; Argument(s):   X - a tree;;                Y - a tree;;                TEST - a function;;                TEST-NOT - a function;;;; Returns:       a tree;;(do-test "test tree-equal - x & y are atoms"  (and (tree-equal 'a 'a)       (tree-equal  0 0)       (tree-equal 3.0 3.00)       (tree-equal #\A #\A)       (not (tree-equal 'c 'e))       (not (tree-equal 2 2.0))       (tree-equal nil () :test #'eq)       (tree-equal 2 2.0 :test #'=)       (tree-equal 3 4 :test-not #'=)       (tree-equal "string" "STRING" :test #'equalp)       (tree-equal 2 (sqrt 4) :test #'equalp)       (tree-equal 10 15 :test #'(lambda (x y) (<= 10 x y 20)));;;; ROACH 1-JUL-86  The form;;     (tree-equal '(2 4) '(4 6) :test-not #'equal);; should not be expected to return T because two corresponding leaves of;; these trees are both NIL.;; '(2 4) = '(2 4 . NIL) and '(4 6 . NIL);;       (tree-equal '(2 4 . 1) '(4 6 . 3) :test-not #'equal)))(do-test "test tree-equal - x & y are conses"    (and 	(tree-equal '(1 . 2) '(1 . 2))		(tree-equal '(a b c d) '(a b c d))		(tree-equal '((1 1 1 1) (2 2) . 3) '((1 1 1 1) (2 2) . 3) )		(tree-equal '((2 . 1) . 4) '((2 . 1) . 4))		(not (tree-equal '("a" "s") '("a" "s")))		(not (tree-equal '(#\a #\b) '(#\A #\b)))		(tree-equal '(#\a #\b) '(#\A #\B)  :test #'equalp)		(tree-equal '((2 1 . 3) 4 . 5) '((2 1 . 3) 4 . 5) :test #'=)		(tree-equal '((1 2.2 . 3) ((4 . 5) 6 7 . 8.8) . 9)  '((1 2.2 . 3) ((4 . 5) 6 7 . 8.8) . 9) :test #'=) 		(tree-equal '(10 (20.0 (30.2))) '(10.0 (20 (30.200))) :test #'equalp)		(tree-equal '(#\a #\c "t" 30) '( 40 #\e  "u" 90)  :test #'(lambda (x y) (and (atom x) (atom y))))    ))		(do-test "test tree-equal - test on a large tree"  (progn (setq tree               '(1 2 (3 4 (5 6 (7 8) 9 10) 11 12) 13 14 15                   (#\p #\l #\m #\g                        ('Fire 'Pink ('black 'eyed 'susan)                               'North-Carolina)                        |asheville|                        (|yarrow| |phlox|                         \ fragrant \ water \ lilies))                   (((((a b) c d (e) f g h) 100.0 (200 400) z w) f g) the end)))           (and (progn (setq tree1 tree)                       (and (tree-equal tree tree1)                            (tree-equal tree tree1 :test #'equal)                            (tree-equal tree tree1 :test #'equalp)))                (progn ;                       ;  replace | phlox| with |phlox|                        ;  replace '\ \ lilies with \ lilies                       ;                       (setq tree1 (subst '| phlox| '|phlox| tree))                       (setq tree2  (subst '\ \ lilies  '\ lilies tree))                       (not (or (tree-equal tree tree1) (tree-equal tree tree2))))                (progn ;                       ;  replace "Fire" "Pink"  with "fire" "pink"                       ;                       (setq tree1                             '(1 2 (3 4 (5 6 (7 8) 9 10) 11 12) 13 14 15                                 (#\p #\l #\m #\g                                      ("Fire" "Pink"                                              ('black 'eyed 'susan)                                              'North-Carolina)                                      |asheville|                                    (|yarrow| |phlox|                                     \ fragrant \ water \ lilies ))                                 (((((a b) c d (e) f g h) 100.0 (200 400) z w)                                   f g) the end)))                      (setq tree2 (subst "fire" "Fire" tree1 :test #'equal)  					  tree2 (subst "pink" "Pink" tree2  :test #'equal))			 	 (and					(not (tree-equal tree1 tree2))					(not (tree-equal tree1 tree2 :test #'equal))				     (tree-equal tree1 tree2      :test #'equalp)))			;;			(progn				;				;  replace 15 with 15.000 and 100.0 with 100				;				(defun num (x y) (if (and (numberp x) (numberp y) (= x y)) t))				(setq tree1 (subst 15.00 15 tree :test #'num) tree1 (subst 100 100.0 tree1 :test #'num))				(and					(not (tree-equal tree tree1))					(not (tree-equal tree tree1 :test #'equal))					(tree-equal tree tree1 :test #'equalp)					(tree-equal tree tree1 						:test #' (lambda (x y) (if (listp x) (= (list-length x) (list-length y)) t)  ))					(tree-equal tree tree1 :test-not #'(lambda (x y) (or (vectorp x) (vectorp y))))					(tree-equal tree tree1 :test #'(lambda (x y) (and (atom x) (atom y)))))))));;;;STOP