;; Function To Be Tested: set-dispatch-macro-character;;;; NOTE: the code for 22-1-5-make-dispatch-macro-character.test and 22-1-5-set-dispatch-macro-character.test are the same, because the two functions work so closely together.  Only the comments and the test names are different.;;;; Source: CLtL p. 364;;;; Chapter 22: Input/Output		Section 1.5: The Readtable;;;; Created By: Peter Reidy;;;; Creation Date: 4 November 86;;;; Last Update: 2/2/87 Jim Blum - rewrote test;;;; Filed As:      {eris}<lispcore>cml>test>22-1-5-set-dispatch-macro-character.test;;;; Syntax: set-dispatch-macro-character disp-char sub-char function &optional readtable;;            ;; Function Description: causes the reader to call function when it encounters the sequence disp-char/sub-char under the control of readtable.;;;; Argument(s):	disp-char, sub-char - characters;;			function - a function;;			readtable - a readtable ; defaults to  NIL (the readtable currently in effect).;;;; Returns: T			 ;; (do-test-group	(set-dispatch-macro-character-group	:before		(progn			(setq 3nov862036 0 3nov862040 0 4nov861358readtable (copy-readtable nil))  ; These have to be setq'd anyway.			(DEFUN setmarker (x y z) (incf 3nov862036))				 (make-dispatch-macro-character #\{ T  4nov861358readtable)				(set-dispatch-macro-character #\{ #\E '(lambda (stream char arg)  (incf 3nov862040)	) 4nov861358readtable)				 (set-dispatch-macro-character #\{ #\K '(lambda (x y z)  T) 4nov861358readtable)		)	)  ; set-dispatch-macro-character-group;;;;	(do-test set-dispatch-macro-character-with-standard-readtable-test		(let ((*readtable* (copy-readtable nil)))			(and				;; Test whether the functions return T.				(eq t (make-dispatch-macro-character #\$))				(eq t (set-dispatch-macro-character #\$ #\q 'setmarker))				;; The  read  under the standard table should stop at the  to .					;; Since non-terminating-p defaults to nil, the read should terminate at the macro char and not increment the counter.				 (with-open-stream (s (make-string-input-stream "tok$qen ")								 ) 								    (and (eq 'tok (read s))									     (= 3nov862036 0)									     (eql 1 (read s))									     (= 3nov862036 1)									     (eq 'en (read s))								    )				)				(equal 'Qq (with-open-stream (s (make-string-input-stream "Qq"))										   (read s)						    )				)		; this should have no effect				(= 3nov862036 1)			)  ; AND		)  ; let	)  ; do-test set-dispatch-macro-character-with-current-readtable-test;;;;;; Try the function under an alternate readtable and non-terminating = T.	(do-test set-dispatch-macro-character-with-alternate-readtable-test-and-non-terminating-p		(let ((*readtable*  (copy-readtable 4nov861358readtable)))				(and				;; {E read in under the alternate table ought to increment the counter.  {k ought to do nothing.				;; Since non-terminating-p all occurrences should invoke the new syntax.				(with-open-stream (s (make-string-input-stream 									"tok{Een ")								) (eq 'tok{een (read s))				)				(= 3nov862040 0)				(with-open-stream (s  (make-string-input-stream "{k{K{K{k"))(read s))		; this should have no effect				(= 3nov862040 0)				(with-open-stream (s (make-string-input-stream "kKkKkK"))(read s))		; nor should this				(= 3nov862040 0)				;; What we do in 4nov861358readtable should have no effect on the other readtable.				(with-open-stream (s (make-string-input-stream "$q$Qxx"))(read s))				(= 3nov862036 1)			)  ; and		)  ; let	)  ; do-test set-dispatch-macro-character-with-alternate-readtable-test)  ; do-test-groupSTOP