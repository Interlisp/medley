;; Function To Be Tested:format;;;; Source: Guy L Steele's CLTL;; Section: 22 Input/Output (Section 22.3.3 - Formatted Output to Character Streams);; Page: 385;;;; Created By:   John Park;;;; Creation Date: Dec 3, 1986;;;; Last Update:    Feb 3, 1987 - Jim Blum - small changes to make it run on the SUN;;			   Feb 6, 1987  - Bob Bane  ;;			   Feb 9, 1987 - Jim Blum - Added missing paren to TAB test.;;			   Feb 16, 1987 - Bob Bane - Fixes for format-new-line-character;;                                and format-justification tests.;;			   Feb 26, 1987 - Bob Bane - Added an error-check case to format-radix.;;;; Filed As:      {ERIS}<LISPCORE>CML>TEST>22-3-3-format.test;; ;;;; Syntax:        (format destination control-string &rest arguments);;;; Function Description: This function is used to produce formatted output.  ;; Format outputs the characters of control-string, except that a tilde (~) introduces;; a directive.  The character after the tilde, possibly preceded by prefic parameters;; and modifiers, specifies what kind of formatting is desired.  Most directives use ;; one or more elements of arguments to create their output; the typical directive;; puts the next element of arguments into the output, formatted in some special way.;; It is an error if no argument remains for a directive requiring an argument, but;; it is not an error if one or more arguments remain unprocessed by a directive.;;;; Argument(s): destination - where output is sent (NIL or stream);;			control-string - string containing directive for formatting output;;			arguments - Parameter(s) to the directive;;			  ;; Returns: Formatted output (string or NIL)    ;;;; Constraints/Limitations:(do-test "format-ascii"	(let	((w '(a b c))		 (x 'lion)		 (y "elephant")		 (z 292))		(and (string-equal (format nil "foo")						"foo")			(string-equal (format nil "Look at the ~A!" y)						"Look at the elephant!")		     (string-equal (format nil "Look at the ~A!" x)						"Look at the lion!")		     (string-equal (format nil "Look at the number ~A!" z)						"Look at the number 292!")		     (string-equal (format nil "Look at ~A!" w)						"Look at (a b c)!")		     (string-equal (format nil "Look at the ~10A!" y)						"Look at the elephant  !")		     (string-equal (format nil "Look at the ~10@A!" y)						"Look at the   elephant!")		     (string-equal (format nil "Look at the (~:A)!" y)						"Look at the (elephant)!")		)	))(do-test "format-S-expression"	(let	((x 'lion)		 (y "elephant")		 (z 292))		(and (string-equal (format nil "Look at the ~S!" y)						"Look at the \"elephant\"!")			(string-equal (format nil "Look at the ~S!" x)						"Look at the lion!")			(string-equal (format nil "Look at the number ~S!" z)						"Look at the number 292!")		)	))(do-test "format-decimal"	(let ((n 3)		 (n1 -3)		 (n2 12982298))		(and (string-equal (format nil "The answer is ~D." n)						"The answer is 3.")		     (string-equal (format nil "The answer is ~3D." n)						"The answer is   3.")		     (string-equal (format nil "The answer is ~3D." n1)						"The answer is  -3.")		     (string-equal (format nil "The answer is ~3@D." n)						"The answer is  +3.")		     (string-equal (format nil "The answer is ~7D." n2)						"The answer is 12982298.")		     (string-equal (format nil "The answer is ~:D." n2)						"The answer is 12,982,298.")		     (string-equal (format nil "The answer is ~:D." (expt 1000 n))						"The answer is 1,000,000,000.")		     (string-equal (format nil "The answer is ~15,'0,:D." n2)						"The answer is 0000012,982,298.")		)	))(do-test "format-binary"	(let ((n 3)		 (n1 -3)		 (n2 123))		(and (string-equal (format nil "The answer is ~B." n)						"The answer is 11.")			(string-equal (format nil "The answer is ~4B." n)						"The answer is   11.")		     (string-equal (format nil "The answer is ~4@B." n)						"The answer is  +11.")		     (string-equal (format nil "The answer is ~4B." n1)						"The answer is  -11.")		     (string-equal (format nil "The answer is ~10B." n2)						"The answer is    1111011.")		     (string-equal (format nil "The answer is ~:B." n2)						"The answer is 1,111,011.")		     (string-equal (format nil "The answer is ~:B." (expt 2 10))						"The answer is 10,000,000,000.")		     (string-equal (format nil "The answer is ~15,'0,:B." n2)						"The answer is 0000001,111,011.")		)	))(do-test "format-octal"	(let ((n 8)		 (n1 -8)		 (n2 1000))		(and (string-equal (format nil "The answer is ~O." n)						"The answer is 10.")			(string-equal (format nil "The answer is ~4O." n)						"The answer is   10.")		     (string-equal (format nil "The answer is ~4@O." n)						"The answer is  +10.")		     (string-equal (format nil "The answer is ~4O." n1)						"The answer is  -10.")		     (string-equal (format nil "The answer is ~10O." n2)						"The answer is       1750.")		     (string-equal (format nil "The answer is ~:O." n2)						"The answer is 1,750.")		     (string-equal (format nil "The answer is ~15,'0,:O." n2)						"The answer is 00000000001,750.")		)	))(do-test "format-hexadecimal"	(let ((n 10)		 (n1 -10)		 (n2 10191))		(and (string-equal (format nil "The answer is ~X." n)						"The answer is A.")			(string-equal (format nil "The answer is ~4X." n)						"The answer is    A.")		     (string-equal (format nil "The answer is ~4@X." n)						"The answer is   +A.")		     (string-equal (format nil "The answer is ~4X." n1)						"The answer is   -A.")		     (string-equal (format nil "The answer is ~10X." n2)						"The answer is       27CF.")		     (string-equal (format nil "The answer is ~:X." n2)						"The answer is 2,7CF.")		     (string-equal (format nil "The answer is ~15,'0,:X." n2)						"The answer is 00000000002,7CF.")		)	))(do-test "format-radix"	(let ((n 3)		 (n1 -3)		 (n2 12982298)		 (r 12))		(and (string-equal (format nil "The answer is ~10R." n)						"The answer is 3.")		     (string-equal (format nil "The answer is ~10,3R." n)						"The answer is   3.")		     (string-equal (format nil "The answer is ~10,3R." n1)						"The answer is  -3.")		     (string-equal (format nil "The answer is ~10,3@R." n)						"The answer is  +3.")		     (string-equal (format nil "The answer is ~10,7R." n2)						"The answer is 12982298.")		     (string-equal (format nil "The answer is ~10,:R." n2)						"The answer is 12,982,298.")		     (string-equal (format nil "The answer is ~10,:R." (expt 1000 n))						"The answer is 1,000,000,000.")		     (string-equal (format nil "The answer is ~10,15,'0,:R." n2)						"The answer is 0000012,982,298.") ;full radix form			(expect-errors (il:format-error) (format nil "~:R" 1/2));;		The following tests various radix cases.			(string-equal (format nil "~D in radix ~D is ~2R." r 2 r)						"12 in radix 2 is 1100.")			(string-equal (format nil "~D in radix ~D is ~3R." r 3 r)						"12 in radix 3 is 110.")			(string-equal (format nil "~D in radix ~D is ~4R." r 4 r)						"12 in radix 4 is 30.")			(string-equal (format nil "~D in radix ~D is ~5R." r 5 r)						"12 in radix 5 is 22.")			(string-equal (format nil "~D in radix ~D is ~6R." r 6 r)						"12 in radix 6 is 20.")			(string-equal (format nil "~D in radix ~D is ~7R." r 7 r)						"12 in radix 7 is 15.")			(string-equal (format nil "~D in radix ~D is ~8R." r 8 r)						"12 in radix 8 is 14.")			(string-equal (format nil "~D in radix ~D is ~9R." r 9 r)						"12 in radix 9 is 13.")			(string-equal (format nil "~D in radix ~D is ~10R." r 10 r)						"12 in radix 10 is 12.")			(string-equal (format nil "~D in radix ~D is ~11R." r 11 r)						"12 in radix 11 is 11.")			(string-equal (format nil "~D in radix ~D is ~12R." r 12 r)						"12 in radix 12 is 10.")			(string-equal (format nil "~D in radix ~D is ~13R." r 13 r)						"12 in radix 13 is C.")			(string-equal (format nil "~D in radix ~D is ~14R." r 14 r)						"12 in radix 14 is C.")			(string-equal (format nil "~D in radix ~D is ~15R." r 15 r)						"12 in radix 15 is C.")			(string-equal (format nil "~D in radix ~D is ~16R." r 16 r)						"12 in radix 16 is C.");;		The following tests various directive cases for formatting a numer				(string-equal (format nil "~R is a cardinal number." 4)						"four is a cardinal number.")			(or (string-equal (format nil "~R is a cardinal number." -4)						"negative four is a cardinal number.")				(string-equal (format nil "~R is a cardinal number." -4)						"minus four is a cardinal number."))			(string-equal (format nil "~:R is an ordinal number." 4)						"fourth is an ordinal number.")			(string-equal (format nil "~@R is a roman number ~D." 4 4)						"IV is a roman number 4.")			(string-equal (format nil "~:@R is an old roman number ~D." 4 4)						"IIII is an old roman number 4.")		)	))(do-test "format-plural"	(let ((zero 0)		 (singular 1)		 (plural 7)		 (float-pt 9.99))		(and (string-equal (format nil "~D tr~:@p/~D win~:P." plural singular)						"7 tries/1 win.")			(string-equal (format nil "~D tr~:@p/~D win~:P." singular zero)						"1 try/0 wins.")			(string-equal (format nil "~D tr~:@p/~D win~:P." float-pt plural)						"9.99 tries/7 wins.")		)	))(do-test "format-character";;	Implementation or I/O dependent characters (i.e. control-C) are not included	(let ((a #\a)		 (Z #\Z)		 (n #\1)		 (s #\*)		 (ch 'character)		 (Space #\ )		 (Tab #\	)		 (Newline #\			))		(and (string-equal (format nil "This is character ~C" a)						"This is character a")			(string-equal (format nil "This is character ~C" Z)						"This is character Z")			(string-equal (format nil "This is character ~C" n)						"This is character 1")			(string-equal (format nil "This is special character ~C" s)						"This is special character *")			(string-equal (format nil "This is character ~@C" a)						"This is character #\\a")			(string-equal (format nil "This is character ~@C" Z)						"This is character #\\Z")			(string-equal (format nil "This is character ~@C" n)						"This is character #\\1")			(string-equal (format nil "This is special character ~@C" s)						"This is special character #\\*")			(string-equal (format nil "This is non-printing ~A ~:C" ch Space)						"This is non-printing character Space")			(string-equal (format nil "This is non-printing ~A ~:C" ch Tab)						"This is non-printing character Tab")			(string-equal (format nil "This is non-printing ~A ~:C" ch newline)						"This is non-printing character newline")			(string-equal (format nil "This is non-printing ~A ~:@C" ch Space)						"This is non-printing character Space")			(string-equal (format nil "This is non-printing ~A ~:@C" ch Tab)						"This is non-printing character Tab")			(string-equal (format nil "This is non-printing ~A ~:@C" ch newline)						"This is non-printing character newline")					 )	))(do-test "format-fixed-floating-point"	(and (defun format-float (x)			(format nil "~6,2F:~6,2,1,'*F:~6,2,,'?F:~6F:~,2F:~F"						x x x x x x))		(string-equal (format-float 3.14159)					"  3.14: 31.42:  3.14:3.1416:3.14:3.14159")		(string-equal (format-float -3.14159)					" -3.14:-31.42: -3.14:-3.142:-3.14:-3.14159")		(string-equal (format-float 100.0)					"100.00:******:100.00: 100.0:100.00:100.0")		(string-equal (format-float 1234.0)					"1234.00:******:??????:1234.0:1234.00:1234.0")		(string-equal (format-float 0.006)					"  0.01:  0.06:  0.01: 0.006:0.01:0.006")		(string-equal (format-float -0.006)					" -0.01: -0.06: -0.01:-0.006:-0.01:-0.006")		(string-equal (format-float 2/3)					"  0.67:  6.67:  0.67:.66667:0.67:0.6666667")		(string-equal (format-float 4/2)					"  2.00: 20.00:  2.00:   2.0:2.00:2.0")		(string-equal (format-float 4/2)					"  2.00: 20.00:  2.00:   2.0:2.00:2.0")		(string-equal (format-float 1234)					"1234.00:******:??????:1234.0:1234.00:1234.0")			))(do-test "format-exponential-floating-point"	(and (defun format-exponent (x)			(format nil 				"~9,2,1,,'*E:~10,3,2,2,'?,,'$E:~9,3,2,-2,'%@e:~9,2E"						x x x x))		(string-equal (format-exponent 3.14159)					"  3.14E+0: 31.42$-01:+.003E+03:  3.14E+0")		(string-equal (format-exponent -3.14159)					" -3.14E+0:-31.42$-01:-.003E+03: -3.14E+0")		(string-equal (format-exponent 1100.0)					"  1.10E+3: 11.00$+02:+.001E+06:  1.10E+3")		(or (string-equal (format-exponent 1100.0L0)						"  1.10L+3: 11.00$+02:+.001L+06:  1.10L+3")		    (string-equal (format-exponent 1100.0L0)						"  1.10E+3: 11.00$+02:+.001E+06:  1.10E+3"))		(string-equal (format-exponent 1.1E13)					"*********: 11.00$+12:+.001E+16: 1.10E+13")		(or (string-equal (format-exponent 1.1L36)					"*********: 11.00$+35:+.001L+39: 1.10L+36")			(string-equal (format-exponent 1.1L36)					"*********: 11.00$+35:+.001E+39: 1.10E+36"))	)); AR 7427(do-test "format-general-floating-point"	(and (defun format-general-float (x)			(format nil 				"~9,2,1,,'*G:~9,3,2,3,'?,,'$G:~9,3,2,0,'%G:~9,2G"						x x x x))		(string-equal (format-general-float 0.0314159)					"  3.14E-2:314.2$-04:0.314E-01:  3.14E-2")		(string-equal (format-general-float 0.314159)					"  0.31   :0.314    :0.314    : 0.31    ")		(string-equal (format-general-float 3.14159)					"   3.1   : 3.14    : 3.14    :  3.1    ")		(string-equal (format-general-float 31.4159)					"   31.   : 31.4    : 31.4    :  31.    ")		(string-equal (format-general-float 314.159)					"  3.14E+2: 314.    : 314.    :  3.14E+2")		(string-equal (format-general-float 3141.59)					"  3.14E+3:314.2$+01:0.314E+04:  3.14E+3")		(or	(string-equal (format-general-float 3141.59L0)						"  3.14L+3:314.2$+01:0.314L+04:  3.14L+3")			(string-equal (format-general-float 3141.59L0)						"  3.14E+3:314.2$+01:0.314E+04:  3.14E+3"))		(string-equal (format-general-float 3.14E12)					"*********:314.0$+10:0.314E+13: 3.14E+12")		(or	(string-equal (format-general-float 3.14L36)						"*********:314.0$+34:0.314L+37: 3.14L+36")			(string-equal (format-general-float 3.14L36)						"*********:314.0$+34:0.314E+37: 3.14E+36"))	)); bug AR 7427(do-test "format-dollars-floating-point"	(and (defun format-dollars-float (x)			(format nil 				"~$:~3,3,7,'*$:~,,10,'*$:~0,,10,'*$"						x x x x ))		(string-equal (format-dollars-float 0.99)					"0.99:000.990:******0.99:********1.")		(string-equal (format-dollars-float 10.99)					"10.99:010.990:*****10.99:*******11.")		(string-equal (format-dollars-float 119.99)					"119.99:119.990:****119.99:******120.")		(string-equal (format-dollars-float 12345.78)					"12345.78:12345.780:**12345.78:****12346.")		(string-equal (format-dollars-float 12762877.49)					"12762877.00:12762877.000:12762877.00:*12762877.")	))(do-test "format-new-line-character"	(and (string-equal (format nil "Hello~%~20TToday is Monday.")					"Hello                    Today is Monday.")		(string-equal (format nil "Hello~2%~20TToday is Monday.")					"Hello                    Today is Monday.")	))(do-test "format-fresh-line"	(and (string-equal (format nil "Hello~&")					"Hello")						(string-equal (format nil "Hello~2&")				"Hello")		(string-equal (format nil "Hello~2&")				"Hello")	))(do-test "format-page-separator-character"	(and (string-equal (format nil "Hello~|")					"Hello")									(string-equal (format nil "Hello~2|")					"Hello")	))(do-test "format-tilde"	(and (string-equal (format nil "outputs ~D ~~~:P" 1)					"outputs 1 ~")		(string-equal (format nil "outputs ~D ~2~~:P" 2)					"outputs 2 ~~s")		(string-equal (format nil "outputs ~D ~3~~:P" 3)					"outputs 3 ~~~s")	))(do-test "format-tilde-newline"	(and (defun type-clash-error (fn nargs argnum right-type wrong-type)			(format nil					"~&~S requires its ~:[~:R~;~*~] ~					argument to be of type ~S, ~%but it was called ~					with an argument of type ~S."					fn (eql nargs 1) argnum right-type wrong-type))		(string-equal (type-clash-error 'aref nil 2 'integer 'vector)					"AREF requires its second argument to be of type INTEGER, but it was called with an argument of type VECTOR.")			(string-equal (type-clash-error 'car 1 1 'list 'short-float)						"CAR requires its  argument to be of type LIST, but it was called with an argument of type SHORT-FLOAT.")	))(do-test "format-tab"	(and (string-equal (format nil "a~3Tb~5Tc~7Td~9Te~11Tf~13Tg~15Th")					"a  b c d e f g h")		(string-equal (format nil "a~3@Tb~5@Tc~7@Td")					"a   b     c       d")		(or (string-equal (format nil "a~3,8@Tb")					"a       b")			(string-equal (format nil "a~3,8@Tb")					"a      b")		)	))(do-test "format-indirection"	(and (string-equal (format nil "~? ~D" "<~A ~D>" '("Foo" 5) 7)					"<foo 5> 7")		(string-equal (format nil "~? ~D" "<~A ~D>" '("Foo" 5 14) 7)					"<foo 5> 7")		(string-equal (format nil "~@? ~D" "<~A ~D>" "Foo" 5 7)					"<foo 5> 7")		(string-equal (format nil "~@? ~D" "<~A ~D>" "Foo" 5 14 7)					"<foo 5> 14")	))(do-test "format-case-conversion"	(and (defun f (n) (format nil "~@(~R~) error~:P detected." n))		(equal (format nil "~:(~A~)" "this capitalizes all words")					"This Capitalizes All Words")		(equal (format nil "~@(~A~)" "this capitalizes just the first word")					"This capitalizes just the first word")		(equal (format nil "~:@(~A~)" 				"This converts every Lowercase character to upper case character")			  "THIS CONVERTS EVERY LOWERCASE CHARACTER TO UPPER CASE CHARACTER")		(equal (format nil "~@R ~(~@R~)" 14 14) "XIV xiv")		(equal (f 0) "Zero errors detected.")		(equal (f 1) "One error detected.")		(equal (f 23) "Twenty-three errors detected.")	))(do-test "format-conditional-expression"		(string-equal (format nil "~[Siamese~;Manx~;Persian~] cat" 0)					"Siamese cat")		(string-equal (format nil "~[Siamese~;Manx~;Persian~] cat" 1)					"Manx cat")		(string-equal (format nil "~[Siamese~;Manx~;Persian~] cat" 2)					"Persian cat")		(string-equal (format nil "~[false~;true~]" 0)					"false")		(let ((*print-level* nil) (*print-length* 5))			(string-equal (format nil						"~@[ print level = ~D~]~@[ print length = ~D~]"						*print-level* *print-length*)						" print length = 5")		)		(let ((foo "Items:~#[ none~; ~S~; ~S and ~S~				  ~:;~@{~#[~; and ~] ~S~^,~}~]."))			(and (string-equal (format nil foo)							"Items: none.")				(string-equal (format nil foo 'foo)							"Items: FOO.")				(string-equal (format nil foo 'foo 'bar)							"Items: FOO and BAR.")				(string-equal (format nil foo 'foo 'bar 'baz)							"Items: FOO, BAR, and  BAZ.")				(string-equal (format nil foo 'foo 'bar 'baz 'quux)							"Items: FOO, BAR, BAZ, and  QUUX.")			)		))(do-test "format-iteration"	(and (string-equal (format nil "The winners are:~{ ~S~}." '(fred harry jill))					"The winners are: Fred harry jill.")		(string-equal (format nil "Pairs:~{ <~S,~S>~}." '(a 1 b 2 c 3))					"Pairs: <A,1> <B,2> <C,3>.")		(string-equal (format nil "Pairs:~:{ <~S,~S>~}." '((a 1) (b 2) (c 3)))					"Pairs: <A,1> <B,2> <C,3>.")		(string-equal (format nil "Pairs:~@{ <~S,~S>~}." 'a 1 'b 2 'c 3)					"Pairs: <A,1> <B,2> <C,3>.")		(string-equal (format nil "Pairs:~:@{ <~S,~S>~}." '(a 1) '(b 2) '(c 3))					"Pairs: <A,1> <B,2> <C,3>.")	))(do-test "format-justification"	(and (string-equal (format nil "~10<FOO~;BAR~>")					"FOO    BAR")		(string-equal (format nil "~10:<FOO~;BAR~>")					"  FOO  BAR")		(string-equal (format nil "~10:@<FOO~;BAR~>")					" FOO BAR  ")		(string-equal (format nil "~10<FOOBAR~>")					"    FOOBAR")		(string-equal (format nil "~10:<FOOBAR~>")					"    FOOBAR")		(string-equal (format nil "~10@<FOOBAR~>")					"FOOBAR    ")		(string-equal (format nil "~10:@<FOOBAR~>")					"  FOOBAR  ")	))(do-test "format-escape-construct"	(and (let ((donestr "Done. ~^ ~D Warning~:P.~^ ~D error~:P."))		 	 (and (string-equal (format nil donestr)							"Done. ")					(string-equal (format nil donestr 3)							"Done.  3 warnings.")					(string-equal (format nil donestr 1 5)							"Done.  1 warning. 5 errors.")			)		)		(let ((tellstr "~@(~@[~R~]~^ ~A.~)"))		 	 (and (equal (format nil tellstr 23)						"Twenty-three")				(equal (format nil tellstr nil "losers")						" Losers.")				(equal (format nil tellstr 23 "losers")							"Twenty-three losers.")			)		)		(let ((up-out-str "~15<~S~;~^~S~;~^~S~>"))		 	 (and (string-equal (format nil up-out-str 'foo)							"            FOO")				 (string-equal (format nil up-out-str 'foo 'bar)						  	"FOO         BAR")				(string-equal (format nil up-out-str 'foo 'bar 'baz)							"FOO   BAR   BAZ")			)		)	))STOP