;;;; Function To Be Tested: defvar;;;; Source:        CLtL p. 68 ;; Chapter 5: program structure       Section 3.2: Declaring global variables and named constants;;;; Created By:    Karin M. Sye;;;; Creation Date:  Nov. 7, 86;;;; Last Update:   Nov. 7, 86 ;;;; Filed As:      {eris}<lispcore>cml>test>5-3-2-defvar.test;;;;;; Syntax: defvar NAME [INITIAL-VALUE [DOCUMENTATION]]               ;;;; Function Description: defvar is the recommended way to declare the use of a special variable in a program;;					(defvar variable) proclaims variable to be special, and my perform other system-dependent ;;					bookkeeping actions. If a second "argument" is supplied, (defvar variable initial-value);;					then variable is initialized to the result of evaluating the form initial-value unless it ;;					already has a value. The initial-value form is not evaluated unless it is used. defvar also ;;					provides a good place to put a comment describing the meaning of the variable.  The value ;;					returned is the name declared.;;					;;;; Argument(s):  name - a variable;;			  initial-value - a lisp form;;			  documentation - a string        	;;;; Returns: NAME             ;;(do-test "test defvar - test case copied from page 68 of CLtL"		(makunbound '*visible-window-defv1*)		(defvar *visible-window-defv1* 0 "Number of window-defv1 at least partially visible on the screen")		(and (zerop *visible-window-defv1*)			(equal (documentation '*visible-window-defv1* 'variable) 				  "Number of window-defv1 at least partially visible on the screen")			(setq *visible-window-defv1* 1)			(defvar *visible-window-defv1* 0)			(= *visible-window-defv1* 1) ; initial value should not take effect since var is already defined		))(do-test "test defvar - defvar proclaims variable to be a special 0"	(= 			 (catch 'cat 				(defvar *defv2* (gcd 10 12))				(let ( (*defv2* (lcm 10 12)) )					(throw 'cat (locally (declare (special *defv2*)) (1+ *defv2*)))				))		  61))(do-test-group ( "test defvar - defvar proclaims variable to be a special 1"		:before (progn 					(defvar *defv3* 789)					(defun foo ()						(let ( (y 100))							(defun fun  () (let ((y 20)) (fun1) ))							(defun fun1 () y)							(fun)  ))					(defun foo2 ()						(let ()							(defun fun  () (let ((*defv3* 20)) (fun1) ))							(defun fun1 () (locally (declare (special *defv3*)) *defv3*) )							(fun)  ))			   ))	(do-test "test defvar - defvar proclaims variable to be a special 1"		(and 			(= (foo) 100)			(= (foo2) 20)			(= *defv3* 789)		)	))(do-test  "test defvar - The initial-value form is not evaluated unless the variable is used."	(let ((k 0)) 		(progn (proclaim '(special *reshaped-window-defv8*))			  (setq *reshaped-window-defv8* 7)			  (defvar *reshaped-window-defv8* (incf k))			  (equal (list *reshaped-window-defv8* k) '(7 0))		)	))(do-test "test defvar - with documentation"		  (progn	(defvar *shrinked-window-defv12* (cos 0) "number of shrinked window-defv12")	(equal (list (documentation '*shrinked-window-defv12* 'variable)			   (1+ *shrinked-window-defv12*)			   (documentation '*shrinked-window-defv12* 'variable) )		 '("number of shrinked window-defv12" 2.0 "number of shrinked window-defv12") )  ))(do-test "test defvar - the value returned by defvar is the name declared"	(and		(eq (defvar var1 1) 'var1)		(eq (defvar var3 3 "str3") 'var3)	))STOP