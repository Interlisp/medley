;; Function To Be Tested: complexp;;;; Source:        CLtL p. 75;;;; Chapter 6: Predicates		Section 2-2: Specific Data Type Predicates;;;; Created By:    Peter Reidy;;;; Creation Date: 20 September 86;;;; Last Update:   15 December 86;;;; Filed As:      {eris}<lispcore>cml>test>6-2-2-complexp.test;;;; Syntax: complexp object;;            ;; Function Description: True iff object is a complex number, NIL otherwise.;;;; Argument(s):	object any cml object ;;;; Returns:  non-nil or NIL          ;;(do-test-group complexp-group	:before	(test-defun complexptest (object &optional (expected-value nil))	"See if complexp is true or not of an object, depending on the expected value; see if (typep object 'complex) <=> (complexp object); see if #c(a b) eql (complex a b)." 		(and			(cond				(expected-value				 (complexp object))				(t (null (complexp object)))			)  ; cond			(eq (complexp object) (typep object 'complex));; #C(a b) is equivalent to (complex a b), for all numbers except floating-point, whose imagpart is 0.00 (see Steele p. 220).			(cond				;; So test this for non-floating numbers				((and (numberp object) (not (floatp object)))				 (eql object (complex (realpart object)(imagpart object))))				;; ... but give floats and non-numbers this one for free.				(t t)			)  ; cond		)  ; and	)  ; test-defun;;	(do-test complexp-with-complex-test		(every #'(lambda (object) (complexptest object t))			(list				#c(3 5)			; the simplest cases				#C(3. 5.)				#c(2/3 3/4)				#c(12/3 77/11)				#C(0 #5r12)		; zero real part is ok				#C(0.00 #5r12)				#C(3/4 3.77)		; mixed types get converted				#C(27 44.99e12)				#C(33e5 27/12)				#c(#O-17/32 12)				#c(#5r12 #4r22/31)				#c(7.7777 3/2)				#C(0 0.0)			; imaginary part can be zero if it's floating zero				#C(3/22 0.00)				#C(37e12 .00)				(+ #C(3/4 22.4e4) pi) ; computed numbers				(+ pi #C(3/4 22.4e4))				(- #C(50/2 35))				(* 3 #C(50/2 35))				(/ 27 #C(3 3))				(cadr (list 25 (* 3 #C(50/2 35)) 40 30 " "))				'#C(3. 5.)			; complex numbers evaluate to themselves				'#C(33e5 27/12)				(eval '#C(0 0.0))				(eval (cadr (list 25 (* 3 '#C(50/2 35)) 40 30 " ")))			) ; list		) ; every	)  ; do-test complexp-with-complex-test;;	(do-test complexp-with-non-complex-test		(every 'complexptest			(list				0				(random most-positive-fixnum) ; integers				-16/2				(realpart (complex 3 3.2))				(imagpart #c(3/2 3))				(- (random most-positive-fixnum))				'5				7.99					; float				(realpart #C(7.00 3.3))				(imagpart (complex 7.00 3.3))				3/2					; ratios				#o-17/32				#c(37/22 0)			; fixed zero imaginary part yields just the real part				#c(0 0)				#c(3/4 0)				"#c(3/4 0)"					(make-symbol "#c(3/4 0)")				) ; list		) ; every	)  ; do-test complexp-with-non-complex-test)  ; do-test-groupSTOP