;; Function To Be Tested: SIGNUM;;;; Source: Guy L Steele's CLTL;; Section: 12.5.2 Trigonometric and Related Functions;; Page: 206;;;; Created By:    Kelly Roach and John Park;;;; Creation Date: July 12,1986;;;; Last Update:   Dec 18,1986;;;; Filed As:      {ERIS}<LISPCORE>CML>TEST>12-5-2-SIGNUM.TEST;;;;;; Syntax:        (SIGNUM NUMBER);;;; Function Description:;; By definition,;; ;;     (SIGNUM X) = (IF (ZEROP X) X (/ X (ABS X)));;     ;; For a rational number, SIGNUM will return one of -1, 0, or 1;; according to whether the number is negative, zero, or positive.;; For a floating-point number, the result will be a floating-point number;; of the same format whose value is minus one, zero, or one.;; For a complex number Z, (SIGNUM Z) is a complex number of;; the same phase but with unit magnitude, unless Z is a complex zero,;; in which case the result is Z.;; For example:;; ;;     (SIGNUM 0) => 0;;     (SIGNUM -3.7L5) => -1.0L0;;     (SIGNUM 4/5) => 1;;     (SIGNUM #C(7.5 10.0)) => #C(0.6 0.8);;     (SIGNUM #C(0.0 -14.7)) => #C(0.0 -1.0);;     ;; For non-complex rational numbers, SIGNUM is a rational function,;; but it may be irrational for complex arguments.;; ;; Argument(s):   NUMBER - a number;;;; Returns:       a number;;(do-test-group 	(signum-setup	:before (progn		(setq signum-tolerance 0.00001)		(setq signum-test-cases '(0 1 2 -1 0.0 3.0 -5.0 #C(0.0 0.0) #C(1.1 -9.0)			#C(-2.0 -3.0)))		(setq complex-zero #C(0.0 0.0))				(defun compute-signum (x)			(if (zerop x) x (/ x (abs x))))		(setq correct-signum 				(mapcar #'compute-signum  signum-test-cases))						(defun signum-difference (pairs) ;  calculate vs correct		   	(cond ((complexp (cdr pairs)) 					(and (< (abs (/ (- (realpart (car pairs))									(realpart (cdr pairs))) 								(realpart (cdr pairs))))					 	signum-tolerance)						(< (abs (/ (- (imagpart (car pairs))									(imagpart (cdr pairs))) 								(imagpart (cdr pairs))))						 signum-tolerance)))				(t (< (abs (/ (- (car pairs)(cdr pairs)) (cdr pairs)))					signum-tolerance))))		(defun check-signum-sign (x)							 (cond ((and (integerp x)(> x 0)) (= (signum x) 1))					((and (integerp x)(= x 0)) (= (signum x) 0))					((and	 (integerp x)(< x 0)) (= (signum x) -1)) 					((and (floatp x)(> x 0.0)) (= (signum x) 1.0))				 	((and (floatp x)(= x 0.0)) (= (signum x) 0.0))					((and (floatp x)(< x 0.0)) (= (signum x) -1.0))					((and	 (complexp x) (= x complex-zero)) (= (signum x) x))					(t (complexp (signum x)))))			)	)																  	(do-test signum-test		(and (setq calculated-signum  				(mapcar #'signum signum-test-cases))			(setq signum-pairs				(pairlis calculated-signum correct-signum))			(notany 'null (mapcar #'check-signum-sign signum-test-cases))			(or (equal calculated-signum correct-signum)				(notany 'null (mapcar #'signum-difference signum-pairs)))		)	))STOP