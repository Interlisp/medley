;; Function To Be Tested: delete;;;; Source:        CLtL    Section 14.3: Modifying Sequences        Page: 254;;;; Created By:    Karin M. Sye;;;; Creation Date: Sept. 22 ,1986;;;; Last Update:   Nov. 5 ,1986;;;; Filed As:      {eris}<lispcore>cml>test>14-3-delete.test;;;;;; Syntax:                delete ITEM SEQUENCE &KEY :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY;;;; Function Description:  delete returns a sequence of the same kind as the argument SEQUENCE that has the same elements ;;					except that those in the subsequence delimited by :START and :END and satisfying the test have;;					been deleted. This is a destructive operation.;;;; Argument(s):           ITEM        - ;;					SEQUENCE    -;;					:FROM-END   - nil or non-nil;;					:TEST       - a function of two arguments;;					:TEST-NOT   - a function of two arguments;;					:START :END - integer indices into the SEQUENCE, with :START <= :END;;					:COUNT      - an integer which limits the number of elements deleted from SEQUENCE;;					:KEY        - a function of one argument that will extract from an element the part;;							    to be tested in place of the whole element.;;;; Returns:               a sequence    ;;(do-test "test delete - test cases from page 254 of CLtL"	(and 	(equal (delete 4 '(1 2 4 1 3 4 5)) '(1 2 1 3 5))		(equal (delete 4 '(1 2 4 1 3 4 5) :count 1) '(1 2 1 3 4 5))		(equal (delete 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 5))		(equal (delete 3 '(1 2 4 1 3 4 5) :test #'>) '(4 3 4 5))	))(do-test "test delete 1"	(let* ((a '(1 2 3 4 5 6 7 8 9 10 5 4 3 2 1 5 4 3 2 1)) (b (copy-seq a)) (c (copy-seq a)) (d (copy-seq a)) (e (copy-seq a) ) (f (copy-seq a)))		(and	(equal (delete 3 a) 					'(1 2 4 5 6 7 8 9 10 5 4 2 1 5 4 2 1))			(equal (delete 3 b :from-end 'non-nil) 	'(1 2 4 5 6 7 8 9 10 5 4 2 1 5 4 2 1))			(equal (delete 3 c :count 2)			'(1 2 4 5 6 7 8 9 10 5 4 2 1 5 4 3 2 1))			(equal (delete 3 d :from-end t :count 2) '(1 2 3 4 5 6 7 8 9 10 5 4 2 1 5 4 2 1))			(equal (delete 3 e :count 0)			'(1 2 3 4 5 6 7 8 9 10 5 4 3 2 1 5 4 3 2 1))			(equal (delete 3 f :from-end t :count 0) '(1 2 3 4 5 6 7 8 9 10 5 4 3 2 1 5 4 3 2 1))		)	))(do-test "test delete 2"	(let* ((b "abcdefgabcdefgabcdefgabcdefgabcdefg") (c (copy-seq b)) (d (copy-seq b)) (e (copy-seq b)))		(and	(equal (delete #\b b :test #'char>) "bcdefgbcdefgbcdefgbcdefgbcdefg")			(equal (delete #\c c :test #'(lambda (x y) (= (char-code x) (- (char-code y) 2))) :count 4)				  "abcdfgabcdfgabcdfgabcdfgabcdefg")			(equal (delete #\f d :test-not #'char/=)  "abcdegabcdegabcdegabcdegabcdeg")			(equal (delete #\a e :test-not #'(lambda (x y) (equal x y) )) 				  "aaaaa")		)	))(do-test "test delete 3"	(let ((c '( (1 2 3) (2 3 4) (4 5 6) (4 6 7) (1 2 3) (6 7 8) (7 8 9) (2 3 4) (1 2 3)  (8 9 0) (4 5 6) )  ) d e f g)		(setf d (copy-seq c) e (copy-seq c) f  (copy-seq c) g (copy-seq c))		(and (equal (delete '(1 2 3) c :start 1 :test #'equal) 				  '((1 2 3) (2 3 4) (4 5 6) (4 6 7) (6 7 8) (7 8 9) (2 3 4)  (8 9 0) (4 5 6) ))			(equal (delete '(2 3 4) d :end  6 :test #'equal)				  '((1 2 3) (4 5 6) (4 6 7) (1 2 3) (6 7 8) (7 8 9) (2 3 4) (1 2 3)  (8 9 0) (4 5 6) )  )			(equal (delete '(1 2 3 ) e :start 2 :end 7 :test #'equal)				  '((1 2 3) (2 3 4) (4 5 6) (4 6 7) (6 7 8) (7 8 9) (2 3 4) (1 2 3)  (8 9 0) (4 5 6) ))			(equal (delete 2 f :key #'second )				  '( (2 3 4) (4 5 6) (4 6 7)  (6 7 8) (7 8 9) (2 3 4)  (8 9 0) (4 5 6) )  )			(equal (delete 6 g :test #'< :key #'third)				  '((1 2 3) (2 3 4) (4 5 6) (1 2 3) (2 3 4) (1 2 3)  (8 9 0) (4 5 6) ) )		)	))(do-test "test delete 4"	(let ((a '((9 2 3) (8 2 4) (1 2 4) (-4 3 2) (5 3 5) (-5 2 1) (3 4) (2 9) (10 2) (-2 4))  ))		(equal (delete 5 a :from-end t :start 2 :end 8 :test #'> :count 4 :key #'car)			  '((9 2 3) (8 2 4) (1 2 4)  (5 3 5)  (10 2) (-2 4))  )	))(do-test "test delete 5"	(let* ((a '#((1 #\2 3) (#\a #\b) (#\9 8 5) (#\1 #\2 #\3) (1 2 3) (3 #\2 1) (4 #\3 #\8) (#\q #\w #\e))  ) 		 (b (delete 56 a :start 1 :end 7 :test-not #'(lambda (x y) (equal (type-of x) (type-of y))) 										:key #'second)  ))		(equalp b '#( (1 #\2 3) (#\9 8 5) (1 2 3) (#\q #\w #\e)))	))(do-test "test delete 6"	(let ( (a (make-array 200 :element-type 'float))  b)		(fill  (fill (fill (fill a  20.0 :end 50) 30.0 :start 50 :end 100) 40.0 :start 100 :end 150) 50.0 :start 150 )		(setq b (delete 35 a :start 75 :end 150 :test #'(lambda (x y) (or (= (+ x 5) y) (= (- x 5) y)))  ))		(equalp b (make-array (+ 50 25 50) :initial-contents (append (make-list 50 :initial-element 20.0)								  (make-list 25 :initial-element 30.0)								  (make-list 50 :initial-element 50.0))))	))STOP