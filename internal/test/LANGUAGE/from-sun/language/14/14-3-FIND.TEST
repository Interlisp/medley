;; Function To Be Tested: find;;;; Source:        CLtL    Section 14.3: Modifying Sequences        Page: 257;;;; Created By:    Karin M. Sye;;;; Creation Date: Sept. 25 ,1986;;;; Last Update:   Sept. 25 ,1986;;;; Filed As:      {eris}<lispcore>cml>test>14-3-find.test;;;;;; Syntax:                find  ITEM SEQUENCE &KEY :FROM-END :TEST :TEST-NOT :START :END :KEY;;;; Function Description:  If the subsequence delemited by :START and :END  contains an element satisfying the test, then the liftmost;;				     (or rightmost) such element is returned.;;;; Argument(s):           ITEM     -			;;					SEQUENCE    -;;					:TEST       - a function which takes two arguments;;					:TEST-NOT   - a function which takes two arguments;;					:FROM-END   - nil or non-nil;;					:START :END - integer indices into the SEQUENCE, with :START <= :END;;					:KEY        - a function of one argument that will extract from an element the part;;							    to be tested in place of the whole element.;;;; Returns:               a sequence    ;;(do-test "test find 0"	(and (eq 		(find 2 '(3 4 5 6 2 1 4)) 2)		(eq		(find 3 '(1 2 4 5 6 7 8 9)) nil)		(equal	(find  '(1 2) '( 1 2 ((1 2)) 3 4 (1 2)) :test #'equal ) '(1 2))		(char-equal (find #\q "antique" :test #'equal) #\Q)		(equalp	(find #*1011 (vector #*0000 #*1111 #*1011) :test #'equalp) #*1011)	))(do-test "test find 1"	(let ((a '(3 4 7 8 -2 9 8 -3 4 6 1 4 5 2 0 4) ))		(and (eq (find 7 a :start 3) nil)			(=  (find 7 a :start 2 ) 7)			(eq (find -3 a :end 7 ) nil)			(=  (find -3 a :end 8) -3)			(eq (find -2 a :start 5 :end 14) nil)			(=  (find -2 a :start 4 :end 14) -2)			(eq (find 2  a :start 4 :end 13) nil)			(=  (find 2  a :start 4 :end 14)  2)			(eq (find 11 a ) nil)		)	))(do-test "test find 2"	(let (( a "Fatal error in function SYSTEM: TASK-SCHEDULER"))		(and	(char= (find #\n a :test #'char=) #\n)			(char= (find #\: a :test #'char=) #\:)			(char= (find #\a a :test-not #'char>= ) #\t)			(char= (find #\F a :test #'(lambda (x y) (and (alpha-char-p y) (char> x y)))) #\E)			(char= (find #\R a :test-not #'(lambda (x y) (/= (- (char-code y) (char-code x)) 												   (- (char-code #\a) (char-code #\A)) ))) #\r)		)	))	(do-test "test find 3"	(let ((a '( (1 3 5) (2 4 6)(38 5 7) (4 2 1) (-3 -5 -7) (-2 -4 -1) (10 22 31) (38 72 10))  ))		(and (equal (find 7  a :key #'third) '(38 5 7))			(equal (find -4 a :key #'second) '(-2 -4 -1))			(equal (find 38 a :key #'first)  '(38 5 7))			(equal (find 38 a :key #'first :from-end t) '(38 72 10))			(equal (find 0 a :key #'cadr :test #'(lambda (x y) (> x y))) '(-3 -5 -7))			(equal (find 0 a :key #'cadr :test #'(lambda (x y) (> x y)) :from-end t) '(-2 -4 -1))		)	))(do-test "test find 4"	(let ((a '(#*11111 #*0000 #*10101010 #*01010101 #*111 #*00000 #*1110 #*0101111 #*000 #*11100 #*01000) ))		(and	(equalp (find #*10 a :start 4 :end 10 :test #'equalp :key #'(lambda (x) (subseq x 1 3)))  #*0101111)			(equalp (find #*11 a :start 1 :end 9 :test #'equalp :from-end t :key #'(lambda (x) (subseq x 0 2)) ) #*1110)			(equalp (find #*01 a :start 4 :end 10 :test-not #'(lambda (x y) (or (/= (elt x 0) (elt y 0))															    (/= (elt x 1)  (elt y 1))  ))							 :from-end t)  #*0101111)			(equalp (find 'dummy a :test-not #'(lambda (x y) (find 0 y))) #*11111)					(equalp (find 'dummy a :test-not #'(lambda (x y) (find 0 y)) :from-end t) #*111)					(equalp (find 'dummy a :test-not #'(lambda (x y) (find 1 y))  :start 2 :from-end t) #*000)						(equalp (find 'dummy a :test-not #'(lambda (x y) (find 1 y)) ) #*0000 )		)	))STOP