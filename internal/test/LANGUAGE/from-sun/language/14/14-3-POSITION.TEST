;; Function To Be Tested: position;;;; Source:        CLtL    Section 14.3: Modifying Sequences        Page: 257;;;; Created By:    Karin M. Sye;;;; Creation Date: Sept. 27 ,1986;;;; Last Update:   Jan 28, 1987 Jim Blum - Changed = to eql in test 0 since one of;;					values in the list was a sublist which fails on the SUN.;;;; Filed As:      {eris}<lispcore>cml>test>14-3-position.test;;;;;; Syntax:                position  ITEM SEQUENCE &KEY :FROM-END :TEST :TEST-NOT :START :END :KEY;;;; Function Description:  If the subsequence delemited by :START and :END  contains an element satisfying the test, then the index;;					within SEQUENCE of the leftmost (or rightmost) such element is returned as a non-negative integer; otherwise;;					nil is returned.;;;; Argument(s):           ITEM     -			;;					SEQUENCE    -;;					:TEST       - a function which takes two arguments;;					:TEST-NOT   - a function which takes two arguments;;					:FROM-END   - nil or non-nil;;					:START :END - integer indices into the SEQUENCE, with :START <= :END;;					:KEY        - a function of one argument that will extract from an element the part;;							    to be tested in place of the whole element.;;;; Returns:               a positive number or nil    ;;(do-test "test position 0"	(and (= 		(position 2 '(3 4 5 2.0 6 2 1 9 8 4 2 4)) 5)		(= 		(position 2 '(3 4 5 2.0 6 2 1 9 8 4 2 4) :from-end t) 10)		(eql		(position 3 '(1 2 4 5 6 7 8 (3) 9)) nil)		(=		(position  '(1 2) '( 1 2 ((1 2)) 3 4 (1 2)) :test #'equal ) 5)		(=	     (position #\q "antique-que-que" :test #'equal) 4)		(=	     (position #\q "antique-que-que" :test #'equal :from-end t ) 12)		(=		(position #*1011 (vector #*0000 #*1111 #*1011) :test #'equalp) 2)	))(do-test "test position 1"	(let ((a '(3 4 7 8 -2 9 7 8 -3 4 6 1 7 4 5 -3 2 0 4 -2 7 2) ))		;;		;;	 0 1 2 3 4  5 6 7 8  9 0 1 2 3 4 5  6 7 8 9 20 21		;;		(and (=  (position 7 a :start 3) 6)			(=  (position 7 a :start 2 ) 2)			(=  (position -3 a :end 17 ) 8)			(=  (position -3 a :start 9 :end 16) 15)			(eq (position -2 a :start 5 :end 14) nil)			(=  (position -2 a :start 4 :end 14) 4)			(=  (position 2  a :start 4 :end 19) 16)			(eq (position 2  a :start 17 :end 21)  nil)			(eq (position 34 a ) nil)		)	))(do-test "test position 2"	(let (( a "Fatal error in function SYSTEM: TASK-SCHEDULER"))		;;		;;    0123456789012345678901234567890123456789012345		;;		(and	(= (position #\n a :test #'char=) 13)			(= (position #\: a :test #'char=) 30)			(= (position #\a a :test-not #'char>= ) 2)			(= (position #\F a :test #'(lambda (x y) (and (alpha-char-p y) (char> x y)))) 28)			(= (position #\R a :test-not #'(lambda (x y) (/= (- (char-code y) (char-code x)) 												   (- (char-code #\a) (char-code #\A)) ))) 7)		)	))(do-test "test position 3"	(let ((a '( (1 3 5) (2 4 6)(38 5 7) (4 2 1) (-3 -5 -7) (-2 -4 -1) (10 22 31) (38 72 10))  ))		;;		;;        0       1      2        3        4         5          6          7		;;		(and (= (position 7  a :key #'third) 2)			(= (position -4 a :key #'second) 5)			(= (position 38 a :key #'first)  2)			(= (position 38 a :key #'first :from-end t) 7)			(= (position 0 a :key #'cadr :test #'(lambda (x y) (> x y))) 4)			(= (position 0 a :key #'cadr :test #'(lambda (x y) (> x y)) :from-end t) 5)			(eq (position 0 a :key #'caddr) nil) 		)	))(do-test "test position 4"	(let ((a '(#*11111 #*0000 #*10101010 #*01010101 #*111 #*00000 #*1110 #*0101111 #*000 #*11100 #*01000) ))		;;		;;       0       1       2         3         4      5        6      7       8      9       10		;;		(and	(= (position #*10 a :start 4 :end 10 :test #'equalp :key #'(lambda (x) (subseq x 1 3)))  7)			(= (position #*11 a :start 1 :end 9 :test #'equalp :from-end t :key #'(lambda (x) (subseq x 0 2)) ) 6)			(= (position #*01 a :start 4 :end 10 :test-not #'(lambda (x y) (or (/= (elt x 0) (elt y 0))															    (/= (elt x 1)  (elt y 1))  ))							 :from-end t)  7)			(= (position 'dummy a :test-not #'(lambda (x y) (find 0 y)) :start 2 ) 4)					(= (position 'dummy a :test-not #'(lambda (x y) (find 0 y)) :end 4 :from-end t) 0)					(= (position 'dummy a :test-not #'(lambda (x y) (find 1 y))  :start 2 :from-end t) 8)						(= (position 'dummy a :test-not #'(lambda (x y) (find 1 y)) ) 1 )		)	))STOP