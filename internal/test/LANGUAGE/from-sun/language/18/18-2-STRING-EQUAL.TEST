;; Function To Be Tested: string-equal;;;; Source:        CLtL p. 301 ;; Chapter 18: Strings		Section 2: String Comparison;;;; Created By:    Peter Reidy;;;; Creation Date: 27 July 86;;;; Last Update:   9 December 86;;;; Filed As:      {eris}<lispcore>cml>test>18-2-string-equal.test;;;;;; Syntax:   string-equal string1 string2 &key :start1 :end1 :start2 :end2             ;;;; Function Description: Compares the 2 strings ignoring case differences; returns the length of the common portion of the keyword-delimited substrings iff their corresponding characters are identical (i.e. char-equal) but for case, nil otherwise. ;;;; Argument(s): :start1, :start2: the start-comparison positions (counting from 0) in the respective strings;;			 :end1, :end2: the end-comparison positions + 1 (counting from 0) - i.e. comparison stops with the previous character; for the string "characters" and the end-position 7, comparison stops with the letter "t".        	;;;; Returns: a length or nil, depending on the results of the comparison.             ;; END PREAMBLE START WORKING CODE;;(do-test-group	(string-equal-group		:before		(test-setq			simple1 ";;;; Function Description: Compares the 2 strings; returns t iff their corresponding characters are identical, nil otherwise. ;;;; Argument(s): :start1, :start2: the start-comparison positions (counting from 0) in the respective strings;;			 :end1, :end2: the end-comparison positions + 1 (counting from 0) - i.e. comparison stops with the previous character; for the string \"characters\" and the end-position 7, comparison stops with the letter \"t\".        	;;"  ; END SIMPLE1 DEFINITION;;;; Simple1 and Simple2 are the same length, but simple2 starts and ends 1 character later.;;			simple2 ";;; Function Description: Compares the 2 strings; returns t iff their corresponding characters are identical, nil otherwise. ;;;; Argument(s): :start1, :start2: the start-comparison positions (counting from 0) in the respective strings;;			 :end1, :end2: the end-comparison positions + 1 (counting from 0) - i.e. comparison stops with the previous character; for the string \"characters\" and the end-position 7, comparison stops with the letter \"t\".        	;;" ; END SIMPLE2 DEFINITION;;;; Simple3 is simple2 with some letters capitalized.			simple3 ";;; FuNcTiOn DESCRIPTION: Compares the 2 STRINGS; returns T IFF their corresponding characters are identical, nil otherwise. ;;;; Argument(S): :start1, :start2: the start-comparison positions (counting from 0) in the reSPECTive strings;;			 :end1, :end2: the end-comparison positions + 1 (counting from 0) - i.e. comparison stops with the previous character; for the string \"characters\" and the end-position 7, comparISON Stops with the letter \"t\".        	;;" ; END SIMPLE3 DEFINITION  			length (length simple1)			arbitrary "llQ8uqk&Y1SlQ8upp"		) ; test-setq	) ; string-equal-group;;	(do-test "check string-equal setups"		(AND		;; Don't bother unless I set things up right.			(every #'(lambda (string) (= length (length string))) (list simple1 simple2))			(string-equal simple2 simple3)			(string/= simple2 simple3)			;; The common portion of the strings is all but the end characters.  What are string= are a fortiori string-equal.			(string-equal simple1 simple2 :start1 1 :end2 (- length 1))			(string-not-equal simple1 simple3)		)  ; and	)  ; do-test "check string-equal setups";;	(do-test "string-equal with a simple array"			(string-equal "q" (make-array 11 :element-type 'string-char :initial-contents '( #\Newline #\Newline #\Newline #\Newline #\Newline #\q #\Newline #\Newline #\Newline #\Newline #\Newline)))	)  ; do-test "string-equal with a simple array";;	(do-test "string-equal with a non-simple array";; NOTE: Not working 27 7.  See AR 6190 - can't displace to a string		;; The quoted portion starts on the 3rd character of simple1 - i.e. 2 if counting from 0.		(string-equal			";; f"			(make-array 5 :element-type 'string-char :adjustable t :fill-pointer t :displaced-to simple1 :displaced-index-offset 2)		)  ; string-equal	)  ; do-test "string-equal with a non-simple array";;	(do-test "string-equal ignores case differences, but string= doesn't"	;; With every corresponding letter of different case		(and			(string-equal arbitrary				(make-array 15 :element-type 'string-char :initial-contents '( #\L #\L #\q #\8 #\U #\Q #\K #\& #\y #\1 #\s #\L #\q #\8 #\U))			:start1 0 :start2 0 :end2 13 :end1 13			)  ; string-equal;; The same comparison for string= should fail.			(not				(string= arbitrary					(make-array 15 :element-type 'string-char :initial-contents '( #\L #\L #\q #\8 #\U #\Q #\K #\& #\y #\1 #\s #\L #\q #\8 #\U))			:start1 0 :start2 0 :end2 13 :end1 13				)			)		)  ; and	)  ; do-test "string-equal ignores case differences, but string= doesn't";;	(do-test "string-equal coerces symbols to strings"		(and			(every 'string-equal 				(list 'atom 'Atom '|Mixed Case|)				(list "ATOM" "ATOM" "mIXED cASE")			)			(not (string-equal "Mixed Case" '|Mixed Case |))		)  ; and	)  ; do-test "string-equal coerces symbols to strings";;	(do-test "string-equal with a symbol-name"		(string-equal (symbol-name 'simple3) "simple3")	) ;do-test "string-equal with a symbol-name";;	(do-test "char-equal portability test"	;; The function should be portable - not contingent on keyboard layout.  Upper- and lower-case numbers and punctuation should fail.		(notany `string-equal '("\\" "1" "2" "3" "4" "5" "6" "7" "8" "9" "0" "-" "=" "[" "]" ";" "'" "`" "," "." "/" ) '("|" "!" "@" "#" "$" "%" "^" "&" "*" "(" ")" "_" "+" "{" "}" ":" "\"" "~" "<" ">" "?"))	) ;do-test "char-equal portability test"	) ;do-test groupSTOP 