;; Function To Be Tested: defstruct;;;; Source: Common Lisp the Language by Guy Steele;;         Section 19: Structures, page 305;;;; Created By: John Park  Reviewed by Peter Reidy (as a brief test of main features ;; already implemented 7 aug.);;;; Creation Date: Aug 5, 86;;;; Last Update:  April 9, 86 (CSW) ;; ;; History:  Added regression tests thru lyric patch 4 (CW);;;; Filed as:      {eris}<lispcore>cml>test>19-defstruct.test;;;; Syntax: (defstruct name-and-options [doc-string] {slot-description}+) ;;;; Function Description:  This function defines a record-structure data type.;; A general call to defstruct looks like the following:;;			(defstruct (name option-1 option-2 ...);;					doc-string;;					slot-description-1;;					slot-description-2;;					....);; ;; Argument(s):  ;;			Name: must be a symbol; it becomes the name of a new data type ;;				consisting of all instances of the structure.  The name is ;;				returned as the value of the defstruct form. ;;			Doc-String: This is attached to the name as a documentation;;					 string of type structure.;;			Slot-description-j:  Each slot-description-j is of the form ;;					(slot-name default-init;;						slot-option-name-1 slot-option-value-1;;						slot-option-name-2 slot-option-value-2;;						......);; Returns: The value of the defstruct form. ;;;; Constraints/limitations: Defstruct options "initial-offset", and "type" ;; (vector), are not implemented as of Aug 7, 86.;; Comments:;;;; Test Case I (simple-defstruct-test): This test checks for data-type of a created ;; structure, make and  copy functions,  and resetting of the structure components.;;;; Test Case II (slot-option-test):  This test determines if defstruct slot options ;; can be specified;; Test Case III:  This test determines if each of the options can be given to;; defstruct.  Options include conc-name, constructor, copier, predicate, include,;; print-function, type, named, and initial-offset.(do-test-group ("defstruct-test-setup"	:before (progn		(setq ship-test-case-1			(defstruct ship x-position y-position x-velocity y-velocity mass))		 (setq ship-1 (make-ship))		 (setq ship-2 (make-ship :x-position 10 :y-position 0							:x-velocity 54 :y-velocity 99))		 (setq ship-3 (copy-ship ship-2))		 (setq ship-4 (make-ship	:x-position 100 :y-position 1)) 				(setq *default-ship-mass* 777.0)		(setq test-case-2 (defstruct new-ship					(x-position 0.0 :type short-float)					(y-position 0.0 :type short-float)					(x-velocity 0 :type fixnum)					(y-velocity 0 :type fixnum)					(mass *default-ship-mass* :type short-float 										:read-only t)))		(setq new-ship-1 (make-new-ship						:x-position 10.9						:y-position 222.99						:x-velocity 50						:y-velocity 100						:mass *default-ship-mass*))))						(do-test "simple-defstruct-test" 		(and (typep ship-1 'ship)				(ship-p ship-1)			(eq ship-test-case-1 'ship)			(eq (ship-x-position ship-2) 10)			(eq (ship-y-position ship-2) 0)			(eq (ship-x-velocity ship-2) 54)			(eq (ship-y-velocity ship-2) 99)			(eq (ship-mass ship-2) nil)			(eq (ship-x-position ship-3) 10)			(eq (ship-y-position ship-3) 0)			(eq (ship-x-velocity ship-3) 54)			(eq (ship-y-velocity ship-3) 99)			(eq (ship-mass ship-3) nil)			(eq (ship-x-position ship-4) 100)			(eq (ship-y-position ship-4) 1)			(eq (ship-x-velocity ship-4) nil)			(eq (ship-y-velocity ship-4) nil)			(eq (ship-mass ship-4) nil)			(setf (ship-x-position ship-3) 0)			(eq (ship-x-position ship-3) 0)))(do-test "slot-option-test" 		(and (new-ship-p new-ship-1)			(typep (new-ship-x-position new-ship-1) 'short-float)			(typep (new-ship-y-position new-ship-1) 'short-float)			(typep (new-ship-x-velocity new-ship-1) 'fixnum)			(typep (new-ship-y-velocity new-ship-1) 'fixnum)			(typep (new-ship-mass new-ship-1) 'single-float)			(setf (new-ship-x-position new-ship-1) 100.0)			(eql (new-ship-mass new-ship-1) *default-ship-mass*)			(typep (new-ship-y-position new-ship-1) 'short-float)))(do-test "conc-name-option-test" 	(and	 (defstruct (employer (:conc-name manager-)) name age sex)		(setq new-employer (make-employer :name 'smith :age 40 :sex 'm))		(eq (manager-name new-employer) 'smith)		(eq (manager-age new-employer) 40)		(eq (manager-sex new-employer) 'm)))(do-test "constructor-option-test"			(and (defstruct auto  engine body)			(fboundp 'make-auto)			(defstruct (auto (:constructor build-auto)) engine body)			(fboundp 'build-auto)			(setq new-auto (build-auto :engine '8cyl :body 'convert))			(eq (auto-engine new-auto) '8cyl)			(defstruct (auto (:constructor design-auto)) engine body)			(fboundp 'design-auto)			))(do-test "copier-option-test"		(and (defstruct (truck (:copier duplicate-truck)) engine body)			(setq prototype (make-truck :engine '16cyl :body 'wide))			(setq new-truck (duplicate-truck prototype))			(eq (truck-engine new-truck) '16cyl)			(eq (truck-body new-truck) 'wide)			(defstruct (sports-car (:copier nil)) engine body)			(not (fboundp 'copy-sports-car))			))(do-test "predicate-option-test"		(and (defstruct (tools (:predicate is-tool?)) name size direction)			(setq tool1 (make-tools))			(is-tool? tool1)))(do-test "include-option-test"		(and (defstruct person name age sex)			(defstruct (astronaut (:include person)							 (:conc-name astro-))							helmet-size							(favorite-beverage 'tang))			(setq astro-1 (make-astronaut :name 'buzz									:age 47									:sex 'm									:helmet-size 17.5))			(eq (person-name astro-1) 'buzz)			(eq (astro-name astro-1) 'buzz)			(eq (astro-age astro-1) 47)			(eq (astro-sex astro-1) 'm)			(equalp (astro-helmet-size astro-1) 17.5)  			(eq (astro-favorite-beverage astro-1) 'tang)))(do-test "print-function-option-test"		(and (defstruct (numbers (:print-function default-structure-printer))					x y z)			(setq  number1 (make-numbers :x 100 :y 200 :z 300))			(eq (numbers-x number1) 100)			(eq (numbers-y number1) 200)			(eq (numbers-z number1) 300)			(numbers-p number1)))(do-test "type-option-test"		(and (defstruct (binop (:type list))				(operator '? :type symbol) operand-1 operand-2)			(setq binop-1 (make-binop :operator '+							:operand-1 'x :operand-2 5))			(equal binop-1 '(+ x 5))			(setq binop-2 (make-binop :operand-2 4 :operator '*))			(equal binop-2 '(* nil 4))			(defstruct (trinop (:type vector)) element1 element2)			(vectorp (make-trinop :element1 0 :element2 1))))(do-test "named-option-test"		(and (defstruct (named-binop (:type list) :named)				(operator '? :type symbol) operand-1 operand-2)			(equal (make-named-binop :operator '+							:operand-1 'x :operand-2 5)			       '(named-binop + x 5))			(equal (make-named-binop :operand-2 4 :operator '*)			       '(named-binop * nil 4))))(do-test "initial-offset-option-test"		(and (defstruct (offset-binop (:type list) (:initial-offset 2))				(operator '? :type symbol) operand-1 operand-2)			(setq offset-binop-1 (make-offset-binop :operator '+							:operand-1 'x :operand-2 5))			(equal offset-binop-1 '(NIL NIL + X 5))			(defstruct (offset-binop2 (:type list) :named (:initial-offset 2))				(operator '? :type symbol) operand-1 operand-2)			(setq offset-binop-3 (make-offset-binop2 :operator '+							:operand-1 'x :operand-2 5))			(equal offset-binop-3 '(NIL NIL OFFSET-BINOP2  + X 5))));;;;  Regression tests (do-test "AR 7650 Regression test"	(and (defstruct (foo (:type (vector fixnum))) s1 (s2 2) s3))		(setq s (make-foo :s1 1))		(eq (foo-s1 s) 1)))) STOP