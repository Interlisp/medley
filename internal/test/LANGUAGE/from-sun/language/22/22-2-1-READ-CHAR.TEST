;; Function To Be Tested: read-char;;;; Source:        CLtL p. 379;;;; Chapter 22: Input/Output		Section 2.1: Input from Character Streams;;;; Created By:    Peter Reidy;;;; Creation Date: 12 November 86;;;; Last Update: 1-6-87 Jim Blum - fixed macro char tests;;			2-3-87 Jim Blum - changed (read test t nil t) to (read test);;						  and for test2 in last test;;						changed (read-char nil nil 50) to ;;								(read-char *standard-input* nil 50);; Filed As:      {eris}<lispcore>cml>test>22-2-1-read-char.test;;;; Syntax: read-char &optional input-stream eof-error-p eof-value recursive-p ;;            ;; Function Description: reads and returns the next character from input-stream. ;;;; Argument(s):	input-stream - a stream;;			eof-error-p - if true, signal an error if eof is encountered before the end of the line;;			eof-value - if eof-error-p is nil, return this value if eof is encountered before the end of the line;;			recursive-p - if true, this is an embedded call, not top-level;;;; Returns: the character read			 ;;(do-test-group	(read-char-group		:before		(test-setq			test(make-string-input-stream "@5")		     test2(make-string-input-stream "#@4")			blood	(make-string-input-stream "12345")			jet	(make-string-input-stream "100")			savetable *readtable*			*readtable* (copy-readtable nil)		)  ; test-setq;;		:after		(progn			(mapcar 'close (list blood jet test test2))			(setq *readtable* savetable)		)  ; progn	)  ; read-char-group;;	(do-test "read-char moves the pointer"		(and			(eq #\1 (read-char blood))			(eq #\2 (read-char blood))			(eq #\3 (read-char blood))			(= 45 (read blood))		)  ; and	)  ; do-test "read-char doesn't move the pointer";;	(do-test "read-char accepts alternative input-stream"		(let	((*standard-input* (make-string-input-stream "a B c D")))			(and				(eq #\a (read-char))				(eq #\space (read-char))				(= 5 (length (read-line)))				(or (close *standard-input*) t)  ; for portability			)  ; and 		)  ; let	)  ;do-test "read-char accepts alternative default stream";;	(do-test "read-char eof arguments test"		(let	((*standard-input* jet))			(read)			(= 50 (read-char *standard-input* nil 50))		)  ; let	)  ;do-test "read-char eof arguments test";;	(do-test read-char-recursive-p-test		(set-macro-character #\@ #'(lambda (stream char) (read-char stream t nil nil)))		(set-dispatch-macro-character  #\# #\@ #'(lambda (stream mac disp) (read-char stream t nil t)))		(and			(equal #\5 (read test))			(equal #\4 (read test2))		)  ; and	)  ;do-test read-char-recursive-p-test)  ; do-test-groupSTOP