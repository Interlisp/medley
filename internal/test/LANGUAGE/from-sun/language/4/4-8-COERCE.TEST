;; Function To Be Tested: coerce;;;; Source:        CLtL p. 51;;;; Chapter 4: Strings		Section 8: Type Conversion Function;;;; Created By:    Peter Reidy;;;; Creation Date: 6 October 86;;;; Last Update:   Feb 3, 87 Jim Blum;;;; Filed As:      {eris}<lispcore>cml>test>4-8-coerce.test;;;; Syntax:coerce object result-type;;;; Function Description: Turns object into a like object of type result-type.;;;; Argument(s):	object - any cml object that may be converted to an object of type result-type;;			result-type - any defined cml type specifier;;;; Returns: the converted object             ;;(do-test-group coerce-group	:before	(progn		(test-setq			bound 0			type-examples (list				(1+ most-positive-fixnum)  ; bignum; common				0				; bit; t				27/60				; rational; ratio				5.00				; float; double-float; single-float; long-float; short-float				3.1415926535897932384d0				#c( 6/7 3.00)		; complex				#\*				; standard-char; character				#\backspace		; semi-standard				bound				; bound symbol				(gentemp)			; unbound symbol				'( a b c . d)		; cons; sequence				(list)			; list				(vector 5 4 3 2 1)		; vector				" string "			; string; simple-string; simple-array				#*1001			; bit-vector; simple-bit-vector				#'+				; compiled-function				#'(lambda nil nil)	; function				(random 1000)		; integer; atom; fixnum				(make-hash-table)	; hash-table				:key				; keyword				(copy-readtable)	; readtable				nil				; null				(car(list-all-packages)) ; package				(pathname nil)			; pathname				(make-synonym-stream nil) ; stream				*random-state*		; random-state			)  ; list		)  ; test-setq		(test-defun charcoercetest (object expected-result)		"See if an object coerced to a character is char= the expected result; if it's an integer, see if it's char= (int-char object)."		 (let ((result (coerce object 'character)))		 	(and				(char= result expected-result)				(cond					((integerp object)					 (char= result (int-char object))					)					;; Non-integers get this one for free.					(t t)				)  ; cond 		 	)  ; and		 )  ; let		)  ; test-defun	)  ; progn;;	(do-test coerce-converts-sequence-types-test		(and			;; A sequence of one type can be converted to a sequence of another type.			(listp (coerce '((1 2 3)(4 5 6)) 'list))			(let ((hexarray	(make-array 5 :initial-contents '(#\E 8 3 0 #\B)						)  ; make-array				 )  ; hexarray				)  ; values (outer let)				(let	((hexlist (coerce hexarray 'list)))			;; Corresponding elements must be eql.					(and						(eql (car hexlist) (aref hexarray 0))						(eql (aref hexarray (1- (length hexlist))) (car (reverse hexlist)))						)  ; and				)  ; inner let			)  ; outer let		)  ; and	)  ; do-test coerce-converts-sequence-types-test;;	(do-test coerce-to-character-test	;; Digits, one-character strings and one-character symbols are coercible to characters.		(every 'charcoercetest			(list "a" "*" #\newline (char-int #\A) 1000 '? (make-symbol "?"))			(list #\a #\* #\newline #\A (int-char 1000) #\? #\?)		)	)  ; do-test coerce-to-character-test;;	(do-test coerce-to-float-test	;; Non-complex numbers are coercible to floating-point.		(AND			(typep (coerce (random 1000) 'float) 'float)			(typep (coerce 100/1000 'long-float) 'long-float)			(typep (coerce (* 3/4 50) 'double-float) 'double-float)			(typep (coerce (* 35e2) 'single-float) 'single-float)		)  ; and	)  ; do-test coerce-to-float-test	(do-test coerce-to-complex-test	;; Any number is coercible to complex		(AND			(eql (coerce #c(3 5) (type-of #c(3 5))) #c(3 5))			(typep (coerce 3/4 'complex) 'ratio)			(typep (coerce (coerce 3/4 'double-float)'complex) 'complex)			(typep (coerce (random 1000) 'complex) 'integer)		)  ; AND	)  ; do-test coerce-to-complex-test)  ; do-test-groupSTOP