;;;; Function To Be Tested: defun;;;; Source:        CLtL p. 67 ;; Chapter 5: Program Structure       Section 3.1: Defining Named Functions;;;; Created By:    Karin M. Sye;;;; Creation Date:  Nov. 9, 86;;;; Last Update:   Feb 3, 1987 Jim Blum - changed DOCUMENTATION defun ;;				and fixed (declare (type (array * (10))) );;				in &allow-other-keys test;;;; Filed As:      {eris}<lispcore>cml>test> 5-3-1-defun.test;;;;;; Syntax: defun NAME LAMBDA-LIST {DECLARATION | DOC-STRING}* {FORM}*	               ;;;; Function Description: The defun special form is the usual means of defining named functions. For detailed description, please;;					read page 66-67 of CLtL;;;; Argument(s):   NAME        - a symbol which is the global name for the defined function;;			  LAMBDA-LIST - (see page 60-61 of CLtL);;			  DECLARATION - a declaration form;;			  DOC-STRING  - a string;;			  FORM        - a lisp form       	;;;; Returns: NAME             ;;(do-test  "test defun - examples of &optional and &rest parameters 0"	(progn 			(defun foo (a b) (+ a (* b 3)))			(defun foo2 (a &optional (b 2)) (+ a (* b 3)))			(and (= (foo 4 5) 19)				(= (foo2 4 5) 19)				(= (foo2 4) 10)			)	))(do-test  "test defun - examples of &optional and &rest parameters 1"	(progn			(defun foo (&optional (a 2 b) (c 3 d) &rest x) (list a b c d x))			(and 				(equal (foo ) '(2 nil 3 nil nil))				(equal (foo 6) '(6 t 3 nil nil))				(equal (foo 6 3) '(6 t 3 t nil))				(equal (foo 6 3 8) '(6 t 3 t (8)))				(equal (foo 6 3 8 9 10 11) '(6 t 3 t (8 9 10 11)))			)	))(do-test  "test defun - examples of &key parameters"	(progn			(defun foo (a b &key c d) (list a b c d))			(and 				(equal (foo 1 2) '(1 2 nil nil))				(equal (foo 1 2 :c 6) '(1 2 6 nil))				(equal (foo 1 2 :d 8) '(1 2 nil 8))				(equal (foo 1 2 :c 6 :d 8) '(1 2 6 8))				(equal (foo 1 2 :d 8 :c 6) '(1 2 6 8))				(equal (foo :a 1 :d 8 :c 6) '(:a 1 6 8))				(equal (foo :a :b :c :d) '(:a :b :d nil))			)	))(do-test  "test defun - examples of mixtures"	(progn			(defun foo (a &optional (b 3) &rest x &key c (d a)) (list a b c d x))			(and				(equal (foo 1) '(1 3 nil 1 nil))				(equal (foo 1 2) '(1 2 nil 1 nil))				(equal (foo :c 7) '(:c 7 nil :c nil))				(equal (foo 1 6 :c 7) '(1 6 7 1 (:c 7)))				(equal (foo 1 6 :d 8) '(1 6 nil 8 (:d 8)))				(equal (foo 1 6 :d 8 :c 9 :d 10) '(1 6 9 8 (:d 8 :c 9 :d 10)))			)	))(do-test  "test defun - examples of &aux"	(progn			(defun foo (x y &aux (a (car x)) (b 2) c) (list x y a b c))			(defun foo2 (&optional (a 2) (b 4) &rest x &aux (c (+  a b)) d (e b)) (list a b c d e x))			(and 				(equal (foo '(6 8 10) '(3 4 5)) '( (6 8 10) (3 4 5) 6 2 nil))				(equal (foo2 22) '(22 4 26 nil 4 nil))			)	))(do-test "test defun - with &allow-other-keys"	(let (aray1)		(declare (type (array * (10))) )			(defun foo (str dims &rest keyword-pairs &key (start 0) end &allow-other-keys)						(apply #'make-array dims :initial-element (subseq str start end)											:allow-other-keys t											keyword-pairs))			(and					(setq aray1 (foo "string" 5 :element-type 'string :start 1 :end 5))				(equal (array-dimensions aray1) '(5))				(equal (mapcar #'(lambda (x) (aref aray1 x)) '(0 1 2 3 4)) (make-list 5 :initial-element "trin"))			)	))(do-test "test defun - the forms constitute the body are executed as an implicit progn"	(progn			(defun foo ())			(defun foo2 () (values 1 2 3 4 5 6))			(and				(not (foo))				(equal (multiple-value-list (foo2)) '(1 2 3 4 5 6))			)	))(do-test "test defun - the body is implicitly enclosed in a block construct"	(progn			(defun foo () 1 3 5 (return-from foo 4321) 7 8 9)			(= (foo) 4321)	))(do-test "test defun - with  doc-string"	(progn			(defun foo () "a b c")			(setf (documentation 'foo 'function) "foo")			(defun foo2 () "a b c" "a b c")			(and				(equal (foo) "a b c")				(equal (foo2) "a b c")				(equal (documentation 'foo 'function) "foo")				(equal (documentation 'foo2 'function) "a b c")			)	))	(do-test "test defun - name is returned as the value of the defun form"	(and		(eq (defun foo () "foo fun" (+ 2 3)) 'foo)		(eq (defun foo2 (x y) (declare (number x y)) "foo fun again" (list x y)) 'foo2)	))(do-test "test defun - use defun to redefine a function/macro as a function"	(progn			(defun foo () 78)			(defmacro mac () 90)			(defun foo () (+ 78 78))			(defun mac () (- 90 78))			(and 				(equal (list (foo) (mac)) '(156 12))				(eq 	  (macro-function 'mac) nil)			)	)) (do-test "test defun - test case copied from page 67 of CLtL"	(progn			(defun foo (a b c)					(declare (number a b c))					"Compute the foo for a quadratic equation.Given a, b, and c, the value ...."					(- (* b b) (* 4 a c)))			(and				(equal (foo 1 2/3 -2) 76/9)				(equal (documentation 'foo 'function) 					  "Compute the foo for a quadratic equation.Given a, b, and c, the value ....")			)	))STOP					