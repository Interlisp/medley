;; Function To Be Tested: bit-vector-p;;;; Source:        CLtL p. 75;;;; Chapter 6: Predicates		Section 2-2: Specific Data Type Predicates;;;; Created By:    Peter Reidy;;;; Creation Date: 22 September 86;;;; Last Update: 15 December 86;;;; Filed As:      {eris}<lispcore>cml>test>6-2-2-bit-vector-p.test;;;; Syntax: bit-vector-p object;;            ;; Function Description: Returns non-nil iff object is a bit-vector (a one-dimensional array of element-type 'bit), and NIL otherwise.;;;; Argument(s):	object any cml object ;;;; Returns:  non-nil or NIL            ;;(do-test-group bit-vector-p-group	:before	(test-defun bit-vector-ptest (object &optional (expected-value nil))	"See if (bit-vector-p object) <=> (typep object 'bit-vector); see if the predicate is true or false of the object, depending on expected-value; see if bit vectors are of the proper type."		(let ((val (bit-vector-p object)))			(and				;; Test equivalence of bit-vector-p to typep...'bit-vector.		  	 	(eq val (typep object 'bit-vector))				(cond					(expected-value					 val)					(t (null val))				)  ; cond				;; Vectors are one-dimensional arrays.				(cond					(expected-value					;; The caller had better not pass anything but an array when expected-value is non-nil.					 (and						(= 1 (array-rank object))						(typep object '(array bit))					 )  ; and					)					;; Non-arrays are moot.					(t t)				)  ; cond			)  ; and		)  ; let	)  ; test-defun	;;	(do-test bit-vector-p-with-bit-vectors-test		(every #'(lambda (object) (bit-vector-ptest object t))			(list				#*1000010101101111111				(make-array 500 :element-type 'bit)				(bit-andc2 (make-array 12 :element-type 'bit) #*000100101110)				(make-array 10 :element-type 'bit :displaced-to (make-array 11 :initial-element 0 :element-type 'bit) :fill-pointer 5)			)  ; list		)  ; every	)  ; do-test bit-vector-p-with-non-bit-vectors-test;;	(do-test bit-vector-p-with-non-bit-vectors-test		(every 'bit-vector-ptest (list;; Vectors containing only bits are not neccessarily bit-vectors.			'#(1 0 0 1 1)			(make-array 50 :initial-element 1)			'#()			'#(1 2 3 (list 1 2 3 #(1 2 3)) #(4 5 6))			(vector)			(vector 1 2 3 4 5 6 7)			(make-array (list 7))			(make-array (+ 10 (random 100)) :displaced-to				(make-array (+ 100 (random 100)) :displaced-to					(make-array 300 :element-type '(or readtable string-char) :initial-element (copy-readtable)					)				):adjustable t :displaced-index-offset (random 10) :fill-pointer (random 5)			)  ; make-array  			)  ; list		)  ; every	)  ; do-test bit-vector-p-with-non-bit-vectors-test;; No string is a bit-vector	(do-test bit-vector-p-with-strings-test		(every 'bit-vector-ptest (list				"1 0 0 1"				"1001"				"#*1001"				(make-array 4 :element-type 'string-char :initial-contents '(#\1 #\0 #\0 #\1))				(make-string (random 10) :initial-element #\0)			)  ; list		)  ; every	)  ; do-test bit-vector-p-with-strings-test;;;; Multi-dimensional arrays don't qualify.	(do-test bit-vector-p-with-multi-dimensional-arrays-test		(every 'bit-vector-ptest (list			(make-array '(1 4) :element-type 'bit)			(make-array '(1 4) :element-type 'bit :initial-contents '((1 0 0 1)))			)  ; list		)  ; every	)  ; do-test bit-vector-p-with-multi-dimensional-arrays-test;;;; Symbols aren't vectors.	(do-test bit-vector-p-with-symbols-test		(every 'bit-vector-ptest (list			'string			(gensym)			(gentemp)			(make-symbol "string")			(make-symbol (make-array 20 :element-type 'string-char :fill-pointer (random 20)))			(make-symbol (symbol-name (gentemp)))				)  ; list		)  ; every	)  ; do-test bit-vector-p-with-symbols-test)  ; do-test-groupSTOP