;; Functions To Be Tested: define-modify-macro;;;; Source:        Steele's book    Section 8.2: Macro definition        ;;			  			    Page: 101 - 105;;;; Created By:    Henry Cate III;;;; Creation Date: November 26, 1986;;;; Last Update:   ;;;; Filed As:      {eris}<lispcore>cml>test>8-1-define-modify-macro.test;;;;;; Syntax:                (define-modify-macro name lambda-list function [doc-string]);;;; Function Description:  defines a read-modify-write macro named name.;;					modifies the value in a given location;;;; Argument(s):           name - the name of the macro;;					lambda-list - describes the arguments for the function;;					function - is literally the function to apply ;;					doc-string - documentation for the macro;;;; Returns:               the name of the macro ;; ;;;;;;	comment:			May want to try the functions nargs and argtype when;;					the work.;;					a macro agaisnt each type of variable?(do-test "try a simple case with lists, cdr"  (let ((temp1 '(a b c d e f)) (temp2 '(1 2 3 4)))  (and	(eq 'MY-RESTF (define-modify-macro my-restf (list) cdr))	(equal (my-restf temp1) '(b c d e f))	(equal (my-restf temp2) '(2 3 4))	(equal temp1 '(b c d e f))	(equal temp2 '(2 3 4))  )))(do-test "try with lists within lists, car"  (let ((temp1 '((a b c) d e)) (temp2 '((1 2 3) 4 5)))  (and	(eq 'MY-FIRSTF (define-modify-macro my-firstf (list) car "doc"))	(equal (my-firstf temp1) '(a b c))	(equal (my-firstf temp2) '(1 2 3))	(equal temp1 '(a b c))	(equal temp2 '(1 2 3))  )))(do-test "test creating a modify macro with same name as a just defined macro"  (let ((temp1 5))  (defmacro my-double (number) `(+ ,number ,number))  (and	(eq 'MY-DOUBLEF (define-modify-macro my-doublef (number) my-double))	(eq 10 (my-doublef temp1))	(eq 10 temp1)  )));  currently when run this by its self it works, but when run from; do-test-file it fails.;(do-test "test creating a modify macro with same name as a just defined ;function";  (let ((temp1 #\M));  (defun MY-LIST*F (temp-var) "dummy-function" (list temp-var));  (and;	(eq 'MY-LIST*F (define-modify-macro my-list*f (first &rest list) ;list*));	(equal (my-list*f temp1 #\B #\C) '(#\M #\B . #\C));	(equal temp1 '(#\M #\B . #\C));  )))(do-test "test &rest"  (let ((temp1 '(a)))  (and 	(eq 'MY-APPENDF (define-modify-macro my-appendf (first &rest rest) append))	(equal (my-appendf temp1 '(b) '(c)) '(a b c))	(equal temp1 '(a b c))	(equal '1 (setq temp1 1))	(eq 'MY-LISTF (define-modify-macro my-listf (first &rest rest) list))	(equal (my-listf temp1 '2 '3 '4 '5) '(1 2 3 4 5))	(equal temp1 '(1 2 3 4 5))  )))(do-test "test &optional"  (let ((temp1 5))  (defmacro my-length (position string) `(+ ,position (length ,string)))  (and	(eq 'MY-LENGTHF (define-modify-macro my-lengthf 		(position &optional string) my-length))	(eq 5 (my-lengthf temp1))	(eq 5 temp1)	(eq 8 (my-lengthf temp1 "bye"))	(eq 8 temp1)  )))STOP