;; Function To Be Tested: loop;;;; Source:        Steele's book    ;;                Section 7.8: Iteration        ;;                Page: 121;;;; Created By:    Bob Bane;;	             Henry Cate III;;;; Creation Date: June 26,1986;;;; Last Update:   June 26,1986;;                October 16,1986 HC3/ documented, and added ;;                               several more test cases;;                October 27,1986 HC3/ broke into several tests ;;;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-1-loop.TEST;;;;;; Syntax:        (loop {form}*);;;;;; Function Description:;;     Each form is evaluated in turn from left to right.  When ;; the last form is evaluated, then  the first is evaluated again, ;; and so on until execution is terminated explicitly.;; ;; ;; ;; Argument(s):   FORM - what is evaluated.;;;; Returns:       depends on what is used to terminate execution.;;(do-test "test simple function"    (and       (loop (return T))       (catch 'looptag (loop (throw 'looptag T)))       (eq (loop (return)) nil)    ))(do-test "test loop can terminate with return."       ; first return a symbol, then a number    (let ((sideffect nil)           (foo '(a b c))           (bar '(1 2 3 4 5 6 7)))    (and       (eq (loop                (if (null foo) (return 'bar)                  (push (pop foo) sideffect)))          'bar)       (equal sideffect '(c b a))       (eq (loop (if (null bar) (return 1013))               (push (pop bar) sideffect))          1013)       (equal sideffect '(7 6 5 4 3 2 1 c b a))    )))(do-test "test loop can with throw and catch."       ; first return a symbol, then a string    (let ((sideffect '(c b a))           (foo '(a b c))           (bar '("a" "little " "short" "string")))    (and       (eq (catch 'looptag (loop                (if (null foo) (throw 'looptag 'bar)               (push (pop foo) sideffect))))          'bar)       (equal sideffect '(c b a c b a))       (equal (catch 'looptag (loop                (if (null bar) (throw 'looptag "string testing"))               (push (pop bar) sideffect)))          "string testing")       (equal sideffect           '("string" "short" "little " "a" c b a c b a))    )))(do-test "test loop can return with multiple values."       ; first return two symbols, then two characters    (let ((sideffect '(c b a))           (foo '(a b c))           (bar '(#\a #\b #\c #\d)))    (and       (equal (multiple-value-list (loop                (if (null foo) (return (values 'foo 'bar))               (push (pop foo) sideffect))))          '(foo bar))       (equal sideffect '(c b a c b a))       (equal (multiple-value-list (loop                 (if (null bar) (return (values #\+ #\-))                (push (pop bar) sideffect))))          '(#\+  #\-))       (equal sideffect '(#\d #\c #\b #\a c b a c b a))    )))(do-test "test loop can throw multiple values."       ; first return two symbols, then two characters    (let ((sideffect '(f e d)) (foo '(a b c)))    (and       (equal (multiple-value-list (catch 'looptag              (loop                 (if (null foo)                    (throw 'looptag (values 'foo 'bar)))                (push (pop foo) sideffect))))          '(foo bar))       (equal sideffect '(c b a f e d))    )))(do-test "test loop can go"    (let ((sideffect '(c b a)) (foo '(a b c)))    (and       (null (tagbody (loop               (if (null foo) (go looptag)              (push (pop foo) sideffect)))           looptag))       (equal sideffect '(c b a c b a))     )))(do-test "test loop can return and throw value from a function"       ; try returning, and throwing the value from a function       ; is the complier smart enough to hardcode in the value       ; instead of making a dumb function call?  want the call    (flet ((tee nil t) (retnumber nil 5)              (retsymbol nil 'hello) (retlist nil '(hi bye)))    (let ((sideffect '(c b a)) (foo '(a b c)))    (and       (loop (return (tee)))       (eq (catch 'looptag (loop             (throw 'looptag (retnumber))))          5)       (eq (loop (return (retsymbol)))           'hello)       (equal (catch 'looptag (loop             (throw 'looptag (retlist))))          '(hi bye))    ))))(do-test "test loop can nest: when, unless"    (let ((sideffect nil) (i 1) (j 1))    (and       (eq (loop (when (> i 4) (return i))             (push i sideffect)             (setq i  (+ i 1)))          5)       (equal sideffect '(4 3 2 1))       (eq (loop (unless (> 6 j) (return j))              (push j sideffect)              (setq j  (+ j 1)))           6)       (equal sideffect '(5 4 3 2 1 4 3 2 1))     )))(do-test "test loop can nest: type, typecase"    (let ((sideffect nil) (i 1) (foo '(1 23 abc)))    (and       (eq (loop (case i ((7 8 9) (return i)))             (push i sideffect)             (setq i  (+ i 1)))           7)       (equal sideffect '(6 5 4 3 2 1))       (equal (loop (typecase (car foo)              (number (push (pop foo) sideffect))             (T (return foo))))           '(abc))       (equal sideffect '(23 1 6 5 4 3 2 1))    )))STOP