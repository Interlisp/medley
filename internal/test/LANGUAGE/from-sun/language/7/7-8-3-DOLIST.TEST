;; Function To Be Tested: dolist;;;; Source:        Steele's book    ;;                Section 7.8.3: Simple Iteration Constructs     ;;                Page: 126;;;; Created By:    Henry Cate III;;;; Creation Date: October 23, 1986;; Creation Date: October 27, 1986 HC3/ broke into several tests;;;; Last Update:   ;;;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-3-dostar.TEST;;;;;; Syntax:        (dolist (var listform [result]);;                       {declaration}* {tag | statement}*);;;;;; Function Description:;;     listform is evaluated returning a list.  The the body ;;     is executed, once for each element in the list, in order, ;;     with var bound to the element.  Then resultform is ;;     evaluated and the result is the value of the dolist form.;; ;; ;; ;; Argument(s):   LISTFORM - evaluated to build a list;;                RESULT - creates the value for dolist;;                DECLARATION - ;;                TAG - for go;;                STATEMENT - where do the work;;;; Returns:       If allowed to finish the list DOLIST will;;                return the value of RESULT.  If control is;;                aborted during the iteration, then the  ;;                value of DOLIST depends on how it was aborted.;;(do-test "test the simple cases"    (and       (dolist (aitem '(a) T) nil)       (dolist (aitem '(a b c d e) T) nil)       (eq (dolist (aitem '(a b c) aitem)) nil)       (eq (dolist (aitem nil) nil) nil)       (catch 'looptag (dolist (aitem '(a)) (throw 'looptag T)))       (dolist (aitem '(a) nil) (return T))       (dolist (aitem '(a b c d e) (null aitem)) nil)    ))(do-test "test building lists by function"       ; again the question about how smart the compilier is       ; do we really need to have a function here?     (flet ((listnum nil '(1 2 3 4 5))             (listsym nil '(a b c d e f))            (listchar nil '(#\a #\b #\c)))     (let ((sideffect nil) (oldval nil))     (and        (eq (dolist (aitem (listnum) oldval)              (setq oldval aitem) (push aitem sideffect))           5)        (equal sideffect '(5 4 3 2 1))        (null (setq sideffect nil))        (eq (dolist (aitem (listsym) oldval)              (setq oldval aitem) (push aitem sideffect))           'f)           (equal sideffect '(f e d c b a))        (null (setq sideffect nil))        (equal (dolist (aitem (listchar) sideffect)              (setq oldval aitem) (push aitem sideffect))           '(#\c #\b #\a))        (eq oldval #\c)        (null (setq sideffect nil))        (eq (dolist (aitem (append '(a b) '(c d) '()) oldval)              (setq oldval aitem) (push aitem sideffect))           'd)        (equal sideffect '(d c b a))     ))))(do-test "test various variable types in list"       ; first pass back a list, then single value       ; again the question about how smart the compilier is       ; do we really need to have a function here?     (let ((sideffect nil) (oldval nil))     (and        (equal (dolist (aitem '(2/3 4/5 6/7) sideffect)              (setq oldval aitem) (push aitem sideffect))           '(6/7 4/5 2/3))        (equal oldval 6/7)        (null (setq sideffect nil))        (eq (dolist (aitem '(#\a #\b #\c #\d) oldval)              (setq oldval aitem) (push aitem sideffect))           #\d)        (equal sideffect '(#\d #\c #\b #\a))        (null (setq sideffect nil))        (equal (dolist (aitem '("a" "little" "string") oldval)              (setq oldval aitem) (push aitem sideffect))           "string")        (equal sideffect '("string" "little" "a"))     )))(do-test "test termination, use when"     (let ((sideffect nil))     (and        (equal (dolist (aitem '(1 2 3 4 5 6 7) sideffect)              (push aitem sideffect)               (when (> aitem 4) (return "hello")))           "hello")        (equal sideffect '(5 4 3 2 1))        (null (setq sideffect nil))        (null (tagbody (dolist (aitem '(a b c d) sideffect)              (push aitem sideffect)               (when (eq aitem 'c) (go dotag)))              dotag))        (equal sideffect '(c b a))        (null (setq sideffect nil))        (eq (catch 'looptag           (dolist (aitem '("a" "b" "c" "d" "e") sideffect)              (push aitem sideffect)              (when (equal aitem "d") (throw 'looptag #\y))))           #\y)        (equal sideffect '("d" "c" "b" "a"))     )))(do-test "test with unless, case, typecase"     (let ((sideffect nil))     (and        (equal (dolist (aitem '(1 2 3 4 5 6 7) sideffect)              (push aitem sideffect)               (unless (< aitem 4) (return "hello")))           "hello")        (equal sideffect '(4 3 2 1))        (null (setq sideffect nil))        (null (tagbody (dolist (aitem '(a b c d) sideffect)              (push aitem sideffect)               (case aitem ('c (go dotag))))              dotag))        (equal sideffect '(c b a))        (null (setq sideffect nil))        (eq (catch 'looptag           (dolist (aitem '(1 a "b" (c) 4/5) sideffect)              (push aitem sideffect)              (typecase aitem (list (throw 'looptag #\y)))))           #\y)        (equal sideffect '((c) "b" a 1 ))     )))(do-test "test return mutiple-values"       ; first return two symbols, then three characters     (and       (equal (multiple-value-list           (dolist (aitem '(a b c d) (values 'a 'b 'c)) nil))         '(a b c))       (equal (multiple-value-list           (dolist (aitem '(#\x #\y #\z) (values 5 6 7)) nil))          '(5 6 7))     ))STOP