;; Function To Be Tested: MAPC;;;; Source: Guy L Steele's CLTL;; Section: 7.8-4 Mapping;; Page: 128;;;; Created By:    Karin M. Sye, Kelly Roach;;;; Creation Date: June 27,1986;;;; Last Update:   Feb 5, 1987 Jim Blum - removed nil lists from mapc test1 as it is an illegal construct on the SUN;; ;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-4-MAPC.TEST;;;;;; Syntax:        (MAPC FUNCTION LIST &REST MORE-LISTS);;;; Function Description:;; For each these mapping functions,;; the first argument is a function and the rest must be lists.;; The function must take as many arguments as there are lists.;; ;; MAPCAR operates on successive elements of the lists.;; First the function is applied to the CAR of each list,;; then to the CADR of each list, and so on.;; (Ideally all the lists are the same length; if not,;; the iteration terminates when the shortest list runs out,;; and excess elements in other lists are ignored.);; The value returned by MAPCAR is a list of the;; results of the successive calls to the function.;; For example:;; ;;     (MAPCAR #'ABS '(3 -4 2 -5 -6)) => (3 4 2 5 6);;     (MAPCAR #'CONS '(A B C) '(1 2 3)) => ((A . 1) (B . 2) (C . 3));;     ;; ;; MAPLIST is like MAPCAR except that the function is applied to;; the list and successive cdr's of that list rather than to successive;; elements of the list.;; For example:;; ;;     (MAPLIST #'(LAMBDA (X) (CONS 'FOO X));;     	 '(A B C D));; ;;      => ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D));;     (MAPLIST #'(LAMBDA (X) (IF (MEMBER (CAR X) (CDR X)) 0 1)));;     	 '(A B A C D B C));;        => (0 0 1 0 1 1 1);;        ;An entry is 1 if the corresponding element of the input;;        ;  list was the last instance of that element in the input list.;;     ;; ;; MAPL and MAPC are like MAPLIST and MAPCAR;; respectively, except that they do not accumulate the results;; of calling the function.;; Compatibility note: In all Lisp systems since Lisp 1.5,;; MAPL has been called MAP.  In the chapter on sequences;;;; it is explained why this was a bad choice.  Here the name MAP;; is used for the far more useful generic sequence mapper,;; in closer accordance to the computer science literature,;; especially the growing body of papers on functional programming.;; These functions are used when the function is being called merely for its;; side effects, rather than its returned values.;; The value returned by MAPL or MAPC is the second argument,;; that is, the first sequence argument.;; ;; MAPCAN and MAPCON are like MAPCAR and MAPLIST respectively,;; except that they combine the results of;; the function using function NCONC instead of LIST.  That is,;; ;;     (MAPCON F X1 ... XN);;        = (APPLY #'NCONC (MAPLIST F X1 ... XN));;     ;; and similarly for the relationship between MAPCAN and MAPCAR.;; Conceptually, these functions allow the mapped function to return;; a variable number of items to be put into the output list.;; This is particularly useful for effectively returning zero or one item:;; ;;     (MAPCAN #'(LAMBDA (X) (AND (NUMBERP X) (LIST X)));;     	'(A 1 B C 3 4 D 5));; ;;       => (1 3 4 5);;     ;; In this case the function serves as a filter; this is a standard Lisp;; idiom using MAPCAN.;; (The function function REMOVE-IF-NOT might have been useful in this;; particular context, however.);; Remember that NCONC is a destructive operation, and therefore;; so are MAPCAN and MAPCON; the lists returned by the FUNCTION;; are altered in order to concatenate them.;; ;; Sometimes a DO or a straightforward recursion is preferable to a;; mapping operation;  however, the mapping functions should be used wherever they;; naturally apply because this increases the clarity of the code. ;; ;; The functional argument to a mapping function must be acceptable;; to APPLY; it cannot be a macro or the name of a special form.;; Of course, there is nothing wrong with using a function that has ;; and  parameters as the functional argument.;; ;; Argument(s):   FUNCTION - a function;;                LIST - a pure list;;                MORE-LISTS - a pure list;;;; Returns:       a pure list;;;;(do-test "test mapc0 - syntax checking";;    (not (or (nlsetq (mapc #'+));;             (nlsetq (mapc #'- '(1 2 3) 4 5 6));;             (nlsetq (mapc #'* 'a 'b 'c 'd (list 3 6 9)));;             (nlsetq (mapc #'car (+ 2 3) (char-code #\a) (cons 1 2)));;             (prog1  nil (makunbound 'fun));;             ; non-existing function;;             (nlsetq (mapc #'fun '(1)));;             (nlsetq (mapc 'm 'n 'o 'p));;             ; missing argument(s);;             (nlsetq (mapc #'(lambda (x) (list x))));;             ; non-function type;;             (nlsetq (mapc #'progn '(list 1 2))))))(do-test "test mapc1 - make sure MAPC always returns the first list argument"    (and (equal (mapc #'+ '(1 2 3) '(4 5 6) '(9 8 7)) '(1 2 3))         (equal (mapc #'- '(1) '(2 3) '(-9 -8 -7)) '(1))         (equal (mapc #'*  '(100 200) '(3 4)) '(100 200))         (equal (mapc #'list (cdr '(a))  '(9 8)) nil)         (equal (mapc #'append '() '((1 2))) '())))(do-test "test mapc2"    (let ()         (defun fun1 (list1)                 (let (buffer) (list (equal (mapc #'(lambda (x) (setq buffer (cons x buffer))) list1) list1)           					  buffer)))         ;         (and (equal (fun1 '(1 2 3 4)) '(t (4 3 2 1)))              (equal (fun1 '('a 'b 'c 'd 'e `f `g `h `i)) `(t ,(reverse '('a 'b 'c 'd 'e `f `g `h `i))))              (equal (fun1 '( 0 0 1 1 2 2 3 3 4 4 5 5)) (list t (reverse '( 0 0 1 1 2 2 3 3 4 4 5 5)))))))(do-test "test mapc3"          (and  (equal (mapc #'(lambda (x y z) (set x (make-list y :initial-element z)))                               '(n1 n2 n3 n4) '(5 10 15 20) '(a b c d))                       '(n1 n2 n3 n4))		      (equal n1 (prog1 '(a a a a a)))                (equal n2 (prog2 (setq z '(b b b b b)) (append z z)))                (equal n3 (progn (setq z '(c c c c c)) (append z z z)))                (equal n4 (progn (setq z '(d d d d d)) (append z z z z)))                ;                (equal (mapc #'makunbound '(n1 n2 n3 n4)) '(n1 n2 n3 n4))                ;                (notany #'boundp '(n1 n2 n3 n4))))(do-test "test mapc4"    (progn (setq nlist '((1 2) (1 2 3 4) (1 2 3 4 5) (1 2 3 4 5 6 7 8)))           (defun fun (ntimes) (setq n4 (pop nlist) n3 (pop nlist) n2 (pop nlist) n1 (pop nlist))                               (push n1 nlist) (push n2 nlist) (push n3 nlist) (push n4 nlist)                               (mapc #'(lambda (x y) (set x (nthcdr y (symbol-value x)))) '(n1 n2 n3 n4) ntimes))            ;           (and (fun '(7 4 3 1))                (equal n1 '(8))  (equal n2 '(5)) (equal n3 '(4)) (equal n4 '(2))                (fun '(7 4))                (equal n1 '(8))  (equal n2 '(5)) (equal n3 '(1 2 3 4)) (equal n4 '(1 2))                (fun '(5 2 1))                (equal n1 '(6 7 8))  (equal n2 '(3 4 5)) (equal n3 '(2 3 4)) (equal n4 '(1 2))                (fun '(8  5 4))                (not (or n1 n2 n3 (not (equal n4 '(1 2))))))))STOP