;; Regression tests for the new compiler;; This tests not only the break-free compilation of the function, but also that;; the cleanup forms are evaluated in the correct order wrt the body.(do-test "AR 7335: Compiler errors on WITH-OPEN-FILE in effect context"	(let* ((test-fn '(lambda (name)					(let (x)					   (when name						(with-open-file (s name :direction :output :if-exists :new-version)							(setq x (il:openp s))))					   x)))	       (compiler-result (compile nil test-fn)))	   (and (compiled-function-p compiler-result)	        (funcall compiler-result "{Core}Foo"))))(do-test "AR 7338: Eliminated :CONS function without arguments breaks compiler"	(let* ((test-fn '(lambda (x)					(let ((a (gensym)))					   (list x))))	       (compiler-result (compile nil test-fn)))	   (and (compiled-function-p compiler-result)	        (equal '(1) (funcall test-fn 1)))))(do-test "AR 7339: Substitution into final statement of PROGN breaks compiler"	(let* ((test-fn '(lambda (x)					(let* ((a x)					       (b a))					   (setq x 7)					   (list b))))	       (compiler-result (compile nil test-fn)))	   (and (compiled-function-p compiler-result)	        (equal '(1) (funcall test-fn 1)))))(do-test "AR 7519: Compiler breaks on nested CATCHes"	(let* ((test-fn '(lambda (f g)	                    (catch 'one	                       (catch 'two	                          (let ((y (funcall f)))	                             (funcall g #'(lambda nil	                                             (case y	                                                (one (throw 'one (list y)))	                                                (two (throw 'two (list (list y))))	                                                (t y)))))))))	       (compiler-result (compile nil test-fn)))	   (and (compiled-function-p compiler-result)	        (equal 'zero    (funcall test-fn #'(lambda () 'zero) 'funcall))	        (equal '(one)   (funcall test-fn #'(lambda () 'one)  'funcall))	        (equal '((two)) (funcall test-fn #'(lambda () 'two)  'funcall)))));;; This test is pretty hard to do.  It wants to see if the :FILE-MANAGER-FORMAT keyword;;; is recognized by the compiler.  The only way to do that is to see if it works.  We make;;; a file that should, in the course of its compilation, push 1, 2 and 3 onto a list, ONLY;;; if the file is being interpreted as a normal Common Lisp file.  We compile it saying;;; ":file-manager-format nil" so as to override the compiler's normal inclination to treat;;; files beginning with an open paren as File Manager files.  If we get the list we expect;;; at the end, it must have recognized our use of the new keyword.(do-test "AR 7378: Compiler documentation says :FILE-MANAGER-FORMAT ..."	(progn	   (with-open-file (s "{Core}AR7378.lisp" :direction :output)	      (princ "(eval-when (compile) (push 1 *foo*))	              (defun foo () (eval-when (compile) (push 2 *foo*)) 5)	              (eval-when (compile) (push 3 *foo*))" s))	   (let ((user::*foo* nil))	      (declare (special user::*foo*))	      	      (compile-file "{Core}AR7378.lisp" :file-manager-format nil)	      (equal user::*foo* '(3 2 1)))));; There was a bug in the fix to AR 7341 that caused the tagbody below not to notice that;; any substitutions had taken place within the progn.  This led to a break.(do-test "Test for bug in fix to AR 7341: Compiler runs forever by reordering uselessly"	(let* ((test-fn '(lambda (y)					(let* ((a y)					       (b a))					   (tagbody tag (progn (setq y b) nil))))))	   (compiled-function-p (compile nil test-fn))))(do-test "AR 7621: COMPILE returns non-compiled code sometimes"	(let* ((test-fn '(lambda ()					(foo #'(lambda (&optional a (b (bar a))) (list a b))))))	   (compiled-function-p (compile nil test-fn))))(do-test "AR 7754: In compiled hard-entry functions, closed-over required args are lost"	(let* ((test-fn '(lambda (a b &rest c)	                     (catch 1	                        (catch 2	                           (list a b c)))))	       (compiled-fn (compile nil test-fn)))	   (and (compiled-function-p compiled-fn)	        (equal '(1 2 (3 4 5 6)) (funcall compiled-fn 1 2 3 4 5 6)))))(do-test "AR 8016: Compiler shouldn't substitute side-effects into IF's"     (let* ((test-fn '(lambda (x y)                          (let* ((a (pop x))                                 (b (if y x a)))                             b)))            (compiled-fn (compile nil test-fn)))	   (and (compiled-function-p compiled-fn)	        (equal '(2 3) (funcall compiled-fn '(1 2 3) t))	        (equal 1      (funcall compiled-fn '(1 2 3) nil)))));; This qualifies as a hairy test.  We want to see if the right set of type-fixups;; is being generated by the assembler.  Thus, we (temporarily) redefine the function;; D-ASSEM:INTERN-DCODE to squirrel away the type-fixups list for us.(do-test "AR 8167: Assembler allocates too little storage sometimes"     (let* ((test-fn '(lambda (a b)                         (foo #'(lambda () (+ (incf a) (incf b))))                         (loop                            (let (c d)                               (foo #'(lambda () (+ (incf c) (incf d))))))))            (intern-dcode-fn (symbol-function 'd-assem:intern-dcode))            (type-fixups :foo))                ;; Redefine D-ASSEM:INTERN-DCODE for a moment, just long enough to compile        ;; the test function.        (unwind-protect (progn (setf (symbol-function 'd-assem:intern-dcode)                                     #'(lambda (dcode)                                            (when (eq :foo type-fixups)                                               (setq type-fixups                                                     (d-assem::dcode-type-fixups dcode)))                                            (funcall intern-dcode-fn dcode)))                               (compile nil test-fn))           ;;Well, that's done, so restore the old definition.           (setf (symbol-function 'd-assem:intern-dcode)                 intern-dcode-fn))        ;; Now we can check that the right set of types are being used.        (null (set-exclusive-or '(il:compiled-closure il:\\ptrhunk2 il:\\ptrhunk4)                                (mapcar #'cadr type-fixups)))));; NOTE: This test fails by running forever, so it should probably be the last;;       one in this file.(do-test "AR 7341: Compiler runs forever by reordering uselessly"	(let* ((test-fn '(lambda (y)					(let* ((a (funcall y))					       b					       c)					   (setq b #'(lambda (x) (+ x a)))					   (setq c 10)					   (funcall b c))))	       (compiler-result (compile nil test-fn)))	   (and (compiled-function-p compiler-result)	        (= 17 (funcall test-fn #'(lambda () 7))))))