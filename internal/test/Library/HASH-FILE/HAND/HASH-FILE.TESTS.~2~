;;;; Test code for HASH-FILE;;; Start with an XCL exec.  Copy each non-commented statement;;; from this file into the executive and observe that it behaves;;; as described in the comments.;;; These tests are meant to be done IN ORDER, and ONLY ONCE;;; as many tests depend upon the sucess of previous tests.;;; Set up a package for testing in.;;; MAKE-PACKAGE will report an error if a package named "TEST" exists.;;; If this happens, use a name besides "TEST".(make-package "TEST")(in-package "TEST")(use-package "HASH-FILE");;; Test MAKE-HASH-FILE & HASH-FILE-P(setq hash-file (make-hash-file "{dsk}test.hash" 10))(hash-file-p hash-file);; should return T;;; Test GET-HASH-FILE(multiple-value-list (get-hash-file :foo hash-file));; should return (nil nil)(multiple-value-list (get-hash-file :foo hash-file :bar));; should return (:bar nil)(setf (get-hash-file :test-key hash-file) :test-value);; should return :test-value(multiple-value-list (get-hash-file :test-key hash-file));; should return (:test-value t);;; Test CLOSE-HASH-FILE(close-hash-file hash-file);; should return #.(pathname "{dsk}test.hash")(multiple-value-list (get-hash-file :test-key hash-file));; should open hash file and return (:test-value t)(close-hash-file hash-file);; should return #.(pathname "{dsk}test.hash");;; Test OPEN-HASH-FILE(setq hash-file (open-hash-file "{dsk}test.hash"))(hash-file-p hash-file);; should be true(setf (get-hash-file :test-key hash-file) :test-value);; should signal an error(close-hash-file hash-file);; should return #.(pathname "{dsk}test.hash")(setq hash-file (open-hash-file "{dsk}test.hash" :direction :io))(hash-file-p hash-file);; should be true(setf (get-hash-file :test-key hash-file) :test-value);; should return :test-value;;; Test MAP-HASH-FILE(dotimes (n 5)  (setf (get-hash-file n hash-file) n));; Note: 5 chosen as we're not yet testing rehash (map-hash-file  #'(lambda (key value)     (format t "key: ~S; value: ~S;~%" key value))  hash-file);; should print contents of HASH-FILE & return NIL.;; contents are not printed in any particular order.;;; Test REM-HASH-FILE(rem-hash-file :test-key hash-file);; should return T(multiple-value-list (get-hash-file :test-key hash-file));; should return (nil nil)(rem-hash-file :test-key hash-file);; should return NIL;;; Test COPY-HASH-FILE(setq hash-file-copy  (copy-hash-file hash-file "{dsk}test-copy.hash"))(hash-file-p hash-file-copy);; should be true(map-hash-file  #'(lambda (key value)     (unless (equal (get-hash-file key hash-file) value)       (error "COPY-HASH-FILE failed to copy key ~S correctly"            key)))  hash-file-copy);; should return NIL with no errors signalled(map-hash-file  #'(lambda (key value)     (unless (equal (get-hash-file key hash-file-copy) value)       (error "COPY-HASH-FILE failed to copy key ~S correctly"            key)))  hash-file);; should return NIL with no errors signalled;;; Test HASH-FILE-COUNT(= (hash-file-count hash-file) 5);; should be true(setf (get-hash-file :test-key hash-file) :test-value)(= (hash-file-count hash-file) 6);; should be true;;; Test HASH-FILE-P(and (hash-file-p hash-file) (typep hash-file 'hash-file));; should be true;;; can't easily test file format;;; Test rehashing(dotimes (n 20)  (setf (get-hash-file n hash-file) n));; should return NIL.hash-file;; should show that version 2 of file has been generated;;; Test :VALUE-PRINT-FN w/ example from documentation(defun print-circular-object (object stream)   (let ((*print-circle* t))      (hash-file::default-print-fn object stream)))(setq hash-file-with-circular-values    (make-hash-file "{core}foo" 10                   :value-print-fn #'print-circular-object))(progn  (setq l (list "foo")) (setf (cdr l) l) (setf (get-hash-file "bar" hash-file-with-circular-values) l) (setq l2 (get-hash-file "bar" hash-file-with-circular-values)) nil)(eq l l2);; should return nil(let ((*print-circle* t)) (string= (prin1-to-string l) (prin1-to-string l2)));; should return t;;; Test default hashing methods;;; We've already seen integers, symbols & strings work as keys;; lists(setf (get-hash-file '(a . b) hash-file) '(c d e))(equal (get-hash-file '(a . b) hash-file) '(c d e));; floats(setf (get-hash-file pi hash-file) (log pi))(= (get-hash-file pi hash-file) (log pi));; ratios(setf (get-hash-file 1/3 hash-file) 1/7)(= (get-hash-file 1/3 hash-file) 1/7);; complex (setf (get-hash-file #c(1 2) hash-file) #c(3 4))(= (get-hash-file #c(1 2) hash-file) #c(3 4));; characters(setf (get-hash-file #\space hash-file) #\newline)(eql (get-hash-file #\space hash-file) #\newline);; pathnames(setf (get-hash-file (pathname "foo") hash-file) (pathname "bar"))(equal (get-hash-file (pathname "foo") hash-file) (pathname "bar"));; clean up(close-hash-file hash-file-with-circular-values)(delete-file "{core}foo")(close-hash-file hash-file)(il:while (xcl:ignore-errors (delete-file "{dsk}test.hash"))  ; delete all versions)(close-hash-file hash-file-copy)(delete-file "{dsk}test-copy.hash")