;; Function To Be Tested: ?? (Find-Event) (Programmer's Assistant Command);;;; Source: Xerox Common Lisp Implementation Notes (Lyric Beta Release);;		 Section 20.2 (The Evaluator), Page 28;;;; Section: The Evaluator;;;; Created By:   John Park;;;; Creation Date: Feb 9, 1987;;;; Last Update:  Feb 26, 1987 ;;;; Filed As:      {ERIS}<lispcore>test>exec>find-event.u;;;;;; Syntax:       ??  EvenSpec;;;; Function Description: Redoes the event(s) specified by EvenSpec.  ;; For example, REDO 123 repeats the event numbered 123.;; ;; Argument(s):  EvenSpec (number or sequence);;			  ;; Returns:       Input and Results of specified event;;;; Constraints/Limitations: Due to the nature of Programmer's Assistant commands,;; testing them willbe accomplished by using the interlisp function bksysbuf ;; in do-test form.  Comments are incorporated within  each command file. ;; The do-test test setup is titled "DO-EVENTS-TEST-SETUP", which executes the command ;; string. The do-test form within the command file will return T or "test "quote" ;; failed in file "unknown". " This test file requires TEDIT package.  ;; The test result will be logged automatically in the following file:;; {ERIS}<lispcore>test>exec>test.report(DO-TEST 'FIND-EVENT-TEST-SETUP	(PROGN 		(SETQ TEST-RESULT "{ERIS}<LISPCORE>TEST>EXEC>TEST.REPORT")		(DEFUN R-FORMAT (STATUS) 			(FORMAT *OUTPUT* "~%COMMAND: FIND-EVENT ~%STATUS:  ~A  DATE:  ~A  TESTER:  ~A~%" STATUS (IL:DATE) IL:USERNAME))		(SETQ MESS1 "Printing input results of first event...")		(SETQ MESS2 "Printinginput results of second event...")		(SETQ MESS3 "Printinginput results of third event...")		(SETQ {CORE}FIRST "{CORE}FIRST")		(SETQ {CORE}SECOND "{CORE}SECOND")		(SETQ {CORE}THIRD "{CORE}THIRD")		(SETQ FIND-EVENT-COMMAND-STRING "(SETQ FIRST-EVENT 1000)(SETQ SECOND-EVENT NIL)(SETQ THIRD-EVENT 'YES)(FORMAT NIL MESS1)(DRIBBLE '{CORE}FIRST)?? -5(DRIBBLE)(FORMAT NIL MESS2)(DRIBBLE '{CORE}SECOND)?? -7(DRIBBLE) (FORMAT NIL MESS3)(DRIBBLE ' {CORE}THIRD)?? -9(DRIBBLE); ?? will print all events; Now the following analyzes to see if the specified events have been found.(LET ((FIRST (OPEN {CORE}FIRST)))	 (PROGN (DO ((I 0 (1+ I)))			  ((= I 6) T)			  (READ FIRST))		    (IF (EQUAL (READ FIRST) '(setq first-event 1000))				(SETQ FOUND-FLG1 T) (SETQ FOUND-FLG1 NIL))			(CLOSE FIRST)	 )) (LET ((SECOND (OPEN {CORE}SECOND)))	 (PROGN (DO ((I 0 (1+ I)))			  ((= I 6) T)			  (READ SECOND))		    (IF (EQUAL (READ SECOND) '(setq second-event NIL))				(SETQ FOUND-FLG2 T) (SETQ FOUND-FLG2 NIL))			(CLOSE SECOND)	 ))(LET ((THIRD (OPEN {CORE}THIRD)))	 (PROGN (DO ((I 0 (1+ I)))			  ((= I 6) T)			  (READ THIRD))		    (IF (EQUAL (READ THIRD) '(setq third-event (quote yes)))				(SETQ FOUND-FLG3 T) (SETQ FOUND-FLG3 NIL))			(CLOSE THIRD)	 ))				(DO-TEST 'FIND-EVENT-TEST-RESULT   	(PROG2 (SETQ *OUTPUT* (OPEN TEST-RESULT :DIRECTION :OUTPUT		 		:IF-EXISTS  :APPEND))            (IF (AND (EQ FOUND-FLG1 T)				(EQ FOUND-FLG2 T)				(EQ FOUND-FLG3 T))				(PROGN (R-FORMAT 'SUCCESS) T)				(PROGN (R-FORMAT 'FAIL) NIL))             (CLOSE *OUTPUT*)	))")	(IL:BKSYSBUF FIND-EVENT-COMMAND-STRING)	))STOP 