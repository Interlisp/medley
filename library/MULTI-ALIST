(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "21-Dec-2025 20:40:36" {WMEDLEY}<library>MULTI-ALIST.;32 15606  

      :EDIT-BY rmk

      :CHANGES-TO (PROPS (SGETMULTI ARGNAMES))
                  (MACROS SGETMULTI GETMULTI)

      :PREVIOUS-DATE "25-Sep-2025 18:41:59" {WMEDLEY}<library>MULTI-ALIST.;30)


(PRETTYCOMPRINT MULTI-ALISTCOMS)

(RPAQQ MULTI-ALISTCOMS
       ((MACROS PUTMULTI PUSHMULTI PUSHMULTI-NEW SPUTMULTI SPUSHMULTI SPUSHMULTI-NEW STOREMULTI)
        (MACROS GETMULTI GETMULTI-PAIR SGETMULTI SGETMULTI-PAIR FETCHMULTI)
        (MACROS REMOVEMULTI REMOVEMULTI-ALL)
        (FNS MAPMULTI MAPMULTI1 COLLECTMULTI FETCHMULTI-PAIR EXTENDMULTI-PAIR)
        (FNS GETMULTI-PAIR.EXPAND PUTMULTI.EXPAND)
        (PROP ARGNAMES PUTMULTI PUSHMULTI PUSHMULTI-NEW SPUTMULTI SPUSHMULTI SPUSHMULTI-NEW GETMULTI
              GETMULTI-PAIR SGETMULTI SGETMULTI-PAIR STOREMULTI REMOVEMULTI)
        (LOCALVARS . T)))
(DECLARE%: EVAL@COMPILE 

(PUTPROPS PUTMULTI MACRO (ARGS (PUTMULTI.EXPAND ARGS 'ASSOC 'PUT)))

(PUTPROPS PUSHMULTI MACRO (ARGS (PUTMULTI.EXPAND ARGS 'ASSOC 'PUSH)))

(PUTPROPS PUSHMULTI-NEW MACRO (ARGS (PUTMULTI.EXPAND ARGS 'ASSOC 'PUSHNEW)))

(PUTPROPS SPUTMULTI MACRO (ARGS (PUTMULTI.EXPAND ARGS 'SASSOC 'PUT)))

(PUTPROPS SPUSHMULTI MACRO (ARGS (PUTMULTI.EXPAND ARGS 'SASSOC 'PUSH)))

(PUTPROPS SPUSHMULTI-NEW MACRO (ARGS (PUTMULTI.EXPAND ARGS 'SASSOC 'PUSHNEW)))

(PUTPROPS STOREMULTI MACRO
          [ARGS (LET ((PLACE (CAR ARGS))
                      (KEYS (CADR ARGS))
                      (VAL (CADDR ARGS))
                      (OPTIONS (CADDDR ARGS)))
                     (CL:MULTIPLE-VALUE-BIND
                      (TEMPVARS VALFORMS STOREVARS STOREFORM ACCESSFORM)
                      (CL:GET-SETF-METHOD PLACE)
                      `(LET (,@(FOR VF IN VALFORMS AS TV IN TEMPVARS COLLECT (LIST TV VF))
                             ($$KEYS$$ ,KEYS))
                            (DECLARE (LOCALVARS $$KEYS$$ ,@TEMPVARS))
                            (EXTENDMULTI-PAIR [OR ,ACCESSFORM (CL:SETF ,ACCESSFORM
                                                                     (CONS (CONS (CAR $$KEYS$$]
                                   $$KEYS$$
                                   ,VAL
                                   ,OPTIONS])
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS GETMULTI MACRO ((MULTIALIST . KEYS)
                          (CDR (GETMULTI-PAIR MULTIALIST . KEYS))))

(PUTPROPS GETMULTI-PAIR MACRO (ARGS (GETMULTI-PAIR.EXPAND 'ASSOC (CAR ARGS)
                                           (CDR ARGS))))

(PUTPROPS SGETMULTI MACRO ((MULTIALIST . KEYS)
                           (CDR (SGETMULTI-PAIR MULTIALIST . KEYS))))

(PUTPROPS SGETMULTI-PAIR MACRO (ARGS (GETMULTI-PAIR.EXPAND 'SASSOC (CAR ARGS)
                                            (CDR ARGS))))

(PUTPROPS FETCHMULTI MACRO ((MULTIALIST KEYS SASSOC)
                            (CDR (FETCHMULTI-PAIR MULTIALIST KEYS SASSOC))))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS REMOVEMULTI MACRO [ARGS `(CHANGE [SGETMULTI ,@(for ATAIL on ARGS while (CDR ATAIL)
                                                           collect (CAR ATAIL]
                                          (REMOVE ,(CAR (LAST ARGS))
                                                 DATUM])

(PUTPROPS REMOVEMULTI-ALL MACRO ((MULTIALIST . KEYS)
                                 (RPLACD (SGETMULTI-PAIR MULTIALIST . KEYS)
                                        NIL)))
)
(DEFINEQ

(MAPMULTI
  [LAMBDA (MULTIALIST MAPFN)                                 (* ; "Edited 12-Aug-2025 11:15 by rmk")
                                                             (* ; "Edited 29-Jan-2025 19:33 by rmk")
                                                             (* ; "Edited 25-Jan-2025 14:51 by rmk")
                                                             (* ; "Edited 16-Jan-2025 10:32 by rmk")
                                                            (* ; "Edited  6-Jan-2020 10:15 by rmk:")

    (* ;; "MAPMULTI applies a mapping function of N args to each item in an N-way item in the multi-alist at MULTIALIST.  If an item C is inserted by (PUTMULT FOO A B C), then MAPFN should be a 3 argument function and it will be applied to A B C. The caller is responsible for making sure the arities of the index and the mapfn correspond.")

    (DECLARE (SPECVARS MAPFN))
    (LET (($$LISTFORARGS$$ (for I from 1 to (NARGS MAPFN) collect NIL)))
         (DECLARE (SPECVARS $$LISTFORARGS$$))
         (MAPMULTI1 MULTIALIST $$LISTFORARGS$$ (NARGS MAPFN])

(MAPMULTI1
  [LAMBDA (SUBALIST ARGLIST NREMAINING)                      (* ; "Edited 25-Jan-2025 15:03 by rmk")
                                                             (* ; "Edited 22-Jan-2025 23:42 by rmk")
                                                             (* ; "Edited 16-Jan-2025 10:29 by rmk")
                                                            (* ; "Edited  6-Jan-2020 10:21 by rmk:")
    (DECLARE (USEDFREE $$LISTFORARGS$$ MAPFN))
    (if [AND (IGREATERP NREMAINING 1)
             (LISTP (CAR (LISTP SUBALIST]
        then 
             (* ;; "Still a list of alists.")

             (for SI in SUBALIST do (RPLACA ARGLIST (CAR SI))
                                    (MAPMULTI1 (CDR SI)
                                           (CDR ARGLIST)
                                           (SUB1 NREMAINING)))
      else (for ITEM inside SUBALIST do (RPLACA ARGLIST ITEM)
                                        (APPLY MAPFN $$LISTFORARGS$$])

(COLLECTMULTI
  [LAMBDA (MULTIALIST MAPFN)                                 (* ; "Edited 25-Jan-2025 15:00 by rmk")
                                                             (* ; "Edited 22-Jan-2025 23:44 by rmk")
                                                            (* ; "Edited  6-Jan-2020 10:15 by rmk:")
    (LET ($$COLLECT)
         (DECLARE (SPECVARS $$COLLECT))
         (MAPMULTI MULTIALIST MAPFN)
         $$COLLECT])

(FETCHMULTI-PAIR
  [LAMBDA (MULTIALIST KEYS SASSOC)                           (* ; "Edited 25-Sep-2025 17:06 by rmk")
                                                             (* ; "Edited 15-Aug-2025 08:08 by rmk")
                                                             (* ; "Edited 13-Aug-2025 13:30 by rmk")

    (* ;; "Parallel to GETMULTI-PAIR but with the keys in a computed list. ")

    (CL:UNLESS (LISTP KEYS)
        (ERROR (ERROR "FETCHMULTI-PAIR requires at least 1 key" KEYS)))
    (for KTAIL (LASTPAIR _ (CL:IF SASSOC
                               (SASSOC (CAR KEYS)
                                      MULTIALIST)
                               (ASSOC (CAR KEYS)
                                      MULTIALIST))) on (CDR KEYS)
       do (SETQ LASTPAIR (CL:IF SASSOC
                             (SASSOC (CAR KTAIL)
                                    LASTPAIR)
                             (ASSOC (CAR KTAIL)
                                    LASTPAIR))) finally (RETURN LASTPAIR])

(EXTENDMULTI-PAIR
  [LAMBDA (MULTIALIST KEYS VAL OPTIONS)                      (* ; "Edited 25-Sep-2025 18:37 by rmk")
                                                             (* ; "Edited 15-Aug-2025 08:08 by rmk")
                                                             (* ; "Edited 13-Aug-2025 14:39 by rmk")
                                                             (* ; "Edited 22-Jan-2025 23:47 by rmk")
                                                            (* ; "Edited 17-Aug-2020 15:05 by rmk:")

    (* ;; "Extends the multi-alist that the caller has rooted at FIRSTPAIR (whose key is presumably (CAR LASTPAIR)). Returns the pair, new or existing, that is headed by the last key.  ")

    (* ;; "There has to be a structure to add to, even at the root.  Otherwise, if we were to make a completely new list and return its last pair, the new list would drop on the floor. ")

    (CL:UNLESS (LISTP (CAR (LISTP MULTIALIST)))
           (ERROR MULTIALIST "is not a MULTI-ALIST"))
    (CL:UNLESS (LISTP KEYS)
           (ERROR "EXTENDMULTI-PAIR requires at least 1 key" KEYS))
    (for K LASTPAIR (SASSOC _ (OR (EQ OPTIONS T)
                                  (EQMEMB 'SASSOC OPTIONS))) in (CDR KEYS)
       first [SETQ LASTPAIR (OR (CL:IF SASSOC
                                    (SASSOC (CAR KEYS)
                                           MULTIALIST)
                                    (ASSOC (CAR KEYS)
                                           MULTIALIST))
                                (CAR (ATTACH (CONS (CAR KEYS))
                                            MULTIALIST] 

             (* ;; "We have insured a pair headed by (CAR KEYS) at the top level of MULTIALIST.")
 do [SETQ LASTPAIR (OR (CL:IF SASSOC
                           (SASSOC K (CDR LASTPAIR))
                           (ASSOC K (CDR LASTPAIR)))
                       (CAR (PUSH (CDR LASTPAIR)
                                  (CONS K] finally (CL:UNLESS (LISTP LASTPAIR)
                                                       (ERROR "INVALID MULTI-ALIST" (LIST LASTPAIR 
                                                                                          KEYS)))
                                                 (if (EQMEMB 'PUSH OPTIONS)
                                                     then (CL:UNLESS (MEMBER VAL (CDR LASTPAIR))
                                                              (CL:PUSH VAL (CDR LASTPAIR)))
                                                   elseif (EQMEMB 'PUSHNEW OPTIONS)
                                                     then (CL:PUSH VAL (CDR LASTPAIR))
                                                   else (RPLACD LASTPAIR VAL)) 
                                                             (* ; "Should it return LASTPAIR?")
                                                 (RETURN VAL])
)
(DEFINEQ

(GETMULTI-PAIR.EXPAND
  [LAMBDA (ASSOCFN PLACE KEYS)                               (* ; "Edited 21-Sep-2025 10:31 by rmk")
                                                             (* ; "Edited 11-Aug-2025 09:56 by rmk")
                                                             (* ; "Edited  8-Aug-2025 12:55 by rmk")
                                                             (* ; "Edited 14-Jun-2025 09:47 by rmk")
                                                             (* ; "Edited 16-Jan-2025 10:27 by rmk")
                                                            (* ; "Edited 19-Jul-2020 00:38 by rmk:")
                                                            (* ; "Edited 22-Mar-2020 13:21 by rmk:")
                                                            (* ; "Edited 27-Feb-2020 13:44 by rmk:")

    (* ;; "This returns the last (key . rest) cell (like ASSOC), error here if no keys, runtime error if place is not a list")

    (if (LISTP KEYS)
        then (for KTAIL (FORM _ PLACE) on KEYS do [SETQ FORM `(,ASSOCFN ,(CAR KTAIL)
                                                                     ,FORM]
                                                  (CL:WHEN (CDR KTAIL)
                                                      [SETQ FORM `(CDR ,FORM])
                finally (RETURN FORM))
      else (ERROR "GETMULTI requires at least 1 key" (CONS PLACE KEYS])

(PUTMULTI.EXPAND
  [LAMBDA (ARGS ASSOCFN OP)                                  (* ; "Edited 14-Aug-2025 22:40 by rmk")
                                                             (* ; "Edited 13-Aug-2025 14:42 by rmk")
                                                             (* ; "Edited 11-Aug-2025 21:43 by rmk")
                                                             (* ; "Edited  8-Jul-2025 12:52 by rmk")
                                                             (* ; "Edited 14-Jun-2025 09:44 by rmk")
                                                             (* ; "Edited 23-Jan-2025 09:40 by rmk")
                                                             (* ; "Edited 16-Jan-2025 10:18 by rmk")
                                                            (* ; "Edited 17-Aug-2020 14:09 by rmk:")

    (* ;; "We get the setf method so that any expressions in the place will be evaluated only once. It may have internal forms that bind to temporary variables (which must come first, for evaluation order.")

    (if (CDDR ARGS)
        then
        [CL:MULTIPLE-VALUE-BIND
         (TEMPVARS VALFORMS STOREVARS STOREFORM ACCESSFORM)
         (CL:GET-SETF-METHOD (CAR ARGS))
         `(LET
           (,@(for VF in VALFORMS as TV in TEMPVARS collect (LIST TV VF))
            $$PAIR$$ $$KEY$$ $$VAL)
           (DECLARE (LOCALVARS $$PAIR$$ $$KEY$$ $$VAL ,@TEMPVARS))
           ,@(for KTAIL (HEAD _ ACCESSFORM) on (CDR ARGS)
                join (if (CDR KTAIL)
                         then 
                              (* ;; "Is HEAD so that CL:PUSH gets PLACE")

                              (PROG1 `[(SETQ $$KEY$$ ,(CAR KTAIL))
                                       (SETQ $$PAIR$$ (OR (,ASSOCFN $$KEY$$ ,HEAD)
                                                          (CAR (CL:PUSH (CONS $$KEY$$)
                                                                      ,HEAD]
                                  (SETQ HEAD '(CDR $$PAIR$$)))
                       else 
                            (* ;; "Last one is the value, it hits the CDR of $$PAIR$$.")

                            (SELECTQ OP
                                (PUT `[(CDR (RPLACD $$PAIR$$ ,(CAR KTAIL])
                                (PUSH `[(CAR (CL:PUSH ,(CAR KTAIL)
                                                    (CDR $$PAIR$$])
                                (PUSHNEW `((SETQ $$VAL ,(CAR KTAIL))
                                           (OR (MEMBER $$VAL (CDR $$PAIR$$))
                                               (CL:PUSH $$VAL (CDR $$PAIR$$)))
                                           $$VAL))
                                (SHOULDN'T]
      else (ERROR "PUTMULTI requires at least 1 key" ARGS])
)

(PUTPROPS PUTMULTI ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS PUSHMULTI ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS PUSHMULTI-NEW ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS SPUTMULTI ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS SPUSHMULTI ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS SPUSHMULTI-NEW ARGNAMES (PLACE KEY1...KEYN VAL))

(PUTPROPS GETMULTI ARGNAMES (PLACE KEY1...KEYN))

(PUTPROPS GETMULTI-PAIR ARGNAMES (PLACE KEY1...KEYN))

(PUTPROPS SGETMULTI ARGNAMES (PLACE KEY1...KEYN))

(PUTPROPS SGETMULTI-PAIR ARGNAMES (PLACE KEY1...KEYN))

(PUTPROPS STOREMULTI ARGNAMES (PLACE KEYS VAL OPTIONS))

(PUTPROPS REMOVEMULTI ARGNAMES (MULTIALIST KEY1...KEYN VAL))
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (3678 10388 (MAPMULTI 3688 . 4834) (MAPMULTI1 4836 . 5893) (COLLECTMULTI 5895 . 6366) (
FETCHMULTI-PAIR 6368 . 7428) (EXTENDMULTI-PAIR 7430 . 10386)) (10389 14763 (GETMULTI-PAIR.EXPAND 10399
 . 11900) (PUTMULTI.EXPAND 11902 . 14761)))))
STOP
