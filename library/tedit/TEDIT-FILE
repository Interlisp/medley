(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "27-Sep-2023 00:15:56" {WMEDLEY}<library>tedit>TEDIT-FILE.;306 220867 

      :EDIT-BY rmk

      :CHANGES-TO (FNS TEDIT.PUT)

      :PREVIOUS-DATE "24-Sep-2023 22:35:01" {WMEDLEY}<library>tedit>TEDIT-FILE.;305)


(PRETTYCOMPRINT TEDIT-FILECOMS)

(RPAQQ TEDIT-FILECOMS
       ((DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (\PieceDescriptorLOOKS 0)
                                                (\PieceDescriptorOBJECT 1)
                                                (\PieceDescriptorPARA 2)
                                                (\PieceDescriptorPAGEFRAME 3)
                                                (\PieceDescriptorCHARLOOKSLIST 4)
                                                (\PieceDescriptorPARALOOKSLIST 5)
                                                (\PieceDescriptorSAFEOBJECT 6)
                                                (\PieceDescriptorMETAINFO 7))
               (EXPORT (MACROS \SMALLPOUT \SMALLPIN)))
        (FNS \TEDIT.MAKE.SAFE.BUFFERS \TEDIT.MAKE.SAFE.PIECES \TEDIT.GET.PIECES3)
        (COMS 
              (* ;; "GETting a file")

              (FNS TEDIT.GET TEDIT.FORMATTEDFILEP \TEDIT.GET.FOREIGN.FILE \TEDIT.GET.UNFORMATTED.FILE
                   \TEDIT.GET.FORMATTED.FILE \TEDIT.FORMATTEDSTREAMP TEDIT.PARSE.PAGEFRAMES1 \ARBIN 
                   \ATMIN \DWIN \STRINGIN \TEDIT.FORMATTEDP1 \TEDIT.CACHEFILE)
              (FNS \TEDIT.GET.PIECES3 \TEDIT.MAKE.SAFE.BUFFERS \TEDIT.MAKE.SAFE.PIECES)
              (FNS \TEDIT.GET.UNFORMATTED.FILE.XCCS \TEDIT.GET.UNFORMATTED.FILE.UTF8)
              
              (* ;; "NOT USED, TO BE REMOVED")

              (FNS TEDIT.GET.PCTB3 \INSERT-NSCLEARED-PIECE TEDIT.GET.PASSWORD))
        (COMS 
              (* ;; "INCLUDEing a file")

              (FNS TEDIT.INCLUDE TEDIT.RAW.INCLUDE))
        (COMS 
              (* ;; "PUTting a file:")

              (FNS TEDIT.PUT TEDIT.PUT.PCTB TEDIT.PUT.PCTB.MERGEABLE \TEDIT.PUT.NEWPIECES 
                   \TEDIT.PUTRESET \ARBOUT \ATMOUT \DWOUT \STRINGOUT))
        (FNS \TEDIT.GET.CHARLOOKS.LIST \TEDIT.GET.SINGLE.CHARLOOKS \TEDIT.PUT.CHARLOOKS.LIST 
             \TEDIT.PUT.SINGLE.CHARLOOKS \TEDIT.PUT.CHARLOOKS \TEDIT.GET.CHARLOOKS)
        (FNS \TEDIT.GET.PARALOOKS.LIST \TEDIT.GET.SINGLE.PARALOOKS \TEDIT.PUT.PARALOOKS.LIST 
             \TEDIT.PUT.SINGLE.PARALOOKS \TEDIT.PUT.PARALOOKS \TEDIT.GET.PARALOOKS)
        (FNS TEDIT.GET.OBJECT TEDIT.PUT.OBJECT)
        (GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
        (FNS TEDITFROMLISPSOURCE)
        (ADDVARS (TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE)))
        (INITVARS (*TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))
                                                             (* ; 
                                         "For consistent reading and writing of info on TEdit files.")
               )
        (COMS 
              (* ;; 
        "For converting old incoming format.  Cutover 5/22/85 to permit looks changes in the future.")

              (FNS TEDIT.GET.PCTB2 \TEDIT.GET.CHARLOOKS.LIST2 \TEDIT.GET.SINGLE.CHARLOOKS2 
                   \TEDIT.PUT.SINGLE.PARALOOKS2 \TEDIT.PUT.SINGLE.CHARLOOKS2 
                   \TEDIT.GET.PARALOOKS.LIST2 \TEDIT.GET.SINGLE.PARALOOKS2 \TEDIT.PUT.CHARLOOKS.LIST2
                   \TEDIT.PUT.PARALOOKS.LIST2))
        (COMS 
              (* ;; "For converting incoming old-format files (1/27/85 cutover)")

              (FNS TEDIT.GET.PCTB1 TEDIT.GET.PAGEFRAMES1 \TEDIT.GET.CHARLOOKS1 \TEDIT.GET.PARALOOKS1
                   TEDIT.GET.OBJECT1))
        (COMS 
              (* ;; "VERSION 0 Compatibility reading functions")

              (FNS TEDIT.GET.PCTB0 TEDIT.GET.CHARLOOKS0 TEDIT.GET.OBJECT0 TEDIT.GET.PARALOOKS0))))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ \PieceDescriptorLOOKS 0)

(RPAQQ \PieceDescriptorOBJECT 1)

(RPAQQ \PieceDescriptorPARA 2)

(RPAQQ \PieceDescriptorPAGEFRAME 3)

(RPAQQ \PieceDescriptorCHARLOOKSLIST 4)

(RPAQQ \PieceDescriptorPARALOOKSLIST 5)

(RPAQQ \PieceDescriptorSAFEOBJECT 6)

(RPAQQ \PieceDescriptorMETAINFO 7)


(CONSTANTS (\PieceDescriptorLOOKS 0)
       (\PieceDescriptorOBJECT 1)
       (\PieceDescriptorPARA 2)
       (\PieceDescriptorPAGEFRAME 3)
       (\PieceDescriptorCHARLOOKSLIST 4)
       (\PieceDescriptorPARALOOKSLIST 5)
       (\PieceDescriptorSAFEOBJECT 6)
       (\PieceDescriptorMETAINFO 7))
)

(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE 

(PUTPROPS \SMALLPOUT MACRO (OPENLAMBDA (STREAM W)
                             (BOUT STREAM (LOGAND 255 (LRSH W 8)))
                             (BOUT STREAM (LOGAND W 255))))

(PUTPROPS \SMALLPIN MACRO (OPENLAMBDA (STREAM)
                            (SIGNED (create WORD
                                           HIBYTE _ (BIN STREAM)
                                           LOBYTE _ (BIN STREAM))
                                   BITSPERWORD)))
)

(* "END EXPORTED DEFINITIONS")

)
(DEFINEQ

(\TEDIT.MAKE.SAFE.BUFFERS
  [LAMBDA (PC ONECHARFN)                                     (* ; "Edited 23-Sep-2023 00:19 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  5-Sep-2023 00:00 by rmk")
                                                             (* ; "Edited 30-Aug-2023 19:09 by rmk")

    (* ;; "This chops PC into a sequence of pieces such that no piece has a character whose bytes cross a PFILE buffer boundary.  Any offending character is placed in a string piece that is linked into the chain.  The return value is the piece that holds the last characters of PC, so the caller's iteration can continue to the next problematic piece in a higher-level chain.")

    (* ;; "This works mostly on PBYTELEN using PBYTESPERCHAR for the granularity, and using PBYTESPERCHAR also to recalculate the output PLENs. PBYTELEN should be a multiple of PBYTESPERCHAR")

    (bind BYTESLEFTINBUFFER BUFPOS BUFSIZE CROSSCHAR STRINGPC PREFIXCHARS PREFIXPC (PREFIXBYTES
                                                                                    _ 0)
          (SUFFIXPC _ PC)
          (PFILE _ (PCONTENTS PC))
          (BYTESPERCHAR _ (PBYTESPERCHAR PC))
          (BYTESLEFT _ (PBYTELEN PC))
          (FPOS _ (PFPOS PC))
          (BYTELEN _ (PBYTELEN PC)) first (SETQ BUFSIZE (fetch (STREAM CBUFMAXSIZE) of PFILE))
                                          (CL:WHEN (AND (EVENP BUFSIZE BYTESPERCHAR)
                                                        (EVENP FPOS BYTESPERCHAR))

                                  (* ;; "A piece with 2-byte characters would always be aligned, for example, if PFPOS and BUFSIZE are both even--nothing to worry about.")

                                              (RETURN PC))
                                          (SETQ BUFPOS FPOS) eachtime (SETQ BYTESLEFTINBUFFER
                                                                       (IDIFFERENCE BUFSIZE
                                                                              (IREMAINDER BUFPOS 
                                                                                     BUFSIZE)))
       do (CL:WHEN (ILEQ BYTESLEFT BYTESLEFTINBUFFER)
              (CL:WHEN (FGETPC SUFFIXPC NEXTPIECE)           (* ; 
                                                            "Point the original next at its new prev")
                  (FSETPC (FGETPC SUFFIXPC NEXTPIECE)
                         PREVPIECE SUFFIXPC))
              (RETURN SUFFIXPC)) 

          (* ;; "The current SUFFIXPC has a character that crosses a buffer boundary (but maybe not the very first boundary--a prefix of 4 3-byte characters might initially align with a 512 byte buffer, but it will lose after that). We either have to extend the current piece across the next buffer (if it is aligned), or split off a file piece and a 1-character string piece.")

          (if (EVENP BYTESLEFTINBUFFER BYTESPERCHAR)
              then 
                   (* ;; "The last character doesn't cross so we don't have to split for this buffer and can continue peeling off prefixbytes from the same SUFFIXPC.  We advance BUFFPOS to the start of the next buffer, but don't advance FPOS.")

                   (* ;; "Note that when we finally run up against the boundary, rounding down to characters may back off some prefixbytes--we have to adjust for that below.")

                   (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))
                   (add BUFPOS BYTESLEFTINBUFFER)
                   (add PREFIXBYTES BYTESLEFTINBUFFER)
            else 
                 (* ;; "The current SUFFIXPC has a boundary-crossing character.  In general we have to divide it into 3 pieces")

                 (* ;; 
  "    1.  PREFIXPC represents SUFFIXPC characters before the offender, with the original ptype etc.")

                 (* ;; "    2.  STRINGPC contains the single offending character, read from the file and inserted as a string piece.")

                 (* ;; 
              "    3.  A new SUFFIXPC representing the characters remaining for the next iteration..")

                 (* ;; " PREFIXPC exists only if BYTESLEFTINBUFFER is greater than BYTESPERCHAR. If less, then it is only the string character that crosses the boundary, there are no other prefix chars. ")

                 (* ;; "Note that SUFFIXPC always carries along any properties of the original PC that might remain useful, even though PC is otherwise cannibalized. Looks, paralast, nextpiece...")

                 (* ;; "")

                 (add PREFIXBYTES BYTESLEFTINBUFFER)
                 (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))  (* ; 
                                                          "Include the last buffer, round down below")
                 (CL:WHEN (IGREATERP PREFIXBYTES BYTESPERCHAR)
                                                             (* ; 
                                                       "There is a prefix to chop off from SUFFIXPC ")
                     (SETQ PREFIXPC SUFFIXPC)
                     (SETQ PREFIXCHARS (IQUOTIENT PREFIXBYTES BYTESPERCHAR))
                     [add BYTESLEFT BYTESPERCHAR (IMINUS (IDIFFERENCE PREFIXBYTES (SETQ PREFIXBYTES
                                                                                   (ITIMES 
                                                                                          PREFIXCHARS
                                                                                          
                                                                                         BYTESPERCHAR
                                                                                          ]
                     (SETQ BUFPOS (IPLUS FPOS PREFIXBYTES))  (* ; 
                                                        "The suffix starts on a character first-byte")
                     (SETQ SUFFIXPC (create PIECE using SUFFIXPC PFPOS _ BUFPOS PBYTELEN _ BYTESLEFT
                                                        PLEN _ (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                                        PREVPIECE _ PREFIXPC))
                     (with PIECE PREFIXPC (SETQ PLEN PREFIXCHARS)
                           (SETQ PBYTELEN PREFIXBYTES)
                           (SETQ PPARALAST NIL)
                           (SETQ NEXTPIECE SUFFIXPC)))
                 (SETQ PREFIXBYTES 0) 

                 (* ;; "")

                 (* ;; 
              "SUFFIXPC now begins with a crosser--convert SUFFIXPC to a one-character string piece ")

                 (SETQ FPOS (FGETPC SUFFIXPC PFPOS))
                 (SETFILEPTR PFILE FPOS)                     (* ; "Fetch the crossing character")
                 (SETQ CROSSCHAR (APPLY* ONECHARFN PFILE))
                 (SETQ STRINGPC SUFFIXPC)
                 (add BYTESLEFT (IMINUS BYTESPERCHAR))
                 (if (IGREATERP BYTESLEFT 0)
                     then                                    (* ; 
                                                             "Create a new SUFFIXPC for the residual")
                          (add FPOS BYTESPERCHAR)            (* ; "Don't include the CROSSCHAR")
                          (SETQ SUFFIXPC
                           (create PIECE using SUFFIXPC PFPOS _ FPOS PBYTELEN _ BYTESLEFT PLEN _
                                               (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                               PREVPIECE _ STRINGPC))
                          (FSETPC STRINGPC NEXTPIECE SUFFIXPC)
                          (FSETPC STRINGPC PPARALAST NIL)
                          (SETQ BUFPOS FPOS)
                   else (SETQ SUFFIXPC NIL)) 

                 (* ;; "")

                 (* ;; 
       "Convert the previous SUFFIXPC (now STRINGPC) to a string piece containing just the CROSSCHAR")

                 (with PIECE STRINGPC (SETQ PCONTENTS (ALLOCSTRING 1 CROSSCHAR))
                       (SETQ PLEN 1)
                       (if (ILEQ CROSSCHAR 255)
                           then (SETQ PTYPE THINSTRING.PTYPE)
                                (SETQ PBYTESPERCHAR 1)
                                (SETQ PBYTELEN 1)
                                (SETQ PBINABLE T)
                         else (SETQ PTYPE FATSTRING.PTYPE)
                              (SETQ PBYTESPERCHAR 2)
                              (SETQ PBYTELEN 2)
                              (SETQ PBINABLE NIL)))
                 (CL:UNLESS SUFFIXPC                         (* ; 
                                                          "Didn't need a SUFFIXPC, end with STRINGPC")
                     (CL:WHEN (FGETPC STRINGPC NEXTPIECE)
                         (FSETPC (FGETPC STRINGPC NEXTPIECE)
                                PREVPIECE STRINGPC))
                     (RETURN STRINGPC))])

(\TEDIT.MAKE.SAFE.PIECES
  [LAMBDA (PIECES)                                           (* ; "Edited 23-Sep-2023 00:28 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  9-Sep-2023 22:59 by rmk")
                                                             (* ; "Edited  7-Sep-2023 10:03 by rmk")
                                                             (* ; "Edited 29-Aug-2023 22:01 by rmk")

    (* ;; "PIECES is a chain of pieces read from a file but not yet inserted into the BTREE.  Each piece has the file (PFILE=PCONTENTS), PFPOS and PLEN.  This function makes normalizes the pieces  to remove complexity from other inner-loop algorithms.  For example, if the external format of the file is XCCS, some pieces may begin with charset shifts, and we need to make sure that those bytes are not visible (by bumping PFPOS and reducing PLEN).")

    (* ;; "And we also want to make sure that no multicharacter piece crosses a buffer-boundary.  We accomplish that by splitting the piece before a character that would cross the boundary, and inserting a string piece to hold that character.")

    (CL:WHEN PIECES                                          (* ; 
                                                             "PFILE is  a stream open for input.")
        [LET
         [(PFILE (for PC inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                    when (\GETSTREAM (PCONTENTS PC)
                                'INPUT T) do (RETURN (PCONTENTS PC]
         (CL:WHEN PFILE                                      (* ; "At least one file piece")
             [SELECTQ (STREAMPROP PFILE :EXTERNAL-FORMAT)
                 (:XCCS 
                        (* ;; 
          "We have to strip shifting bytes for text, but object bytes have already been interpreted.")

                        (for PC BYTE inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                           do (SETFILEPTR PFILE (PFPOS PC))
                              (if (EQ NSCHARSETSHIFT (BIN PFILE))
                                  then [SELECTC (SETQ BYTE (BIN PFILE))
                                           (0 (FSETPC PC PTYPE THINFILE.PTYPE)
                                              (FSETPC PC PBINABLE T)
                                              (add (PFPOS PC)
                                                   2)
                                              (add (PBYTELEN PC)
                                                   -2)       (* ; 
                                                             "The shift characters really disappear")
                                              (FSETPC PC PLEN (PBYTELEN PC)))
                                           (NSCHARSETSHIFT 
                                                (CL:UNLESS (EQ 0 (BIN PFILE))
                                                       (SHOULDNT "XCCS CHARACTER NOT IN PLANE 0"))
                                                (FSETPC PC PTYPE FATFILE2.PTYPE)
                                                (FSETPC PC PBYTESPERCHAR 2)
                                                (add (PFPOS PC)
                                                     3)
                                                (add (PBYTELEN PC)
                                                     -3)
                                                (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                                       2))
                                                [SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS
                                                          PC
                                                          (FUNCTION (LAMBDA (PFILE)
                                                                      (\WIN PFILE])
                                           (PROGN 

                                 (* ;; "A run in a non-zero charset.  It's not worth dealing with the complexity of maintaining that storage efficiency, here we convert it to a fat-string piece.")

                                                  (add (PBYTELEN PC)
                                                       -2)
                                                  (FSETPC PC PLEN (PBYTELEN PC))
                                                  (FSETPC PC PTYPE FATSTRING.PTYPE)
                                                  (FSETPC PC PBYTESPERCHAR 2)
                                                  (FSETPC PC PBINABLE NIL)
                                                  (for I (CHARSET _ (LLSH BYTE 8))
                                                       (STRING _ (ALLOCSTRING (PLEN PC)
                                                                        NIL NIL T)) from 1
                                                     to (PLEN PC) first (FSETPC PC PCONTENTS STRING)
                                                     do (RPLCHARCODE STRING I (LOGOR CHARSET
                                                                                     (BIN PFILE]
                                elseif (EQ 2 (PBYTESPERCHAR PC))
                                  then (FSETPC PC PTYPE FATFILE2.PTYPE) 
                                                             (* ; "This is the continuation of an XCCS 2-byte run that was broken up presumably for looks or paragraphs")
                                       (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                              2))
                                       [SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS PC (FUNCTION (LAMBDA (PFILE
                                                                                                )
                                                                                         (\WIN PFILE]
                                else (FSETPC PC PTYPE THINFILE.PTYPE) 
                                                             (* ; "A charset 0 1-byte run")
                                     (FSETPC PC PBINABLE T)
                                     (FSETPC PC PLEN (PBYTELEN PC))
                                     (FSETPC PC PBYTESPERCHAR 1))))
                 (:UTF-8 (HELP 'UTF8))
                 (for PC inpieces PC unless (EQ OBJECT.PTYPE (PTYPE PC))
                    do (FSETPC PC PTYPE THINFILE.PTYPE)      (* ; "Default:  assume :THROUGH ?")
                       (FSETPC PC PBINABLE T)
                       (FSETPC PC PLEN (FGETPC PC PBYTELEN])])
    PIECES])

(\TEDIT.GET.PIECES3
  [LAMBDA (TEXT TEXTOBJ PCCOUNT CURFILEBYTE# END)            (* ; "Edited 24-Sep-2023 22:00 by rmk")
                                                             (* ; "Edited  2-Sep-2023 11:12 by rmk")
                                                             (* ; "Edited 29-Aug-2023 00:18 by rmk")

    (* ;; "This runs through the Looks table portion of the TEXT file, gathering the looks and  installing pointers to positions in the character section of the file.  It doesn't actually examine the characters in the file.  It returns a piece chain that covers the text but that hasn't been installed in the btree.  The pieces need further adjustment for character encoding and to prevent mutlibyte characters from crossing buffer boundaries before they are installed in the btree.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                            8))
    (SETFILEPTR TEXT (\DWIN TEXT))                           (* ; "Pieceinfo char #")
    (for PCNO PC BYTELEN PREVPC FIRSTPC PARAMAP LOOKSMAP (ORIGBYTE# _ CURFILEBYTE#)
         (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
         (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) from 1 to PCCOUNT first (SETQ FIRSTPC
                                                                              (CREATE PIECE)) 
                                                             (* ; "Throw away at the end")
                                                                             (SETQ PREVPC FIRSTPC)
       do (SETQ PC NIL)                                      (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
          (SETQ BYTELEN (\DWIN TEXT))
          [SELECTC (\SMALLPIN TEXT)
              (\PieceDescriptorLOOKS                         (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ BYTELEN
                           PBYTELEN _ BYTELEN
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ THINFILE.PTYPE
                           PBYTESPERCHAR _ 1
                           PREVPIECE _ PREVPC))
                   (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSMAP)   (* ; 
                                                             "Get its looks and character-pointers")
                   (add CURFILEBYTE# BYTELEN))
              (\PieceDescriptorPARA                          (* ; 
                                                             "Reading a new set of paragraph looks.")
                   (CL:WHEN PREVPC (FSETPC PREVPC PPARALAST T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                   (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAMAP))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                              "Mark the document as containing paragraph formatting ")
                   (SETTOBJ TEXTOBJ FORMATTEDP T))
              (\PieceDescriptorOBJECT 
                                      (* ;; 
                             "BYTELEN is the number of bytes on the file, PLEN is always 1 character")

                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PBYTELEN _ BYTELEN
                           PLEN _ 1
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ OBJECT.PTYPE
                           PREVPIECE _ PREVPC))
                   (TEDIT.GET.OBJECT (GETTOBJ TEXTOBJ STREAMHINT)
                          PC TEXT CURFILEBYTE#)
                   (add CURFILEBYTE# BYTELEN)
                   [FSETPC PC PLOOKS (if (ZEROP (BIN TEXT))
                                         then 
                                              (* ;; 
                    "No new looks;  steal them from the prior piece.  RMK: Goofy part of this format")

                                              (OR (AND PREVPC (PLOOKS PREVPC))
                                                  DEFAULTCHARLOOKS)
                                       else 
                                            (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                            (FSETPC PC PLOOKS (\TEDIT.GET.SINGLE.CHARLOOKS TEXT])
              (\PieceDescriptorPAGEFRAME                     (* ; 
                                                             "This is page layout info for the file")
                   (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (TEDIT.PARSE.PAGEFRAMES (READ TEXT))))
              (\PieceDescriptorCHARLOOKSLIST                 (* ; 
                                                 "Read the list of CHARLOOKSs used in this document.")
                   (add PCNO -1)                             (* ; 
                                                             "Lists don't count, in this format.")
                   (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST TEXT))
                   [SETQ LOOKSMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                      do (SETA LOOKSMAP J LOOKS)))
              (\PieceDescriptorPARALOOKSLIST                 (* ; 
                                                 "Read the list of PARALOOKSs used in this document.")
                   (add PCNO -1)                             (* ; "Lists don't count in this format")
                   (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST TEXT TEXTOBJ))
                   [SETQ PARAMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                      do (SETA PARAMAP J LOOKS)))
              (PROGN (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Unknown-type piece skipped." T)
                     (SETFILEPTR TEXT (IPLUS (GETFILEPTR TEXT)
                                             (\SMALLPIN TEXT]
          (CL:WHEN PC                                        (* ; 
                                               "Chain them together without putting them in the tree")
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ PREVPC PC)) finally (SETQ PC (NEXTPIECE FIRSTPC)) 
                                                             (* ; "Throw out the dummy FIRSTPC")
                                      (FSETPC PC PREVPIECE NIL)
                                      (RETURN PC])
)



(* ;; "GETting a file")

(DEFINEQ

(TEDIT.GET
  [LAMBDA (TSTREAM FILE UNFORMATTED? PROPS)                  (* ; "Edited 22-Sep-2023 20:16 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:41 by rmk")
                                                             (* ; "Edited  9-Sep-2023 17:24 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:12 by jds")

    (* ;; "A new file overwrites the textstream,textobj, and window of the one being edited.  We have to make a new TEXTOBJ because we don't want the new file to inherit random properties (like READONLY etc.  (Not sure about BEING-EDITED, that may only have been used for window-creation)")

    (SETQ TSTREAM (TEXTSTREAM TSTREAM))
    (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
           FSTREAM GETFN MAINWINDOW BEINGEDITED PROC NTSTREAM NTEXTOBJ TEDITCREATED BEING-EDITED)
          (CL:WHEN [AND (GETTOBJ TEXTOBJ \DIRTY)
                        (PROGN (TEDIT.PROMPTCLEAR TEXTOBJ)
                               (NOT (MOUSECONFIRM "Not saved yet; LEFT go Get anyway." T
                                           (GETTOBJ TEXTOBJ PROMPTWINDOW]

              (* ;; "Only do the GET if he knows he'll zorch himself.")

              (RETURN))
          (CL:UNLESS FILE
              [SETQ FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ "File to GET:  "
                                                     (OR (GETTEXTPROP TEXTOBJ 'LASTGETFILENAME)
                                                         (\TEXTSTREAM.FILENAME TEXTOBJ])
          (CL:WHEN [AND (SETQ GETFN (GETTEXTPROP TEXTOBJ 'GETFN))
                        (EQ 'DON'T (APPLY* GETFN (GETTOBJ TEXTOBJ STREAMHINT)
                                          (FULLNAME FSTREAM)
                                          'BEFORE]           (* ; 
                                                      "He doesn't want this document put.  Bail out.")
              (RETURN))

     (* ;; "")

          (SETQ FSTREAM (\TEDIT.OPENTEXTFILE FILE))
          (CL:UNLESS (\GETSTREAM FSTREAM 'INPUT T)           (* ; 
                                        "Didn't find it but save the name as a hint for the next try")
              (PUTTEXTPROP TEXTOBJ 'LASTGETFILENAME FILE)
              (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FILE " not found--aborted")
                     T)
              (RETURN NIL))
          (RESETLST
              (RESETSAVE (TTYDISPLAYSTREAM (OR (AND (NEQ 'DON'T (GETTOBJ TEXTOBJ PROMPTWINDOW)
                                                         'DON'T)
                                                    (GETTOBJ TEXTOBJ PROMPTWINDOW))
                                               PROMPTWINDOW)))

              (* ;; "New file is good, clean out the old stuff")

              (\SHOWSEL (TEXTSEL TEXTOBJ)
                     NIL)
              (\TEXTCLOSEF TEXTOBJ)                          (* ; 
                                                             "Close the old files, still in TXTFILE")

              (* ;; "")

              (* ;; "Open a textstream NTSTREAM on the new file, then reconnect its textobj to the old TSTREAM and window")

              (SETQ MAINWINDOW (\TEDIT.MAINW TEXTOBJ))
              (SETQ BEING-EDITED (GETTEXTPROP TEXTOBJ 'BEING-EDITED))
              (CL:WHEN MAINWINDOW
                  (SETQ TEDITCREATED (WINDOWPROP MAINWINDOW 'TEDITCREATED)))
              (CL:WHEN UNFORMATTED?
                  (push PROPS 'CLEARGET T))
              (SETQ NTSTREAM (OPENTEXTSTREAM FSTREAM MAINWINDOW NIL NIL PROPS))
              (SETQ NTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of NTSTREAM))
              (replace (TEXTSTREAM TEXTOBJ) of TSTREAM with NTEXTOBJ)
              (SETTOBJ NTEXTOBJ STREAMHINT TSTREAM)
              (\TEXTSETFILEPTR TSTREAM 0)
              (CL:WHEN MAINWINDOW
                  (\TEDIT.UPDATE.TITLE NTEXTOBJ)
                  (WINDOWPROP MAINWINDOW 'TEDITCREATED TEDITCREATED)
                                                             (* ; "To keep the default region")
                  (WINDOWPROP MAINWINDOW 'TEXTSTREAM TSTREAM))
              (CL:WHEN BEING-EDITED (TEDIT TSTREAM)))        (* ; "find and set the title")
          (CL:WHEN GETFN
              (APPLY* GETFN TSTREAM (FULLNAME (GETTOBJ TEXTOBJ TXTFILE))
                     'AFTER))
          (RETURN TSTREAM])

(TEDIT.FORMATTEDFILEP
  [LAMBDA (FILE)                                             (* ; "Edited 12-Jul-2023 23:35 by rmk")

    (* ;; "If FILE is a Tedit formatted stream or the name of a Tedit formatted file, returns a pair consistening of its version number and piececount.  Piececount is probably useless.")

    (RESETLST
        (if (STREAMP FILE)
            then [RESETSAVE (GETFILEPTR FILE)
                        `(PROGN (SETFILEPTR ,FILE OLDVALUE]
                 (\TEDIT.FORMATTEDP1 FILE)
          else (LET (STREAM)
                    [RESETSAVE (SETQ STREAM (OPENSTREAM FILE 'INPUT))
                           `(PROGN (CLOSEF? OLDVALUE]
                    (\TEDIT.FORMATTEDP1 STREAM))))])

(\TEDIT.GET.FOREIGN.FILE
  [LAMBDA (TEXT TSTREAM START END PROPS)                     (* ; "Edited 22-Sep-2023 09:11 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:40 by rmk")
                                                             (* ; "Edited 10-Aug-2023 17:26 by rmk")
                                                             (* ; "Edited  6-Sep-2022 12:18 by rmk")
                                                             (* ; "Edited 26-Aug-2022 08:43 by rmk")
                                                             (* ; "Edited 25-Jul-2022 21:21 by rmk")

    (* ;; "If TEXT is recognized as a file in a user format, convert it into a new text stream. It could be that the foreign file is coming from a TEDIT.GET on an existing stream. There may be a window attached to TSTREAM, and that's where the edit will eventually take place.  Its dimensions are available, e.g. for width and height, but it may not yet have been initialized for TEDIT (because the source text is being installed here). ")

    (* ;; "")

    (* ;; "The foreign function returns a textstream  FSTREAM.  If FSTREAM=TSTREAM then we assume that everything the foreign function filled it in completely.  If it is a different stream, then we assume that its pieces are safe and its looks are good, we copy that information back into TSTREAM")

    (LET (USERFILEFORMAT USERTEMP FSTREAM FTEXTOBJ (TTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
                )

         (* ;; "Do the predicate and the converter agree that they can handle this?")

         (CL:WHEN (AND (SETQ USERFILEFORMAT (for FILETYPE in TEDIT.INPUT.FORMATS
                                               when (SETQ USERTEMP (APPLY* (CAR FILETYPE)
                                                                          TEXT TSTREAM PROPS))
                                               do (RETURN FILETYPE)))
                       (SETQ FSTREAM (APPLY* (CADR USERFILEFORMAT)
                                            TEXT TSTREAM PROPS USERTEMP))
                       (TEXTSTREAMP FSTREAM))                (* ; "Return NIL if we couldn't convert")
             (CL:UNLESS (EQ TSTREAM FSTREAM)
                 (SETQ FTEXTOBJ (TEXTOBJ FSTREAM))
                 (\INSERTPIECES (\FIRSTPIECE FTEXTOBJ)
                        NIL TTEXTOBJ)
                 (FSETTOBJ TTEXTOBJ LASTPIECE (FGETTOBJ FTEXTOBJ LASTPIECE))
                                                             (* ; "Last piece  have different looks")
                 (FSETTOBJ TTEXTOBJ TXTPAGEFRAMES (FGETTOBJ FTEXTOBJ TXTPAGEFRAMES))
                 (FSETTOBJ TTEXTOBJ FMTSPEC (FGETTOBJ FTEXTOBJ FMTSPEC))
                 (FSETTOBJ TTEXTOBJ DEFAULTCHARLOOKS (FGETTOBJ FTEXTOBJ DEFAULTCHARLOOKS)))
             (\TEDIT.UNIQUIFY.ALL TTEXTOBJ)
             TSTREAM)])

(\TEDIT.GET.UNFORMATTED.FILE
  [LAMBDA (STREAM TSTREAM START END)                         (* ; "Edited 12-Sep-2023 16:45 by rmk")
                                                             (* ; "Edited 30-Aug-2023 23:48 by rmk")
                                                             (* ; "Edited 29-Aug-2023 21:53 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:04 by rmk")
                                                             (* ; "Edited  3-May-2023 17:38 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:09 by rmk")
    (RESETLST
        [RESETSAVE NIL `(STREAMPROP ,STREAM ENDOFSTREAMOP ,(STREAMPROP STREAM 'ENDOFSTREAMOP
                                                                  (FUNCTION NILL]
        (CL:UNLESS START (SETQ START 0))
        (CL:UNLESS END
            (SETQ END (GETEOFPTR STREAM)))
        (\SETFILEPTR STREAM START)
        (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
              (FORMAT (STREAMPROP STREAM 'FORMAT))
              DEFAULTCHARLOOKS DEFAULTPARALOOKS PIECES)
             (SETQ DEFAULTCHARLOOKS (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
             (SETQ DEFAULTPARALOOKS (GETTOBJ TEXTOBJ FMTSPEC))
             (CL:WHEN (AND (EQ FORMAT :STRING)
                           (\IOMODEP STREAM 'OUTPUT T))
                 (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))
             (SETQ PIECES
              (SELECTQ FORMAT
                  (:XCCS (\TEDIT.GET.UNFORMATTED.FILE.XCCS STREAM START END DEFAULTCHARLOOKS 
                                DEFAULTPARALOOKS))
                  (:UTF-8 (\TEDIT.GET.UNFORMATTED.FILE.UTF8 STREAM START END DEFAULTCHARLOOKS 
                                 DEFAULTPARALOOKS))
                  (:STRING (CL:WHEN (\IOMODEP STREAM 'OUTPUT T)

                               (* ;; 
            "Protect against somebody smashing the string. (Should also protect other files, but...)")

                               (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))

                           (* ;; "String format is known to be fat.  Eventually it should be sufficient to know the byesperchar of the piece to figure out the PFILEPOS byte pointers, and just use the generic \OUTCHAR to get the characters.")

                           (create PIECE
                                  PCONTENTS _ STREAM
                                  PFPOS _ START
                                  PLEN _ (FOLDLO (IDIFFERENCE END START)
                                                2)
                                  PLOOKS _ DEFAULTCHARLOOKS
                                  PPARALAST _ NIL
                                  PPARALOOKS _ DEFAULTPARALOOKS
                                  PTYPE _ FATFILE2.PTYPE
                                  PEXTERNALFORMAT _ FORMAT
                                  PBYTESPERCHAR _ 2))
                  (create PIECE
                         PCONTENTS _ STREAM
                         PFPOS _ START
                         PLEN _ (IDIFFERENCE END START)
                         PLOOKS _ DEFAULTCHARLOOKS
                         PPARALAST _ NIL
                         PPARALOOKS _ DEFAULTPARALOOKS
                         PTYPE _ THINFILE.PTYPE
                         PEXTERNALFORMAT _ FORMAT)))
             (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES PIECES)
                    NIL TEXTOBJ)))])

(\TEDIT.GET.FORMATTED.FILE
  [LAMBDA (TEXT TSTREAM START END)                           (* ; "Edited 22-Sep-2023 19:52 by rmk")
                                                             (* ; "Edited 12-Sep-2023 16:46 by rmk")
                                                             (* ; "Edited  7-Sep-2023 22:18 by rmk")
                                                             (* ; "Edited  2-Sep-2023 11:01 by rmk")
                                                             (* ; "Edited 31-Aug-2023 15:30 by rmk")
                                                             (* ; "Edited 28-Aug-2023 22:19 by rmk")
                                                             (* ; "Edited 24-Aug-2023 22:14 by rmk")
                                                             (* ; "Edited 12-Aug-2023 08:41 by rmk")
                                                             (* ; "Edited 11-Jun-99 14:37 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:46 by jds")

    (* ;; "TEXT is an open stream that knows its external format, TEXTOBJ is the TEXTOBJ to be filled in.  If specified, START and END define the byte positions in TEXT to be included.")

    (* ;; 
   "If TSTREAM is a formatted file, it is included in TEXTOBJ and TEXTOBJ is returned, otherwise NIL")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          (PCCOUNT (\TEDIT.FORMATTEDP1 TEXT END))
          PC)
         (CL:WHEN PCCOUNT
             (SETTOBJ TEXTOBJ TXTPAGEFRAMES NIL)
             (if (OR (GETTEXTPROP TEXTOBJ 'CACHE)
                     (NOT (RANDACCESSP TEXT)))
                 then                                        (* ; 
                                    "If the file device isn't random access, cache the file locally.")
                                                             (* ; 
                                                         "Also do this if he asks for a local cache.")
                      (SETQ TEXT (\TEDIT.CACHEFILE TEXT TEXTOBJ START END)) 

                      (* ;; 
 "Since we only copied the relevant part of the file into the cache, the whole file is now relevant.")

                      (SETQ START 0)
                      (SETQ END (GETEOFPTR TEXT))
               else (CL:UNLESS START (SETQ START 0))
                    (CL:UNLESS END (GETEOFPTR TEXT)))
             (SELECTQ (CAR PCCOUNT)
                 (3                                          (* ; "Current version")
                    (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES (\TEDIT.GET.PIECES3 TEXT TEXTOBJ
                                                                   (CADR PCCOUNT)
                                                                   START END))
                           NIL TEXTOBJ))
                 (2                                          (* ; "Version 2;  obsoleted 5/22/85")
                    (TEDIT.GET.PCTB2 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END))
                 (1                                          (* ; 
                                                   "Version 1;  obsoleted at INTERMEZZO release 2/85")
                    (TEDIT.GET.PCTB1 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END))
                 (0                                          (* ; "VERSION 0")
                    (TEDIT.GET.PCTB0 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END))
                 (SHOULDNT "File format version incompatible with this version of TEdit."))
             (CL:WHEN (SETQ PC (PREVPIECE (\LASTPIECE TEXTOBJ)))
                 (replace (PIECE PPARALAST) of PC with T))
             TEXTOBJ)])

(\TEDIT.FORMATTEDSTREAMP
  [LAMBDA (TSTREAM)                                          (* ; "Edited 22-Sep-2023 20:17 by rmk")
                                                             (* ; "Edited 15-Sep-2023 00:09 by rmk")
                                                             (* ; "Edited 15-Aug-2023 17:35 by rmk")
                                                             (* ; "Edited 16-Sep-2022 21:00 by rmk")
                                                             (* ; "Edited  1-Sep-2022 08:54 by rmk")
                                                             (* ; "Edited 19-Apr-93 11:57 by jds")

    (* ;; 
   "Test to see if this stream's text would need a TEdit-format file (T) or is just plain text (NIL)")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM)))
         (for PC (FORMATLEVEL _ 0)
              (DEFAULTCLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
              (DEFAULTPLOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC))
              (TENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE)) inpieces (\FIRSTPIECE TEXTOBJ)
            do [COND
                  ((EQ OBJECT.PTYPE (PTYPE PC))              (* ; 
                                                             "OBJECTS require the special format")
                   (SETQ FORMATLEVEL 4)
                   (GO $$OUT))
                  ([OR (AND (PPARALAST PC)
                            (NEXTPIECE PC))
                       (NOT (EQFMTSPEC DEFAULTPLOOKS (PPARALOOKS PC]
                                                             (* ; 
                                                   "A paragraph break not at the end, or a new plook")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 3)))
                  ((OR (NOT (EQCLOOKS DEFAULTCLOOKS (PLOOKS PC)))
                       (AND TENTATIVE (PNEW PC)))            (* ; "Change in font, size, etc.")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 2)))
                  ((MEMB (PTYPE PC)
                         (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE)))
                                                             (* ; "16-bit chars in the piece")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 1]
            finally 

                  (* ;; 
             "1 originally meant NSCHARS.  But that's not a %"look%", just an external format issue.")

                  (RETURN (SELECTQ FORMATLEVEL
                              (0 NIL)
                              (2 'CHARLOOKS)
                              (3 'PARALOOKS)
                              (4 'IMAGEOBJ)
                              NIL])

(TEDIT.PARSE.PAGEFRAMES1
  [LAMBDA (PAGELIST PARENT)                                  (* ; "Edited  8-Mar-2023 18:14 by rmk")
                                                             (* ; "Edited  4-Oct-2022 16:57 by rmk")
                                                             (* ; "Edited  1-Oct-2022 16:02 by rmk")

    (* ;; "Internalize an external pageframe.")

    (* ;; "Exactly like TEDIT.PARSE.PAGEFRAMES, except this scales the region specs.")

    (LET (FRAMETYPE PAGEFRAME)
         (COND
            ((type? PAGEREGION PAGELIST)
             PAGELIST)
            ((NEQ 'LIST (SETQ FRAMETYPE (pop PAGELIST)))
             [SETQ PAGEFRAME (create PAGEREGION
                                    REGIONFILLMETHOD _ FRAMETYPE
                                    REGIONTYPE _ (pop PAGELIST)
                                    REGIONLOCALINFO _ (pop PAGELIST)
                                    REGIONSPEC _ (for VAL
                                                    in (OR (pop PAGELIST)
                                                           (LIST 0 0 0 0))
                                                    collect (HCUNSCALE MICASPERPT VAL]
             (replace REGIONSUBBOXES of PAGEFRAME with (for ALIST in (pop PAGELIST)
                                                          collect (TEDIT.PARSE.PAGEFRAMES1 ALIST 
                                                                         PAGEFRAME)))
             PAGEFRAME)
            (T (for FRAMESPEC in (CAR PAGELIST) collect (TEDIT.PARSE.PAGEFRAMES1 FRAMESPEC NIL])

(\ARBIN
  [LAMBDA (STREAM)                                           (* jds "13-Nov-86 20:21")
                                                             (* ; 
                                     "Read an arbitrary object from a file, parse it, and return it.")
    (PROG ((LEN (\SMALLPIN STREAM))
           USERSTR)
          (COND
             ((NOT (ZEROP LEN))
              (SETQ USERSTR (OPENSTRINGSTREAM (\STRINGIN STREAM LEN)
                                   'INPUT))
              (RETURN (PROG1 (READ USERSTR *TEDIT-FILE-READTABLE*)
                             (CLOSEF? USERSTR])

(\ATMIN
  [LAMBDA (STREAM)                                           (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-Apr-84 10:41")
    (PROG ((LEN (\SMALLPIN STREAM)))
          (RETURN (COND
                     ((ZEROP LEN)
                      NIL)
                     (T (PACK (for I from 1 to LEN collect (CHARACTER (BIN STREAM])

(\DWIN
  [LAMBDA (FILE)                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-JAN-83 16:08")
    (IPLUS (LLSH (BIN FILE)
                 24)
           (LLSH (BIN FILE)
                 16)
           (LLSH (BIN FILE)
                 8)
           (BIN FILE])

(\STRINGIN
  [LAMBDA (STREAM SETLEN)                                    (* ; "Edited 20-Apr-88 19:54 by jds")

         (* Read a string in length-contents form%: One word for the length, and one byte 
         per character contained. However, the length may be specified by the caller 
         instead of being read from the file.)

    (PROG ((LEN (OR SETLEN (\SMALLPIN STREAM)))
           STR)
          (SETQ STR (ALLOCSTRING LEN))
          [OR (ZEROP LEN)
              (for I from 1 to LEN do (RPLCHARCODE STR I (READCCODE STREAM]
          (RETURN STR])

(\TEDIT.FORMATTEDP1
  [LAMBDA (FILE LEN)

    (* ;; "Edited 22-Jul-2022 12:04 by rmk: Returns the version as well as the piece-count in the current-version case, to be consistent.  Also, return is a LIST instead of a CONS, so more information (like a date) can eventually be provided.")

    (* ;; "Edited 21-Jul-2022 22:41 by rmk")

    (* ;; "Edited 12-Feb-88 11:43 by jds")
                                                             (* ; 
                                                             "Checks for a version-1 formatted file")

    (* ;; "Returns NIL if it isn't a formatted file. Leaves file at start of text or of piece descriptions, resp.")

    (SETQ LEN (OR LEN (GETEOFPTR FILE)))
    (CL:WHEN (IGREATERP LEN 8)
        (LET (DESCPTR PCCOUNT VERSION)
             (SETFILEPTR FILE (IDIFFERENCE LEN 8))           (* ; 
                                                           "Move to start of FILEPTR to descriptions")
             (SETQ DESCPTR (\DWIN FILE))                     (* ; 
                                                             "Read the file pos of the descriptions")
             (SETQ PCCOUNT (\SMALLPIN FILE))
             (SETQ VERSION (IDIFFERENCE (\SMALLPIN FILE)
                                  31415))
             (SELECTQ VERSION
                 ((3 1 2 0)                                  (* ; "The known versions.  3 is current")
                      (SETFILEPTR FILE DESCPTR)
                      (LIST VERSION PCCOUNT))
                 (PROGN                                      (* ; "NOT A FORMATTED FILE")
                        (SETFILEPTR FILE 0)
                        NIL))))])

(\TEDIT.CACHEFILE
  [LAMBDA (TEXT TEXTOBJ START END)                           (* ; "Edited 22-Sep-2023 20:15 by rmk")
                                                             (* ; "Edited 31-Aug-2023 15:35 by rmk")
                                                             (* ; "Edited 14-Jul-2022 08:44 by rmk")

    (* ;; "If TEXT is not a random-access file, we copy it into local storage (NODIRCORE)")

    (LET (CACHE)

         (* ;; "Sets the external format and its EOL.")

         [SETQ CACHE (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((TYPE TEXT)
                                                           (:EXTERNAL-FORMAT ,(GETSTREAMPROP TEXT 
                                                                                     :EXTERNAL-FORMAT
                                                                                     ]
         (COND
            ((OR START END)
             (COPYBYTES TEXT CACHE (OR START 0)
                    (OR END -1)))
            (T (COPYBYTES TEXT CACHE)))                      (* ; "Copy the text there")

         (* ;; "COPYBYTES can only have start/end args of NIL if the file is not random access.  So it's impossible to grab out of the middle of a file on an NS server.  Sorry.")

         (CLOSEF TEXT)
         (CL:WHEN TEXTOBJ

             (* ;; 
             "REMEMBER THAT THIS TEXT WAS CACHED, SO THAT LATER PUTS DON'T INVALIDATE THE CACHE.")

             (PUTTEXTPROP TEXTOBJ 'CACHE T))
         CACHE])
)
(DEFINEQ

(\TEDIT.GET.PIECES3
  [LAMBDA (TEXT TEXTOBJ PCCOUNT CURFILEBYTE# END)            (* ; "Edited 24-Sep-2023 22:00 by rmk")
                                                             (* ; "Edited  2-Sep-2023 11:12 by rmk")
                                                             (* ; "Edited 29-Aug-2023 00:18 by rmk")

    (* ;; "This runs through the Looks table portion of the TEXT file, gathering the looks and  installing pointers to positions in the character section of the file.  It doesn't actually examine the characters in the file.  It returns a piece chain that covers the text but that hasn't been installed in the btree.  The pieces need further adjustment for character encoding and to prevent mutlibyte characters from crossing buffer boundaries before they are installed in the btree.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                            8))
    (SETFILEPTR TEXT (\DWIN TEXT))                           (* ; "Pieceinfo char #")
    (for PCNO PC BYTELEN PREVPC FIRSTPC PARAMAP LOOKSMAP (ORIGBYTE# _ CURFILEBYTE#)
         (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
         (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) from 1 to PCCOUNT first (SETQ FIRSTPC
                                                                              (CREATE PIECE)) 
                                                             (* ; "Throw away at the end")
                                                                             (SETQ PREVPC FIRSTPC)
       do (SETQ PC NIL)                                      (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
          (SETQ BYTELEN (\DWIN TEXT))
          [SELECTC (\SMALLPIN TEXT)
              (\PieceDescriptorLOOKS                         (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ BYTELEN
                           PBYTELEN _ BYTELEN
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ THINFILE.PTYPE
                           PBYTESPERCHAR _ 1
                           PREVPIECE _ PREVPC))
                   (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSMAP)   (* ; 
                                                             "Get its looks and character-pointers")
                   (add CURFILEBYTE# BYTELEN))
              (\PieceDescriptorPARA                          (* ; 
                                                             "Reading a new set of paragraph looks.")
                   (CL:WHEN PREVPC (FSETPC PREVPC PPARALAST T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                   (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAMAP))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                              "Mark the document as containing paragraph formatting ")
                   (SETTOBJ TEXTOBJ FORMATTEDP T))
              (\PieceDescriptorOBJECT 
                                      (* ;; 
                             "BYTELEN is the number of bytes on the file, PLEN is always 1 character")

                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PBYTELEN _ BYTELEN
                           PLEN _ 1
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ OBJECT.PTYPE
                           PREVPIECE _ PREVPC))
                   (TEDIT.GET.OBJECT (GETTOBJ TEXTOBJ STREAMHINT)
                          PC TEXT CURFILEBYTE#)
                   (add CURFILEBYTE# BYTELEN)
                   [FSETPC PC PLOOKS (if (ZEROP (BIN TEXT))
                                         then 
                                              (* ;; 
                    "No new looks;  steal them from the prior piece.  RMK: Goofy part of this format")

                                              (OR (AND PREVPC (PLOOKS PREVPC))
                                                  DEFAULTCHARLOOKS)
                                       else 
                                            (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                            (FSETPC PC PLOOKS (\TEDIT.GET.SINGLE.CHARLOOKS TEXT])
              (\PieceDescriptorPAGEFRAME                     (* ; 
                                                             "This is page layout info for the file")
                   (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (TEDIT.PARSE.PAGEFRAMES (READ TEXT))))
              (\PieceDescriptorCHARLOOKSLIST                 (* ; 
                                                 "Read the list of CHARLOOKSs used in this document.")
                   (add PCNO -1)                             (* ; 
                                                             "Lists don't count, in this format.")
                   (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST TEXT))
                   [SETQ LOOKSMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                      do (SETA LOOKSMAP J LOOKS)))
              (\PieceDescriptorPARALOOKSLIST                 (* ; 
                                                 "Read the list of PARALOOKSs used in this document.")
                   (add PCNO -1)                             (* ; "Lists don't count in this format")
                   (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST TEXT TEXTOBJ))
                   [SETQ PARAMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                      do (SETA PARAMAP J LOOKS)))
              (PROGN (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Unknown-type piece skipped." T)
                     (SETFILEPTR TEXT (IPLUS (GETFILEPTR TEXT)
                                             (\SMALLPIN TEXT]
          (CL:WHEN PC                                        (* ; 
                                               "Chain them together without putting them in the tree")
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ PREVPC PC)) finally (SETQ PC (NEXTPIECE FIRSTPC)) 
                                                             (* ; "Throw out the dummy FIRSTPC")
                                      (FSETPC PC PREVPIECE NIL)
                                      (RETURN PC])

(\TEDIT.MAKE.SAFE.BUFFERS
  [LAMBDA (PC ONECHARFN)                                     (* ; "Edited 23-Sep-2023 00:19 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  5-Sep-2023 00:00 by rmk")
                                                             (* ; "Edited 30-Aug-2023 19:09 by rmk")

    (* ;; "This chops PC into a sequence of pieces such that no piece has a character whose bytes cross a PFILE buffer boundary.  Any offending character is placed in a string piece that is linked into the chain.  The return value is the piece that holds the last characters of PC, so the caller's iteration can continue to the next problematic piece in a higher-level chain.")

    (* ;; "This works mostly on PBYTELEN using PBYTESPERCHAR for the granularity, and using PBYTESPERCHAR also to recalculate the output PLENs. PBYTELEN should be a multiple of PBYTESPERCHAR")

    (bind BYTESLEFTINBUFFER BUFPOS BUFSIZE CROSSCHAR STRINGPC PREFIXCHARS PREFIXPC (PREFIXBYTES
                                                                                    _ 0)
          (SUFFIXPC _ PC)
          (PFILE _ (PCONTENTS PC))
          (BYTESPERCHAR _ (PBYTESPERCHAR PC))
          (BYTESLEFT _ (PBYTELEN PC))
          (FPOS _ (PFPOS PC))
          (BYTELEN _ (PBYTELEN PC)) first (SETQ BUFSIZE (fetch (STREAM CBUFMAXSIZE) of PFILE))
                                          (CL:WHEN (AND (EVENP BUFSIZE BYTESPERCHAR)
                                                        (EVENP FPOS BYTESPERCHAR))

                                  (* ;; "A piece with 2-byte characters would always be aligned, for example, if PFPOS and BUFSIZE are both even--nothing to worry about.")

                                              (RETURN PC))
                                          (SETQ BUFPOS FPOS) eachtime (SETQ BYTESLEFTINBUFFER
                                                                       (IDIFFERENCE BUFSIZE
                                                                              (IREMAINDER BUFPOS 
                                                                                     BUFSIZE)))
       do (CL:WHEN (ILEQ BYTESLEFT BYTESLEFTINBUFFER)
              (CL:WHEN (FGETPC SUFFIXPC NEXTPIECE)           (* ; 
                                                            "Point the original next at its new prev")
                  (FSETPC (FGETPC SUFFIXPC NEXTPIECE)
                         PREVPIECE SUFFIXPC))
              (RETURN SUFFIXPC)) 

          (* ;; "The current SUFFIXPC has a character that crosses a buffer boundary (but maybe not the very first boundary--a prefix of 4 3-byte characters might initially align with a 512 byte buffer, but it will lose after that). We either have to extend the current piece across the next buffer (if it is aligned), or split off a file piece and a 1-character string piece.")

          (if (EVENP BYTESLEFTINBUFFER BYTESPERCHAR)
              then 
                   (* ;; "The last character doesn't cross so we don't have to split for this buffer and can continue peeling off prefixbytes from the same SUFFIXPC.  We advance BUFFPOS to the start of the next buffer, but don't advance FPOS.")

                   (* ;; "Note that when we finally run up against the boundary, rounding down to characters may back off some prefixbytes--we have to adjust for that below.")

                   (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))
                   (add BUFPOS BYTESLEFTINBUFFER)
                   (add PREFIXBYTES BYTESLEFTINBUFFER)
            else 
                 (* ;; "The current SUFFIXPC has a boundary-crossing character.  In general we have to divide it into 3 pieces")

                 (* ;; 
  "    1.  PREFIXPC represents SUFFIXPC characters before the offender, with the original ptype etc.")

                 (* ;; "    2.  STRINGPC contains the single offending character, read from the file and inserted as a string piece.")

                 (* ;; 
              "    3.  A new SUFFIXPC representing the characters remaining for the next iteration..")

                 (* ;; " PREFIXPC exists only if BYTESLEFTINBUFFER is greater than BYTESPERCHAR. If less, then it is only the string character that crosses the boundary, there are no other prefix chars. ")

                 (* ;; "Note that SUFFIXPC always carries along any properties of the original PC that might remain useful, even though PC is otherwise cannibalized. Looks, paralast, nextpiece...")

                 (* ;; "")

                 (add PREFIXBYTES BYTESLEFTINBUFFER)
                 (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))  (* ; 
                                                          "Include the last buffer, round down below")
                 (CL:WHEN (IGREATERP PREFIXBYTES BYTESPERCHAR)
                                                             (* ; 
                                                       "There is a prefix to chop off from SUFFIXPC ")
                     (SETQ PREFIXPC SUFFIXPC)
                     (SETQ PREFIXCHARS (IQUOTIENT PREFIXBYTES BYTESPERCHAR))
                     [add BYTESLEFT BYTESPERCHAR (IMINUS (IDIFFERENCE PREFIXBYTES (SETQ PREFIXBYTES
                                                                                   (ITIMES 
                                                                                          PREFIXCHARS
                                                                                          
                                                                                         BYTESPERCHAR
                                                                                          ]
                     (SETQ BUFPOS (IPLUS FPOS PREFIXBYTES))  (* ; 
                                                        "The suffix starts on a character first-byte")
                     (SETQ SUFFIXPC (create PIECE using SUFFIXPC PFPOS _ BUFPOS PBYTELEN _ BYTESLEFT
                                                        PLEN _ (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                                        PREVPIECE _ PREFIXPC))
                     (with PIECE PREFIXPC (SETQ PLEN PREFIXCHARS)
                           (SETQ PBYTELEN PREFIXBYTES)
                           (SETQ PPARALAST NIL)
                           (SETQ NEXTPIECE SUFFIXPC)))
                 (SETQ PREFIXBYTES 0) 

                 (* ;; "")

                 (* ;; 
              "SUFFIXPC now begins with a crosser--convert SUFFIXPC to a one-character string piece ")

                 (SETQ FPOS (FGETPC SUFFIXPC PFPOS))
                 (SETFILEPTR PFILE FPOS)                     (* ; "Fetch the crossing character")
                 (SETQ CROSSCHAR (APPLY* ONECHARFN PFILE))
                 (SETQ STRINGPC SUFFIXPC)
                 (add BYTESLEFT (IMINUS BYTESPERCHAR))
                 (if (IGREATERP BYTESLEFT 0)
                     then                                    (* ; 
                                                             "Create a new SUFFIXPC for the residual")
                          (add FPOS BYTESPERCHAR)            (* ; "Don't include the CROSSCHAR")
                          (SETQ SUFFIXPC
                           (create PIECE using SUFFIXPC PFPOS _ FPOS PBYTELEN _ BYTESLEFT PLEN _
                                               (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                               PREVPIECE _ STRINGPC))
                          (FSETPC STRINGPC NEXTPIECE SUFFIXPC)
                          (FSETPC STRINGPC PPARALAST NIL)
                          (SETQ BUFPOS FPOS)
                   else (SETQ SUFFIXPC NIL)) 

                 (* ;; "")

                 (* ;; 
       "Convert the previous SUFFIXPC (now STRINGPC) to a string piece containing just the CROSSCHAR")

                 (with PIECE STRINGPC (SETQ PCONTENTS (ALLOCSTRING 1 CROSSCHAR))
                       (SETQ PLEN 1)
                       (if (ILEQ CROSSCHAR 255)
                           then (SETQ PTYPE THINSTRING.PTYPE)
                                (SETQ PBYTESPERCHAR 1)
                                (SETQ PBYTELEN 1)
                                (SETQ PBINABLE T)
                         else (SETQ PTYPE FATSTRING.PTYPE)
                              (SETQ PBYTESPERCHAR 2)
                              (SETQ PBYTELEN 2)
                              (SETQ PBINABLE NIL)))
                 (CL:UNLESS SUFFIXPC                         (* ; 
                                                          "Didn't need a SUFFIXPC, end with STRINGPC")
                     (CL:WHEN (FGETPC STRINGPC NEXTPIECE)
                         (FSETPC (FGETPC STRINGPC NEXTPIECE)
                                PREVPIECE STRINGPC))
                     (RETURN STRINGPC))])

(\TEDIT.MAKE.SAFE.PIECES
  [LAMBDA (PIECES)                                           (* ; "Edited 23-Sep-2023 00:28 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  9-Sep-2023 22:59 by rmk")
                                                             (* ; "Edited  7-Sep-2023 10:03 by rmk")
                                                             (* ; "Edited 29-Aug-2023 22:01 by rmk")

    (* ;; "PIECES is a chain of pieces read from a file but not yet inserted into the BTREE.  Each piece has the file (PFILE=PCONTENTS), PFPOS and PLEN.  This function makes normalizes the pieces  to remove complexity from other inner-loop algorithms.  For example, if the external format of the file is XCCS, some pieces may begin with charset shifts, and we need to make sure that those bytes are not visible (by bumping PFPOS and reducing PLEN).")

    (* ;; "And we also want to make sure that no multicharacter piece crosses a buffer-boundary.  We accomplish that by splitting the piece before a character that would cross the boundary, and inserting a string piece to hold that character.")

    (CL:WHEN PIECES                                          (* ; 
                                                             "PFILE is  a stream open for input.")
        [LET
         [(PFILE (for PC inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                    when (\GETSTREAM (PCONTENTS PC)
                                'INPUT T) do (RETURN (PCONTENTS PC]
         (CL:WHEN PFILE                                      (* ; "At least one file piece")
             [SELECTQ (STREAMPROP PFILE :EXTERNAL-FORMAT)
                 (:XCCS 
                        (* ;; 
          "We have to strip shifting bytes for text, but object bytes have already been interpreted.")

                        (for PC BYTE inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                           do (SETFILEPTR PFILE (PFPOS PC))
                              (if (EQ NSCHARSETSHIFT (BIN PFILE))
                                  then [SELECTC (SETQ BYTE (BIN PFILE))
                                           (0 (FSETPC PC PTYPE THINFILE.PTYPE)
                                              (FSETPC PC PBINABLE T)
                                              (add (PFPOS PC)
                                                   2)
                                              (add (PBYTELEN PC)
                                                   -2)       (* ; 
                                                             "The shift characters really disappear")
                                              (FSETPC PC PLEN (PBYTELEN PC)))
                                           (NSCHARSETSHIFT 
                                                (CL:UNLESS (EQ 0 (BIN PFILE))
                                                       (SHOULDNT "XCCS CHARACTER NOT IN PLANE 0"))
                                                (FSETPC PC PTYPE FATFILE2.PTYPE)
                                                (FSETPC PC PBYTESPERCHAR 2)
                                                (add (PFPOS PC)
                                                     3)
                                                (add (PBYTELEN PC)
                                                     -3)
                                                (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                                       2))
                                                [SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS
                                                          PC
                                                          (FUNCTION (LAMBDA (PFILE)
                                                                      (\WIN PFILE])
                                           (PROGN 

                                 (* ;; "A run in a non-zero charset.  It's not worth dealing with the complexity of maintaining that storage efficiency, here we convert it to a fat-string piece.")

                                                  (add (PBYTELEN PC)
                                                       -2)
                                                  (FSETPC PC PLEN (PBYTELEN PC))
                                                  (FSETPC PC PTYPE FATSTRING.PTYPE)
                                                  (FSETPC PC PBYTESPERCHAR 2)
                                                  (FSETPC PC PBINABLE NIL)
                                                  (for I (CHARSET _ (LLSH BYTE 8))
                                                       (STRING _ (ALLOCSTRING (PLEN PC)
                                                                        NIL NIL T)) from 1
                                                     to (PLEN PC) first (FSETPC PC PCONTENTS STRING)
                                                     do (RPLCHARCODE STRING I (LOGOR CHARSET
                                                                                     (BIN PFILE]
                                elseif (EQ 2 (PBYTESPERCHAR PC))
                                  then (FSETPC PC PTYPE FATFILE2.PTYPE) 
                                                             (* ; "This is the continuation of an XCCS 2-byte run that was broken up presumably for looks or paragraphs")
                                       (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                              2))
                                       [SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS PC (FUNCTION (LAMBDA (PFILE
                                                                                                )
                                                                                         (\WIN PFILE]
                                else (FSETPC PC PTYPE THINFILE.PTYPE) 
                                                             (* ; "A charset 0 1-byte run")
                                     (FSETPC PC PBINABLE T)
                                     (FSETPC PC PLEN (PBYTELEN PC))
                                     (FSETPC PC PBYTESPERCHAR 1))))
                 (:UTF-8 (HELP 'UTF8))
                 (for PC inpieces PC unless (EQ OBJECT.PTYPE (PTYPE PC))
                    do (FSETPC PC PTYPE THINFILE.PTYPE)      (* ; "Default:  assume :THROUGH ?")
                       (FSETPC PC PBINABLE T)
                       (FSETPC PC PLEN (FGETPC PC PBYTELEN])])
    PIECES])
)
(DEFINEQ

(\TEDIT.GET.UNFORMATTED.FILE.XCCS
  [LAMBDA (STREAM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS)
                                                             (* ; "Edited 31-Aug-2023 00:22 by rmk")
                                                             (* ; "Edited 29-Aug-2023 22:06 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:05 by rmk")
                                                             (* ; "Edited 19-Aug-2022 22:34 by rmk")

    (* ;; "We build a chain of pieces one for each NS stringlet.  All pieces start on the charset shift byte as THINFILE pieces with BYTESPERCHAR=1. We don't interpret those bytes here, they wlll be decoded and made buffer-safe later.")

    (* ;; "We assume that caller has positioned the stream at the intended start byte has set the ENDOFSTREAMOP to return NIL on EOF. We have to worry about END: it is the ptr to the last byte")

    (for I PC BYTE PREVPC BYTELEN NEXTPTR (BEGINPTR _ (GETFILEPTR STREAM))
         (FIRSTPC _ (create PIECE))
         (EXTFORMAT _ (ffetch (STREAM EXTERNALFORMAT) of STREAM)) from 0
       to (ADD1 (IDIFFERENCE END START)) first (SETQ PREVPC FIRSTPC) 
                                                             (* ; "FIRSTPC is a throwaway")
       eachtime (SETQ BYTE (BIN STREAM)) when (OR (EQ NSCHARSETSHIFT BYTE)
                                                  (NULL BYTE))
       do (SETQ NEXTPTR (\GETFILEPTR STREAM))
          (CL:WHEN BYTE                                      (* ; 
                    "Back up to point of the just-read shift byte (but stream didn't advance at EOF)")
              (add NEXTPTR -1))
          (SETQ BYTELEN (IDIFFERENCE NEXTPTR BEGINPTR))
          (CL:UNLESS (ZEROP BYTELEN)                         (* ; 
                                                     "Empty piece, possibly a charset shift at START")
              (SETQ PC
               (create PIECE
                      PCONTENTS _ STREAM
                      PFPOS _ BEGINPTR
                      PLEN _ BYTELEN
                      PLOOKS _ DEFAULTCHARLOOKS
                      PPARALOOKS _ DEFAULTPARALOOKS
                      PEXTERNALFORMAT _ EXTFORMAT
                      PTYPE _ THINFILE.PTYPE
                      PBYTESPERCHAR _ 1
                      PBYTELEN _ BYTELEN
                      PREVPIECE _ PREVPC))
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ BEGINPTR NEXTPTR)
              (SETQ PREVPC PC))
          (CL:WHEN (EQ \NORUNCODE (\PEEKCCODE STREAM T))     (* ; "We don't want to trip on a following \NORUNCODE, which happens to look like the just binned \NSCHARSETSHIFT")
              (add I 1)
              (BIN STREAM)) finally (RETURN (NEXTPIECE FIRSTPC])

(\TEDIT.GET.UNFORMATTED.FILE.UTF8
  [LAMBDA (STREAM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS)
                                                             (* ; "Edited 31-Aug-2023 15:20 by rmk")

    (* ;; 
    "We build a separate piece for each sequence of UTF8 characters with the same number of bytes.")

    (for I PC PREVPC FIRSTPC NBYTES PREVNBYTES PFPOS BYTELEN (EXTFORMAT _ (ffetch (STREAM 
                                                                                       EXTERNALFORMAT
                                                                                         )
                                                                             of STREAM))
         (PREVFPOS _ START) from 0 to (ADD1 (IDIFFERENCE END START))
       eachtime (SETQ NBYTES (NUTF8BYTES (BIN STREAM)))
       do (CL:WHEN (AND PREVNBYTES (NEQ NBYTES PREVNBYTES))
              (SETQ BYTELEN (IDIFFERENCE PFPOS PREVFPOS))
              (SETQ PC
               (create PIECE
                      PCONTENTS _ STREAM
                      PFPOS _ BYTELEN
                      PBYTELEN _ BYTELEN
                      PLEN _ (ADD1 (IDIFFERENCE PFPOS LASTPFPOS))
                      PBYTESPERCHAR _ NBYTES
                      PLOOKS _ DEFAULTCHARLOOKS
                      PPARALOOKS _ DEFAULTPARALOOKS
                      PEXTERNALFORMAT _ EXTFORMAT
                      PREVPIECE _ PREVPC
                      PTYPE _ (SELECTQ PREVNBYTES
                                  (1 THINFILE.PTYPE)
                                  (2 UTF8-2.PTYPE)
                                  (3 UTF8-3.PTYPE)
                                  (4 UTF8-4.PTYPE)
                                  (SHOULDNT))
                      PBINABLE _ (EQ NBYTES 1)))
              (CL:WHEN PREVPC (SETPC PREVPC NEXTPIECE PC))
              (SETQ PREVFPOS PFPOS)
              (SETQ PREVNBYTES NBYTES)
              (SETQ PREVPC PC)
              (CL:UNLESS FIRSTPC (SETQ FIRSTPC PC)))
          (FRPTQ (SUB1 NBYTES)
                 (BIN STREAM))
          (add I (SUB1 NBYTES))
          (add PFPOS NBYTES) finally (RETURN FIRSTPC])
)



(* ;; "NOT USED, TO BE REMOVED")

(DEFINEQ

(TEDIT.GET.PCTB3
  [LAMBDA (TEXT TEXTOBJ PCCOUNT CURFILEBYTE# END)            (* ; "Edited 28-Aug-2023 17:55 by rmk")
                                                             (* ; "Edited 12-Oct-2022 14:24 by rmk")
                                                             (* ; "Edited  9-Aug-2022 20:44 by rmk")

    (* ;; "This runs through the piece table portion of the TEXT file, gathering the looks and  installing pointers to positions in the character section of the file.  Until the last pass of splitting pieces to pass over any residual NS character shifts, it doesn't actually read the characters.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                            8))
    (SETFILEPTR TEXT (\DWIN TEXT))                           (* ; "Pieceinfo char #")
    (for PCNO PC BYTELEN OLDPC PARAMAP LOOKSMAP (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ 
                                                                           DEFAULTCHARLOOKS))
         (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) from 1 to PCCOUNT
       do (SETQ PC NIL)                                      (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
          (SETQ BYTELEN (\DWIN TEXT))
          [SELECTC (\SMALLPIN TEXT)
              (\PieceDescriptorPAGEFRAME                     (* ; 
                                                             "This is page layout info for the file")
                   (CL:WHEN TEXTOBJ
                       (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (TEDIT.PARSE.PAGEFRAMES (READ TEXT)))))
              (\PieceDescriptorCHARLOOKSLIST                 (* ; 
                                                 "Read the list of CHARLOOKSs used in this document.")
                   (add PCNO -1)                             (* ; 
                                                             "Lists don't count, in this format.")
                   (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST TEXT))
                   [SETQ LOOKSMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as CSLOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                      do (SETA LOOKSMAP J CSLOOKS)))
              (\PieceDescriptorPARALOOKSLIST                 (* ; 
                                                 "Read the list of PARALOOKSs used in this document.")
                   (add PCNO -1)                             (* ; "Lists don't count, in this format")
                   (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST TEXT TEXTOBJ))
                   [SETQ PARAMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as PLOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                      do (SETA PARAMAP J PLOOKS)))
              (\PieceDescriptorPARA                          (* ; 
                                                             "Reading a new set of paragraph looks.")
                   (CL:WHEN OLDPC (FSETPC OLDPC PPARALAST T))(* ; 
                                                           "Mark the end of the preceding paragraph.")
                   (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAMAP))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                              "Mark the document as containing paragraph formatting ")
                   (SETTOBJ TEXTOBJ FORMATTEDP T))
              (\PieceDescriptorLOOKS                         (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ BYTELEN
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ THINFILE.PTYPE
                           PBYTESPERCHAR _ 1))
                   (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSMAP)   (* ; 
                                                             "Get its looks and character-pointers")
                   (add CURFILEBYTE# BYTELEN))
              (\PieceDescriptorOBJECT 
                                      (* ;; 
                             "BYTELEN is the number of bytes on the file, PLEN is always 1 character")

                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ 1
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ OBJECT.PTYPE))
                   (TEDIT.GET.OBJECT (GETTOBJ TEXTOBJ STREAMHINT)
                          PC TEXT CURFILEBYTE# BYTELEN)
                   (add CURFILEBYTE# BYTELEN)
                   (SELECTQ (BIN TEXT)
                       (0 
                          (* ;; 
          "Old format: no new looks;  steal them from the prior piece.  Which is really not correct.")

                          (FSETPC PC PLOOKS (OR (AND OLDPC (PLOOKS OLDPC))
                                                DEFAULTCHARLOOKS)))
                       (1 
                          (* ;; "Old format: explicit looks at this location")

                          (FSETPC PC PLOOKS (\TEDIT.GET.SINGLE.CHARLOOKS TEXT)))
                       (2                                    (* ; 
                        "Allow for indexed looks in situ?  Maybe this will wait for format version 4")
                          (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSMAP))
                       (SHOULDNT)))
              (PROGN (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Unknown-type piece skipped." T)
                     (SETFILEPTR TEXT (IPLUS (GETFILEPTR TEXT)
                                             (\SMALLPIN TEXT]
          (CL:WHEN PC                                        (* ; 
                                                       "If we created a piece, save it in the table.")
              (SETQ OLDPC (\INSERT-NSCLEARED-PIECE PC TEXTOBJ)))])

(\INSERT-NSCLEARED-PIECE
  [LAMBDA (PC TEXTOBJ)                                       (* ; "Edited 27-Jul-2023 08:18 by rmk")
                                                             (* ; "Edited 11-Oct-2022 15:11 by rmk")

    (* ;; "If this traps on an existing file, this code should be completed so that it splits the piece to skip the NS char shifting bytes.  The prefix piece is not PPARALAST, the following piece's PTYPE may depend on what the shift says:  (255 0) presumably means THIN, (255 255 0) means fat.")

    (CL:WHEN PC
        (CL:WHEN (MEMB (PTYPE PC)
                       FILE.PTYPES)
            (LET ((FILE (PCONTENTS PC))
                  NBYTES LOOKSFILEPTR)
                 (SETQ NBYTES (PBYTESPERCHAR PC))
                 (SETQ LOOKSFILEPTR (GETFILEPTR FILE))
                 (SETFILEPTR FILE (fetch (PIECE PFPOS) of PC))
                 (for I from 1 to NBYTES when (EQ NSCHARSETSHIFT (BIN FILE)) do (HELP))
                 (SETFILEPTR FILE LOOKSFILEPTR))))
    (\INSERTPIECE PC NIL TEXTOBJ)
    PC])

(TEDIT.GET.PASSWORD
  [LAMBDA (FILE LEN)                                         (* ; "Edited 20-Jun-2022 12:04 by rmk")

    (* ;; "Returns the TEDIT password of FILE, if it is a TEDIT formatted file")

    (LET (DESCPTR NPIECES PASSWORD)
         (CL:WITH-OPEN-FILE (STREAM FILE :DIRECTION :INPUT)
                (CL:UNLESS LEN
                    (SETQ LEN (GETEOFPTR STREAM)))
                (CL:WHEN (IGREATERP LEN 8)
                    (SETFILEPTR STREAM (IDIFFERENCE LEN 8))  (* ; 
                                                           "Move to start of FILEPTR to descriptions")
                    (SETQ DESCPTR (\DWIN STREAM))            (* ; 
                                                             "Read the file pos of the descriptions")
                    (SETQ NPIECES (\SMALLPIN STREAM))
                    [CAR (MEMB (\SMALLPIN STREAM)
                               '(31415 31416 31417 31418 31419])])
)



(* ;; "INCLUDEing a file")

(DEFINEQ

(TEDIT.INCLUDE
  [LAMBDA (TSTREAM FILE START END SAFE PLAINTEXT)            (* ; "Edited 23-Jul-2023 15:30 by rmk")
                                                             (* ; "Edited 16-Jul-2023 10:18 by rmk")
                                                             (* ; "Edited 21-Jun-2023 17:46 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; 
                                                        "Edited  1-Jun-93 11:31 by sybalsky:mv:envos")

    (* ;; "Obtain a file name, and include that file's contents at the place where the caret is.")

    (* ;; "This is a documented entry, but SAFE wasn't described there and I (RMK) added PLAINTEXT to collapse with TEDIT.INCLUDE.RAW.")

    (* ;; 
   "Returns the length of the input, if the insertion happened, NIL if there was no place to put it.")

    (* ;; "")

    (* ;; "This assumes that START and END are file positions (defaulting to 0 and length), not character numbers.")

    (* ;; "")

    (* ;; "If SAFE, the caller is taking responsibility for closing FILE when its contents are no longer needed (e.g. DOC-OBJECTS inclusions).  Otherwise, the contents are copied to a NODIRCORE that is owned by this TSTREAM, and then FILE is closed here if it wasn't previously open.  (This may not be accurate, unless FILE was actually an open stream and not a name?)")

    (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
           TSEL FSEL WASOPEN FTSTREAM NDCSTREAM (FROMFILE FILE))
          (CL:WHEN (GETTOBJ TEXTOBJ TXTREADONLY)
              (TEDIT.PROMPTPRINT "Text is read only--include aborted" T T)
              (RETURN))
          (SETQ TSEL (TEXTSEL TEXTOBJ))
          (CL:UNLESS (GETSEL TSEL SET)
              (TEDIT.PROMPTPRINT TEXTOBJ "Please select a destination for the included text" T)
              (RETURN NIL))

     (* ;; "We know where the new text is supposed to go. Where is it coming from?")

          (CL:UNLESS FROMFILE
              (SETQ FROMFILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ 
                                                         "Name of the file to include:  ")))
              (CL:UNLESS FROMFILE
                  (TEDIT.PROMPTPRINT TEXTOBJ "No file to include--aborted]" T)
                  (RETURN)))
          (CL:UNLESS (OR (STREAMP FROMFILE)
                         (INFILEP FROMFILE))                 (* ; "File not found")
              (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FROMFILE " not found--include aborted")
                     T T)
              (RETURN))

     (* ;; "")

     (* ;; "Now we have the FROMFILE, which may be a stream.")

          (CL:UNLESS START (SETQ START 0))
          (CL:UNLESS END
              (SETQ END (GETFILEINFO FILE 'LENGTH)))
          (CL:UNLESS (IGEQ END START)
              (TEDIT.PROMPTPRINT TEXTOBJ "Negative number of characters to include--aborted" T T)
              (RETURN))

     (* ;; "")

     (* ;; "If the caller says SAFE, he's guranteeing that the file will be there at least as long as we need it.  Otherwise, we take ownership of the information by copying it to a NODIRCORE. ")

          (CL:UNLESS SAFE
              [if (\GETSTREAM FROMFILE 'INPUT T)
                  then (SETQ WASOPEN T)
                else                                         (* ; 
                                                        "Wasn't open -- need to open it for input...")
                     (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT NIL '((TYPE TEXT]

              (* ;; "Create our holding file and copy the file-section into it.")

              (SETQ NDCSTREAM (OPENSTREAM '{NODIRCORE} 'OUTPUT 'NEW))

              (* ;; "Have to explicitly fill in 0 and EOFPTR, because if the file was open already, NILs would only copy from current fileptr to EOF.")

              (* ;; 
            "Use COPYBYTES for formatted files, otherwise allow natural EOL conversion to take place")

              (if (\TEDIT.FORMATTEDP1 FROMFILE)
                  then (COPYBYTES FROMFILE NDCSTREAM START END)
                else (COPYCHARS FROMFILE NDCSTREAM START END))
              (CL:UNLESS WASOPEN (CLOSEF FROMFILE))          (* ; 
                                                      "If the file didn't come to us open, close it.")
              (CLOSEF NDCSTREAM)
              (SETQ START 0)                                 (* ; 
                                                             "But we now want everything we copied")
              (SETQ END (GETFILEINFO NDCSTREAM 'LENGTH))
              (SETQ FROMFILE NDCSTREAM))

     (* ;; "")

     (* ;; "FROMFILE is now a safe file or stream, possibly already open.  If it wasn't open before, we want to make sure it gets closed if/when this event gets undone.")

          (CL:UNLESS (\GETSTREAM FROMFILE 'INPUT T)
              (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT))
              (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                THACTION _ :Closefile
                                                THOLDINFO _ FROMFILE)))
          [SETQ FTSTREAM (OPENTEXTSTREAM FROMFILE NIL NIL NIL `(FONT ,(\TEDIT.GET.INSERT.CHARLOOKS
                                                                       TEXTOBJ TSEL)
                                                                     PARALOOKS
                                                                     ,(GETTOBJ TEXTOBJ FMTSPEC)
                                                                     PLAINTEXT
                                                                     ,PLAINTEXT]

     (* ;; "")

     (* ;; "FTSTREAM is now a text stream for the source.")

          (SETQ FSEL (TEXTSEL (TEXTOBJ FTSTREAM)))           (* ; "Select START to END")
          (\TEDIT.UPDATE.SEL FSEL (ADD1 START)
                 (IDIFFERENCE END START)
                 NIL NIL T)                                  (* ; "ADD1 takes filepos to charno")
          (TEDIT.MOVE FSEL TSEL T)

     (* ;; "The exit conditions are not documented, but we set the fileptr to the end of the insertion and  return the length of the insertion.")

          (\TEXTSETFILEPTR (GETTOBJ TEXTOBJ STREAMHINT)
                 (SUB1 (GETSEL TSEL CHLIM)))
          (RETURN (GETSEL FSEL DCH])

(TEDIT.RAW.INCLUDE
  [LAMBDA (TSTREAM INFILE START END SAFE)                    (* ; "Edited  1-May-2023 08:46 by rmk")
                                                             (* ; 
                                                        "Edited 27-May-93 16:36 by sybalsky:mv:envos")

    (* ;; "Inserts the INFILE characters betwen START and END into TSTREAM,  treating INFILE as a plain text file.  This is a documented entry, motivated by now-silly speed considerations.  But it really amounts to just calling TEDIT.INCLUDE with a (new) PLAINTEXT flag and let the OPENTEXTSTREAM plaintext reader do its thing.  I (RMK) added the SAFE argument here, consistent with the (undocumented) SAFE argument of TEDIT.INCLUDE.")

    (TEDIT.INCLUDE TSTREAM INFILE START END SAFE T])
)



(* ;; "PUTting a file:")

(DEFINEQ

(TEDIT.PUT
  [LAMBDA (TSTREAM FILE FORCENEW UNFORMATTED?)               (* ; "Edited 27-Sep-2023 00:15 by rmk")
                                                             (* ; "Edited 24-Sep-2023 21:00 by rmk")
                                                             (* ; "Edited 22-Sep-2023 20:20 by rmk")
                                                             (* ; "Edited  9-Sep-2022 09:00 by rmk")
                                                             (* ; "Edited 21-Jun-99 19:02 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:04 by jds")

    (* ;; "If the guy was editing a file, make a new updated version;  else, ask for a file name")

    (* ;; "If FILE is specd, it's used;  else the user must give us one")

    (* ;; "Returns an open stream on the file you PUT to.")

    (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
           OFILE NEWPIECES PUTFN CACHE TEDIT.PUT.FINISHEDFORMS)
          (DECLARE (SPECVARS TEDIT.PUT.FINISHEDFORMS))
          [SETQ OFILE (OR FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ "File to PUT to:  "
                                                           (CL:UNLESS FORCENEW (\TEXTSTREAM.FILENAME
                                                                                TEXTOBJ]
          (CL:UNLESS OFILE                                   (* ; "No file to put to.")
              (RETURN))
          (SETQ PUTFN (GETTEXTPROP TEXTOBJ 'PUTFN))
          (CL:WHEN (AND PUTFN (EQ (APPLY* PUTFN TSTREAM (FULLNAME OFILE)
                                         'BEFORE)
                                  'DON'T))

              (* ;; "PUTFN BEFORE says it can't be saved, even though asked.  Let him know")

              (TEDIT.PROMPTPRINT "This document cannot be saved" T T)
              (RETURN))

     (* ;; "")

     (* ;; "Ready to save")

          (SETQ CACHE (GETTEXTPROP TEXTOBJ 'CACHE))
          (CL:UNLESS UNFORMATTED?
              (SETQ UNFORMATTED? (NULL (\TEDIT.FORMATTEDSTREAMP TEXTOBJ))))
          (RESETLST
              [RESETSAVE [SETQ OFILE (OPENSTREAM OFILE 'OUTPUT 'NEW
                                            `([TYPE ,(CL:IF UNFORMATTED?
                                                         'TEXT
                                                         'BINARY)]
                                              (LINELENGTH ,MAX.SMALLP]
                     '(AND RESETSTATE (DELFILE (CLOSEF? OLDVALUE]
              [RESETSAVE (\TEDIT.PUTRESET (CONS (THIS.PROCESS)
                                                'DON'T]
              (replace DESC of (FGETTOBJ TEXTOBJ THISLINE) with NIL)
              (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT "PUTting file " (fetch (STREAM FULLNAME)
                                                                    of OFILE)
                                                "...")
                     T)

              (* ;; "Here's where the pieces get written")

              (CL:WHEN (OR (IGREATERP (TEXTLEN TEXTOBJ)
                                  0)
                           (TEDIT.GETINPUT TEXTOBJ "Document is empty.  Save anyway? " "Yes"))

                  (* ;; "The text part of the file is always unformatted.  If UNFORMATTED? is passed in, the looks file gets made here and thrown away.  We fix up NEWPIECES for continued editing")

                  [SETQ NEWPIECES (TEDIT.PUT.PCTB TEXTOBJ OFILE (CL:WHEN UNFORMATTED?
                                                                    (OPENSTREAM '{NODIRCORE}
                                                                           'BOTH))])
              (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))
              (CLOSEF OFILE)                                 (* ; "Close OFILE  for output")
              (CL:UNLESS CACHE                               (* ; 
                                                             "Reopen it for input, if not caching ")

                  (* ;; "Declare as type text, even if it has been specified as a binary file--could simply be an unformatted stream.")

                  [SETQ OFILE (OPENSTREAM (fetch (STREAM FULLFILENAME) of OFILE)
                                     'INPUT NIL '((TYPE TEXT])
                                                             (* ; 
                             "changed TEMPORary for ns filing with caching.  may not work in general")
              (CLOSEF? (FGETTOBJ TEXTOBJ TXTFILE))           (* ; "Close the old text file")
              (FSETTOBJ TEXTOBJ TXTFILE OFILE))
          (\TEDIT.PUT.NEWPIECES OFILE TEXTOBJ NEWPIECES)
          (FSETTOBJ TEXTOBJ \DIRTY NIL)                      (* ; 
                                                           "We can QUIT now without losing anything.")
          (\TEDIT.UPDATE.TITLE TEXTOBJ OFILE)
          (\TEDIT.HISTORYADD TEXTOBJ
                 (create TEDITHISTORYEVENT
                        THACTION _ :Put
                        THCH# _ 0
                        THLEN _ 0
                        THFIRSTPIECE _ NIL))                 (* ; "Remember we did this.")
          (CL:WHEN PUTFN
              (APPLY* PUTFN TSTREAM (fetch (STREAM FULLNAME) of (FGETTOBJ TEXTOBJ TXTFILE))
                     'AFTER))                                (* ; 
                                                "Changed to not presume ofile is the txtfile anymore")
          (TEDIT.PROMPTPRINT TEXTOBJ "done")
          (RETURN OFILE])

(TEDIT.PUT.PCTB
  [LAMBDA (TEXTOBJ OFILE LOOKSFILE)                          (* ; "Edited 22-Sep-2023 20:18 by rmk")
                                                             (* ; "Edited 14-Sep-2023 10:15 by rmk")
                                                             (* ; "Edited  7-Sep-2023 23:43 by rmk")
                                                            (* ; "Edited 30-Apr-2021 14:46 by rmk:")
                                                             (* ; "Edited 19-May-99 21:58 by rmk:")
                                                             (* ; 
                                                        "Edited 27-May-93 16:00 by sybalsky:mv:envos")

    (* ;; "Put a representation of a piece table as plaintext on OFILE, preserving font changes and paragraph looks in the binary LOOKSFILE.  If LOOKSFILE is not provided, it is created here and then concatenated at the end of OFILE. Otherwise the two files from the caller are kept separate. ")

    (* ;; "")

    (* ;; "The characters and objects in the pieces are put out in the plaintext OFILE.  And the end of each sequence, when the byte positions are known, the hashed look-identifiers are put out to connect the looks back to the character sequences.")

    (* ;; "")

    (* ;; "If a sequence of pieces have equivalent piece properties (same character representation (fat, thin, utf-8 size) and looks) then the the characters of those pieces are concatenated and a single looks record is posted for the whole sequence.  For example, a sequence of THINFILE THINSTRING THINFILE pieces may be collapsed if they have the same font, new, etc. (but objects always have individual pieces).  Concatenation also stops at paralast sequences. ")

    (* ;; "WHAT ABOUT CACHE??")

    (* ;; "PLEN is the number of characters in the piece, but they occupy different numbers of bytes depending on thin, fat, utf-8...    Earlier files also had NSCHARSHIFT's to redundantly indicate that thins and fats are switching.  The GET.CHARLOOKS function skips those shift bytes if they happen to be there.")

    (* ;; "")

    (* ;; "NEWPIECES is the head of a  chain ofnew pieces that characterize the merged pieces on the file, to reestablish the correspondence between memory pieces and file pieces for continued editing. It is initialized to a throwaway dummy dummy")

    (for PC PREVPC CURBYTE# OLDBYTE# PFILE NEXTNEW (SEPARATELOOKS _ LOOKSFILE)
         (NEWPIECES _ (create PIECE))
         (PCCOUNT _ 0)
         (EDITSTENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE))
         (LOOKSHASH _ (HASHARRAY 50))
         (PARAHASH _ (HASHARRAY 50))
         (CACHE _ (GETTEXTPROP TEXTOBJ 'CACHE))
         (*READTABLE* _ *TEDIT-FILE-READTABLE*)
         (*PRINT-BASE* _ 10) inpieces (\FIRSTPIECE TEXTOBJ)
       first (CL:UNLESS LOOKSFILE
                 [SETQ LOOKSFILE (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((LINELENGTH ,MAX.SMALLP])
             (SETQ NEXTNEW NEWPIECES) 

             (* ;; "All the layout and looks information goes into the LOOKSFILE, OFILE is essentally plaintext.  Unless SEPARATEFORMAT, LOOKSFILE is appended to the end of OFILE.")

             (* ;; "It seems that PCCOUNT isn't incremented for the PARA and CHARLOOKS lists, just for the page frame and the actual document pieces.dd")

             (CL:WHEN (FGETTOBJ TEXTOBJ TXTPAGEFRAMES)
                 (TEDIT.PUT.PAGEFRAMES LOOKSFILE (FGETTOBJ TEXTOBJ TXTPAGEFRAMES))
                 (add PCCOUNT 1))
             (\TEDIT.FLUSH.UNUSED.LOOKS TEXTOBJ)
             (\TEDIT.UNIQUIFY.ALL TEXTOBJ)                   (* ; "We can now use EQ tests on looks")
             (\TEDIT.PUT.PARALOOKS.LIST LOOKSFILE PARAHASH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST))
             (\TEDIT.PUT.CHARLOOKS.LIST LOOKSFILE LOOKSHASH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)) 

             (* ;; "The hash-tables map char and parlooks to unique id numbers")

             (* ;; "")

             (* ;; " We're ready put the pieces on the output file.  We set its external format to XCCS for now--it is supposed to look like a plain-text file.")

             (STREAMPROP OFILE :EXTERNAL-FORMAT :XCCS)
             (SETQ CURBYTE# (ADD1 (GETFILEPTR OFILE)))       (* ; 
                                                   "Why ADD1 ? Always pointing at the %"next%" byte?")
             (SETQ OLDBYTE# CURBYTE#) unless (ZEROP (PLEN PC))
       do 
          (* ;; "If there are undescribed characters and PC can't be merged with PREVPC, then finish off PREVPC by writing its character looks.  And if PREVPC was the last of a pargraph, put out its PARALOOKS.  ")

          (CL:UNLESS (OR (IEQP CURBYTE# OLDBYTE#)
                         (TEDIT.PUT.PCTB.MERGEABLE PREVPC PC EDITSTENTATIVE))
              (\TEDIT.PUT.CHARLOOKS LOOKSFILE OLDBYTE# CURBYTE# PREVPC EDITSTENTATIVE LOOKSHASH)
              (add PCCOUNT 1)                                (* ; 
                                                            "We've decribed all preceding characters")
              (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW (create PIECE using PREVPC PFPOS _ (SUB1 
                                                                                             OLDBYTE#
                                                                                               )
                                                                          PBYTELEN _ (IDIFFERENCE
                                                                                      CURBYTE# 
                                                                                      OLDBYTE#)
                                                                          PREVPIECE _ NEXTNEW)))
              (SETQ OLDBYTE# CURBYTE#))
          (CL:WHEN (OR (NULL PREVPC)
                       (PPARALAST PREVPC))                   (* ; 
                                            "Last piece of a paragraph terminates with its paralooks")
              (\TEDIT.PUT.PARALOOKS LOOKSFILE PC PARAHASH)
              (add PCCOUNT 1))
          (SELECTC (PTYPE PC)
              (FILE.PTYPES                                   (* ; 
                                             "COPYCHARS automatically deals with external formats.  ")
                           (SETQ PFILE (PCONTENTS PC))
                           (CL:UNLESS (\GETSTREAM PFILE 'INPUT T)
                                                             (* ; "Make sure the input file is open.")
                               (SETQ PFILE (\TEDIT.REOPEN.STREAM TEXTOBJ PFILE)))
                           [COPYCHARS PFILE OFILE (PFPOS PC)
                                  (IPLUS (PFPOS PC)
                                         (ITIMES (PLEN PC)
                                                (PBYTESPERCHAR PC])
              (STRING.PTYPES                                 (* ; 
                                                             "\OUTCHAR deals with external format")
                             (for CH instring (PCONTENTS PC) do (\OUTCHAR OFILE CH)))
              (OBJECT.PTYPE                                  (* ; 
                  "It's an object, use its PUTFN. Byte positions don't matter for continued editing.")
                            (TEDIT.PUT.OBJECT PC OFILE LOOKSFILE CURBYTE#)
                            (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW
                                                       (create PIECE using PC PREVPIECE _ NEXTNEW)))
                            (add PCCOUNT 1)

                            (* ;; "0 indicates that nothing special needs to be done to recover the looks of this piece, its index will be written on the next iteration.  In earlier versions the value 1 indicated that the looks were not indexed and therefore had to be written explicitly here. This byte won't be needed in the next version of the format.")

                            (BOUT LOOKSFILE 0)

                            (* ;; "RMK: Upping OLDBYTE# suppresses the natural charlooks that ought to happen on the next iteration if we just go around the loop. But things get screwed up if we take this out, even though OLDBYTE#.  Possibly the extra 0 byte makes it think that the object is bigger than it is?  I really don't understand why it fails if this is left out.")

                            (SETQ OLDBYTE# (ADD1 (GETFILEPTR OFILE)))
                            (CL:WHEN NIL (\TEDIT.PUT.CHARLOOKS LOOKSFILE OLDBYTE# CURBYTE# PC 
                                                EDITSTENTATIVE LOOKSHASH)))
              (SHOULDNT "OTHER PTYPES")) 

          (* ;; "Record the file positions of the pieces in the file, so that pieces of the current text can be redirected to their filed-equivalents. We defer this until we know that every thing has settled down.  This records thenew position of every piece, even pieces that have been merged as suffixes of earlier ones, so  updating some old pieces may cause them to point into the middle of new file pieces.The updating code has to worry about NS charset shifts and buffer-crossing.")

          (SETQ CURBYTE# (ADD1 (GETFILEPTR OFILE)))
          (SETQ PREVPC PC) finally (CL:UNLESS (IEQP OLDBYTE# CURBYTE#)
                                                             (* ; 
                                                         "The charlooks for the final piece sequence")
                                       (\TEDIT.PUT.CHARLOOKS LOOKSFILE OLDBYTE# CURBYTE# PREVPC 
                                              EDITSTENTATIVE LOOKSHASH)
                                       (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW
                                                                  (create PIECE
                                                                     using PREVPC PFPOS _
                                                                           (SUB1 OLDBYTE#)
                                                                           PBYTELEN _
                                                                           (IDIFFERENCE CURBYTE# 
                                                                                  OLDBYTE#)
                                                                           PREVPIECE _ NEXTNEW)))
                                       (add PCCOUNT 1)) 

                                 (* ;; 
             "Do any user-specific cleanup? Never documented or implemented, assume it's a property?")

                                 (for FORM in (GETTEXTPROP TEXTOBJ 'TEDIT.PUT.FINISHEDFORMS)
                                    do (EVAL FORM)) 

                                 (* ;; "Finalize LOOKSFILE")

                                 (\DWOUT LOOKSFILE (GETFILEPTR OFILE)) 
                                                             (* ; 
                                                         "The end of the plain-text part of the file")
                                 (\SMALLPOUT LOOKSFILE PCCOUNT) 
                                                             (* ; "Number of pieces")
                                 (\SMALLPOUT LOOKSFILE 31418) 
                                                             (* ; 
                                                          "Password for format-file version 3: 31418")
                                 (CL:UNLESS SEPARATELOOKS

                                     (* ;; "Append LOOKSFILE to the end of OFILE unless SEPARATELOOKS. This is undocumented but used internally by COERECETEXTOBJ. ")

                                     (COPYBYTES LOOKSFILE OFILE 0 (GETEOFPTR LOOKSFILE)))
                                 (CLOSEF LOOKSFILE) 

                                 (* ;; 
 "Throw away the dummy head of the new piece chain. The newpieces must be made safe, then installed.")

                                 (RETURN (NEXTPIECE NEWPIECES])

(TEDIT.PUT.PCTB.MERGEABLE
  [LAMBDA (PREVPC PC EDITSTENTATIVE)                         (* ; "Edited 22-Sep-2023 10:12 by rmk")
                                                             (* ; "Edited  6-Sep-2023 00:03 by rmk")
                                                             (* ; "Edited 24-Aug-2023 11:03 by rmk")

    (* ;; "True if PREVPC and PC have enough properties in common so they can be concatenated together into a single new piece on a file.  The PPARALOOKS test allows for the possibility that different pieces in a paragraph might have different formatting (e.g. tab stops)--but that will mess up assumptions that the paragraph menu and maybe other things depend on.  PBYTESPERCHAR is a good first filter.")

    (AND (EQ (PBYTESPERCHAR PREVPC)
             (PBYTESPERCHAR PC))
         (SELECTC (PTYPE PREVPC)
             ((LIST THINFILE.PTYPE THINSTRING.PTYPE) 
                  (MEMB (PTYPE PC)
                        (CONSTANT (LIST THINFILE.PTYPE THINSTRING.PTYPE))))
             ((LIST FATFILE2.PTYPE FATSTRING.PTYPE) 
                  (MEMB (PTYPE PC)
                        (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE))))
             (OBJECT.PTYPE NIL)
             NIL)
         (EQ (PLOOKS PREVPC)
             (PLOOKS PC))
         (EQ (PPARALOOKS PREVPC)
             (PPARALOOKS PC))
         (NOT (PPARALAST PREVPC))
         (OR (NOT EDITSTENTATIVE)
             (EQ (PNEW PREVPC)
                 (PNEW PC])

(\TEDIT.PUT.NEWPIECES
  [LAMBDA (OFILE TEXTOBJ NEWPIECES)                          (* ; "Edited  8-Sep-2023 16:32 by rmk")

    (* ;; "This makes the pieces and BTREE of TEXTOBJ consistent with the NEWPIECES chain and the new OFILE.  The character numbers of old and new pieces correspond, so editing should continue without updating panes, lines, or selections (which are all based on character numbers, not particular pieces).  This puts OFILE as the PFILE of each new piece, insures safety (which fixes the ptypes etc), and then installs NEWPIECES in TEXTOBJ, replacing the BTREE and pieces already there.")

    (* ;; "The \SETFILEPTR translates TSTREAM's buffer parameters to the new file. ")

    (LET ((TSTREAM (GETTOBJ TEXTOBJ STREAMHINT))
          FILEPTR)
         (SETQ FILEPTR (\TEXTGETFILEPTR TSTREAM))
         (for PC inpieces NEWPIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
            do (FSETPC PC PCONTENTS OFILE))                  (* ; "Non-object pieces are on OFILE")
         (SETQ NEWPIECES (\TEDIT.MAKE.SAFE.PIECES NEWPIECES))

         (* ;; "Here, finally, we toss the out-of-date pieces to install the new ones. For complete safety, the rest should be uninterruptable (although the file has just been saved, so nothing would really be lost)")

         (\MAKEPCTB TEXTOBJ)
         (\INSERTPIECES NEWPIECES NIL TEXTOBJ)               (* ; 
                                                             "Build the tree, then fix the stream")
         (\TEXTSETFILEPTR TSTREAM FILEPTR])

(\TEDIT.PUTRESET
  [LAMBDA (PROC&VALUE)                                       (* jds "15-May-85 16:38")
    (CONS (CAR PROC&VALUE)
          (PROCESSPROP (CAR PROC&VALUE)
                 'BEFOREEXIT
                 (CDR PROC&VALUE])

(\ARBOUT
  [LAMBDA (STREAM ITEM)                                      (* ; "Edited  7-Sep-2023 09:06 by rmk")
                                                             (* ; "Edited 20-Apr-88 19:55 by jds")

    (* ;; "Write an arbitrary MKSTRING-able thing in length-contents form.  SIZE is in characters, not bytes, which is OK because \STRINGIN uses READCCODE.")

    (LET [(SIZE (AND ITEM (NCHARS ITEM T *TEDIT-FILE-READTABLE*]
         (\SMALLPOUT STREAM (OR SIZE 0))
         (OR (NOT ITEM)
             (ZEROP SIZE)
             (PRIN2 ITEM STREAM *TEDIT-FILE-READTABLE*))
         NIL])

(\ATMOUT
  [LAMBDA (STREAM ATOM)                                      (* jds "30-Jan-85 14:46")
                                                             (* Write an atom's characters in 
                                                             length-contents form.)
    (\SMALLPOUT STREAM (COND
                          (ATOM (NCHARS ATOM))
                          (T 0)))
    (OR (NOT ATOM)
        (ZEROP (NCHARS ATOM))
        (for CH inatom ATOM do (\BOUT STREAM CH])

(\DWOUT
  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))
    (\BOUT FILE (LOGAND 255 NUMBER])

(\STRINGOUT
  [LAMBDA (STREAM STRING LEN)                                (* jds " 1-May-84 11:58")

         (* Write a string on a file in length-contents form;
         one word for the length, and one byte per character contained.)

    (SETQ LEN (OR LEN (NCHARS STRING)))
    (\SMALLPOUT STREAM LEN)
    (OR (ZEROP LEN)
        (for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH])
)
(DEFINEQ

(\TEDIT.GET.CHARLOOKS.LIST
  [LAMBDA (FILE)                                             (* jds "28-Jan-85 17:50")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\SMALLPIN FILE) collect (\TEDIT.GET.SINGLE.CHARLOOKS FILE])

(\TEDIT.GET.SINGLE.CHARLOOKS
  [LAMBDA (FILE)                                             (* ; "Edited 24-Aug-2023 15:05 by rmk")
                                                           (* ; "Edited 20-Feb-2022 12:42 by larry")
                                                             (* ; "Edited 30-May-91 20:25 by jds")

    (* ;; "Read one CHARLOOKS from FILE.  This gets and then sets the file pointer, based on the stored length.  But that won't work if the file is not random access.  Maybe that's not necessary?")

    (PROG* ((LOOKS (create CHARLOOKS))
            (FILEPOS (GETFILEPTR FILE))
            (LOOKSLEN (\SMALLPIN FILE))
            FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR)
           (SETQ NAME (\ARBIN FILE))                         (* ; "The font name")
           (SETQ SIZE (\SMALLPIN FILE))                      (* ; "Size of the type, in points")
           (SETQ SUPER (\SMALLPIN FILE))                     (* ; "Superscripting distance")
           (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                          0))
           (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE))
           (SETQ PROPS (\SMALLPIN FILE))
           (with CHARLOOKS LOOKS [SETQ CLLEADER (NOT (ZEROP (LOGAND 2048 PROPS]
                 [SETQ CLINVERTED (NOT (ZEROP (LOGAND 1024 PROPS]
                 [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                 [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                 [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                 [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                 [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                 [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                 [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                 [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                 [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                 [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                 (SETQ CLSIZE SIZE)
                 (SETQ CLOFFSET SUPER))
           [replace (CHARLOOKS CLFONT) of LOOKS with (COND
                                                        ((LISTP NAME)
                                                             (* ; 
                                                             "This was a font class.  Restore it.")
                                                         (FONTCLASS (pop NAME)
                                                                NAME))
                                                        ((AND NAME (NOT (ZEROP SIZE)))
                                                         (replace (CHARLOOKS CLNAME) of LOOKS
                                                            with NAME)
                                                         (FONTCREATE NAME SIZE
                                                                (COND
                                                                   ((AND (fetch (CHARLOOKS CLBOLD)
                                                                            of LOOKS)
                                                                         (fetch (CHARLOOKS CLITAL)
                                                                            of LOOKS))
                                                                    'BOLDITALIC)
                                                                   ((fetch (CHARLOOKS CLBOLD)
                                                                       of LOOKS)
                                                                    'BOLD)
                                                                   ((fetch (CHARLOOKS CLITAL)
                                                                       of LOOKS)
                                                                    'ITALIC))
                                                                NIL NIL T NIL]
           (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN))
           (RETURN LOOKS])

(\TEDIT.PUT.CHARLOOKS.LIST
  [LAMBDA (LOOKSFILE LOOKSHASH LOOKSLIST LOOKSHASH)          (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:08 by rmk")
                                                             (* jds " 5-Mar-85 15:58")
                                                             (* ; 
                                                   "Write the list of CHARLOOKSs into the font file.")

    (* ;; "Returns a hasharray that will map from a given CHARLOOKS to its index in the list.  Those position numbers are then written in the individual piece descriptions, and are used to reconstruct the piece looks when the file is read back in.  These descriptions are written in a 0-character pseudo-piece")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
                                         "No characters, marked as containing the list of CHARLOOKSs")
    (\SMALLPOUT LOOKSFILE \PieceDescriptorCHARLOOKSLIST)
    (\SMALLPOUT LOOKSFILE (FLENGTH LOOKSLIST))               (* ; "Number of charlooks to follow")
    (for I from 1 as LOOKS in LOOKSLIST do 
                                           (* ;; 
                                        "Write each charlooks, in the order they appear in the list.")

                                           (\TEDIT.PUT.SINGLE.CHARLOOKS LOOKSFILE LOOKS)
                                           (PUTHASH LOOKS I LOOKSHASH])

(\TEDIT.PUT.SINGLE.CHARLOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 26-Aug-2023 11:29 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:17 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")

    (* ;; "Put out a single CHARLOOKS description.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          (FONT (fetch (CHARLOOKS CLFONT) of LOOKS))
          LEN)
         (\SMALLPOUT FONTFILE 0)                             (* ; 
                                                         "Reserve space for the length of this looks")
         [COND
            ((type? FONTCLASS FONT)                          (* ; 
                                         "For font classes, we need to save a list of device-FD sets")
             (\ARBOUT FONTFILE (FONTCLASSUNPARSE FONT)))
            (T                                               (* ; 
                                                            "For FONTDESCRIPTORs, do it the easy way")
               (\ATMOUT FONTFILE (FONTPROP FONT 'FAMILY]     (* ; "The font family")
         (\SMALLPOUT FONTFILE (OR (FONTPROP FONT 'SIZE)
                                  0))                        (* ; "Size of the type, in points")
         (\SMALLPOUT FONTFILE (OR (fetch (CHARLOOKS CLOFFSET) of LOOKS)
                                  0))                        (* ; "Super/subscripting distance")
         (COND
            ([AND (fetch (CHARLOOKS CLSTYLE) of LOOKS)
                  (NOT (ZEROP (fetch (CHARLOOKS CLSTYLE) of LOOKS]
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLSTYLE) of LOOKS)))
            (T (\SMALLPOUT FONTFILE 0)))
         (COND
            ((fetch (CHARLOOKS CLUSERINFO) of LOOKS)
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLUSERINFO) of LOOKS)))
            (T (\SMALLPOUT FONTFILE 0)))
         (\SMALLPOUT FONTFILE (LOGOR (CL:IF (fetch (CHARLOOKS CLLEADER) of LOOKS)
                                         2048
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLINVERTED) of LOOKS)
                                         1024
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                         512
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLITAL) of LOOKS)
                                         256
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLULINE) of LOOKS)
                                         128
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLOLINE) of LOOKS)
                                         64
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLSTRIKE) of LOOKS)
                                         32
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLSMALLCAP) of LOOKS)
                                         16
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLPROTECTED) of LOOKS)
                                         8
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLINVISIBLE) of LOOKS)
                                         4
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLSELHERE) of LOOKS)
                                         2
                                         0)
                                     (CL:IF (fetch (CHARLOOKS CLCANCOPY) of LOOKS)
                                         1
                                         0)))

         (* ;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Go write the length field")
         (\SMALLPOUT FONTFILE LEN)                           (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.CHARLOOKS
  [LAMBDA (LOOKSFILE OLDBYTE# CURBYTE# PREVPC EDITSTENTATIVE LOOKSHARRAY)
                                                             (* ; "Edited 26-Aug-2023 19:53 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:40 by rmk")
                                                             (* ; "Edited 23-Aug-2023 22:27 by rmk")
                                                             (* ; "Edited 24-Jul-2023 17:21 by rmk")
                                                             (* ; "Edited  8-Sep-2022 22:54 by rmk")
                                                             (* ; "Edited 30-May-91 21:45 by jds")

    (* ;; "Put a description of PREVPC's charlooks into LOOKSFILE.  The looks apply to bytes OLDBYTE# thru CURBYTE#-1")

    (\DWOUT LOOKSFILE (IDIFFERENCE CURBYTE# OLDBYTE#))       (* ; "The length of this run of looks")
    (\SMALLPOUT LOOKSFILE \PieceDescriptorLOOKS)             (* ; 
                                                             "Mark this as setting the piece's looks")

    (* ;; "Flag for newness and fatness")

    (\BOUT LOOKSFILE (LOGOR (CL:IF (AND EDITSTENTATIVE PREVPC (PNEW PREVPC))
                                1
                                0)
                            (CL:IF (AND PREVPC (EQ FATFILE2.PTYPE (PTYPE PREVPC)))
                                2
                                0)))                         (* ; "The index into the list of fonts")
    (\SMALLPOUT LOOKSFILE (GETHASH (PLOOKS PREVPC)
                                 LOOKSHARRAY])

(\TEDIT.GET.CHARLOOKS
  [LAMBDA (PC FILE LOOKSARRAY)                               (* ; "Edited  3-Sep-2023 23:31 by rmk")
                                                             (* ; "Edited 28-Aug-2023 22:19 by rmk")
                                                             (* ; "Edited 26-Aug-2023 23:22 by rmk")
                                                             (* ; "Edited 30-May-91 21:43 by jds")

    (* ;; "Set the PLOOKS for the current piece, PC, according to what the file says")

    (* ;; "The incoming PLEN field of this piece is the number of FILE BYTES taken to describe the piece.  There may be a flag to indicate whether this is a fat or thin XCCS piece, here we only record the fatness by changing the PBYTESPERCHAR.  Stripping possible charset shifts for XCCS fat pieces is done by \TEDIT.MAKE.SAFE.PIECES--those shift might not appear at the front of pieces that continue the encoding from a previous piece.")

    (* ;; "We also ")

    (LET ((FLAGS (BIN FILE))
          BYTE LOOKSFILEPOS)
         (FSETPC PC PLOOKS (ELT LOOKSARRAY (\SMALLPIN FILE)))
         (SETQ LOOKSFILEPOS (GETFILEPTR FILE))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 1))
                (FSETPC PC PNEW T))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 2))                 (* ; 
                                         "XCSS FAT. It may be a continuation of a previous fat piece")
             (FSETPC PC PLEN (IQUOTIENT (FGETPC PC PLEN)
                                    2))
             (FSETPC PC PTYPE FATFILE2.PTYPE)
             (FSETPC PC PBYTESPERCHAR 2))])
)
(DEFINEQ

(\TEDIT.GET.PARALOOKS.LIST
  [LAMBDA (FILE TEXTOBJ)                                     (* jds "13-Jun-85 11:14")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\SMALLPIN FILE) collect (\TEDIT.GET.SINGLE.PARALOOKS FILE TEXTOBJ])

(\TEDIT.GET.SINGLE.PARALOOKS
  [LAMBDA (FILE TEXTOBJ)                                     (* ; "Edited  3-Mar-2023 23:16 by rmk")
                                                             (* ; "Edited 11-Oct-2022 15:23 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:31 by sybalskY:MV:ENVOS")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           (FILEPOS (GETFILEPTR FILE))
           (LOOKSLEN (\SMALLPIN FILE))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC TABTYPE QUAD)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (SETQ QUAD (BIN FILE))
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 1))               (* ; "There are tabs to read")
              (SETQ DEFTAB (\SMALLPIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\SMALLPIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (SETQ TABTYPE
                                                                               (BIN FILE))
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (4 'DOTTEDLEFT)
                                                                         (5 'DOTTEDRIGHT)
                                                                         (6 'DOTTEDCENTERED)
                                                                         (7 'DOTTEDDECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 2))               (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\SMALLPIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTHEADINGKEEP) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTKEEP) of LOOKS with (\ARBIN FILE))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTBASETOBASE) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTREVISED) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCOLUMN) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))))
          (CL:WHEN (ILESSP (GETFILEPTR FILE)
                          (IPLUS FILEPOS LOOKSLEN))          (* ; 
                               "There is more PARALOOKS info in this piece -- we probably lost data.")
              (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Newer file version; you lost PARALOOKS info" T)
              (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN)))
          (RETURN LOOKS])

(\TEDIT.PUT.PARALOOKS.LIST
  [LAMBDA (LOOKSFILE PARAHASH PARALOOKS)                     (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:25 by rmk")
                                                             (* ; "Edited  1-Sep-87 20:34 by jds")

    (* ;; "Write out the looks in a no-characters pseudo-piece, producing a hashtable of their arbitrary indexes for future reference.")

    (\DWOUT LOOKSFILE 0)
    (\SMALLPOUT LOOKSFILE \PieceDescriptorPARALOOKSLIST)
    (\SMALLPOUT LOOKSFILE (FLENGTH PARALOOKS))
    (for I from 1 as PL in PARALOOKS do (\TEDIT.PUT.SINGLE.PARALOOKS LOOKSFILE PL)
                                        (PUTHASH PL I PARAHASH])

(\TEDIT.PUT.SINGLE.PARALOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 16-Aug-2023 22:11 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:25 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:30 by sybalskY:MV:ENVOS")

    (* ;; "Put a description of LOOKS into FILE.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          DEFTAB TABSPECS LEN)
         (\SMALLPOUT FONTFILE 0)                             (* ; 
                                                             "Reserve space to store the look length")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC 1STLEFTMAR) of LOOKS))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC LEFTMAR) of LOOKS))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC RIGHTMAR) of LOOKS))
                                                             (* ; "Right margin for the paragraph")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC LEADBEFORE) of LOOKS))
                                                             (* ; "Leading before the paragraph")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC LEADAFTER) of LOOKS))
                                                             (* ; "Lead after the paragraph")
         (\SMALLPOUT FONTFILE (fetch (FMTSPEC LINELEAD) of LOOKS))
                                                             (* ; "inter-line leading")
         (SETQ DEFTAB (CAR (fetch (FMTSPEC TABSPEC) of LOOKS)))
         (SETQ TABSPECS (CDR (fetch (FMTSPEC TABSPEC) of LOOKS)))

         (* ;; "Indicate whether there are tab specs  or a default tab setting to save")

         (\BOUT FONTFILE (CL:IF (OR DEFTAB TABSPECS)
                             3
                             2))
         (\BOUT FONTFILE (SELECTQ (fetch (FMTSPEC QUAD) of LOOKS)
                             (LEFT 1)
                             (RIGHT 2)
                             ((CENTER CENTERED) 
                                  3)
                             ((JUST JUSTIFIED) 
                                  4)
                             (SHOULDNT)))
         (CL:WHEN (OR TABSPECS DEFTAB)                       (* ; "There are tab specs to save.")
             (\SMALLPOUT FONTFILE (OR DEFTAB 0))
             (CL:WHEN (IGREATERP (LENGTH TABSPECS)
                             255)
                    (SHOULDNT "Paragraph has more than 255 TABs set--can't be saved."))
             (\BOUT FONTFILE (LENGTH TABSPECS))
             [for TAB in TABSPECS do (\SMALLPOUT FONTFILE (fetch TABX of TAB)) 
                                                             (* ; "Setting and tab type.")
                                     (\BOUT FONTFILE (SELECTQ (fetch TABKIND of TAB)
                                                         (LEFT 0)
                                                         (RIGHT 1)
                                                         (CENTERED 2)
                                                         (DECIMAL 3)
                                                         (DOTTEDLEFT 4)
                                                         (DOTTEDRIGHT 5)
                                                         (DOTTEDCENTERED 
                                                              6)
                                                         (DOTTEDDECIMAL 7)
                                                         (SHOULDNT])
         (\SMALLPOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALX) of LOOKS)
                                  0))
         (\SMALLPOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALY) of LOOKS)
                                  0))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTUSERINFO) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARATYPE) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARASUBTYPE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTSTYLE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEAFTER) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTHEADINGKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTBASETOBASE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTREVISED) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCOLUMN) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))

(* ;;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Write the length field")
         (\SMALLPOUT FONTFILE LEN)                           (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.PARALOOKS
  [LAMBDA (LOOKSFILE PC PARAHASH)                            (* ; "Edited 25-Aug-2023 11:41 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:28 by rmk")
                                                             (* ; "Edited 30-May-91 21:44 by jds")

    (* ;; 
  "Put the identifier of PC's paralooks into LOOKSFILE.  This applies to characters CH1 thru CHLIM-1")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
             "Place holder for number of characters in the piece -- really taken from the charlooks.")
    (\SMALLPOUT LOOKSFILE \PieceDescriptorPARA)              (* ; 
                                                           "Identify this as a paragraph looks piece")
    (\SMALLPOUT LOOKSFILE (OR (FIXP PC)
                              (GETHASH (PPARALOOKS PC)
                                     PARAHASH])

(\TEDIT.GET.PARALOOKS
  [LAMBDA (FILE PARAHASH)                                    (* ; "Edited 18-Dec-88 17:47 by jds")

    (* ;; "Read a paragraph format spec from the FILE, and return it for later use.")

    (* ;; "Paragraph format # of 0 indicates an end-of-file dummy, used to preserve the paralooks of EOF para break.")

    (LET ((LOOKS# (\SMALLPIN FILE)))
         (COND
            ((ZEROP LOOKS#)
             NIL)
            (T (ELT PARAHASH LOOKS#])
)
(DEFINEQ

(TEDIT.GET.OBJECT
  [LAMBDA (TSTREAM PIECE FILE CURFILEBYTE# BYTELEN)          (* ; "Edited 25-Aug-2023 23:07 by rmk")
                                                             (* ; "Edited 12-Oct-2022 14:10 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:50 by mitani")

    (* ;; "Get an object from FILE")

    (* ;; "TSTREAM =TEXTOBJ are used for the error message and (possibly for default charlooks)")

    (* ;; "CURFILEBYTE# = fileptr within the text section of the file where the object's text starts. On entry the file is positioned just before the object's GETFN in the looks section of the file. On exit, the fileptr points just after the GETFN in the looks section, after having been detoured to the text section for the getfn to read the object's data.")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM))
          FILEPTRSAVE GETFN OBJ)

         (* ;; "rrb 10-AUG-87 --- calculate the length of the image object's data.  This assumes that the file is currently pointed at the end of the data which is where the GETFN is written {I think}.")

         (* ;; "RMK:  Originally, BYTELEN was calculated here as (DIFFERENCE (GETFILEPTR FILE) CURFILEBYTE#).  But this is garbage: (GETFILEPTR FILE) is in the looks section, CURFILEBYTE# is in the text section. The caller knows the true value, now passes it in. ")

         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURFILEBYTE#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN NIL BYTELEN))
         (CL:WHEN (IMAGEOBJPROP OBJ 'UNKNOWNGETFN)           (* ; 
      "If the object has an unknown getfn property, then it's an encapsulated object.  Warn the user")
             (TEDIT.PROMPTPRINT TSTREAM "WARNING: Document contains unknown image objects." T))
         (SETFILEPTR FILE FILEPTRSAVE)
         (SETPC PIECE PCONTENTS OBJ)
         [FSETPC PIECE PLOOKS (COND
                                 ((PREVPIECE PIECE)
                                  (PLOOKS (PREVPIECE PIECE)))
                                 (T (OR (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS)
                                        (\TEDIT.UNIQUIFY.CHARLOOKS (CHARLOOKS.FROM.FONT DEFAULTFONT)
                                               TEXTOBJ]
         (FSETPC PIECE PTYPE (CL:IF (IMAGEOBJPROP OBJ 'SUBSTREAM)
                                 SUBSTREAM.PTYPE
                                 OBJECT.PTYPE))
         OBJ])

(TEDIT.PUT.OBJECT
  [LAMBDA (PIECE OFILE LOOKSFILE CURFILEBYTE#)               (* ; "Edited 26-Aug-2023 15:13 by rmk")
                                                             (* ; "Edited 17-Jul-2023 16:39 by rmk")
                                                             (* ; "Edited  6-Aug-2022 10:02 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:49 by mitani")

    (* ;; "Given a piece which describes an object, put the object out there.")

    (LET ((OBJECT (fetch (PIECE PCONTENTS) of PIECE))
          (ORIGFILEPTR (GETFILEPTR LOOKSFILE))
          BYTELEN)
         (\DWOUT LOOKSFILE 0)                                (* ; 
                                            "Placeholder for byte-length of the object's description")
         (\SMALLPOUT LOOKSFILE \PieceDescriptorOBJECT)       (* ; 
                                                             "Mark this as setting the piece's looks")
         (\ATMOUT LOOKSFILE (IMAGEOBJPROP OBJECT 'GETFN))    (* ; 
                                                          "The FN to apply to reconstruct the object")
         (APPLY* (IMAGEOBJPROP OBJECT 'PUTFN)
                OBJECT OFILE)
         (SETQ BYTELEN (ADD1 (IDIFFERENCE (GETEOFPTR OFILE)
                                    CURFILEBYTE#)))
         (SETFILEPTR LOOKSFILE ORIGFILEPTR)                  (* ; 
                          "Now go back and fill in the length of the text description of the object.")
         (\DWOUT LOOKSFILE BYTELEN)
         (SETFILEPTR LOOKSFILE -1)                           (* ; 
                                                             "Move back to the end of the looks file")
         (CL:WHEN (RANDACCESSP OFILE)                        (* ; "And the end of OFILE")
             (SETFILEPTR OFILE -1))
         BYTELEN])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
)
(DEFINEQ

(TEDITFROMLISPSOURCE
  [LAMBDA (SOURCEFILE TSTREAM PROPS)                         (* ; "Edited 22-Sep-2023 09:07 by rmk")

    (* ;; "This is called because OPENTEXTSTREAM recognized that SOURCESTREAM is a LISPSOURCEP foreign-format file.  TSTREAM may have a partially instantiated attached window with region and prompt, etc., but it does not have the properties of a text or process.")

    (* ;; "We open an empty text stream, SEE SOURCEFILE to that stream, and return it.  ")

    (* ;; 
    "TSTREAM and its window are available to provide default looks and region for the empty stream")

    (LET* ((TEXTOBJ (TEXTOBJ TSTREAM))
           (TWINDOW (CAR (FGETTOBJ TEXTOBJ \WINDOW)))
           (TEMPTS (OPENTEXTSTREAM)))

          (* ;; "An empty window for TSTREAM may already be up on the screen.  Since this conversion can take awhile, we tell the user what's going on")

          (TEDIT.PROMPTPRINT TSTREAM (CONCAT "Fetching " (FULLNAME SOURCEFILE)
                                            " ...")
                 T)
          (APPLY* (FUNCTION SEE)
                 SOURCEFILE TEMPTS)
          (TEDIT.PROMPTCLEAR TSTREAM)
          TEMPTS])
)

(ADDTOVAR TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE))

(RPAQ? *TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))



(* ;; "For converting old incoming format.  Cutover 5/22/85 to permit looks changes in the future.")

(DEFINEQ

(TEDIT.GET.PCTB2
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited 25-Aug-2023 22:51 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:08 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:39 by rmk")
                                                             (* ; "Edited 19-Apr-2023 07:53 by rmk")
                                                             (* ; "Edited  4-Oct-2022 16:58 by rmk")
                                                             (* ; "Edited  8-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited  5-Sep-2022 21:33 by rmk")
                                                             (* ; "Edited  4-May-93 16:27 by jds")

    (* ;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (* ;; "START = 1st char of file to read from, if specified")

    (* ;; "END = use this as eofptr of file.  For use in reading files within files.")

    (LET (PIECEINFOCH# (CURFILECH# (OR START 0))
                LOOKSHASH PARAHASH)
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTCHARLOOKS _ (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                              of TEXTOBJ))
               (OLDPARALOOKS _ (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ)) for I from 1 to PCCOUNT
            do (SETQ PC NIL)                                 (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
               (SETQ PCLEN (\DWIN TEXT))
               (SETQ TYPECODE (\SMALLPIN TEXT))              (* ; "What kind of piece is it?")
               (SELECTC TYPECODE
                   (\PieceDescriptorPAGEFRAME                (* ; 
                                                             "This is page layout info for the file")
                        (CL:WHEN TEXTOBJ
                            (replace (TEXTOBJ TXTPAGEFRAMES) of TEXTOBJ with (TEDIT.PARSE.PAGEFRAMES
                                                                              (READ TEXT)))))
                   (\PieceDescriptorCHARLOOKSLIST            (* ; 
                                              "This is the list of CHARLOOKSs used in this document.")
                        (replace (TEXTOBJ TXTCHARLOOKSLIST) of TEXTOBJ with (
                                                                           \TEDIT.GET.CHARLOOKS.LIST2
                                                                             TEXT))
                                                             (* ; 
                                                      "Read the list of looks used in this document.")
                        [SETQ LOOKSHASH (ARRAY (FLENGTH (fetch (TEXTOBJ TXTCHARLOOKSLIST)
                                                           of TEXTOBJ]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                        (for I from 1 as LOOKS in (fetch (TEXTOBJ TXTCHARLOOKSLIST) of TEXTOBJ)
                           do (SETA LOOKSHASH I LOOKS))
                        (add I -1))
                   (\PieceDescriptorPARALOOKSLIST            (* ; 
                                              "This is the list of PARALOOKSs used in this document.")
                        (replace (TEXTOBJ TXTPARALOOKSLIST) of TEXTOBJ with (
                                                                           \TEDIT.GET.PARALOOKS.LIST2
                                                                             TEXT))
                                                             (* ; 
                                                      "Read the list of looks used in this document.")
                        [SETQ PARAHASH (ARRAY (FLENGTH (fetch (TEXTOBJ TXTPARALOOKSLIST) of TEXTOBJ]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                        (for I from 1 as LOOKS in (fetch (TEXTOBJ TXTPARALOOKSLIST) of TEXTOBJ)
                           do (SETA PARAHASH I LOOKS))
                        (add I -1))
                   (\PieceDescriptorPARA                     (* ; 
                                                             "Reading a new set of paragraph looks.")
                        (CL:WHEN OLDPC
                            (replace (PIECE PPARALAST) of OLDPC with T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                        (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAHASH))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                        (CL:WHEN TEXTOBJ                     (* ; 
                                          "Mark the document as containing paragraph formatting info")
                            (replace (TEXTOBJ FORMATTEDP) of TEXTOBJ with T)))
                   (\PieceDescriptorLOOKS                    (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ PCLEN
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE))     (* ; "Build the new piece")
                        (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSHASH)
                                                             (* ; 
                                                             "Read the character looks for this guy.")
                        (COND
                           [OLDPC                            (* ; 
                                              "If there's a prior piece, hook this one on the chain.")
                                  (COND
                                     ([AND (EQ FATFILE2.PTYPE (PTYPE PC))
                                           (NOT (EQ FATFILE2.PTYPE (PTYPE OLDPC]
                                                             (* ; 
                                      "Switching from not-fat to fat.  Add 3 bytes for the 255-255-0")
                                      (add (fetch (PIECE PFPOS) of PC)
                                           3)
                                      (add CURFILECH# -3))
                                     ([AND (EQ FATFILE2.PTYPE (PTYPE OLDPC))
                                           (NOT (EQ FATFILE2.PTYPE (PTYPE PC]
                                                             (* ; 
                                          "Switching from fat to not-fat.  Add 3 bytes for the 255-0")
                                      (add (fetch (PIECE PFPOS) of PC)
                                           2]
                           ((EQ FATFILE2.PTYPE (PTYPE PC))   (* ; 
                                      "Switching from not-fat to fat.  Add 3 bytes for the 255-255-0")
                            (add (fetch (PIECE PFPOS) of PC)
                                 3)
                            (add CURFILECH# -3)))            (* ; 
                                                             "And note the passing of characters.")
                        (add CURFILECH# PCLEN))
                   (\PieceDescriptorOBJECT                   (* ; 
   "It describes an object.  Read that, and perhaps some description of the charlooks to go with it.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ 1
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ OBJECT.PTYPE))
                        (TEDIT.GET.OBJECT (AND TEXTOBJ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                               PC TEXT CURFILECH# PCLEN)
                        (add CURFILECH# (PLEN PC))
                        (replace (PIECE PLOOKS) of PC
                           with (if (ZEROP (BIN TEXT))
                                    then 
                                         (* ;; "No new looks;  steal them from the prior piece.")

                                         (OR (AND OLDPC (fetch (PIECE PLOOKS) of OLDPC))
                                             DEFAULTCHARLOOKS)
                                  else 
                                       (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                       (\TEDIT.GET.SINGLE.CHARLOOKS2 TEXT))))
                   (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))
               (CL:WHEN PC                                   (* ; 
                                                       "If we created a piece, save it in the table.")
                   (\INSERTPIECE PC NIL TEXTOBJ)
                   (SETQ OLDPC PC))])

(\TEDIT.GET.CHARLOOKS.LIST2
  [LAMBDA (FILE)                                             (* jds "22-May-85 14:28")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\SMALLPIN FILE) collect (\TEDIT.GET.SINGLE.CHARLOOKS2 FILE])

(\TEDIT.GET.SINGLE.CHARLOOKS2
  [LAMBDA (FILE)                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Read a set of CHARLOOKS from FILE)
    (PROG* ((LOOKS (create CHARLOOKS))
            FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR)
           (SETQ NAME (\ARBIN FILE))                         (* The font name)
           (SETQ SIZE (\SMALLPIN FILE))                      (* Size of the type, in points)
           (SETQ SUPER (\SMALLPIN FILE))                     (* Superscripting distance)
           (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                          0))
           (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE))
           (SETQ PROPS (\SMALLPIN FILE))
           (with CHARLOOKS LOOKS [SETQ CLLEADER (NOT (ZEROP (LOGAND 2048 PROPS]
                 [SETQ CLINVERTED (NOT (ZEROP (LOGAND 1024 PROPS]
                 [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                 [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                 [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                 [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                 [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                 [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                 [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                 [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                 [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                 [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                 (SETQ CLSIZE SIZE)
                 (SETQ CLOFFSET SUPER))
           [replace (CHARLOOKS CLFONT) of LOOKS with (COND
                                                        ((LISTP NAME)
                                                             (* This was a font class.
                                                             Restore it.)
                                                         (FONTCLASS (pop NAME)
                                                                NAME))
                                                        ((AND NAME (NOT (ZEROP SIZE)))
                                                         (FONTCREATE NAME SIZE
                                                                (COND
                                                                   ((AND (fetch (CHARLOOKS CLBOLD)
                                                                            of LOOKS)
                                                                         (fetch (CHARLOOKS CLITAL)
                                                                            of LOOKS))
                                                                    'BOLDITALIC)
                                                                   ((fetch (CHARLOOKS CLBOLD)
                                                                       of LOOKS)
                                                                    'BOLD)
                                                                   ((fetch (CHARLOOKS CLITAL)
                                                                       of LOOKS)
                                                                    'ITALIC]
           (RETURN LOOKS])

(\TEDIT.PUT.SINGLE.PARALOOKS2
  [LAMBDA (FILE LOOKS)                                       (* ; "Edited  3-Mar-2023 23:23 by rmk")
                                                             (* ; "Edited 30-May-91 20:33 by jds")
                                                             (* ; 
                  "Put a description of LOOKS into FILE.  LOOKS apply to characters CH1 thru CHLIM-1")
    (PROG (DEFTAB TABSPECS OUTPUTFORMAT LEN)
          (\SMALLPOUT FILE (fetch (FMTSPEC 1STLEFTMAR) of LOOKS))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (\SMALLPOUT FILE (fetch (FMTSPEC LEFTMAR) of LOOKS))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (\SMALLPOUT FILE (fetch (FMTSPEC RIGHTMAR) of LOOKS))
                                                             (* ; "Right margin for the paragraph")
          (\SMALLPOUT FILE (fetch (FMTSPEC LEADBEFORE) of LOOKS))
                                                             (* ; "Leading before the paragraph")
          (\SMALLPOUT FILE (fetch (FMTSPEC LEADAFTER) of LOOKS))
                                                             (* ; "Lead after the paragraph")
          (\SMALLPOUT FILE (fetch (FMTSPEC LINELEAD) of LOOKS))
                                                             (* ; "inter-line leading")
          (SETQ DEFTAB (CAR (fetch (FMTSPEC TABSPEC) of LOOKS)))
          (SETQ TABSPECS (CDR (fetch (FMTSPEC TABSPEC) of LOOKS)))
          (COND
             ((AND (fetch (FMTSPEC TABSPEC) of LOOKS)
                   (OR DEFTAB TABSPECS))                     (* ; 
                             "There are tab specs to save, or there is a default tab setting to save")
              (\BOUT FILE 3))
             (T                                              (* ; 
                                                          "There are no tab looks.  Just let him go.")
                (\BOUT FILE 2)))
          (\BOUT FILE (SELECTQ (fetch (FMTSPEC QUAD) of LOOKS)
                          (LEFT 1)
                          (RIGHT 2)
                          ((CENTER CENTERED) 
                               3)
                          ((JUST JUSTIFIED) 
                               4)
                          (SHOULDNT)))
          [COND
             ((OR TABSPECS DEFTAB)                           (* ; "There are tab specs to save.")
              (COND
                 (DEFTAB (\SMALLPOUT FILE DEFTAB))
                 (T (\SMALLPOUT FILE 0)))
              (\BOUT FILE (LENGTH TABSPECS))
              (COND
                 (TABSPECS                                   (* ; "# of tab settings <256!")
                        (for TAB in TABSPECS do (\SMALLPOUT FILE (fetch TABX of TAB)) 
                                                             (* ; "And setting.")
                                                (\BOUT FILE (SELECTQ (fetch TABKIND of TAB)
                                                                (LEFT 0)
                                                                (RIGHT 1)
                                                                (CENTERED 2)
                                                                (DECIMAL 3)
                                                                (SHOULDNT))) 
                                                             (* ; "Tab type")]
          (\SMALLPOUT FILE (OR (fetch (FMTSPEC FMTSPECIALX) of LOOKS)
                               0))
          (\SMALLPOUT FILE (OR (fetch (FMTSPEC FMTSPECIALY) of LOOKS)
                               0))
          (\ARBOUT FILE (fetch (FMTSPEC FMTUSERINFO) of LOOKS))
          (\ATMOUT FILE (fetch (FMTSPEC FMTPARATYPE) of LOOKS))
          (\ATMOUT FILE (fetch (FMTSPEC FMTPARASUBTYPE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTSTYLE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTNEWPAGEAFTER) of LOOKS])

(\TEDIT.PUT.SINGLE.CHARLOOKS2
  [LAMBDA (FILE LOOKS)                                       (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Put out a single CHARLOOKS 
                                                             description.)
    (PROG ((FONT (fetch (CHARLOOKS CLFONT) of LOOKS))
           STR LEN)
          [COND
             ((type? FONTCLASS FONT)                         (* For font classes, we need to save a 
                                                             list of device-FD sets)
              (\ARBOUT FILE (FONTCLASSUNPARSE FONT)))
             (T                                              (* For FONTDESCRIPTORs, do it the easy 
                                                             way)
                (\ATMOUT FILE (FONTPROP FONT 'FAMILY]        (* The font family)
          (\SMALLPOUT FILE (OR (FONTPROP FONT 'SIZE)
                               0))                           (* Size of the type, in points)
          (\SMALLPOUT FILE (OR (fetch (CHARLOOKS CLOFFSET) of LOOKS)
                               0))                           (* Super/subscripting distance)
          (COND
             ([AND (fetch (CHARLOOKS CLSTYLE) of LOOKS)
                   (NOT (ZEROP (fetch (CHARLOOKS CLSTYLE) of LOOKS]
              (\ARBOUT FILE (fetch (CHARLOOKS CLSTYLE) of LOOKS)))
             (T (\SMALLPOUT FILE 0)))
          (COND
             ((fetch (CHARLOOKS CLUSERINFO) of LOOKS)
              (\ARBOUT FILE (fetch (CHARLOOKS CLUSERINFO) of LOOKS)))
             (T (\SMALLPOUT FILE 0)))
          (\SMALLPOUT FILE (LOGOR (COND
                                     ((fetch (CHARLOOKS CLLEADER) of LOOKS)
                                                             (* Dotted-leader; relevant only to 
                                                             TABs)
                                      2048)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLINVERTED) of LOOKS)
                                                             (* Inverse-video)
                                      1024)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                      512)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                      256)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLULINE) of LOOKS)
                                      128)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLOLINE) of LOOKS)
                                      64)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLSTRIKE) of LOOKS)
                                      32)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLSMALLCAP) of LOOKS)
                                      16)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLPROTECTED) of LOOKS)
                                      8)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLINVISIBLE) of LOOKS)
                                      NIL 4)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLSELHERE) of LOOKS)
                                      2)
                                     (T 0))
                                  (COND
                                     ((fetch (CHARLOOKS CLCANCOPY) of LOOKS)
                                      1)
                                     (T 0])

(\TEDIT.GET.PARALOOKS.LIST2
  [LAMBDA (FILE)                                             (* jds "22-May-85 14:28")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\SMALLPIN FILE) collect (\TEDIT.GET.SINGLE.PARALOOKS2 FILE])

(\TEDIT.GET.SINGLE.PARALOOKS2
  [LAMBDA (FILE)                                             (* ; "Edited  3-Mar-2023 23:18 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:33 by jds")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (COND
             ((NOT (ZEROP (LOGAND TABFLG 1)))                (* ; "There are tabs to read")
              (SETQ DEFTAB (\SMALLPIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\SMALLPIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (BIN FILE)
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS)))
          [COND
             ((NOT (ZEROP (LOGAND TABFLG 2)))                (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\SMALLPIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE]
          (RETURN LOOKS])

(\TEDIT.PUT.CHARLOOKS.LIST2
  [LAMBDA (FILE LOOKSLIST)                                   (* jds "22-May-85 15:12")
                                                             (* Write the list of CHARLOOKSs into 
                                                             the font file.)

         (* Returns a hasharray that will map from a given CHARLOOKS to that CHARLOOKS' 
         position in the list we wrote on the file.
         Those position numbers are then written in the individual looks descriptions, and 
         are used to reconstruct the piece looks when the file is read back in.)

    (PROG ((LOOKSHASH (HASHARRAY 50)))
          (\DWOUT FILE 0)                                    (* No characters are described by this 
                                                             pseudo-piece entry.)
          (\SMALLPOUT FILE \PieceDescriptorCHARLOOKSLIST)    (* Mark it as containing the list of 
                                                             CHARLOOKSs)
          (\SMALLPOUT FILE (FLENGTH LOOKSLIST))              (* How many CHARLOOKSs there are in 
                                                             the list)
          (for I from 1 as LOOKS in LOOKSLIST do             (* Write each charlooks, in the order 
                                                             they appear in the list.)
                                                 (\TEDIT.PUT.SINGLE.CHARLOOKS2 FILE LOOKS) 
                                                             (* Write out the description)
                                                 (PUTHASH LOOKS I LOOKSHASH) 
                                                             (* And save it in the hash table so 
                                                             people can find its index.))
          (RETURN LOOKSHASH])

(\TEDIT.PUT.PARALOOKS.LIST2
  [LAMBDA (FILE LOOKSLIST)                                   (* jds "22-May-85 15:09")
                                                             (* Write the list of FMTSPECs into the 
                                                             font file.)
    (PROG ((LOOKSHASH (HASHARRAY 50)))
          (\DWOUT FILE 0)
          (\SMALLPOUT FILE \PieceDescriptorPARALOOKSLIST)
          (\SMALLPOUT FILE (FLENGTH LOOKSLIST))
          (for I from 1 as LOOKS in LOOKSLIST do (\TEDIT.PUT.SINGLE.PARALOOKS2 FILE LOOKS) 
                                                             (* Write out the description)
                                                 (PUTHASH LOOKS I LOOKSHASH) 
                                                             (* And save it in the hash table so 
                                                             people can find its index.))
          (RETURN LOOKSHASH])
)



(* ;; "For converting incoming old-format files (1/27/85 cutover)")

(DEFINEQ

(TEDIT.GET.PCTB1
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited  3-Aug-2023 22:08 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:18 by rmk")
                                                             (* ; "Edited  5-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited 22-May-92 18:00 by jds")

(* ;;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (* ;; "START = 1st char of file to read from, if specified")

    (* ;; "END = use this as eofptr of file.  For use in reading files within files.")

    (LET (PIECEINFOCH# TSTREAM (CURFILECH# (OR START 0)))
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTCHARLOOKS _ (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                              of TEXTOBJ))
               (OLDPARALOOKS _ (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ)) for I from 1 to PCCOUNT
            do (SETQ PC NIL)                                 (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
               (SETQ PCLEN (\DWIN TEXT))
               (SETQ TYPECODE (\SMALLPIN TEXT))              (* ; "What kind of piece is it?")
               (SELECTC TYPECODE
                   (\PieceDescriptorPAGEFRAME                (* ; 
                                                             "This is page layout info for the file")
                        (AND TEXTOBJ (replace (TEXTOBJ TXTPAGEFRAMES) of TEXTOBJ with (
                                                                                TEDIT.GET.PAGEFRAMES1
                                                                                       TEXT))))
                   (\PieceDescriptorPARA                     (* ; 
                                                             "Reading a new set of paragraph looks.")
                        (CL:WHEN OLDPC                       (* ; 
                                                           "Mark the end of the preceding paragraph.")
                            (replace (PIECE PPARALAST) of OLDPC with T))
                        (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS1 TEXT))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                        (CL:WHEN TEXTOBJ                     (* ; 
                                          "Mark the document as containing paragraph formatting info")
                            (replace (TEXTOBJ FORMATTEDP) of TEXTOBJ with T)))
                   (\PieceDescriptorLOOKS                    (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ PCLEN
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE))     (* ; "Build the new piece")
                        (\TEDIT.GET.CHARLOOKS1 PC TEXT)      (* ; 
                                                             "Read the character looks for this guy.")
                        (add CURFILECH# (PLEN PC))           (* ; 
                                                             "And note the passing of characters.")
                        )
                   (\PieceDescriptorOBJECT                   (* ; 
   "It describes an object.  Read that, and perhaps some description of the charlooks to go with it.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ 1
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE))
                        (TEDIT.GET.OBJECT1 (AND TEXTOBJ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                               PC TEXT CURFILECH#)
                        (add CURFILECH# (fetch (PIECE PLEN) of PC))
                        [COND
                           ((NOT (ZEROP (BIN TEXT)))         (* ; 
                                      "There are new character looks for this object.  Read them in.")
                            (\DWIN TEXT)
                            (\WIN TEXT)                      (* ; 
                                              "Skip over the piece-type code we know has to be here.")
                            (\TEDIT.GET.CHARLOOKS1 PC TEXT))
                           (T                                (* ; 
                                                    "No new looks;  steal them from the prior piece.")
                              (replace (PIECE PLOOKS) of PC with (OR (AND OLDPC (PLOOKS OLDPC))
                                                                     DEFAULTCHARLOOKS])
                   (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))
               (CL:WHEN PC
                   (\INSERTPIECE PC NIL TEXTOBJ)
                   (SETQ OLDPC PC))])

(TEDIT.GET.PAGEFRAMES1
  [LAMBDA (FILE)                                             (* jds " 1-Feb-85 14:55")
                                                             (* Read a bunch of page frames from 
                                                             the file, and return it.)
    (TEDIT.PARSE.PAGEFRAMES1 (READ FILE])

(\TEDIT.GET.CHARLOOKS1
  [LAMBDA (PC FILE)                                          (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Read a description of PC's 
                                                             CHARLOOKS from FILE.)
    (PROG (FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR (LOOKS (create CHARLOOKS)))
          (replace (PIECE PLOOKS) of PC with LOOKS)
          (SETQ NAME (\ARBIN FILE))                          (* The font name)
          (SETQ SIZE (\SMALLPIN FILE))                       (* Size of the type, in points)
          (SETQ SUPER (\SMALLPIN FILE))                      (* Superscripting distance)
          (SETQ SUB (\SMALLPIN FILE))                        (* former Subscripting distance)
          (OR (ZEROP SUB)
              (SETQ SUPER (IMINUS SUB)))

         (* If this is an old file, it'll have a subscript value not zero.
         Let those past and do the right thing.)

          (COND
             ((NOT (ZEROP (BIN FILE)))                       (* This text is NEW.
                                                             Mark it so.)
              (replace (PIECE PNEW) of PC with T)))
          [COND
             ((NOT (ZEROP (BIN FILE)))                       (* There is style or user information 
                                                             to be read)
              (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                             0))
              (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE]
          (SETQ PROPS (\SMALLPIN FILE))
          (with CHARLOOKS LOOKS [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                (SETQ CLSIZE SIZE)
                (SETQ CLOFFSET SUPER))
          (replace (CHARLOOKS CLFONT) of LOOKS with (COND
                                                       ((LISTP NAME)
                                                             (* This was a font class.
                                                             Restore it.)
                                                        (FONTCLASS (pop NAME)
                                                               NAME))
                                                       ((AND NAME (NOT (ZEROP SIZE)))
                                                        (FONTCREATE NAME SIZE
                                                               (COND
                                                                  ((AND (fetch (CHARLOOKS CLBOLD)
                                                                           of LOOKS)
                                                                        (fetch (CHARLOOKS CLITAL)
                                                                           of LOOKS))
                                                                   'BOLDITALIC)
                                                                  ((fetch (CHARLOOKS CLBOLD)
                                                                      of LOOKS)
                                                                   'BOLD)
                                                                  ((fetch (CHARLOOKS CLITAL)
                                                                      of LOOKS)
                                                                   'ITALIC])

(\TEDIT.GET.PARALOOKS1
  [LAMBDA (FILE)                                             (* ; "Edited  3-Mar-2023 23:20 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:34 by jds")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 1))               (* ; "There are tabs to read")
              (SETQ DEFTAB (\SMALLPIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\SMALLPIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (BIN FILE)
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 2))               (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\SMALLPIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE)))
          (RETURN LOOKS])

(TEDIT.GET.OBJECT1
  [LAMBDA (STREAM PIECE FILE CURCH#)                         (* ; "Edited  6-Aug-2022 09:11 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:17 by mitani")

    (* ;; "Get an object from the file")

    (* ;; "CURCH# = fileptr within the text section of the file where the object's text starts.")

    (PROG ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
           FILEPTRSAVE NAMELEN GETFN OBJ)
          (SETQ GETFN (\ATMIN FILE))                         (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
          (SETQ FILEPTRSAVE (GETFILEPTR FILE))               (* ; 
                                             "Save our file location thru the building of the object")
          (SETFILEPTR FILE CURCH#)
          (SETQ OBJ (READIMAGEOBJ FILE GETFN))
          (SETFILEPTR FILE FILEPTRSAVE)
          (replace (PIECE PCONTENTS) of PIECE with OBJ)
          (replace (PIECE PTYPE) of PIECE with OBJECT.PTYPE) (* ; "Just in case")
          [replace (PIECE PLOOKS) of PIECE with (COND
                                                   ((fetch (PIECE PREVPIECE) of PIECE)
                                                    (fetch (PIECE PLOOKS) of (fetch (PIECE PREVPIECE)
                                                                                of PIECE)))
                                                   (T (OR (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ)
                                                          (\TEDIT.UNIQUIFY.CHARLOOKS (
                                                                                  CHARLOOKS.FROM.FONT
                                                                                      DEFAULTFONT)
                                                                 TEXTOBJ]
          (RETURN (fetch (PIECE PCONTENTS) of PIECE])
)



(* ;; "VERSION 0 Compatibility reading functions")

(DEFINEQ

(TEDIT.GET.PCTB0
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited  3-Aug-2023 22:09 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:21 by rmk")
                                                             (* ; "Edited  5-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited 22-May-92 18:01 by jds")

(* ;;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (LET (OLDPC TYPECODE PCLEN PIECEINFOCH# TSTREAM USERFILEFORMAT USERTEMP (CURFILECH# (OR START 0))
                )
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTPARALOOKS _ (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ))
            for I from 1 to PCCOUNT
            do (SETQ PCLEN (\DWIN TEXT))
               (SETQ PC
                (create PIECE
                       PCONTENTS _ TEXT
                       PFPOS _ CURFILECH#
                       PLEN _ PCLEN
                       PREVPIECE _ OLDPC
                       PPARALOOKS _ DEFAULTPARALOOKS
                       PTYPE _ THINFILE.PTYPE))
               [COND
                  (OLDPC (replace (PIECE NEXTPIECE) of OLDPC with PC)
                         (replace (PIECE PPARALOOKS) of PC with (PPARALOOKS OLDPC]
               (SETQ TYPECODE (\SMALLPIN TEXT))
               (SELECTC TYPECODE
                   (\PieceDescriptorLOOKS 
                        (TEDIT.GET.CHARLOOKS0 PC TEXT)
                        (add CURFILECH# (fetch (PIECE PLEN) of PC)))
                   (\PieceDescriptorOBJECT 
                        (TEDIT.GET.OBJECT0 (AND TEXTOBJ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                               PC TEXT CURFILECH#)
                        (add CURFILECH# (fetch (PIECE PLEN) of PC))
                        (replace (PIECE PLEN) of PC with 1)  (* ; 
                                            "Only object--can't be followed by either ot the others.")
                        )
                   (\PieceDescriptorPARA 
                        (AND OLDPC (replace (PIECE PPARALAST) of OLDPC with T))
                        (TEDIT.GET.PARALOOKS0 PC TEXT)
                        (replace (PIECE PLEN) of PC with (\DWIN TEXT))
                                                             (* ; 
                                                  "Set this piece's length from the character looks.")
                        (\SMALLPIN TEXT)                     (* ; 
                                                "Skip the piece-type code, since we know what's next")
                        (TEDIT.GET.CHARLOOKS0 PC TEXT)       (* ; "This document is 'formatted' .")
                        (add CURFILECH# (PLEN PC))
                        (AND TEXTOBJ (replace (TEXTOBJ FORMATTEDP) of TEXTOBJ with T)))
                   (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))
               (SETQ OLDPC PC)
               (\INSERTPIECE PC NIL TEXTOBJ])

(TEDIT.GET.CHARLOOKS0
  [LAMBDA (PC FILE)                                          (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Put a description of LOOKS into 
                                                             FILE. LOOKS apply to characters CH1 
                                                             thru CHLIM-1)
    (PROG (FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR (LOOKS (create CHARLOOKS)))
          (replace (PIECE PLOOKS) of PC with LOOKS)
          (SETQ NAMELEN (\SMALLPIN FILE))                    (* The length of the description which 
                                                             follows)
          [SETQ NAME (PACK (for I from 1 to NAMELEN collect (CHARACTER (BIN FILE]
                                                             (* The font name)
          (SETQ SIZE (\SMALLPIN FILE))                       (* Size of the type, in points)
          (SETQ SUPER (\SMALLPIN FILE))                      (* Superscripting distance)
          (SETQ SUB (\SMALLPIN FILE))                        (* former Subscripting distance)
          (OR (ZEROP SUB)
              (SETQ SUPER (IMINUS SUB)))

         (* If this is an old file, it'll have a subscript value not zero.
         Let those past and do the right thing.)

          (COND
             ((NOT (ZEROP (BIN FILE)))                       (* This text is NEW.
                                                             Mark it so.)
              (replace (PIECE PNEW) of PC with T)))
          [COND
             ((NOT (ZEROP (BIN FILE)))                       (* There is style or user information 
                                                             to be read)
              (SETQ STYLESTR (\STRINGIN FILE))
              (SETQ USERSTR (\STRINGIN FILE))
              (COND
                 ((NOT (ZEROP (NCHARS STYLESTR)))            (* There IS style info)
                  (replace (CHARLOOKS CLSTYLE) of LOOKS with (READ STYLESTR)))
                 (T (replace (CHARLOOKS CLSTYLE) of LOOKS with 0)))
              (COND
                 ((NOT (ZEROP (NCHARS USERSTR)))             (* There IS user info)
                  (replace (CHARLOOKS CLUSERINFO) of LOOKS with (READ USERSTR]
          (SETQ PROPS (\SMALLPIN FILE))
          (with CHARLOOKS LOOKS [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                (SETQ CLSIZE SIZE)
                (SETQ CLOFFSET SUPER))
          (replace (CHARLOOKS CLFONT) of LOOKS with (AND NAME (NOT (ZEROP SIZE))
                                                         (FONTCREATE NAME SIZE
                                                                (COND
                                                                   ((AND (fetch (CHARLOOKS CLBOLD)
                                                                            of LOOKS)
                                                                         (fetch (CHARLOOKS CLITAL)
                                                                            of LOOKS))
                                                                    'BOLDITALIC)
                                                                   ((fetch (CHARLOOKS CLBOLD)
                                                                       of LOOKS)
                                                                    'BOLD)
                                                                   ((fetch (CHARLOOKS CLITAL)
                                                                       of LOOKS)
                                                                    'ITALIC])

(TEDIT.GET.OBJECT0
  [LAMBDA (STREAM PIECE FILE CURCH#)                         (* ; "Edited  6-Aug-2022 15:57 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:17 by mitani")

    (* ;; "Get an object from the file")

    (* ;; "CURCH# = fileptr within the text section of the file where the object's text starts.")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
          FILEPTRSAVE NAMELEN GETFN OBJ)
         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURCH#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN))
         (SETFILEPTR FILE FILEPTRSAVE)
         (replace (PIECE PCONTENTS) of PIECE with OBJ)
         [replace (PIECE PLOOKS) of PIECE with (COND
                                                  ((fetch (PIECE PREVPIECE) of PIECE)
                                                   (fetch (PIECE PLOOKS) of (fetch (PIECE PREVPIECE)
                                                                               of PIECE)))
                                                  (T (OR (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                            of TEXTOBJ)
                                                         (\TEDIT.UNIQUIFY.CHARLOOKS (
                                                                                  CHARLOOKS.FROM.FONT
                                                                                     DEFAULTFONT)
                                                                TEXTOBJ]
         OBJ])

(TEDIT.GET.PARALOOKS0
  [LAMBDA (PC FILE)                                          (* ; "Edited  3-Mar-2023 23:14 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:34 by jds")
                                                             (* ; 
                  "Put a description of LOOKS into FILE.  LOOKS apply to characters CH1 thru CHLIM-1")
    (PROG ((LOOKS (create FMTSPEC))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC)
          (replace (PIECE PPARALOOKS) of PC with LOOKS)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\SMALLPIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (COND
             ((NOT (ZEROP TABFLG))                           (* ; "There are tabs to read")
              (SETQ DEFTAB (\SMALLPIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\SMALLPIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (BIN FILE)
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (SHOULDNT]
              (OR (ZEROP DEFTAB)
                  (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (5125 28905 (\TEDIT.MAKE.SAFE.BUFFERS 5135 . 14325) (\TEDIT.MAKE.SAFE.PIECES 14327 . 
21124) (\TEDIT.GET.PIECES3 21126 . 28903)) (28938 54310 (TEDIT.GET 28948 . 33519) (
TEDIT.FORMATTEDFILEP 33521 . 34264) (\TEDIT.GET.FOREIGN.FILE 34266 . 37227) (
\TEDIT.GET.UNFORMATTED.FILE 37229 . 40761) (\TEDIT.GET.FORMATTED.FILE 40763 . 44657) (
\TEDIT.FORMATTEDSTREAMP 44659 . 47346) (TEDIT.PARSE.PAGEFRAMES1 47348 . 49029) (\ARBIN 49031 . 49647) 
(\ATMIN 49649 . 50082) (\DWIN 50084 . 50463) (\STRINGIN 50465 . 51069) (\TEDIT.FORMATTEDP1 51071 . 
52779) (\TEDIT.CACHEFILE 52781 . 54308)) (54311 78091 (\TEDIT.GET.PIECES3 54321 . 62098) (
\TEDIT.MAKE.SAFE.BUFFERS 62100 . 71290) (\TEDIT.MAKE.SAFE.PIECES 71292 . 78089)) (78092 83173 (
\TEDIT.GET.UNFORMATTED.FILE.XCCS 78102 . 80986) (\TEDIT.GET.UNFORMATTED.FILE.UTF8 80988 . 83171)) (
83215 92232 (TEDIT.GET.PCTB3 83225 . 90165) (\INSERT-NSCLEARED-PIECE 90167 . 91258) (
TEDIT.GET.PASSWORD 91260 . 92230)) (92268 99623 (TEDIT.INCLUDE 92278 . 98811) (TEDIT.RAW.INCLUDE 98813
 . 99621)) (99657 122648 (TEDIT.PUT 99667 . 105302) (TEDIT.PUT.PCTB 105304 . 117485) (
TEDIT.PUT.PCTB.MERGEABLE 117487 . 118980) (\TEDIT.PUT.NEWPIECES 118982 . 120548) (\TEDIT.PUTRESET 
120550 . 120792) (\ARBOUT 120794 . 121414) (\ATMOUT 121416 . 121927) (\DWOUT 121929 . 122208) (
\STRINGOUT 122210 . 122646)) (122649 136905 (\TEDIT.GET.CHARLOOKS.LIST 122659 . 123060) (
\TEDIT.GET.SINGLE.CHARLOOKS 123062 . 127266) (\TEDIT.PUT.CHARLOOKS.LIST 127268 . 128836) (
\TEDIT.PUT.SINGLE.CHARLOOKS 128838 . 133584) (\TEDIT.PUT.CHARLOOKS 133586 . 135265) (
\TEDIT.GET.CHARLOOKS 135267 . 136903)) (136906 152320 (\TEDIT.GET.PARALOOKS.LIST 136916 . 137325) (
\TEDIT.GET.SINGLE.PARALOOKS 137327 . 144215) (\TEDIT.PUT.PARALOOKS.LIST 144217 . 145020) (
\TEDIT.PUT.SINGLE.PARALOOKS 145022 . 150853) (\TEDIT.PUT.PARALOOKS 150855 . 151832) (
\TEDIT.GET.PARALOOKS 151834 . 152318)) (152321 157057 (TEDIT.GET.OBJECT 152331 . 155107) (
TEDIT.PUT.OBJECT 155109 . 157055)) (157152 158352 (TEDITFROMLISPSOURCE 157162 . 158350)) (158603 
189899 (TEDIT.GET.PCTB2 158613 . 168769) (\TEDIT.GET.CHARLOOKS.LIST2 168771 . 169174) (
\TEDIT.GET.SINGLE.CHARLOOKS2 169176 . 172653) (\TEDIT.PUT.SINGLE.PARALOOKS2 172655 . 177216) (
\TEDIT.PUT.SINGLE.CHARLOOKS2 177218 . 181734) (\TEDIT.GET.PARALOOKS.LIST2 181736 . 182139) (
\TEDIT.GET.SINGLE.PARALOOKS2 182141 . 186960) (\TEDIT.PUT.CHARLOOKS.LIST2 186962 . 188901) (
\TEDIT.PUT.PARALOOKS.LIST2 188903 . 189897)) (189976 207275 (TEDIT.GET.PCTB1 189986 . 195744) (
TEDIT.GET.PAGEFRAMES1 195746 . 196102) (\TEDIT.GET.CHARLOOKS1 196104 . 200375) (\TEDIT.GET.PARALOOKS1 
200377 . 205158) (TEDIT.GET.OBJECT1 205160 . 207273)) (207335 220844 (TEDIT.GET.PCTB0 207345 . 210695)
 (TEDIT.GET.CHARLOOKS0 210697 . 215233) (TEDIT.GET.OBJECT0 215235 . 217188) (TEDIT.GET.PARALOOKS0 
217190 . 220842)))))
STOP
