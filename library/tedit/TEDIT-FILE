(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "15-Jan-2024 17:39:40" {WMEDLEY}<library>TEDIT>TEDIT-FILE.;467 158184 

      :EDIT-BY rmk

      :CHANGES-TO (FNS \TEDIT.GET.TRAILER)

      :PREVIOUS-DATE "14-Jan-2024 13:19:01" {WMEDLEY}<library>TEDIT>TEDIT-FILE.;466)


(PRETTYCOMPRINT TEDIT-FILECOMS)

(RPAQQ TEDIT-FILECOMS
       ((DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (\PieceDescriptorLOOKS 0)
                                                (\PieceDescriptorOBJECT 1)
                                                (\PieceDescriptorPARA 2)
                                                (\PieceDescriptorPAGEFRAME 3)
                                                (\PieceDescriptorCHARLOOKSLIST 4)
                                                (\PieceDescriptorPARALOOKSLIST 5)
                                                (\PieceDescriptorSAFEOBJECT 6)
                                                (\PieceDescriptorMETAINFO 7)))
        (COMS 
              (* ;; "Public entries ")

              (FNS TEDIT.GET TEDIT.FORMATTEDFILEP TEDIT.FILEDATE \TEDIT.GET.IDATE3 TEDIT.INCLUDE 
                   TEDIT.RAW.INCLUDE TEDIT.PUT)
              
              (* ;; "Getting (pageframe functions on TEDIT-PAGE)")

              (FNS \TEDIT.GET.FOREIGN.FILE \TEDIT.GET.UNFORMATTED.FILE \TEDIT.GET.FORMATTED.FILE 
                   \TEDIT.FORMATTEDSTREAMP \ARBIN \ATMIN \DWIN \STRINGIN \TEDIT.GET.TRAILER 
                   \TEDIT.CACHEFILE)
              [COMS 
                    (* ;; 
  "Until CL:COMPILE-FILE and any others are updated, They should use the public TEDIT.FORMATTEDFILEP")

                    (P (MOVD? '\TEDIT.GET.TRAILER '\TEDIT.FORMATTEDP1]
              (FNS \TEDIT.GET.PIECES3 \TEDIT.MAKE.STRINGPIECE \TEDIT.MAKE.SAFE.PIECES 
                   \TEDIT.MAKE.SAFE.BUFFERS)
              (FNS \TEDIT.GET.UNFORMATTED.FILE.XCCS \TEDIT.INTERPRET.XCCS.SHIFTS)
                                                             (* ; "XCCS")
              (FNS \TEDIT.GET.UNFORMATTED.FILE.UTF8 \TEDIT.ADJUST.EOLPIECES)
                                                             (* ; "UTF-8")
              (FNS \TEDIT.GET.CHARLOOKS.LIST \TEDIT.GET.SINGLE.CHARLOOKS \TEDIT.GET.CHARLOOKS 
                   \TEDIT.GET.PARALOOKS.INDEX \TEDIT.GET.CHARLOOKS.INDEX)
              (FNS \TEDIT.GET.PARALOOKS.LIST \TEDIT.GET.SINGLE.PARALOOKS \TEDIT.GET.PARALOOKS)
              (FNS TEDIT.GET.OBJECT))
        (COMS 
              (* ;; "Putting (pageframe functions on TEDIT-PAGE)")

              (FNS \TEDIT.PUT.PCTB \TEDIT.PUT.TRAILER \TEDIT.PUT.PCTB.MERGEABLE 
                   \TEDIT.PUT.UTF8.SPLITPIECES \TEDIT.PUT.PCTB.NEXTNEW \TEDIT.INSERT.NEWPIECES 
                   \TEDIT.PUTRESET \ARBOUT \ATMOUT \DWOUT \STRINGOUT)
              (FNS \TEDIT.PUT.CHARLOOKS.LIST \TEDIT.PUT.SINGLE.CHARLOOKS \TEDIT.PUT.CHARLOOKS 
                   \TEDIT.PUT.CHARLOOKS1)
              (FNS \TEDIT.PUT.PARALOOKS.LIST \TEDIT.PUT.SINGLE.PARALOOKS \TEDIT.PUT.PARALOOKS)
              (FNS TEDIT.PUT.OBJECT))
        (GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
        (FNS TEDITFROMLISPSOURCE)
        (ADDVARS (TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE)))
        (INITVARS (*TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))
                                                             (* ; 
                                         "For consistent reading and writing of info on TEdit files.")
               )))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ \PieceDescriptorLOOKS 0)

(RPAQQ \PieceDescriptorOBJECT 1)

(RPAQQ \PieceDescriptorPARA 2)

(RPAQQ \PieceDescriptorPAGEFRAME 3)

(RPAQQ \PieceDescriptorCHARLOOKSLIST 4)

(RPAQQ \PieceDescriptorPARALOOKSLIST 5)

(RPAQQ \PieceDescriptorSAFEOBJECT 6)

(RPAQQ \PieceDescriptorMETAINFO 7)


(CONSTANTS (\PieceDescriptorLOOKS 0)
       (\PieceDescriptorOBJECT 1)
       (\PieceDescriptorPARA 2)
       (\PieceDescriptorPAGEFRAME 3)
       (\PieceDescriptorCHARLOOKSLIST 4)
       (\PieceDescriptorPARALOOKSLIST 5)
       (\PieceDescriptorSAFEOBJECT 6)
       (\PieceDescriptorMETAINFO 7))
)
)



(* ;; "Public entries ")

(DEFINEQ

(TEDIT.GET
  [LAMBDA (TSTREAM FILE UNFORMATTED? PROPS)                  (* ; "Edited 22-Sep-2023 20:16 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:41 by rmk")
                                                             (* ; "Edited  9-Sep-2023 17:24 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:12 by jds")

    (* ;; "A new file overwrites the textstream,textobj, and window of the one being edited.  We have to make a new TEXTOBJ because we don't want the new file to inherit random properties (like READONLY etc.  (Not sure about BEING-EDITED, that may only have been used for window-creation)")

    (SETQ TSTREAM (TEXTSTREAM TSTREAM))
    (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
           FSTREAM GETFN MAINWINDOW BEINGEDITED PROC NTSTREAM NTEXTOBJ TEDITCREATED BEING-EDITED)
          (CL:WHEN [AND (GETTOBJ TEXTOBJ \DIRTY)
                        (PROGN (TEDIT.PROMPTCLEAR TEXTOBJ)
                               (NOT (MOUSECONFIRM "Not saved yet; LEFT go Get anyway." T
                                           (GETTOBJ TEXTOBJ PROMPTWINDOW]

              (* ;; "Only do the GET if he knows he'll zorch himself.")

              (RETURN))
          (CL:UNLESS FILE
              [SETQ FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ "File to GET:  "
                                                     (OR (GETTEXTPROP TEXTOBJ 'LASTGETFILENAME)
                                                         (\TEXTSTREAM.FILENAME TEXTOBJ])
          (CL:WHEN [AND (SETQ GETFN (GETTEXTPROP TEXTOBJ 'GETFN))
                        (EQ 'DON'T (APPLY* GETFN (GETTOBJ TEXTOBJ STREAMHINT)
                                          (FULLNAME FSTREAM)
                                          'BEFORE]           (* ; 
                                                      "He doesn't want this document put.  Bail out.")
              (RETURN))

     (* ;; "")

          (SETQ FSTREAM (\TEDIT.OPENTEXTFILE FILE))
          (CL:UNLESS (\GETSTREAM FSTREAM 'INPUT T)           (* ; 
                                        "Didn't find it but save the name as a hint for the next try")
              (PUTTEXTPROP TEXTOBJ 'LASTGETFILENAME FILE)
              (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FILE " not found--aborted")
                     T)
              (RETURN NIL))
          (RESETLST
              (RESETSAVE (TTYDISPLAYSTREAM (OR (AND (NEQ 'DON'T (GETTOBJ TEXTOBJ PROMPTWINDOW)
                                                         'DON'T)
                                                    (GETTOBJ TEXTOBJ PROMPTWINDOW))
                                               PROMPTWINDOW)))

              (* ;; "New file is good, clean out the old stuff")

              (\SHOWSEL (TEXTSEL TEXTOBJ)
                     NIL)
              (\TEXTCLOSEF TEXTOBJ)                          (* ; 
                                                             "Close the old files, still in TXTFILE")

              (* ;; "")

              (* ;; "Open a textstream NTSTREAM on the new file, then reconnect its textobj to the old TSTREAM and window")

              (SETQ MAINWINDOW (\TEDIT.MAINW TEXTOBJ))
              (SETQ BEING-EDITED (GETTEXTPROP TEXTOBJ 'BEING-EDITED))
              (CL:WHEN MAINWINDOW
                  (SETQ TEDITCREATED (WINDOWPROP MAINWINDOW 'TEDITCREATED)))
              (CL:WHEN UNFORMATTED?
                  (push PROPS 'CLEARGET T))
              (SETQ NTSTREAM (OPENTEXTSTREAM FSTREAM MAINWINDOW NIL NIL PROPS))
              (SETQ NTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of NTSTREAM))
              (replace (TEXTSTREAM TEXTOBJ) of TSTREAM with NTEXTOBJ)
              (SETTOBJ NTEXTOBJ STREAMHINT TSTREAM)
              (\TEXTSETFILEPTR TSTREAM 0)
              (CL:WHEN MAINWINDOW
                  (\TEDIT.UPDATE.TITLE NTEXTOBJ)
                  (WINDOWPROP MAINWINDOW 'TEDITCREATED TEDITCREATED)
                                                             (* ; "To keep the default region")
                  (WINDOWPROP MAINWINDOW 'TEXTSTREAM TSTREAM))
              (CL:WHEN BEING-EDITED (TEDIT TSTREAM)))        (* ; "find and set the title")
          (CL:WHEN GETFN
              (APPLY* GETFN TSTREAM (FULLNAME (GETTOBJ TEXTOBJ TXTFILE))
                     'AFTER))
          (RETURN TSTREAM])

(TEDIT.FORMATTEDFILEP
  [LAMBDA (FILE)                                             (* ; "Edited 13-Jan-2024 11:57 by rmk")
                                                             (* ; "Edited 12-Jul-2023 23:35 by rmk")

    (* ;; "If FILE is a Tedit formatted stream or the name of a Tedit formatted file, returns a pair consistening of its version number and piececount.  Piececount is probably useless.")

    (RESETLST
        (if (STREAMP FILE)
            then [RESETSAVE (GETFILEPTR FILE)
                        `(PROGN (SETFILEPTR ,FILE OLDVALUE]
                 (\TEDIT.GET.TRAILER FILE)
          else (LET (STREAM)
                    [RESETSAVE (SETQ STREAM (OPENSTREAM FILE 'INPUT))
                           `(PROGN (CLOSEF? OLDVALUE]
                    (\TEDIT.GET.TRAILER STREAM))))])

(TEDIT.FILEDATE
  [LAMBDA (FILE INTEGER)                                     (* ; "Edited 13-Jan-2024 10:20 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  6-Dec-2023 20:11 by rmk")
                                                             (* ; "Edited 28-Sep-2023 22:47 by rmk")

    (* ;; "If FILE is a Tedit-format file, returns its save date if it is stamped in the file, otherwise its file-system creation date as an integer or string.  NIL if not a Tedit file.")

    (* ;; "FILE must be random access.  If not, then presumably we first have to fetch the last 5+4+8 bytes to someplace else.")

    (CL:WHEN FILE
        (RESETLST
            (LET ((STREAM (\GETSTREAM FILE 'INPUT T))
                  IDATE TRAILER)
                 [if STREAM
                     then [RESETSAVE (GETFILEPTR STREAM)
                                 `(PROGN (SETFILEPTR ,STREAM OLDVALUE]
                   else (RESETSAVE (SETQ STREAM (OPENSTREAM FILE 'INPUT))
                               `(PROGN (CLOSEF? OLDVALUE]
                 (SETQ TRAILER (\TEDIT.GET.TRAILER STREAM))
                 (SETQ IDATE (CADDDR (CDR TRAILER)))
                 (CL:UNLESS IDATE
                     (SETQ IDATE (GETFILEINFO STREAM 'ICREATIONDATE)))
                 (CL:IF INTEGER
                     IDATE
                     (GDATE IDATE)))))])

(\TEDIT.GET.IDATE3
  [LAMBDA (STREAM END)                                       (* ; "Edited  6-Dec-2023 16:55 by rmk")

    (* ;; "Returns the integer IDATE for slightly updated version 3 files, otherwise NIL.  4 for the bytes of the IDATE, 8 for the header. Leaves resets to starting position (assumes an error wouldn't matter).")

    (CL:WHEN (IGREATERP END (IPLUS (CONSTANT (NCHARS "DATE:"))
                                   4 8))
        (LET ((FILEPTR (GETFILEPTR STREAM)))
             (SETFILEPTR STREAM (IDIFFERENCE END (IPLUS (CONSTANT (NCHARS "DATE:"))
                                                        4 8)))

             (* ;; 
     "DATE: is the marker for this extension to version 3 (could be removed if version is update).  ")

             (PROG1 (CL:WHEN (AND (EQ (CHARCODE D)
                                      (BIN STREAM))
                                  (EQ (CHARCODE A)
                                      (BIN STREAM))
                                  (EQ (CHARCODE T)
                                      (BIN STREAM))
                                  (EQ (CHARCODE E)
                                      (BIN STREAM))
                                  (EQ (CHARCODE %:)
                                      (BIN STREAM)))
                           (\DWIN STREAM))
                    (SETFILEPTR STREAM FILEPTR))))])

(TEDIT.INCLUDE
  [LAMBDA (TSTREAM FILE START END SAFE PLAINTEXT)            (* ; "Edited 13-Jan-2024 09:39 by rmk")
                                                             (* ; "Edited 12-Nov-2023 12:29 by rmk")
                                                             (* ; "Edited 23-Jul-2023 15:30 by rmk")
                                                             (* ; "Edited 16-Jul-2023 10:18 by rmk")
                                                             (* ; "Edited 21-Jun-2023 17:46 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; 
                                                        "Edited  1-Jun-93 11:31 by sybalsky:mv:envos")

    (* ;; "Obtain a file name, and include that file's contents at the place where the caret is.")

    (* ;; "This is a documented entry, but SAFE wasn't described there and I (RMK) added PLAINTEXT to collapse with TEDIT.INCLUDE.RAW.")

    (* ;; 
   "Returns the length of the input, if the insertion happened, NIL if there was no place to put it.")

    (* ;; "")

    (* ;; "This assumes that START and END are file positions (defaulting to 0 and length), not character numbers.")

    (* ;; "")

    (* ;; "If SAFE, the caller is taking responsibility for closing FILE when its contents are no longer needed (e.g. DOC-OBJECTS inclusions).  Otherwise, the contents are copied to a NODIRCORE that is owned by this TSTREAM, and then FILE is closed here if it wasn't previously open.  (This may not be accurate, unless FILE was actually an open stream and not a name?)")

    (CL:UNLESS (\TEDIT.READONLY TSTREAM)
        (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
               TSEL FSEL WASOPEN FTSTREAM NDCSTREAM (FROMFILE FILE))
              (SETQ TSEL (TEXTSEL TEXTOBJ))
              (CL:UNLESS (GETSEL TSEL SET)
                  (TEDIT.PROMPTPRINT TEXTOBJ "Please select a destination for the included text" T)
                  (RETURN NIL))

         (* ;; "We know where the new text is supposed to go. Where is it coming from?")

              (CL:UNLESS FROMFILE
                  (SETQ FROMFILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ 
                                                             "Name of the file to include:  ")))
                  (CL:UNLESS FROMFILE
                      (TEDIT.PROMPTPRINT TEXTOBJ "No file to include--aborted]" T)
                      (RETURN)))
              (CL:UNLESS (OR (STREAMP FROMFILE)
                             (INFILEP FROMFILE))             (* ; "File not found")
                  (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FROMFILE " not found--include aborted")
                         T T)
                  (RETURN))

         (* ;; "")

         (* ;; "Now we have the FROMFILE, which may be a stream.")

              (CL:UNLESS START (SETQ START 0))
              (CL:UNLESS END
                  (SETQ END (GETFILEINFO FILE 'LENGTH)))
              (CL:UNLESS (IGEQ END START)
                  (TEDIT.PROMPTPRINT TEXTOBJ "Negative number of characters to include--aborted" T T)
                  (RETURN))

         (* ;; "")

         (* ;; "If the caller says SAFE, he's guranteeing that the file will be there at least as long as we need it.  Otherwise, we take ownership of the information by copying it to a NODIRCORE. ")

              (CL:UNLESS SAFE
                  [if (\GETSTREAM FROMFILE 'INPUT T)
                      then (SETQ WASOPEN T)
                    else                                     (* ; 
                                                        "Wasn't open -- need to open it for input...")
                         (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT NIL '((TYPE TEXT]

                  (* ;; "Create our holding file and copy the file-section into it.")

                  (SETQ NDCSTREAM (OPENSTREAM '{NODIRCORE} 'OUTPUT 'NEW))

                  (* ;; "Have to explicitly fill in 0 and EOFPTR, because if the file was open already, NILs would only copy from current fileptr to EOF.")

                  (* ;; 
            "Use COPYBYTES for formatted files, otherwise allow natural EOL conversion to take place")

                  (if (\TEDIT.GET.TRAILER FROMFILE)
                      then (COPYBYTES FROMFILE NDCSTREAM START END)
                    else (COPYCHARS FROMFILE NDCSTREAM START END))
                  (CL:UNLESS WASOPEN (CLOSEF FROMFILE))      (* ; 
                                                      "If the file didn't come to us open, close it.")
                  (CLOSEF NDCSTREAM)
                  (SETQ START 0)                             (* ; 
                                                             "But we now want everything we copied")
                  (SETQ END (GETFILEINFO NDCSTREAM 'LENGTH))
                  (SETQ FROMFILE NDCSTREAM))

         (* ;; "")

         (* ;; "FROMFILE is now a safe file or stream, possibly already open.  If it wasn't open before, we want to make sure it gets closed if/when this event gets undone.")

              (CL:UNLESS (\GETSTREAM FROMFILE 'INPUT T)
                  (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT))
                  (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                    THACTION _ :Closefile
                                                    THOLDINFO _ FROMFILE)))
              [SETQ FTSTREAM (OPENTEXTSTREAM FROMFILE NIL NIL NIL
                                    `(FONT ,(\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ TSEL)
                                           PARALOOKS
                                           ,(GETTOBJ TEXTOBJ FMTSPEC)
                                           PLAINTEXT
                                           ,PLAINTEXT]

         (* ;; "")

         (* ;; "FTSTREAM is now a text stream for the source.")

              (SETQ FSEL (TEXTSEL (TEXTOBJ FTSTREAM)))       (* ; "Select START to END")
              (\TEDIT.UPDATE.SEL FSEL (ADD1 START)
                     (IDIFFERENCE END START)
                     NIL NIL T)                              (* ; "ADD1 takes filepos to charno")
              (TEDIT.MOVE FSEL TSEL T)

         (* ;; "The exit conditions are not documented, but we set the fileptr to the end of the insertion and  return the length of the insertion.")

              (\TEXTSETFILEPTR (GETTOBJ TEXTOBJ STREAMHINT)
                     (SUB1 (GETSEL TSEL CHLIM)))
              (RETURN (GETSEL FSEL DCH))))])

(TEDIT.RAW.INCLUDE
  [LAMBDA (TSTREAM INFILE START END SAFE)                    (* ; "Edited  1-May-2023 08:46 by rmk")
                                                             (* ; 
                                                        "Edited 27-May-93 16:36 by sybalsky:mv:envos")

    (* ;; "Inserts the INFILE characters betwen START and END into TSTREAM,  treating INFILE as a plain text file.  This is a documented entry, motivated by now-silly speed considerations.  But it really amounts to just calling TEDIT.INCLUDE with a (new) PLAINTEXT flag and let the OPENTEXTSTREAM plaintext reader do its thing.  I (RMK) added the SAFE argument here, consistent with the (undocumented) SAFE argument of TEDIT.INCLUDE.")

    (TEDIT.INCLUDE TSTREAM INFILE START END SAFE T])

(TEDIT.PUT
  [LAMBDA (TSTREAM FILE FORCENEW UNFORMATTED? FORMAT)        (* ; "Edited 11-Jan-2024 23:09 by rmk")
                                                             (* ; "Edited 10-Jan-2024 10:33 by rmk")
                                                             (* ; "Edited  4-Jan-2024 23:12 by rmk")
                                                             (* ; "Edited 31-Dec-2023 00:12 by rmk")
                                                             (* ; "Edited 29-Dec-2023 00:30 by rmk")
                                                             (* ; "Edited 22-Dec-2023 10:41 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:18 by rmk")
                                                             (* ; "Edited 21-Jun-99 19:02 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:04 by jds")

    (* ;; "If the guy was editing a file, make a new updated version;  else, ask for a file name")

    (* ;; "If FILE is specd, it's used;  else the user must give us one")

    (* ;; "Returns an open stream on the file you PUT to.")

    (CL:UNLESS (\TEDIT.READONLY TSTREAM)
        (RESETLST
            (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
                   CHARSTREAM NEWPIECES PUTFN TEDIT.PUT.FINISHEDFORMS OLDEXTFORMAT NEWEXTFORMAT 
                   CONTINUE)
                  (CL:WHEN (AND (SETQ PUTFN (GETTEXTPROP TEXTOBJ 'PUTFN))
                                (EQ (APPLY* PUTFN TSTREAM (FULLNAME FILE)
                                           'BEFORE)
                                    'DON'T))

                      (* ;; "PUTFN BEFORE says it can't be saved, even though asked.  Let him know")

                      (TEDIT.PROMPTPRINT "This document cannot be saved" T T)
                      (RETURN NIL))
                  (CL:UNLESS (OR (IGREATERP (TEXTLEN TEXTOBJ)
                                        0)
                                 (TEDIT.GETINPUT TEXTOBJ "Document is empty.  Save anyway? " "Yes"))
                         (RETURN NIL))
                  (if (AND (STREAMP FILE)
                           (\GETSTREAM FILE 'OUTPUT T))
                      then (SETQ CHARSTREAM FILE)
                    else (CL:UNLESS UNFORMATTED?
                             (if (\TEDIT.FORMATTEDSTREAMP TEXTOBJ)
                                 then [SETQ UNFORMATTED?
                                       (AND (GETTEXTPROP TEXTOBJ 'CLEARGET)
                                            (EQ 'N (U-CASE (NTHCHAR (TEDIT.GETINPUT TEXTOBJ 
                                                              "Convert plaintext to formatted file? "
                                                                           "No")
                                                                  1]
                               else (SETQ UNFORMATTED? T)))
                         (CL:UNLESS FILE
                             (CL:UNLESS FORCENEW             (* ; "Forcenew for templates?")
                                 (CL:WHEN [AND (TEXTPROP TEXTOBJ 'TEMPLATE)
                                               (EQ 'N (U-CASE (NTHCHAR (TEDIT.GETINPUT TEXTOBJ 
                                                                              "Overwrite template? "
                                                                              "No")
                                                                     1]
                                     (SETQ FORCENEW 'DETEMPLATE)))
                             [SETQ FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ 
                                                                    "File to PUT to:  "
                                                                    (CL:UNLESS FORCENEW
                                                                           (\TEXTSTREAM.FILENAME
                                                                            TEXTOBJ UNFORMATTED?])
                         (CL:UNLESS FILE                     (* ; "No file to put to.")
                             (TEDIT.PROMPTPRINT TEXTOBJ "No output file--aborted" T T)
                             (RETURN)))

             (* ;; "")

             (* ;; "Ready to save. IF the external format changes, we don't want to update the current textstream.  Unlesss we figure out what the new proper piecetypes should be (FATFILE2, UTF8...).")

                  [SETQ OLDEXTFORMAT (AND (STREAMP (FGETTOBJ TEXTOBJ TXTFILE))
                                          (STREAMPROP (FGETTOBJ TEXTOBJ TXTFILE)
                                                 'FORMAT]
                  (SETQ NEWEXTFORMAT (OR FORMAT OLDEXTFORMAT :XCCS))
                  [SETQ CONTINUE (AND (EQ OLDEXTFORMAT NEWEXTFORMAT)
                                      (NOT (GETTEXTPROP TEXTOBJ 'CACHE]
                  [RESETSAVE [SETQ CHARSTREAM (OPENSTREAM FILE 'OUTPUT 'NEW
                                                     `([TYPE ,(CL:IF UNFORMATTED?
                                                                  'TEXT
                                                                  'BINARY)]
                                                       (LINELENGTH T)
                                                       (FORMAT ,NEWEXTFORMAT]
                         '(AND RESETSTATE (DELFILE (CLOSEF? OLDVALUE]
                  [RESETSAVE (\TEDIT.PUTRESET (CONS (THIS.PROCESS)
                                                    'DON'T]
                  (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT "PUTting to file " (FULLNAME CHARSTREAM)
                                                    "...")
                         T)

             (* ;; "")

             (* ;; "CHARSTREAM is open, we're ready to go.")

             (* ;; "The text part of the file is always unformatted.  If UNFORMATTED? the looks part is created but is not appended.  We fix up NEWPIECES below for continued editing in this TEXTOBJ.")

                  (SETQ NEWPIECES (\TEDIT.PUT.PCTB TEXTOBJ CHARSTREAM UNFORMATTED? CONTINUE))

             (* ;; "")

             (* ;; 
       "TEDIT.PUT.FINISHEDFORMS is not documented.  Are we supposed to supply some defined specvars?")

             (* ;; "STREAM isn't closed yet, for the benefit of the finish forms?")

                  (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))
                  (SETQ CHARSTREAM (CLOSEF CHARSTREAM))      (* ; 
                                                   "Close the output stream , below reopen for input")
                  (CL:UNLESS UNFORMATTED?                    (* ; 
                                         "Make the directory date the same as the internal Tedi date")
                      (SETFILEINFO CHARSTREAM 'ICREATIONDATE (TEDIT.FILEDATE CHARSTREAM T)))

             (* ;; "The file is written, nothing can be lost.")

             (* ;; "")

                  (TEDIT.PROMPTPRINT TEXTOBJ "done")
                  (CL:UNLESS CONTINUE (RETURN CHARSTREAM))

             (* ;; "")

             (* ;; "If we are continuing in this textobj, the new CHARSTREAM becomes the TXTFILE that backs the new pieces.  So, close the old TXTFILE, open CHARSTREAM for input, and insert the pieces that now point to it. ")

             (* ;; "Declare as type text, even if it has been specified as a binary file--could simply be an unformatted stream.")

                  (CLOSEF? (FGETTOBJ TEXTOBJ TXTFILE))
                  [SETQ CHARSTREAM (OPENSTREAM CHARSTREAM 'BOTH NIL `((TYPE TEXT)
                                                                      (FORMAT ,NEWEXTFORMAT]
                  (\SETFILEPTR CHARSTREAM 0)                 (* ; "Gets buffers set up")
                  (\TEDIT.INSERT.NEWPIECES CHARSTREAM TEXTOBJ NEWPIECES)
                  (CL:WHEN (EQ FORCENEW 'DETEMPLATE)
                      (TEXTPROP TEXTOBJ 'TEMPLATE NIL))
                  (FSETTOBJ TEXTOBJ TXTFILE CHARSTREAM)
                  (FSETTOBJ TEXTOBJ \DIRTY NIL)
                  (\TEDIT.UPDATE.TITLE TEXTOBJ CHARSTREAM)
                  (\TEDIT.HISTORYADD TEXTOBJ
                         (create TEDITHISTORYEVENT
                                THACTION _ :Put
                                THCH# _ 0
                                THLEN _ 0
                                THFIRSTPIECE _ NIL))         (* ; "Remember we did this.")
                  (CL:WHEN PUTFN
                      (APPLY* PUTFN TSTREAM (FULLNAME CHARSTREAM)
                             'AFTER))                        (* ; 
                                           "Changed to not presume CHARSTREAM is the txtfile anymore")
                  (RETURN CHARSTREAM))))])
)



(* ;; "Getting (pageframe functions on TEDIT-PAGE)")

(DEFINEQ

(\TEDIT.GET.FOREIGN.FILE
  [LAMBDA (TEXT TSTREAM START END PROPS)                     (* ; "Edited 22-Oct-2023 20:40 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:40 by rmk")
                                                             (* ; "Edited 10-Aug-2023 17:26 by rmk")
                                                             (* ; "Edited  6-Sep-2022 12:18 by rmk")
                                                             (* ; "Edited 26-Aug-2022 08:43 by rmk")
                                                             (* ; "Edited 25-Jul-2022 21:21 by rmk")

    (* ;; "If TEXT is recognized as a file in a user format, convert it into a new text stream. It could be that the foreign file is coming from a TEDIT.GET on an existing stream. There may be a window attached to TSTREAM, and that's where the edit will eventually take place.  Its dimensions are available, e.g. for width and height, but it may not yet have been initialized for TEDIT (because the source text is being installed here). ")

    (* ;; "")

    (* ;; "The foreign function returns a textstream  FSTREAM.  If FSTREAM=TSTREAM then we assume that the foreign function filled in everything completely.  If it is a different stream, then we assume that its pieces are safe and its looks are good, we copy that information back into TSTREAM.")

    (* ;; "")

    (* ;; "Either way, the foreign function guarantees that file pieces, if any, are safe wrt buffer boundaries.")

    (LET (USERFILEFORMAT USERTEMP FSTREAM FTEXTOBJ (TTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
                )

         (* ;; "Do the predicate and the converter agree that they can handle this?")

         (CL:WHEN (AND (SETQ USERFILEFORMAT (for FILETYPE in TEDIT.INPUT.FORMATS
                                               when (SETQ USERTEMP (APPLY* (CAR FILETYPE)
                                                                          TEXT TSTREAM PROPS))
                                               do (RETURN FILETYPE)))
                       (SETQ FSTREAM (APPLY* (CADR USERFILEFORMAT)
                                            TEXT TSTREAM PROPS USERTEMP START END))
                       (TEXTSTREAMP FSTREAM))                (* ; "Return NIL if we couldn't convert")
             (CL:UNLESS (EQ TSTREAM FSTREAM)
                 (SETQ FTEXTOBJ (TEXTOBJ FSTREAM))
                 (\INSERTPIECES (\FIRSTPIECE FTEXTOBJ)
                        NIL TTEXTOBJ)
                 (FSETTOBJ TTEXTOBJ LASTPIECE (FGETTOBJ FTEXTOBJ LASTPIECE))
                                                             (* ; "Last piece  have different looks")
                 (FSETTOBJ TTEXTOBJ TXTPAGEFRAMES (FGETTOBJ FTEXTOBJ TXTPAGEFRAMES))
                 (FSETTOBJ TTEXTOBJ FMTSPEC (FGETTOBJ FTEXTOBJ FMTSPEC))
                 (FSETTOBJ TTEXTOBJ DEFAULTCHARLOOKS (FGETTOBJ FTEXTOBJ DEFAULTCHARLOOKS)))
             TSTREAM)])

(\TEDIT.GET.UNFORMATTED.FILE
  [LAMBDA (STREAM TSTREAM START END PROPS)                   (* ; "Edited 29-Dec-2023 11:52 by rmk")
                                                             (* ; "Edited 27-Dec-2023 13:33 by rmk")
                                                             (* ; "Edited 22-Oct-2023 22:59 by rmk")
                                                             (* ; "Edited 12-Sep-2023 16:45 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:04 by rmk")
                                                             (* ; "Edited  3-May-2023 17:38 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:09 by rmk")
    (RESETLST
        [RESETSAVE NIL `(STREAMPROP ,STREAM ENDOFSTREAMOP ,(STREAMPROP STREAM 'ENDOFSTREAMOP
                                                                  (FUNCTION NILL]
        (\SETFILEPTR STREAM START)
        (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
              (FORMAT (STREAMPROP STREAM 'FORMAT))
              DEFAULTCHARLOOKS DEFAULTPARALOOKS PIECES)
             (PUTTEXTPROP TEXTOBJ 'CLEARGET T)
             (SETQ DEFAULTCHARLOOKS (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
             (SETQ DEFAULTPARALOOKS (GETTOBJ TEXTOBJ FMTSPEC))
             (CL:WHEN (AND (EQ FORMAT :STRING)
                           (\IOMODEP STREAM 'OUTPUT T))
                 (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))
             (SETQ PIECES
              (SELECTQ FORMAT
                  (:XCCS (\TEDIT.GET.UNFORMATTED.FILE.XCCS STREAM START END DEFAULTCHARLOOKS 
                                DEFAULTPARALOOKS))
                  (:UTF-8 (\TEDIT.GET.UNFORMATTED.FILE.UTF8 STREAM START END DEFAULTCHARLOOKS 
                                 DEFAULTPARALOOKS))
                  (:STRING (CL:WHEN (\IOMODEP STREAM 'OUTPUT T)

                               (* ;; 
            "Protect against somebody smashing the string. (Should also protect other files, but...)")

                               (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))

                           (* ;; "String format is known to be fat.  Eventually it should be sufficient to know the byesperchar of the piece to figure out the PFILEPOS byte pointers, and just use the generic \OUTCHAR to get the characters.")

                           (create PIECE
                                  PCONTENTS _ STREAM
                                  PFPOS _ START
                                  PLEN _ (FOLDLO (IDIFFERENCE END START)
                                                2)
                                  PLOOKS _ DEFAULTCHARLOOKS
                                  PPARALAST _ NIL
                                  PPARALOOKS _ DEFAULTPARALOOKS
                                  PTYPE _ FATFILE2.PTYPE
                                  PBYTESPERCHAR _ 2))
                  (create PIECE
                         PCONTENTS _ STREAM
                         PFPOS _ START
                         PLEN _ (IDIFFERENCE END START)
                         PLOOKS _ DEFAULTCHARLOOKS
                         PPARALAST _ NIL
                         PPARALOOKS _ DEFAULTPARALOOKS
                         PTYPE _ THINFILE.PTYPE
                         PBYTESPERCHAR _ 1
                         PBINABLE _ T)))
             (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES PIECES)
                    NIL TEXTOBJ)))])

(\TEDIT.GET.FORMATTED.FILE
  [LAMBDA (TEXT TSTREAM START END PROPS)                     (* ; "Edited 13-Jan-2024 09:39 by rmk")
                                                             (* ; "Edited 28-Dec-2023 20:43 by rmk")
                                                             (* ; "Edited 27-Dec-2023 13:34 by rmk")
                                                             (* ; "Edited  6-Dec-2023 19:57 by rmk")
                                                             (* ; "Edited  1-Dec-2023 22:14 by rmk")
                                                             (* ; "Edited 30-Nov-2023 00:02 by rmk")
                                                             (* ; "Edited 26-Nov-2023 00:37 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:48 by rmk")
                                                             (* ; "Edited 11-Jun-99 14:37 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:46 by jds")

    (* ;; "TEXT is an open stream that knows its external format, TEXTOBJ is the TEXTOBJ to be filled in.  If specified, START and END define the byte positions in TEXT to be included")

    (* ;; 
   "If TSTREAM is a formatted file, it is included in TEXTOBJ and TEXTOBJ is returned, otherwise NIL")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          (PCCOUNT (\TEDIT.GET.TRAILER TEXT END))
          IDATE PC)
         (CL:WHEN PCCOUNT
             (SETTOBJ TEXTOBJ TXTPAGEFRAMES NIL)
             (SELECTQ (CAR PCCOUNT)
                 (3                                          (* ; "Version 3")
                    (CL:WHEN (\TEDIT.GET.IDATE3 TEXT END)    (* ; 
                                                           "IDATE means 3.1, LINELEADING above-hack.")
                        (FSETTOBJ TEXTOBJ TXTLINELEADINGABOVE T))
                    (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES (\TEDIT.GET.PIECES3 TEXT TEXTOBJ
                                                                   (CADR PCCOUNT)
                                                                   START END))
                           NIL TEXTOBJ))
                 (2                                          (* ; "Version 2;  obsoleted 5/22/85")
                    (\TEDIT.GET.PCTB2 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END)
                    (\TEDIT.UNIQUIFY.ALL TEXTOBJ))
                 (1                                          (* ; 
                                                   "Version 1;  obsoleted at INTERMEZZO release 2/85")
                    (\TEDIT.GET.PCTB1 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END)
                    (\TEDIT.UNIQUIFY.ALL TEXTOBJ))
                 (0                                          (* ; "VERSION 0")
                    (TEDIT.GET.PCTB0 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END))
                 (SHOULDNT "File format version incompatible with this version of TEdit."))
             (CL:WHEN (SETQ PC (PREVPIECE (\LASTPIECE TEXTOBJ)))
                    (FSETPC PC PPARALAST T))
             (\TEDIT.TRANSLATE.ASCIICHARS TEXTOBJ NIL)
             TEXTOBJ)])

(\TEDIT.FORMATTEDSTREAMP
  [LAMBDA (TSTREAM)                                          (* ; "Edited 22-Sep-2023 20:17 by rmk")
                                                             (* ; "Edited 15-Sep-2023 00:09 by rmk")
                                                             (* ; "Edited 15-Aug-2023 17:35 by rmk")
                                                             (* ; "Edited 16-Sep-2022 21:00 by rmk")
                                                             (* ; "Edited  1-Sep-2022 08:54 by rmk")
                                                             (* ; "Edited 19-Apr-93 11:57 by jds")

    (* ;; 
   "Test to see if this stream's text would need a TEdit-format file (T) or is just plain text (NIL)")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM)))
         (for PC (FORMATLEVEL _ 0)
              (DEFAULTCLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
              (DEFAULTPLOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC))
              (TENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE)) inpieces (\FIRSTPIECE TEXTOBJ)
            do [COND
                  ((EQ OBJECT.PTYPE (PTYPE PC))              (* ; 
                                                             "OBJECTS require the special format")
                   (SETQ FORMATLEVEL 4)
                   (GO $$OUT))
                  ([OR (AND (PPARALAST PC)
                            (NEXTPIECE PC))
                       (NOT (EQFMTSPEC DEFAULTPLOOKS (PPARALOOKS PC]
                                                             (* ; 
                                                   "A paragraph break not at the end, or a new plook")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 3)))
                  ((OR (NOT (EQCLOOKS DEFAULTCLOOKS (PLOOKS PC)))
                       (AND TENTATIVE (PNEW PC)))            (* ; "Change in font, size, etc.")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 2)))
                  ((MEMB (PTYPE PC)
                         (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE)))
                                                             (* ; "16-bit chars in the piece")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 1]
            finally 

                  (* ;; 
             "1 originally meant NSCHARS.  But that's not a %"look%", just an external format issue.")

                  (RETURN (SELECTQ FORMATLEVEL
                              (0 NIL)
                              (2 'CHARLOOKS)
                              (3 'PARALOOKS)
                              (4 'IMAGEOBJ)
                              NIL])

(\ARBIN
  [LAMBDA (STREAM)                                           (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "13-Nov-86 20:21")
                                                             (* ; 
                                     "Read an arbitrary object from a file, parse it, and return it.")
    (PROG ((LEN (\WIN STREAM))
           USERSTR)
          (COND
             ((NOT (ZEROP LEN))
              (SETQ USERSTR (OPENSTRINGSTREAM (\STRINGIN STREAM LEN)
                                   'INPUT))
              (RETURN (PROG1 (READ USERSTR *TEDIT-FILE-READTABLE*)
                             (CLOSEF? USERSTR])

(\ATMIN
  [LAMBDA (STREAM)                                           (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-Apr-84 10:41")
    (PROG ((LEN (\WIN STREAM)))
          (RETURN (COND
                     ((ZEROP LEN)
                      NIL)
                     (T (PACK (for I from 1 to LEN collect (CHARACTER (BIN STREAM])

(\DWIN
  [LAMBDA (FILE)                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-JAN-83 16:08")
    (IPLUS (LLSH (BIN FILE)
                 24)
           (LLSH (BIN FILE)
                 16)
           (LLSH (BIN FILE)
                 8)
           (BIN FILE])

(\STRINGIN
  [LAMBDA (STREAM SETLEN)                                    (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 20-Apr-88 19:54 by jds")

         (* Read a string in length-contents form%: One word for the length, and one byte 
         per character contained. However, the length may be specified by the caller 
         instead of being read from the file.)

    (PROG ((LEN (OR SETLEN (\WIN STREAM)))
           STR)
          (SETQ STR (ALLOCSTRING LEN))
          [OR (ZEROP LEN)
              (for I from 1 to LEN do (RPLCHARCODE STR I (READCCODE STREAM]
          (RETURN STR])

(\TEDIT.GET.TRAILER
  [LAMBDA (STREAM LEN)                                       (* ; "Edited 15-Jan-2024 17:38 by rmk")
                                                             (* ; "Edited 13-Jan-2024 21:49 by rmk")

    (* ;; "For an open formatted stream, returns a list (VERSION PCCOUNT DESCPTR IDATE) where DESCPTR is the byte position of the first piece.  Returns NIL if it is not a formatted stream. Either way, the file is left at position 0 FWIW ")

    (* ;; "If STREAM is the format-stream split of a complete Tedit file, then PIECESTART is the position in that larger file that this section was taken from, and 0 in STREAM corresponds to PIECESTART in that file.  TRAILERSIZE")

    (SETQ LEN (OR LEN (GETEOFPTR STREAM)))
    (CL:WHEN (IGREATERP LEN 8)
        (LET (PIECESTART TRAILERSIZE PCCOUNT VERSION IDATE)
             (SETFILEPTR STREAM (IDIFFERENCE LEN 8))         (* ; 
                                                           "Move to start of FILEPTR to descriptions")
             (SETQ PIECESTART (\DWIN STREAM))                (* ; 
                                                             "Read the file pos of the descriptions")
             (SETQ PCCOUNT (\WIN STREAM))
             (SETQ VERSION (IDIFFERENCE (\WIN STREAM)
                                  31415))
             (PROG1 (SELECTQ VERSION
                        (3                                   (* ; "Current version")
                           (SETQ IDATE (\TEDIT.GET.IDATE3 STREAM LEN))
                           (SETQ TRAILERSIZE (IPLUS 8 (CL:IF IDATE
                                                          (IPLUS (CONSTANT (NCHARS "DATE:"))
                                                                 4)
                                                          0)))
                           (LIST VERSION PCCOUNT PIECESTART TRAILERSIZE IDATE))
                        ((2 1 0) 
                             (LIST VERSION PCCOUNT PIECESTART 8))
                        NIL)
                    (SETFILEPTR STREAM 0))))])

(\TEDIT.CACHEFILE
  [LAMBDA (TEXT TEXTOBJ START END)                           (* ; "Edited 22-Sep-2023 20:15 by rmk")
                                                             (* ; "Edited 31-Aug-2023 15:35 by rmk")
                                                             (* ; "Edited 14-Jul-2022 08:44 by rmk")

    (* ;; "If TEXT is not a random-access file, we copy it into local storage (NODIRCORE)")

    (LET (CACHE)

         (* ;; "Sets the external format and its EOL.")

         [SETQ CACHE (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((TYPE TEXT)
                                                           (:EXTERNAL-FORMAT ,(GETSTREAMPROP TEXT 
                                                                                     :EXTERNAL-FORMAT
                                                                                     ]
         (COND
            ((OR START END)
             (COPYBYTES TEXT CACHE (OR START 0)
                    (OR END -1)))
            (T (COPYBYTES TEXT CACHE)))                      (* ; "Copy the text there")

         (* ;; "COPYBYTES can only have start/end args of NIL if the file is not random access.  So it's impossible to grab out of the middle of a file on an NS server.  Sorry.")

         (CLOSEF TEXT)
         (CL:WHEN TEXTOBJ

             (* ;; 
             "REMEMBER THAT THIS TEXT WAS CACHED, SO THAT LATER PUTS DON'T INVALIDATE THE CACHE.")

             (PUTTEXTPROP TEXTOBJ 'CACHE T))
         CACHE])
)



(* ;; 
"Until CL:COMPILE-FILE and any others are updated, They should use the public TEDIT.FORMATTEDFILEP")


(MOVD? '\TEDIT.GET.TRAILER '\TEDIT.FORMATTEDP1)
(DEFINEQ

(\TEDIT.GET.PIECES3
  [LAMBDA (TEXT TEXTOBJ PCCOUNT CURFILEBYTE# END)            (* ; "Edited 14-Jan-2024 00:22 by rmk")
                                                             (* ; "Edited 11-Jan-2024 12:37 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  8-Dec-2023 22:49 by rmk")
                                                             (* ; "Edited  7-Nov-2023 13:10 by rmk")
                                                             (* ; "Edited 24-Sep-2023 22:00 by rmk")
                                                             (* ; "Edited  2-Sep-2023 11:12 by rmk")
                                                             (* ; "Edited 29-Aug-2023 00:18 by rmk")

    (* ;; "This runs through the Looks table portion of the TEXT file, gathering the looks and  installing pointers to positions in the character section of the file.  It doesn't actually examine the characters in the file.  It returns a piece chain that covers the text but that hasn't been installed in the btree.  The pieces need further adjustment for character encoding and to prevent mutlibyte characters from crossing buffer boundaries before they are installed in the btree.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                            8))
    (SETFILEPTR TEXT (\DWIN TEXT))                           (* ; "Pieceinfo byte #")
    (for PCNO PC BYTELEN PREVPC FIRSTPC PARALOOKSMAP CHARLOOKSMAP (ORIGBYTE# _ CURFILEBYTE#)
         (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
         (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) from 1 to PCCOUNT first (SETQ FIRSTPC
                                                                              (CREATE PIECE)) 
                                                             (* ; "Throw away at the end")
                                                                             (SETQ PREVPC FIRSTPC)
       do (SETQ PC NIL)                                      (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
          (SETQ BYTELEN (\DWIN TEXT))
          [SELECTC (\WIN TEXT)
              (\PieceDescriptorLOOKS                         (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ BYTELEN
                           PBYTELEN _ BYTELEN
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ THINFILE.PTYPE
                           PCHARSET _ 0
                           PBYTESPERCHAR _ 1
                           PREVPIECE _ PREVPC))
                   (\TEDIT.GET.CHARLOOKS.INDEX PC TEXT)      (* ; 
                                                             "Get its looks and character-pointers")
                   (add CURFILEBYTE# BYTELEN))
              (\PieceDescriptorPARA                          (* ; 
                                                             "Reading a new set of paragraph looks.")
                   (CL:WHEN PREVPC (FSETPC PREVPC PPARALAST T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                   (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS.INDEX TEXT))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                              "Mark the document as containing paragraph formatting ")
                   (SETTOBJ TEXTOBJ FORMATTEDP T))
              (\PieceDescriptorOBJECT 
                                      (* ;; 
                             "BYTELEN is the number of bytes on the file, PLEN is always 1 character")

                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PBYTELEN _ BYTELEN
                           PLEN _ 1
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ OBJECT.PTYPE
                           PREVPIECE _ PREVPC))
                   (TEDIT.GET.OBJECT (GETTOBJ TEXTOBJ STREAMHINT)
                          PC TEXT CURFILEBYTE#)
                   (add CURFILEBYTE# BYTELEN)
                   (FSETPC PC PLOOKS (if (ZEROP (BIN TEXT))
                                         then 
                                              (* ;; "No new looks;  steal them from the prior piece.  RMK: Goofy part of this format--we now always put out 0.")

                                              (OR (AND PREVPC (PLOOKS PREVPC))
                                                  DEFAULTCHARLOOKS)
                                       else 
                                            (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                            (\TEDIT.GET.SINGLE.CHARLOOKS TEXT))))
              (\PieceDescriptorPAGEFRAME                     (* ; 
                                                             "This is page layout info for the file")
                   (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (\TEDIT.PARSE.PAGEFRAMES (READ TEXT))))
              (\PieceDescriptorCHARLOOKSLIST                 (* ; 
                                                 "Read the list of CHARLOOKSs used in this document.")
                   (add PCNO -1)                             (* ; 
                                                             "Lists don't count, in this format.")
                   (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST TEXT))
                   [SETQ CHARLOOKSMAP (ARRAY (LENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as CHARLOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                      do (SETA CHARLOOKSMAP J CHARLOOKS)))
              (\PieceDescriptorPARALOOKSLIST                 (* ; 
                                                 "Read the list of PARALOOKSs used in this document.")
                   (add PCNO -1)                             (* ; "Lists don't count in this format")
                   (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST TEXT TEXTOBJ))
                   [SETQ PARALOOKSMAP (ARRAY (LENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as PARALOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                      do (SETA PARALOOKSMAP J PARALOOKS)))
              (PROGN (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Unknown-type piece skipped." T)
                     (SETFILEPTR TEXT (IPLUS (GETFILEPTR TEXT)
                                             (\WIN TEXT]
          (CL:WHEN PC                                        (* ; 
                                               "Chain them together without putting them in the tree")
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ PREVPC PC)) finally (SETQ PC (NEXTPIECE FIRSTPC)) 
                                                             (* ; "Throw out the dummy FIRSTPC")
                                      (FSETPC PC PREVPIECE NIL) 

                                 (* ;; "We defer filling in the actual looks to avoid requiring the mapping arrays to come before the content pieces.  This makes it easier to prepend additional pieces without parsing the whole sequence, as Lafite wants to do.")

                                      [for P inpieces PC
                                         do (CL:WHEN (SMALLP (PLOOKS P))
                                                (change (PLOOKS P)
                                                       (ELT CHARLOOKSMAP DATUM)))
                                            (CL:WHEN (SMALLP (PPARALOOKS P))
                                                (change (PPARALOOKS P)
                                                       (CL:UNLESS (EQ DATUM 0)
                                                             (* ; " For the last piece?")
                                                           (ELT PARALOOKSMAP DATUM))))]
                                      (CL:WHEN (EQ :XCCS (STREAMPROP TEXT 'FORMAT))
                                             (\TEDIT.INTERPRET.XCCS.SHIFTS PC TEXT))
                                      (RETURN PC])

(\TEDIT.MAKE.STRINGPIECE
  [LAMBDA (PC CODE)                                          (* ; "Edited 12-Jan-2024 16:34 by rmk")

    (* ;; "Makes a one character string piece modeled on PC containing CODE, and links it in the piece-chain after PC.")

    (LET ((SPIECE (create PIECE
                     using PC PTYPE _ THINSTRING.PTYPE PCONTENTS _ (ALLOCSTRING 1 CODE)
                           PLEN _ 1 PBYTESPERCHAR _ 1 PBINABLE _ 1 PBYTELEN _ 1 PREVPIECE _ PC 
                           PUTF8BYTESPERCHAR _ 1)))
         (CL:WHEN (NEXTPIECE PC)
             (FSETPC (NEXTPIECE PC)
                    PREVPIECE SPIECE))
         (FSETPC PC NEXTPIECE SPIECE)
         SPIECE])

(\TEDIT.MAKE.SAFE.PIECES
  [LAMBDA (PIECES)                                           (* ; "Edited 12-Jan-2024 09:40 by rmk")
                                                             (* ; "Edited  6-Jan-2024 13:29 by rmk")
                                                             (* ; "Edited 30-Dec-2023 11:13 by rmk")
                                                             (* ; "Edited 19-Dec-2023 13:14 by rmk")
                                                             (* ; "Edited 17-Dec-2023 23:08 by rmk")

    (* ;; "PIECES is the head of a chain of pieces that have not yet been inserted into the BTREE. We make sure here that there are no multi-byte characters on files that straddle the file's buffer boundary.  We accomplish that by splitting the piece before a character that would cross the boundary, and inserting a string piece to hold that character.")

    (CL:WHEN PIECES                                          (* ; 
                                                             "PFILE is  a stream open for input.")
        [LET [(PFILE (for PC inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                        when (\GETSTREAM (PCONTENTS PC)
                                    'INPUT T) do (RETURN (PCONTENTS PC]
             (CL:WHEN PFILE                                  (* ; "At least one file piece")
                 (\PEEKBIN PFILE T)                          (* ; " To make sure it has its buffers")
                 [for PC inpieces PIECES when (AND (EQ PFILE (PCONTENTS PC))
                                                   (IGREATERP (PBYTESPERCHAR PC)
                                                          1))
                    do 
                       (* ;; 
         "PC may have advanced to the end of a safe insertion, we have to reestablish our iteration.")

                       (SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS PC (SELECTC (PTYPE PC)
                                                                 (FATFILE2.PTYPE 
                                                                      [FUNCTION (LAMBDA (PFILE)
                                                                                  (\WIN PFILE])
                                                                 (UTF8.PTYPE (FUNCTION UTF8.INCCODEFN
                                                                              ))
                                                                 NIL])])
    PIECES])

(\TEDIT.MAKE.SAFE.BUFFERS
  [LAMBDA (PC ONECHARFN)                                     (* ; "Edited  9-Dec-2023 13:13 by rmk")
                                                             (* ; "Edited 23-Sep-2023 00:19 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  5-Sep-2023 00:00 by rmk")
                                                             (* ; "Edited 30-Aug-2023 19:09 by rmk")

    (* ;; "This chops PC into a sequence of pieces such that no piece has a character whose bytes cross a PFILE buffer boundary.  Any offending character is placed in a string piece that is linked into the chain.  The return value is the piece that holds the last characters of PC, so the caller's iteration can continue to the next problematic piece in a higher-level chain.")

    (* ;; "This works mostly on PBYTELEN using PBYTESPERCHAR for the granularity, and using PBYTESPERCHAR also to recalculate the output PLENs. PBYTELEN should be a multiple of PBYTESPERCHAR")

    (bind BYTESLEFTINBUFFER BUFPOS BUFSIZE CROSSCHAR STRINGPC PREFIXCHARS PREFIXPC (PREFIXBYTES
                                                                                    _ 0)
          (SUFFIXPC _ PC)
          (PFILE _ (PCONTENTS PC))
          (BYTESPERCHAR _ (PBYTESPERCHAR PC))
          (BYTESLEFT _ (PBYTELEN PC))
          (FPOS _ (PFPOS PC))
          (BYTELEN _ (PBYTELEN PC)) first (SETQ BUFSIZE (fetch (STREAM CBUFMAXSIZE) of PFILE))
                                          (CL:WHEN (AND (EVENP BUFSIZE BYTESPERCHAR)
                                                        (EVENP FPOS BYTESPERCHAR))

                                  (* ;; "A piece with 2-byte characters would always be aligned, for example, if PFPOS and BUFSIZE are both even--nothing to worry about.")

                                              (RETURN PC))
                                          (SETQ BUFPOS FPOS) eachtime (SETQ BYTESLEFTINBUFFER
                                                                       (IDIFFERENCE BUFSIZE
                                                                              (IREMAINDER BUFPOS 
                                                                                     BUFSIZE)))
       do (CL:WHEN (ILEQ BYTESLEFT BYTESLEFTINBUFFER)
              (CL:WHEN (FGETPC SUFFIXPC NEXTPIECE)           (* ; 
                                                            "Point the original next at its new prev")
                  (FSETPC (FGETPC SUFFIXPC NEXTPIECE)
                         PREVPIECE SUFFIXPC))
              (RETURN SUFFIXPC)) 

          (* ;; "The current SUFFIXPC has a character that crosses a buffer boundary (but maybe not the very first boundary--a prefix of 4 3-byte characters might initially align with a 512 byte buffer, but it will lose after that). We either have to extend the current piece across the next buffer (if it is aligned), or split off a file piece and a 1-character string piece.")

          (if (EVENP BYTESLEFTINBUFFER BYTESPERCHAR)
              then 
                   (* ;; "The last character doesn't cross so we don't have to split for this buffer and can continue peeling off prefixbytes from the same SUFFIXPC.  We advance BUFFPOS to the start of the next buffer, but don't advance FPOS.")

                   (* ;; "Note that when we finally run up against the boundary, rounding down to characters may back off some prefixbytes--we have to adjust for that below.")

                   (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))
                   (add BUFPOS BYTESLEFTINBUFFER)
                   (add PREFIXBYTES BYTESLEFTINBUFFER)
            else 
                 (* ;; "The current SUFFIXPC has a boundary-crossing character.  In general we have to divide it into 3 pieces")

                 (* ;; 
  "    1.  PREFIXPC represents SUFFIXPC characters before the offender, with the original ptype etc.")

                 (* ;; "    2.  STRINGPC contains the single offending character, read from the file and inserted as a string piece.")

                 (* ;; 
              "    3.  A new SUFFIXPC representing the characters remaining for the next iteration..")

                 (* ;; " PREFIXPC exists only if BYTESLEFTINBUFFER is greater than BYTESPERCHAR. If less, then it is only the string character that crosses the boundary, there are no other prefix chars. ")

                 (* ;; "Note that SUFFIXPC always carries along any properties of the original PC that might remain useful, even though PC is otherwise cannibalized. Looks, paralast, nextpiece...")

                 (* ;; "")

                 (add PREFIXBYTES BYTESLEFTINBUFFER)
                 (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))  (* ; 
                                                          "Include the last buffer, round down below")
                 (CL:WHEN (IGREATERP PREFIXBYTES BYTESPERCHAR)
                                                             (* ; 
                                                       "There is a prefix to chop off from SUFFIXPC ")
                     (SETQ PREFIXPC SUFFIXPC)
                     (SETQ PREFIXCHARS (IQUOTIENT PREFIXBYTES BYTESPERCHAR))
                     [add BYTESLEFT BYTESPERCHAR (IMINUS (IDIFFERENCE PREFIXBYTES (SETQ PREFIXBYTES
                                                                                   (ITIMES 
                                                                                          PREFIXCHARS
                                                                                          
                                                                                         BYTESPERCHAR
                                                                                          ]
                     (SETQ BUFPOS (IPLUS FPOS PREFIXBYTES))  (* ; 
                                                        "The suffix starts on a character first-byte")
                     (SETQ SUFFIXPC (create PIECE using SUFFIXPC PFPOS _ BUFPOS PBYTELEN _ BYTESLEFT
                                                        PLEN _ (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                                        PREVPIECE _ PREFIXPC))
                     (with PIECE PREFIXPC (SETQ PLEN PREFIXCHARS)
                           (SETQ PBYTELEN PREFIXBYTES)
                           (SETQ PPARALAST NIL)
                           (SETQ NEXTPIECE SUFFIXPC)))
                 (SETQ PREFIXBYTES 0) 

                 (* ;; "")

                 (* ;; 
              "SUFFIXPC now begins with a crosser--convert SUFFIXPC to a one-character string piece ")

                 (SETQ FPOS (FGETPC SUFFIXPC PFPOS))
                 (SETFILEPTR PFILE FPOS)                     (* ; "Fetch the crossing character")
                 (SETQ CROSSCHAR (APPLY* ONECHARFN PFILE))
                 (SETQ STRINGPC SUFFIXPC)
                 (add BYTESLEFT (IMINUS BYTESPERCHAR))
                 (if (IGREATERP BYTESLEFT 0)
                     then                                    (* ; 
                                                             "Create a new SUFFIXPC for the residual")
                          (add FPOS BYTESPERCHAR)            (* ; "Don't include the CROSSCHAR")
                          (SETQ SUFFIXPC
                           (create PIECE using SUFFIXPC PFPOS _ FPOS PBYTELEN _ BYTESLEFT PLEN _
                                               (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                               PREVPIECE _ STRINGPC))
                          (FSETPC STRINGPC NEXTPIECE SUFFIXPC)
                          (FSETPC STRINGPC PPARALAST NIL)
                          (SETQ BUFPOS FPOS)
                   else (SETQ SUFFIXPC NIL)) 

                 (* ;; "")

                 (* ;; 
       "Convert the previous SUFFIXPC (now STRINGPC) to a string piece containing just the CROSSCHAR")

                 (with PIECE STRINGPC (SETQ PCONTENTS (ALLOCSTRING 1 CROSSCHAR))
                       (SETQ PLEN 1)
                       (if (ILEQ CROSSCHAR 255)
                           then (SETQ PTYPE THINSTRING.PTYPE)
                                (SETQ PCHARSET 0)
                                (SETQ PBYTESPERCHAR 1)
                                (SETQ PBYTELEN 1)
                                (SETQ PBINABLE T)
                         else (SETQ PTYPE FATSTRING.PTYPE)
                              (SETQ PCHARSET \NORUNCODE)
                              (SETQ PBYTESPERCHAR 2)
                              (SETQ PBYTELEN 2)
                              (SETQ PBINABLE NIL)))
                 (CL:UNLESS SUFFIXPC                         (* ; 
                                                          "Didn't need a SUFFIXPC, end with STRINGPC")
                     (CL:WHEN (FGETPC STRINGPC NEXTPIECE)
                         (FSETPC (FGETPC STRINGPC NEXTPIECE)
                                PREVPIECE STRINGPC))
                     (RETURN STRINGPC))])
)
(DEFINEQ

(\TEDIT.GET.UNFORMATTED.FILE.XCCS
  [LAMBDA (STRM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS) (* ; "Edited 12-Jan-2024 13:13 by rmk")
                                                             (* ; "Edited 10-Jan-2024 11:19 by rmk")
                                                             (* ; "Edited  8-Jan-2024 13:15 by rmk")

    (* ;; "We build a chain of pieces  for the NS stringlets, some of which are divided at CR/LF.  ")

    (* ;; "We assume that caller has positioned the stream at the intended start byte and has set the ENDOFSTREAMOP to return NIL on EOF. ")

    (* ;; "CRBEFORE and the LF test are used to ensure that potential EOL's are normalized to EOL and appear at the end of their pieces, whether or not they we decide to make them PPARALAST on input.  LF's after CR are discarded, LF's by themselves are converted to singleton EOLstring pieces.")

    (bind (NEXTFILEPOS _ START)
          (CHARSET _ 0)
          (FIRSTPC _ (create PIECE
                            PLOOKS _ DEFAULTCHARLOOKS
                            PPARALOOKS _ DEFAULTPARALOOKS))
          (CODESIZE _ 1)
          EOLC PC BYTE CHAR PREVPC PTYPE RUNLEN FILEPOS CRBEFORE SHIFTNEXT first (SETQ PREVPC FIRSTPC
                                                                                  ) 
                                                             (* ; "FIRSTPC is a throwaway")
       do (SETQ FILEPOS NEXTFILEPOS)                         (* ; "Start of next file piece")

          (* ;; "In thin or fat mode, we have to look at the first byte of the next character, to see if it is a shift. If not a shift, we have to decode the byte configuration to make sure we can detect CR or LF.")

          (do (CL:WHEN (IGEQ NEXTFILEPOS END)
                     (RETURN))
              (SETQ BYTE (\PEEKBIN STRM T))
              (CL:WHEN (SETQ SHIFTNEXT (EQ NSCHARSETSHIFT BYTE))
                  (SETQ CHAR NIL)                            (* ; 
                                                             "Suppress CR/LF checking on real shift")
                  (RETURN))
              (BIN STRM)                                     (* ; "Not a shift, read the peeked byte")
              (SETQ CHAR (if (EQ CODESIZE 2)
                             then                            (* ; 
                                                             "Return T if this takes us over the end")
                                  (LOGOR (LLSH BYTE 8)
                                         (CL:IF (AND (ILEQ NEXTFILEPOS END)
                                                     (SETQ BYTE (BIN STRM)))
                                             BYTE
                                             (RETURN)))
                           else (LOGOR (LLSH CHARSET 8)
                                       BYTE)))
              (add NEXTFILEPOS CODESIZE)
              (CL:WHEN (MEMB CHAR (CHARCODE (CR LF)))
                     (RETURN))) 

          (* ;; "NEXTFILEPOS and file are positioned at beginning of the next piece, possibly after CR and LF have been read.")

          (SETQ RUNLEN (IDIFFERENCE NEXTFILEPOS FILEPOS))
          (CL:WHEN (EQ CHAR (CHARCODE LF))                   (* ; "We never produce raw LF's")
              (add RUNLEN (IMINUS CODESIZE)))
          (CL:WHEN (IGREATERP RUNLEN 0)
              (SETQ PTYPE (if (EQ CODESIZE 2)
                              then FATFILE2.PTYPE
                            elseif (EQ CHARSET 0)
                              then THINFILE.PTYPE
                            else FATFILE1.PTYPE))
              (SETQ PC
               (create PIECE
                      PTYPE _ PTYPE
                      PCONTENTS _ STRM
                      PFPOS _ FILEPOS
                      PLEN _ (IQUOTIENT RUNLEN CODESIZE)
                      PLOOKS _ DEFAULTCHARLOOKS
                      PPARALOOKS _ DEFAULTPARALOOKS
                      PCHARSET _ CHARSET
                      PBYTESPERCHAR _ CODESIZE
                      PBYTELEN _ RUNLEN
                      PREVPIECE _ PREVPC
                      PBINABLE _ (EQ PTYPE THINFILE.PTYPE)))
              (SETQ PREVPC (FSETPC PREVPC NEXTPIECE PC)))
          (CL:WHEN (EQ CHAR (CHARCODE LF))
              [if CRBEFORE
                  then (SETQ EOLC CRLF.EOLC)
                else 
                     (* ;; "Linefeed not preceded by CR, replace by string piece")

                     (SETQ EOLC LF.EOLC)
                     (SETQ PREVPC (\TEDIT.MAKE.STRINGPIECE PREVPC (CHARCODE EOL])
          (CL:WHEN SHIFTNEXT                                 (* ; 
                                           "Interpret and bump NEXTFILEPOS for the shifting bytes.  ")
              (BIN STRM)                                     (* ; "Read the original peeked byte")
              (SETQ CHARSET (BIN STRM))
              (if (EQ CHARSET \NORUNCODE)
                  then (CL:UNLESS (MEMB (BIN STRM)
                                        '(0 NIL))
                              (ERROR "EXPECTED PLANE 0 XCCS CHARACTER IS ILL-FORMED"))
                       (SETQ CHARSET 0)
                       (SETQ CODESIZE 2)
                else (SETQ CODESIZE 1))
              (add NEXTFILEPOS (ADD1 CODESIZE))
              (SETQ SHIFTNEXT NIL))
          (CL:WHEN (IGEQ NEXTFILEPOS END)
              (CL:WHEN EOLC                                  (* ; 
                                                             "Record the last one we encountered")
                  (replace (STREAM EOLCONVENTION) of STRM with EOLC))
              (RETURN (NEXTPIECE FIRSTPC)))
          (CL:WHEN (SETQ CRBEFORE (EQ CHAR (CHARCODE CR)))
                 (SETQ EOLC CR.EOLC])

(\TEDIT.INTERPRET.XCCS.SHIFTS
  [LAMBDA (PIECES PFILE)                                     (* ; "Edited 12-Jan-2024 23:53 by rmk")
                                                             (* ; "Edited  6-Jan-2024 15:02 by rmk")
                                                             (* ; "Edited 19-Dec-2023 13:13 by rmk")

    (* ;; "PIECES is a chain of pieces read from a formatted XCCS file but not yet inserted into the BTREE.  Each file piece has PFILE, PFPOS, and PBYTELEN.  This function interprets any XCCS shift characters that prefix the actual characters, coercing the piece properties and bumping the PFPOS/PLEN to hide the shifts. ")

    (for PC BYTE EOLC inpieces PIECES when (EQ PFILE (PCONTENTS PC))
       do (\SETFILEPTR PFILE (PFPOS PC))
          (SETQ BYTE (BIN PFILE))
          [if (EQ NSCHARSETSHIFT BYTE)
              then (SELECTC (SETQ BYTE (BIN PFILE))
                       (0 (add (PBYTELEN PC)
                               -2)                           (* ; 
                                                             "The shift characters really disappear")
                          (FSETPC PC PLEN (PBYTELEN PC))
                          (FSETPC PC PTYPE THINFILE.PTYPE)
                          (FSETPC PC PBINABLE T)
                          (FSETPC PC PCHARSET 0)
                          (add (PFPOS PC)
                               2))
                       (\NORUNCODE (CL:UNLESS (EQ 0 (BIN PFILE))
                                          (SHOULDNT "XCCS CHARACTER NOT IN PLANE 0"))
                                   (FSETPC PC PTYPE FATFILE2.PTYPE)
                                   (FSETPC PC PBYTESPERCHAR 2)
                                   (add (PFPOS PC)
                                        3)
                                   (add (PBYTELEN PC)
                                        -3)
                                   (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                          2)))
                       (PROGN 
                              (* ;; "A run in a non-zero charset.  Convert it to FATFILE1. Could also read into a FATSTRING instead, get rid of on-file FATFILE1. A string piece could hold adjacent  substrings in different charsets")

                              (add (PBYTELEN PC)
                                   -2)
                              (add (PFPOS PC)
                                   2)
                              (FSETPC PC PLEN (PBYTELEN PC))
                              (FSETPC PC PBINABLE NIL)
                              (FSETPC PC PTYPE FATFILE1.PTYPE)
                              (FSETPC PC PBYTESPERCHAR 1)
                              (FSETPC PC PCHARSET BYTE)))
            elseif (EQ 2 (PBYTESPERCHAR PC))
              then (FSETPC PC PTYPE FATFILE2.PTYPE)          (* ; "This is the continuation of an XCCS 2-byte run that was broken up presumably for looks or paragraphs")
                   (FSETPC PC PCHARSET \NORUNCODE)
                   (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                          2))
            else (FSETPC PC PCHARSET 0)                      (* ; "A charset 0 1-byte run")
                 (FSETPC PC PBINABLE T)
                 (FSETPC PC PBYTESPERCHAR 1)
                 [\SETFILEPTR PFILE (IPLUS (PFPOS PC)
                                           (SUB1 (PLEN PC]
                 (if (EQ (CHARCODE LF)
                         (SETQ BYTE (BIN PFILE)))
                     then 
                          (* ;; "First EOL approximation:  Convert trailing LF's to string-piece EOL's. This doesn't get LF's at the end of FATFILE2 or anywhere other than the end.")

                          [if (EQ (PLEN PC)
                                  1)
                              then (FSETPC PC PTYPE THINSTRING.PTYPE) 
                                                             (* ; "Convert to EOL string")
                                   (FSETPC PC PCONTENTS (ALLOCSTRING 1 (CHARCODE EOL)))
                            else (add (PLEN PC)
                                      -1)                    (* ; 
                                             "Shorten PC, add EOL string piece unless preceded by CR")
                                 (add (PBYTELEN PC)
                                      -1)
                                 (if (EQ (CHARCODE CR)
                                         (\BACKBIN PFILE))
                                     then (SETQ EOLC CRLF.EOLC)
                                   else (SETQ EOLC LF.EOLC)
                                        (SETQ PC (\TEDIT.MAKE.STRINGPIECE PC (CHARCODE EOL]
                   else (CL:WHEN (EQ BYTE (CHARCODE CR))
                               (SETQ EOLC CR.EOLC))
                        (FSETPC PC PTYPE THINFILE.PTYPE)
                        (FSETPC PC PLEN (PBYTELEN PC] finally (CL:WHEN EOLC
                                                                  (replace (STREAM EOLCONVENTION)
                                                                     of PFILE with EOLC)))
    PIECES])
)



(* ; "XCCS")

(DEFINEQ

(\TEDIT.GET.UNFORMATTED.FILE.UTF8
  [LAMBDA (STRM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS) (* ; "Edited 12-Jan-2024 13:17 by rmk")
                                                             (* ; "Edited 10-Jan-2024 10:32 by rmk")
                                                             (* ; "Edited  8-Jan-2024 12:08 by rmk")

    (* ;; "Break a UTF-8 file into pieces all of whose characters are of the same length. This is roughly the same logic of \TEDIT.GET.UNFORMATTED.FILE.XCCS.")

    (* ;; "We assume that caller has positioned the stream at the intended start byte and has set the ENDOFSTREAMOP to return NIL on EOF. ")

    (* ;; "CRBEFORE and the LF test are used to ensure that potential CR/LF's are normalized to EOL and appear at the end of their pieces, whether or not we decide to make them PPARALAST on input.  LF's after CR are discarded, LF's by themselves are converted to singleton EOLstring pieces.")

    (bind (NEXTFILEPOS _ START)
          (FIRSTPC _ (create PIECE
                            PLOOKS _ DEFAULTCHARLOOKS
                            PPARALOOKS _ DEFAULTPARALOOKS))
          (NEXTCODESIZE _ 1)
          EOLC CHAR PREVPC PTYPE RUNLEN FILEPOS CRBEFORE CODESIZE PREVCRLF first (SETQ CODESIZE 
                                                                                  NEXTCODESIZE) 
                                                             (* ; "Assume Ascii to start")
                                                                                 (SETQ PREVPC FIRSTPC
                                                                                  ) 
                                                             (* ; "FIRSTPC is a throwaway")
       do (SETQ FILEPOS NEXTFILEPOS)                         (* ; "Start of next file piece")
          (do 
              (* ;; "We stop extending if the next character wouold be out of range, go below to wrap up the final piece. ")

              (CL:WHEN (IGEQ NEXTFILEPOS END)
                     (RETURN))
              (SETQ CHAR (\PEEKBIN STRM))                    (* ; 
                                                         "Keep CHAR for CR/LF checking, error if EOF")
                                                             (* ; "Error if  invalid header")
              (SETQ NEXTCODESIZE (NUTF8CODEBYTES CHAR))
              (CL:UNLESS (EQ CODESIZE NEXTCODESIZE)          (* ; "Header byte hasn't been read")

                  (* ;; "Don't want LF processing if we split because of size change. If next is a CR/LF still in size 1, we pick it up below")

                  (SETQ CHAR NIL)
                  (RETURN))
              (SETQ NEXTCODESIZE (UTF-8.VALIDATE STRM))      (* ; "\Read/validate the trailing bytes")
              (add NEXTFILEPOS NEXTCODESIZE)
              (CL:WHEN (MEMB CHAR (CHARCODE (CR LF)))

                  (* ;; "Force a split now, after reading the CR/LF. But make sure a size change doesn't force an empty split in front of the next character.")

                  (SETQ NEXTCODESIZE (NUTF8CODEBYTES (OR (\PEEKBIN STRM)
                                                         0)))
                  (RETURN))) 

          (* ;; "")

          (* ;; "NEXTFILEPOS and file are positioned at beginning of next piece, possibly after CR and LF have been read.")

          (SETQ RUNLEN (IDIFFERENCE NEXTFILEPOS FILEPOS))
          (CL:WHEN (EQ CHAR (CHARCODE LF))                   (* ; "We never produce raw LF's")
              (add RUNLEN -1))
          (CL:WHEN (IGREATERP RUNLEN 0)
              (SETQ PTYPE (CL:IF (EQ CODESIZE 1)
                              THINFILE.PTYPE
                              UTF8.PTYPE))
              (SETQ PREVPC
               (FSETPC PREVPC NEXTPIECE
                      (create PIECE
                             PTYPE _ PTYPE
                             PCONTENTS _ STRM
                             PFPOS _ FILEPOS
                             PLEN _ (IQUOTIENT RUNLEN CODESIZE)
                             PLOOKS _ DEFAULTCHARLOOKS
                             PPARALOOKS _ DEFAULTPARALOOKS
                             PBYTESPERCHAR _ CODESIZE
                             PBYTELEN _ RUNLEN
                             PREVPIECE _ PREVPC
                             PBINABLE _ (EQ PTYPE THINFILE.PTYPE)
                             PUTF8BYTESPERCHAR _ CODESIZE))))
          (CL:WHEN (EQ CHAR (CHARCODE LF))
              [if CRBEFORE
                  then (SETQ EOLC CRLF.EOLC)
                else 
                     (* ;; "Linefeed not preceded by CR, replace by string piece")

                     (SETQ EOLC LF.EOLC)
                     (SETQ PREVPC (\TEDIT.MAKE.STRINGPIECE PREVPC (CHARCODE EOL])
          (CL:WHEN (IGEQ NEXTFILEPOS END)
              (CL:WHEN EOLC                                  (* ; 
                                                             "Record the last EOLC we encountered")
                  (replace (STREAM EOLCONVENTION) of STRM with EOLC))
              (RETURN (NEXTPIECE FIRSTPC)))
          (SETQ CODESIZE NEXTCODESIZE)
          (CL:WHEN (SETQ CRBEFORE (EQ CHAR (CHARCODE CR)))
                 (SETQ EOLC CR.EOLC])

(\TEDIT.ADJUST.EOLPIECES
  [LAMBDA (PIECES)                                           (* ; "Edited 12-Jan-2024 16:37 by rmk")
                                                             (* ; "Edited  1-Jan-2024 00:14 by rmk")
                                                             (* ; "Edited 28-Dec-2023 00:32 by rmk")

    (* ;; "This normalizes all EOL conventions to (CHARCODE EOL), essentially simulating the effect of ANY.EOLC.  It is a separate question whether resulting pieces that end in EOL are marked as PPARALAST.")

    (* ;; "PIECES is a chain of file-pieces some of which are THINFILE pieces ending in a CR or LF . A piece ending in LF is shortened to remove the LF, and a string piece with EO is inserted after it.")

    (* ;; "This assumes that (CHARCODE EOL)=(CHARCODE LF), it would need to be changed if the internal coding changes.")

    (* ;; "NOTE: If CR and LF appear as leading characters in XCCS pieces, this can be extended to deal with LF/CRs in singleton FATFILE2 pieces after \TEDIT.INTERPRET.XCCS.SHIFTS")

    [for PC NEXTPC STREAM inpieces PIECES when (EQ THINFILE.PTYPE (PTYPE PC))
       do (SETQ STREAM (PCONTENTS PC))
          [\SETFILEPTR STREAM (SUB1 (IPLUS (PFPOS PC)
                                           (PLEN PC]
          (CL:WHEN (EQ (CHARCODE LF)
                       (BIN STREAM))

              (* ;; "Convert the singleton LF file piece  to a single EOL string piece. We could flush other garbage, but it's harmless.")

              (if (EQ 1 (PLEN PC))
                  then (FSETPC PC PTYPE THINSTRING.PTYPE)    (* ; "Coerce to an EOL string piece")
                       (FSETPC PC PCONTENTS (ALLOCSTRING 1 (CHARCODE EOL)))
                else (add (PLEN PC)
                          -1)                                (* ; "Strip LF from PC's end")
                     (add (PBYTELEN PC)
                          -1)
                     (SETQ NEXTPC (NEXTPIECE PC))            (* ; "Link in a new EOLstring piece")
                     (SETQ PC (\TEDIT.MAKE.STRINGPIECE (CHARCODE EOL)
                                     PC))))]
    PIECES])
)



(* ; "UTF-8")

(DEFINEQ

(\TEDIT.GET.CHARLOOKS.LIST
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "28-Jan-85 17:50")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.CHARLOOKS FILE])

(\TEDIT.GET.SINGLE.CHARLOOKS
  [LAMBDA (FILE)                                             (* ; "Edited 21-Dec-2023 23:54 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 25-Nov-2023 23:21 by rmk")
                                                             (* ; "Edited 24-Aug-2023 15:05 by rmk")
                                                           (* ; "Edited 20-Feb-2022 12:42 by larry")
                                                             (* ; "Edited 30-May-91 20:25 by jds")

    (* ;; "Read one CHARLOOKS from FILE.  This gets and then sets the file pointer, based on the stored length.  But that won't work if the file is not random access.  Maybe that's not necessary?")

    (PROG* ((LOOKS (create CHARLOOKS))
            (FILEPOS (GETFILEPTR FILE))
            (LOOKSLEN (\WIN FILE))
            FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR)
           (SETQ NAME (\ARBIN FILE))                         (* ; "The font name")
           (SETQ SIZE (\WIN FILE))                           (* ; "Size of the type, in points")
           (SETQ SUPER (\WIN FILE))                          (* ; "Superscripting distance")
           (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                          0))
           (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE))
           (SETQ PROPS (\WIN FILE))
           (with CHARLOOKS LOOKS [SETQ CLUNBREAKABLE (NOT (ZEROP (LOGAND 4096 PROPS]
                 [SETQ CLLEADER (NOT (ZEROP (LOGAND 2048 PROPS]
                 [SETQ CLINVERTED (NOT (ZEROP (LOGAND 1024 PROPS]
                 [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                 [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                 [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                 [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                 [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                 [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                 [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                 [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                 [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                 [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                 (SETQ CLSIZE SIZE)
                 (SETQ CLOFFSET SUPER))
           [SETQ FONT (COND
                         ((LISTP NAME)                       (* ; 
                                                             "This was a font class.  Restore it.")
                          (FONTCLASS (pop NAME)
                                 NAME))
                         ((AND NAME (NOT (ZEROP SIZE)))
                          (FONTCREATE NAME SIZE (COND
                                                   ((AND (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                         (fetch (CHARLOOKS CLITAL) of LOOKS))
                                                    'BOLDITALIC)
                                                   ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                    'BOLD)
                                                   ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                                    'ITALIC]
           (replace (CHARLOOKS CLNAME) of LOOKS
              with (if (type? FONTCLASS FONT)
                       then 
                            (* ;; "Put the display family in the CLNAME spot.  Better than NIL.")

                            (CL:WHEN [SETQ NAME (FONTCOPY FONT '(DEVICE DISPLAY NOERROR T]
                                (FONTPROP NAME 'FAMILY))
                     else NAME))
           (replace (CHARLOOKS CLFONT) of LOOKS with FONT)
           (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN))
           (RETURN LOOKS])

(\TEDIT.GET.CHARLOOKS
  [LAMBDA (PC FILE LOOKSARRAY)                               (* ; "Edited 13-Jan-2024 00:01 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Sep-2023 23:31 by rmk")
                                                             (* ; "Edited 28-Aug-2023 22:19 by rmk")
                                                             (* ; "Edited 26-Aug-2023 23:22 by rmk")
                                                             (* ; "Edited 30-May-91 21:43 by jds")

    (* ;; "Set the PLOOKS for the current piece, PC, according to what the file says")

    (* ;; "We also ")

    (LET ((FLAGS (BIN FILE)))
         (FSETPC PC PLOOKS (ELT LOOKSARRAY (\WIN FILE)))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 1))
                (FSETPC PC PNEW T))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 2))                 (* ; 
                                         "XCSS FAT. It may be a continuation of a previous fat piece")
             (FSETPC PC PLEN (IQUOTIENT (FGETPC PC PLEN)
                                    2))
             (FSETPC PC PTYPE FATFILE2.PTYPE)
             (FSETPC PC PBYTESPERCHAR 2))])

(\TEDIT.GET.PARALOOKS.INDEX
  [LAMBDA (STREAM PARAHASH)                                  (* ; "Edited 13-Jan-2024 13:06 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 18-Dec-88 17:47 by jds")

    (* ;; "Reads the index of a paragraph format.  .")

    (* ;; "Index 0 indicates an end-of-file dummy, used to preserve the paralooks of EOF para break.")

    (\WIN STREAM])

(\TEDIT.GET.CHARLOOKS.INDEX
  [LAMBDA (PC FORMATSTREAM)                                  (* ; "Edited 14-Jan-2024 00:11 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Sep-2023 23:31 by rmk")
                                                             (* ; "Edited 28-Aug-2023 22:19 by rmk")
                                                             (* ; "Edited 26-Aug-2023 23:22 by rmk")
                                                             (* ; "Edited 30-May-91 21:43 by jds")

    (* ;; "Set the type, length, and and charlooks-index for the current piece, PC")

    (LET ((FLAGS (BIN FORMATSTREAM)))
         (FSETPC PC PLOOKS (\WIN FORMATSTREAM))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 1))
                (FSETPC PC PNEW T))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 2))                 (* ; 
                                         "XCSS FAT. It may be a continuation of a previous fat piece")
             (FSETPC PC PLEN (IQUOTIENT (FGETPC PC PLEN)
                                    2))
             (FSETPC PC PTYPE FATFILE2.PTYPE)
             (FSETPC PC PBYTESPERCHAR 2))])
)
(DEFINEQ

(\TEDIT.GET.PARALOOKS.LIST
  [LAMBDA (FILE TEXTOBJ)                                     (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "13-Jun-85 11:14")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.PARALOOKS FILE TEXTOBJ])

(\TEDIT.GET.SINGLE.PARALOOKS
  [LAMBDA (FILE TEXTOBJ)                                     (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:16 by rmk")
                                                             (* ; "Edited 11-Oct-2022 15:23 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:31 by sybalskY:MV:ENVOS")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           (FILEPOS (GETFILEPTR FILE))
           (LOOKSLEN (\WIN FILE))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC TABTYPE QUAD)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\WIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\WIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\WIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (SETQ QUAD (BIN FILE))
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 1))               (* ; "There are tabs to read")
              (SETQ DEFTAB (\WIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\WIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (SETQ TABTYPE
                                                                               (BIN FILE))
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (4 'DOTTEDLEFT)
                                                                         (5 'DOTTEDRIGHT)
                                                                         (6 'DOTTEDCENTERED)
                                                                         (7 'DOTTEDDECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 2))               (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\WIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTHEADINGKEEP) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTKEEP) of LOOKS with (\ARBIN FILE))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTBASETOBASE) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTREVISED) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCOLUMN) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))))
          (CL:WHEN (ILESSP (GETFILEPTR FILE)
                          (IPLUS FILEPOS LOOKSLEN))          (* ; 
                               "There is more PARALOOKS info in this piece -- we probably lost data.")
              (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Newer file version; you lost PARALOOKS info" T)
              (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN)))
          (RETURN LOOKS])

(\TEDIT.GET.PARALOOKS
  [LAMBDA (FILE PARAHASH)                                    (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 18-Dec-88 17:47 by jds")

    (* ;; "Read a paragraph format spec from the FILE, and return it for later use.")

    (* ;; "Paragraph format # of 0 indicates an end-of-file dummy, used to preserve the paralooks of EOF para break.")

    (LET ((LOOKS# (\WIN FILE)))
         (COND
            ((ZEROP LOOKS#)
             NIL)
            (T (ELT PARAHASH LOOKS#])
)
(DEFINEQ

(TEDIT.GET.OBJECT
  [LAMBDA (TSTREAM PIECE FILE CURFILEBYTE# BYTELEN)          (* ; "Edited  5-Dec-2023 12:28 by rmk")
                                                             (* ; "Edited 26-Nov-2023 10:22 by rmk")
                                                             (* ; "Edited 21-Nov-2023 17:53 by rmk")
                                                             (* ; "Edited 25-Aug-2023 23:07 by rmk")
                                                             (* ; "Edited 12-Oct-2022 14:10 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:50 by mitani")

    (* ;; "Get an object from FILE")

    (* ;; "TSTREAM =TEXTOBJ are used for the error message and (possibly for default charlooks)")

    (* ;; "CURFILEBYTE# = fileptr within the text section of the file where the object's text starts. On entry the file is positioned just before the object's GETFN in the looks section of the file. On exit, the fileptr points just after the GETFN in the looks section, after having been detoured to the text section for the getfn to read the object's data.")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM))
          FILEPTRSAVE GETFN OBJ)

         (* ;; "rrb 10-AUG-87 --- calculate the length of the image object's data.  This assumes that the file is currently pointed at the end of the data which is where the GETFN is written {I think}.")

         (* ;; "RMK:  Originally, BYTELEN was calculated here as (DIFFERENCE (GETFILEPTR FILE) CURFILEBYTE#).  But this is garbage: (GETFILEPTR FILE) is in the looks section, CURFILEBYTE# is in the text section. The caller knows the true value, now passes it in. ")

         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURFILEBYTE#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN NIL BYTELEN))
         (CL:WHEN (IMAGEOBJPROP OBJ 'UNKNOWNGETFN)           (* ; 
      "If the object has an unknown getfn property, then it's an encapsulated object.  Warn the user")
             (TEDIT.PROMPTPRINT TSTREAM (CONCAT (CL:IF (GETD (IMAGEOBJPROP OBJ 'UNKNOWNGETFN))
                                                    "Cannot read image object with GETFN "
                                                    "Image object with unknown GETFN ")
                                               (IMAGEOBJPROP OBJ 'UNKNOWNGETFN))
                    T))
         (SETFILEPTR FILE FILEPTRSAVE)
         (SETPC PIECE PCONTENTS OBJ)
         [FSETPC PIECE PLOOKS (COND
                                 ((PREVPIECE PIECE)
                                  (PLOOKS (PREVPIECE PIECE)))
                                 (T (OR (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS)
                                        (\TEDIT.UNIQUIFY.CHARLOOKS (CHARLOOKS.FROM.FONT DEFAULTFONT)
                                               TEXTOBJ]
         (FSETPC PIECE PTYPE (CL:IF (IMAGEOBJPROP OBJ 'SUBSTREAM)
                                 SUBSTREAM.PTYPE
                                 OBJECT.PTYPE))
         OBJ])
)



(* ;; "Putting (pageframe functions on TEDIT-PAGE)")

(DEFINEQ

(\TEDIT.PUT.PCTB
  [LAMBDA (TEXTOBJ CHARSTREAM FORMATSTREAM CONTINUE KEEPSEPARATE)
                                                             (* ; "Edited 13-Jan-2024 19:57 by rmk")
                                                             (* ; "Edited 27-Sep-2023 23:50 by rmk")
                                                             (* ; "Edited  7-Sep-2023 23:43 by rmk")
                                                            (* ; "Edited 30-Apr-2021 14:46 by rmk:")
                                                             (* ; "Edited 19-May-99 21:58 by rmk:")
                                                             (* ; 
                                                        "Edited 27-May-93 16:00 by sybalsky:mv:envos")

    (* ;; "Put a representation of a piece table as plaintext on CHARSTREAM, preserving font changes and paragraph looks in a binary FORMATSTREAM. If FORMATSTREAM is not a stream, a stream is created here.   FORMATSTREAM=T if an unformatted stream is desired.  In that case, the format stream, whether created here or passed in, is not appended to the end of CHARSTREAM")

    (* ;; "")

    (* ;; "The characters and objects in the pieces are put out in the plaintext CHARSTREAM.  At the end of each sequence, when the byte positions are known, the hashed look-identifiers are put out to connect the looks back to the character sequences.")

    (* ;; "")

    (* ;; "If a sequence of pieces have equivalent piece properties (same character representation (fat, thin, utf-8 size) and looks) then the the characters of those pieces are concatenated and a single looks record is posted for the whole sequence.  For example, a sequence of THINFILE THINSTRING THINFILE pieces may be collapsed if they have the same font, new, etc. (but objects always have individual pieces).  Concatenation also stops at paralast sequences. ")

    (* ;; "")

    (* ;; "PLEN is the number of characters in the piece, but they occupy different numbers of bytes depending on thin, fat, utf-8...      ")

    (* ;; "")

    (* ;; "If CONTINUE, return NEWPIECES for continued editing. NEWPIECES is the head of a  chain of new pieces that characterize the merged pieces on the file, to reestablish the correspondence between memory pieces and file pieces for continued editing. It is initialized to a throwaway dummy, and NEXTNEW slides down to link in subsequent new pieces.  If not CONTINUE, there will be no future editing in CHARSTREAM, no need to build new pieces.")

    (CL:WHEN (AND KEEPSEPARATE (NOT (STREAMP FORMATSTREAM)))
           (SHOULDNT "FORMATSTREAM not provided with KEEPSEPARATE"))
    (CL:WHEN (EQ :UTF-8 (STREAMPROP CHARSTREAM 'FORMAT))
           (\TEDIT.PUT.UTF8.SPLITPIECES TEXTOBJ))
    (for PC PREVPC CURBYTE# OLDBYTE# PFILE NEXTNEW RUNLEN PLEN (UNFORMATTED? _ (EQ FORMATSTREAM T))
         (NEWPIECES _ (CL:WHEN CONTINUE (create PIECE)))
         (PCCOUNT _ 0)
         (EDITSTENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE))
         (LOOKSHASH _ (HASHARRAY 50))
         (PARAHASH _ (HASHARRAY 50))
         (*READTABLE* _ *TEDIT-FILE-READTABLE*)
         (*PRINT-BASE* _ 10)
         (EXTFORMAT _ (GETSTREAMPROP CHARSTREAM 'FORMAT))
         (EOLC _ (fetch (STREAM EOLCONVENTION) of CHARSTREAM)) inpieces (\FIRSTPIECE TEXTOBJ)
       first (CL:UNLESS (STREAMP FORMATSTREAM)
                 [SETQ FORMATSTREAM (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((LINELENGTH ,MAX.SMALLP])
             (SETQ NEXTNEW NEWPIECES) 

             (* ;; "All the layout and looks information goes into the LOOKSTREAM, CHARSTREAM is essentally plaintext.  Unless UNFORMATTED?, APPENDEDSTREAM is appended to the end of CHARSTREAM.")

             (* ;; "It seems that PCCOUNT isn't incremented for the PARA and CHARLOOKS lists, just for the page frame and the actual document pieces.")

             (CL:WHEN (FGETTOBJ TEXTOBJ TXTPAGEFRAMES)
                 (\TEDIT.PUT.PAGEFRAMES FORMATSTREAM (FGETTOBJ TEXTOBJ TXTPAGEFRAMES))
                 (add PCCOUNT 1))
             (\TEDIT.FLUSH.UNUSED.LOOKS TEXTOBJ)
             (\TEDIT.UNIQUIFY.ALL TEXTOBJ)                   (* ; "We can now use EQ tests on looks")
             (\TEDIT.PUT.PARALOOKS.LIST FORMATSTREAM PARAHASH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST))
             (\TEDIT.PUT.CHARLOOKS.LIST FORMATSTREAM LOOKSHASH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)) 

             (* ;; "The hash-tables map char and parlooks to unique id numbers")

             (* ;; "")

             (* ;; " We're ready to put the pieces on the output file.  ")

             (SETQ CURBYTE# (ADD1 (GETFILEPTR CHARSTREAM)))  (* ; 
                                                   "Why ADD1 ? Always pointing at the %"next%" byte?")
             (SETQ OLDBYTE# CURBYTE#)
             (CHARSET CHARSTREAM 0 T) 

             (* ;; "ZEROP should never happen, but...")
 unless (ZEROP (SETQ PLEN (PLEN PC)))
       do 
          (* ;; "If there are undescribed characters and PC can't be merged with PREVPC, then finish off PREVPC by writing its character looks.  And if PREVPC was the last of a pargraph, put out its PARALOOKS.  ")

          (CL:UNLESS (OR (IEQP CURBYTE# OLDBYTE#)
                         (\TEDIT.PUT.PCTB.MERGEABLE PREVPC PC EDITSTENTATIVE EXTFORMAT TEXTOBJ))
              (SETQ RUNLEN (IDIFFERENCE CURBYTE# OLDBYTE#))
              (\TEDIT.PUT.CHARLOOKS FORMATSTREAM RUNLEN PREVPC EDITSTENTATIVE LOOKSHASH)
              (add PCCOUNT 1)

              (* ;; "We've put out all the preceding characters in a sequence of BYTELEN bytes that combined the mergeable pieces.   ")

              (CL:WHEN NEWPIECES

                  (* ;; "Unless cached, make a new piece that describes how those characters reside on CHARSTREAM, for continued editing.")

                  (SETQ NEXTNEW (\TEDIT.PUT.PCTB.NEXTNEW NEXTNEW PREVPC OLDBYTE# RUNLEN EXTFORMAT 
                                       TEXTOBJ EOLC)))
              (SETQ OLDBYTE# CURBYTE#))
          (CL:WHEN (OR (NULL PREVPC)
                       (PPARALAST PREVPC))                   (* ; 
                                            "Last piece of a paragraph terminates with its paralooks")
              (\TEDIT.PUT.PARALOOKS FORMATSTREAM PC PARAHASH)
              (add PCCOUNT 1))
          (CL:WHEN (MEMB (PTYPE PC)
                         FILE.PTYPES)
              (SETQ PFILE (PCONTENTS PC))
              (CL:UNLESS (\GETSTREAM PFILE 'INPUT T)         (* ; "Make sure the input file is open.")
                  (SETQ PFILE (\TEDIT.REOPEN.STREAM TEXTOBJ PFILE)))
              (SETFILEPTR PFILE (PFPOS PC)))
          (SELECTC (PTYPE PC)
              ((LIST THINFILE.PTYPE FATFILE1.PTYPE) 
                   [for I (CSET _ (PCHARSET PC)) from 1 to PLEN first (CHARSET CHARSTREAM CSET)
                      do (\OUTCHAR CHARSTREAM (LOGOR CSET (BIN PFILE])
              (FATFILE2.PTYPE                                (* ; 
                                             "COPYCHARS automatically deals with external formats.  ")
                   (CHARSET CHARSTREAM T)
                   (for I from 1 to PLEN do (\OUTCHAR CHARSTREAM (\WIN PFILE))))
              (THINSTRING.PTYPE                              (* ; 
                                                             "\OUTCHAR deals with external format")
                   (CHARSET CHARSTREAM 0)
                   (for CH instring (PCONTENTS PC) do (\OUTCHAR CHARSTREAM CH)))
              (FATSTRING.PTYPE                               (* ; 
                                                             "\OUTCHAR deals with external format")
                   (CHARSET CHARSTREAM T)
                   (for CH instring (PCONTENTS PC) do (\OUTCHAR CHARSTREAM CH)))
              (UTF8.PTYPE (for I from 1 to PLEN do (\OUTCHAR CHARSTREAM (UTF8.INCCODEFN PFILE))))
              (OBJECT.PTYPE                                  (* ; 
                  "It's an object, use its PUTFN. Byte positions don't matter for continued editing.")
                            (TEDIT.PUT.OBJECT PC CHARSTREAM FORMATSTREAM CURBYTE#)
                            (CL:WHEN NEWPIECES               (* ; 
                                                    "Link in the object piece, for continued editing")
                                (SETQ NEXTNEW (FSETPC NEXTNEW NEXTPIECE
                                                     (create PIECE using PC PREVPIECE _ NEXTNEW))))
                            (add PCCOUNT 1)

                            (* ;; "0 indicates that nothing special needs to be done to recover the looks of this piece, its index will be written on the next iteration.  In earlier versions the value 1 indicated that the looks were not indexed and therefore had to be written explicitly here. This byte won't be needed in the next version of the format.")

                            (BOUT FORMATSTREAM 0)

                            (* ;; "RMK: Upping OLDBYTE# suppresses the natural charlooks that ought to happen on the next iteration if we just go around the loop. But things get screwed up if we take this out, even though OLDBYTE#.  Possibly the extra 0 byte makes it think that the object is bigger than it is?  I really don't understand why it fails if this is left out.")

                            (SETQ OLDBYTE# (ADD1 (GETFILEPTR CHARSTREAM))))
              (SHOULDNT "OTHER PTYPES")) 

          (* ;; "Record the file positions of the pieces in the file, so that pieces of the current text can be redirected to their filed-equivalents. We defer this until we know that every thing has settled down.  This records thenew position of every piece, even pieces that have been merged as suffixes of earlier ones, so  updating some old pieces may cause them to point into the middle of new file pieces.The updating code has to worry about NS charset shifts and buffer-crossing.")

          (SETQ CURBYTE# (ADD1 (GETFILEPTR CHARSTREAM)))
          (SETQ PREVPC PC) finally (CL:UNLESS (IEQP OLDBYTE# CURBYTE#)
                                                             (* ; 
                                                         "The charlooks for the final piece sequence")
                                       (SETQ RUNLEN (IDIFFERENCE CURBYTE# OLDBYTE#))
                                       (\TEDIT.PUT.CHARLOOKS FORMATSTREAM RUNLEN PREVPC 
                                              EDITSTENTATIVE LOOKSHASH)
                                       (CL:WHEN NEWPIECES (\TEDIT.PUT.PCTB.NEXTNEW NEXTNEW PREVPC 
                                                                 OLDBYTE# RUNLEN EXTFORMAT TEXTOBJ 
                                                                 EOLC))
                                       (add PCCOUNT 1)) 

                                 (* ;; 
             "Do any user-specific cleanup? Never documented or implemented, assume it's a property?")

                                 (for FORM in (GETTEXTPROP TEXTOBJ 'TEDIT.PUT.FINISHEDFORMS)
                                    do (EVAL FORM)) 

                                 (* ;; "Finalize and append FORMATSTREAM unless unformatted or keepseparate (for splitting). If KEEPSEPARATE, the caller must have provided the formatstream")

                                 (\TEDIT.PUT.TRAILER FORMATSTREAM (GETFILEPTR CHARSTREAM)
                                        PCCOUNT 3)
                                 (CL:UNLESS (OR UNFORMATTED? KEEPSEPARATE)
                                     (COPYBYTES FORMATSTREAM CHARSTREAM 0 (GETEOFPTR FORMATSTREAM)))
                                 
                                 (* ;; "Throw away the dummy head of the new piece chain (NEWPIECES is NIL if not continuing). The caller must make newpieces safe and then installed them.")

                                 (RETURN (AND NEWPIECES (NEXTPIECE NEWPIECES])

(\TEDIT.PUT.TRAILER
  [LAMBDA (FORMATSTREAM PIECESTART PCCOUNT VERSION)          (* ; "Edited 13-Jan-2024 10:13 by rmk")

    (* ;; "Finalize FORMATSTREAM.  We sneak in the date here--at the end of the looks, after the last look but before the final pointers, so that it doesn't interfere with anything.  TEDIT.FILEDATE pulls it out if it's there.")

    (PRIN1 "DATE:" FORMATSTREAM)
    (\DWOUT FORMATSTREAM (IDATE))
    (\DWOUT FORMATSTREAM PIECESTART)                         (* ; "Position of the first piece")
    (\WOUT FORMATSTREAM PCCOUNT)                             (* ; 
                                                          "Number of pieces followed by the password")
    (\WOUT FORMATSTREAM (IPLUS 31415 VERSION])

(\TEDIT.PUT.PCTB.MERGEABLE
  [LAMBDA (PREVPC PC EDITSTENTATIVE EXTFORMAT TEXTOBJ)       (* ; "Edited 12-Jan-2024 09:46 by rmk")
                                                             (* ; "Edited  5-Jan-2024 11:34 by rmk")
                                                             (* ; "Edited 30-Dec-2023 00:44 by rmk")
                                                             (* ; "Edited 22-Sep-2023 10:12 by rmk")
                                                             (* ; "Edited  6-Sep-2023 00:03 by rmk")
                                                             (* ; "Edited 24-Aug-2023 11:03 by rmk")

    (* ;; "True if PREVPC and PC have enough properties in common so they can be concatenated together into a single new piece on a file.  The PPARALOOKS test allows for the possibility that different pieces in a paragraph might have different formatting (e.g. tab stops)--but that will mess up assumptions that the paragraph menu and maybe other things depend on.  Object pieces and pieces with different looks can never merge.")

    (LET ((PREVTYPE (PTYPE PREVPC))
          (PCTYPE (PTYPE PC)))
         (CL:UNLESS [OR (EQ OBJECT.PTYPE PREVTYPE)
                        (EQ OBJECT.PTYPE PCTYPE)
                        (NEQ (PLOOKS PREVPC)
                             (PLOOKS PC))
                        (NEQ (PPARALOOKS PREVPC)
                             (PPARALOOKS PC))
                        (PPARALAST PREVPC)
                        (AND EDITSTENTATIVE (NEQ (PNEW PREVPC)
                                                 (PNEW PC]

             (* ;; "PC cannot merge with PREVPC if PREVPC ends in EOL (even if not PPARALAST). (We assume here that EOL's of interest appear only in last-of-piece position.)  For some input piece types we can make the decision without bothering to look at their last character. If the destination EXTFORMAT is :UTF-8, the splitter has presumably arranged it so that EOL's only appear in thin string and file pieces.")

             [AND (SELECTQ EXTFORMAT
                      (:XCCS (SELECTC PREVTYPE
                                 ((LIST THINFILE.PTYPE THINSTRING.PTYPE) 
                                      (MEMB PCTYPE (CONSTANT (LIST THINFILE.PTYPE THINSTRING.PTYPE))))
                                 ((LIST FATFILE2.PTYPE FATSTRING.PTYPE) 
                                      (MEMB PCTYPE (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE))))
                                 NIL))
                      (:UTF-8 
                              (* ;; "UTF8 pieces with the same bytesperchar are mergeable.  We rely on \TEDIT.PUT.UTF8.SPLITPIECES to examine string pieces and split thin strings that include mixtures of Ascii and non-Ascii characters, and to split fat pieces that may contain Ascii character in 2-byte form. After splitting all pieces with the same PUTF8BYTESPERCHAR can be merged.")

                              (EQ (FGETPC PREVPC PUTF8BYTESPERCHAR)
                                  (FGETPC PC PUTF8BYTESPERCHAR)))
                      NIL)
                  (OR (EQ PREVTYPE UTF8.PTYPE)
                      (AND (EQ PREVTYPE FATFILE1.PTYPE)
                           (NEQ 0 (PCHARSET PREVPC)))
                      [AND (EQ EXTFORMAT :UTF-8)
                           (NOT (MEMB PREVTYPE (CONSTANT (LIST THINFILE.PTYPE THINSTRING.PTYPE]
                      (NEQ (MEMB (\TEDIT.PIECE.NTHCHARCODE TEXTOBJ PREVPC (SUB1 (PLEN PREVPC)))
                                 (CHARCODE (EOL LF])])

(\TEDIT.PUT.UTF8.SPLITPIECES
  [LAMBDA (TEXTOBJ)                                          (* ; "Edited 11-Jan-2024 23:29 by rmk")
                                                             (* ; "Edited  5-Jan-2024 11:37 by rmk")
                                                             (* ; "Edited 30-Dec-2023 11:27 by rmk")

    (* ;; "We are putting to a UTF-8 format file. This function splits pieces if necessary to ensure that all the characters in a piece map to Unicode characters with the same-length UTF8 encoding. That length is stored in PUTF8BYTESPERCHAR.")

    (for PC inpieces (\FIRSTPIECE TEXTOBJ)
       do (SELECTC (PTYPE PC)
              (UTF8.PTYPE (FSETPC PC PUTF8BYTESPERCHAR (PBYTESPERCHAR PC)))
              (STRING.PTYPES (for CH BPC instring (PCONTENTS PC) as I from 1
                                do 

                                 (* ;; "If BPC changes, split off and mark the prefix piece with the previous value, go back to the main loop to continue on the residual suffix piece.")

                                   (if (EQ I 1)
                                       then (SETQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE CH 
                                                                             *XCCSTOUNICODE*)))
                                            (FSETPC PC PUTF8BYTESPERCHAR BPC) 
                                                             (* ; 
                                                             "The first character defines the piece")
                                     elseif (EQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE CH 
                                                                           *XCCSTOUNICODE*)))
                                     else (\SPLITPIECE PC (SUB1 I)
                                                 TEXTOBJ)
                                          (SETQ PC (PREVPIECE PC)) 
                                                             (* ; 
                                                             "Prefix piece always exists since I>1")
                                          (FSETPC PC PUTF8BYTESPERCHAR BPC) 
                                                             (* ; 
                                                          "Mark it, iteration continues on its next.")
                                          (RETURN))))
              (THINFILE.PTYPE 
                   (CL:UNLESS (EQ :UTF-8 (GETSTREAMPROP (PCONTENTS PC)
                                                'FORMAT))    (* ; "Could be above Ascii")
                       (for I BPC (PFILE _ (PCONTENTS PC)) from 1 to (PLEN PC)
                          first (\SETFILEPTR PFILE (PFPOS PC))
                          do (if (EQ I 1)
                                 then (SETQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE (BIN PFILE)
                                                                       *XCCSTOUNICODE*)))
                                      (FSETPC PC PUTF8BYTESPERCHAR BPC)
                               elseif (EQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE (BIN PFILE)
                                                                     *XCCSTOUNICODE*)))
                               else (\SPLITPIECE PC (SUB1 I)
                                           TEXTOBJ)
                                    (SETQ PC (PREVPIECE PC))
                                    (FSETPC PC PUTF8BYTESPERCHAR BPC)
                                    (RETURN)))))
              ((LIST FATFILE2.PTYPE FATFILE1.PTYPE)          (* ; "XCCS pieces")
                   (for I BPC CH (PFILE _ (PCONTENTS PC)) from 1 to (PLEN PC)
                      first (\SETFILEPTR PFILE (PFPOS PC))
                      do (SETQ CH (LOGOR (LLSH (CL:IF (EQ FATFILE2.PTYPE (PTYPE PC))
                                                   (BIN PFILE)
                                                   (PCHARSET PC))
                                               8)
                                         (BIN PFILE)))
                         (if (EQ I 1)
                             then (SETQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE CH *XCCSTOUNICODE*)))
                                  (FSETPC PC PUTF8BYTESPERCHAR BPC)
                           elseif (EQ BPC (NUTF8CODEBYTES (UNICODE.TRANSLATE CH *XCCSTOUNICODE*)))
                           else (\SPLITPIECE PC (SUB1 I)
                                       TEXTOBJ)
                                (SETQ PC (PREVPIECE PC))
                                (FSETPC PC PUTF8BYTESPERCHAR BPC)
                                (RETURN))))
              NIL])

(\TEDIT.PUT.PCTB.NEXTNEW
  [LAMBDA (NEXTNEW PREVPC OLDBYTE# RUNLEN EXTFORMAT TEXTOBJ EOLC)
                                                             (* ; "Edited 12-Jan-2024 16:24 by rmk")
                                                             (* ; "Edited  5-Jan-2024 17:46 by rmk")
                                                             (* ; "Edited 30-Dec-2023 21:56 by rmk")

    (* ;; "This updates the piece chain for continued editing.")

    (* ;; "Note that the PCONTENTS (=  PFILE) field for these file pieces isn't filled in, that has to be done after CHARSTREAM is closed and reopened at the TEDIT.PUT level.")

    (* ;; "Note also that PREVPC is never an object piece.")

    (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW (create PIECE using PREVPC PFPOS _ (SUB1 OLDBYTE#)
                                                                PBYTELEN _ RUNLEN PREVPIECE _ NEXTNEW
                                                   )))
    (SELECTQ EXTFORMAT
        (:UTF-8 (FSETPC NEXTNEW PTYPE (CL:IF (EQ 1 (FGETPC PREVPC PUTF8BYTESPERCHAR))
                                          THINFILE.PTYPE
                                          UTF8.PTYPE))
                (FSETPC NEXTNEW PBYTESPERCHAR (FGETPC PREVPC PUTF8BYTESPERCHAR)))
        (:XCCS                                               (* ; 
                                         "String pieces can be merged with corresponding file pieces")
               (LET [(PTYPE (SELECTC (PTYPE PREVPC)
                                (THINSTRING.PTYPE 
                                     THINFILE.PTYPE)
                                (FATSTRING.PTYPE 
                                     FATFILE2.PTYPE)
                                (PTYPE PREVPC]
                    (FSETPC NEXTNEW PTYPE PTYPE)
                    (FSETPC NEXTNEW PBYTESPERCHAR (CL:IF (EQ PTYPE FATFILE2.PTYPE)
                                                      2
                                                      1))))
        (HELP "FORMAT NOT RECOGNIZED" EXTFORMAT))            (* ; 
                                                             "Accumulate PLEN across merged pieces")
    (FSETPC NEXTNEW PLEN (IQUOTIENT RUNLEN (PBYTESPERCHAR NEXTNEW)))
    (FSETPC NEXTNEW PBINABLE (EQ THINFILE.PTYPE (PTYPE NEXTNEW)))
    (CL:UNLESS (EQ EOLC CR.EOLC)
        (CL:WHEN [AND (EQ THINFILE.PTYPE (PTYPE NEXTNEW))
                      (EQ (CHARCODE EOL)
                          (\TEDIT.PIECE.NTHCHARCODE TEXTOBJ PREVPC (PLEN PREVPC]
            [if (EQ 1 (PLEN PREVPC))
                then (FSETPC NEXTNEW PTYPE THINSTRING.PTYPE)
                     (FSETPC NEXTNEW PCONTENTS (ALLOCSTRING 1 (CHARCODE EOL)))
              else (add (FGETPC NEXTNEW PLEN)
                        -1)
                   (add (FGETPC NEXTNEW PBYTELEN)
                        -1)
                   (SETQ NEXTNEW (\TEDIT.MAKE.STRINGPIECE PREVPC (CHARCODE EOL]))
    NEXTNEW])

(\TEDIT.INSERT.NEWPIECES
  [LAMBDA (STREAM TEXTOBJ NEWPIECES)                         (* ; "Edited 12-Jan-2024 21:06 by rmk")
                                                             (* ; "Edited 18-Dec-2023 17:00 by rmk")
                                                             (* ; "Edited 11-Nov-2023 16:31 by rmk")
                                                             (* ; "Edited  8-Sep-2023 16:32 by rmk")

    (* ;; "This makes the pieces and BTREE of TEXTOBJ consistent with the NEWPIECES chain and the new OFILE.  The character numbers of old and new pieces correspond, so editing should continue without updating panes, lines, or selections (which are all based on character numbers, not particular pieces).  This puts STREAM as the PFILE of each new piece, insures safety (which fixes the ptypes etc), and then installs NEWPIECES in TEXTOBJ, replacing the BTREE and pieces already there.")

    (\DTEST TEXTOBJ 'TEXTOBJ)

    (* ;; "The \SETFILEPTR translates TSTREAM's buffer parameters to the new file. ")

    (LET ((TSTREAM (GETTOBJ TEXTOBJ STREAMHINT))
          FILEPTR)
         (SETQ FILEPTR (\TEXTGETFILEPTR TSTREAM))
         (for PC inpieces NEWPIECES when (MEMB (PTYPE PC)
                                               FILE.PTYPES) do (FSETPC PC PCONTENTS STREAM))
                                                             (* ; "Non-object pieces are on OFILE")
         (SETQ NEWPIECES (\TEDIT.MAKE.SAFE.PIECES NEWPIECES))

         (* ;; "Here, finally, we toss the out-of-date pieces to install the new ones. For complete safety, the rest should be uninterruptable (although the file has just been saved, so nothing would really be lost)")

         (\MAKEPCTB TEXTOBJ)
         (\INSERTPIECES NEWPIECES NIL TEXTOBJ)               (* ; 
                                                             "Build the tree, then fix the stream")

         (* ;; "This guards agains the possiblity that a sequence of edits somehow got the positioning parameters cached in the stream out of step with the document.  This ensures that they are consistent after all the pieces have been written out.")

         (\TEXTSETFILEPTR TSTREAM (IMAX 0 (IMIN FILEPTR (FGETTOBJ TEXTOBJ TEXTLEN])

(\TEDIT.PUTRESET
  [LAMBDA (PROC&VALUE)                                       (* jds "15-May-85 16:38")
    (CONS (CAR PROC&VALUE)
          (PROCESSPROP (CAR PROC&VALUE)
                 'BEFOREEXIT
                 (CDR PROC&VALUE])

(\ARBOUT
  [LAMBDA (STREAM ITEM)                                      (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited  7-Sep-2023 09:06 by rmk")
                                                             (* ; "Edited 20-Apr-88 19:55 by jds")

    (* ;; "Write an arbitrary MKSTRING-able thing in length-contents form.  SIZE is in characters, not bytes, which is OK because \STRINGIN uses READCCODE.")

    (LET [(SIZE (AND ITEM (NCHARS ITEM T *TEDIT-FILE-READTABLE*]
         (\WOUT STREAM (OR SIZE 0))
         (OR (NOT ITEM)
             (ZEROP SIZE)
             (PRIN2 ITEM STREAM *TEDIT-FILE-READTABLE*))
         NIL])

(\ATMOUT
  [LAMBDA (STREAM ATOM)                                      (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds "30-Jan-85 14:46")
                                                             (* Write an atom's characters in 
                                                             length-contents form.)
    (\WOUT STREAM (COND
                     (ATOM (NCHARS ATOM))
                     (T 0)))
    (OR (NOT ATOM)
        (ZEROP (NCHARS ATOM))
        (for CH inatom ATOM do (\BOUT STREAM CH])

(\DWOUT
  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))
    (\BOUT FILE (LOGAND 255 NUMBER])

(\STRINGOUT
  [LAMBDA (STREAM STRING LEN)                                (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds " 1-May-84 11:58")

         (* Write a string on a file in length-contents form;
         one word for the length, and one byte per character contained.)

    (SETQ LEN (OR LEN (NCHARS STRING)))
    (\WOUT STREAM LEN)
    (OR (ZEROP LEN)
        (for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH])
)
(DEFINEQ

(\TEDIT.PUT.CHARLOOKS.LIST
  [LAMBDA (LOOKSFILE LOOKSHASH LOOKSLIST LOOKSHASH)          (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:08 by rmk")
                                                             (* jds " 5-Mar-85 15:58")
                                                             (* ; 
                                                   "Write the list of CHARLOOKSs into the font file.")

    (* ;; "Returns a hasharray that will map from a given CHARLOOKS to its index in the list.  Those position numbers are then written in the individual piece descriptions, and are used to reconstruct the piece looks when the file is read back in.  These descriptions are written in a 0-character pseudo-piece")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
                                         "No characters, marked as containing the list of CHARLOOKSs")
    (\WOUT LOOKSFILE \PieceDescriptorCHARLOOKSLIST)
    (\WOUT LOOKSFILE (FLENGTH LOOKSLIST))                    (* ; "Number of charlooks to follow")
    (for I from 1 as LOOKS in LOOKSLIST do 
                                           (* ;; 
                                        "Write each charlooks, in the order they appear in the list.")

                                           (\TEDIT.PUT.SINGLE.CHARLOOKS LOOKSFILE LOOKS)
                                           (PUTHASH LOOKS I LOOKSHASH])

(\TEDIT.PUT.SINGLE.CHARLOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 21-Dec-2023 23:54 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 26-Aug-2023 11:29 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:17 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")

    (* ;; "Put out a single CHARLOOKS description.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          (FONT (fetch (CHARLOOKS CLFONT) of LOOKS))
          LEN)
         (\WOUT FONTFILE 0)                                  (* ; 
                                                         "Reserve space for the length of this looks")
         [COND
            ((type? FONTCLASS FONT)                          (* ; 
                                         "For font classes, we need to save a list of device-FD sets")
             (\ARBOUT FONTFILE (FONTCLASSUNPARSE FONT)))
            (T                                               (* ; 
                                                            "For FONTDESCRIPTORs, do it the easy way")
               (\ATMOUT FONTFILE (FONTPROP FONT 'FAMILY]     (* ; "The font family")
         (\WOUT FONTFILE (OR (FONTPROP FONT 'SIZE)
                             0))                             (* ; "Size of the type, in points")
         (\WOUT FONTFILE (OR (fetch (CHARLOOKS CLOFFSET) of LOOKS)
                             0))                             (* ; "Super/subscripting distance")
         (COND
            ([AND (fetch (CHARLOOKS CLSTYLE) of LOOKS)
                  (NOT (ZEROP (fetch (CHARLOOKS CLSTYLE) of LOOKS]
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLSTYLE) of LOOKS)))
            (T (\WOUT FONTFILE 0)))
         (COND
            ((fetch (CHARLOOKS CLUSERINFO) of LOOKS)
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLUSERINFO) of LOOKS)))
            (T (\WOUT FONTFILE 0)))
         (\WOUT FONTFILE (LOGOR (CL:IF (fetch (CHARLOOKS CLUNBREAKABLE) of LOOKS)
                                    4096
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLLEADER) of LOOKS)
                                    2048
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLINVERTED) of LOOKS)
                                    1024
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                    512
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLITAL) of LOOKS)
                                    256
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLULINE) of LOOKS)
                                    128
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLOLINE) of LOOKS)
                                    64
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSTRIKE) of LOOKS)
                                    32
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSMALLCAP) of LOOKS)
                                    16
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLPROTECTED) of LOOKS)
                                    8
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLINVISIBLE) of LOOKS)
                                    4
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSELHERE) of LOOKS)
                                    2
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLCANCOPY) of LOOKS)
                                    1
                                    0)))

         (* ;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Go write the length field")
         (\WOUT FONTFILE LEN)                                (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.CHARLOOKS
  [LAMBDA (FORMATSTREAM BYTELEN PREVPC EDITSTENTATIVE LOOKSHARRAY)
                                                             (* ; "Edited 13-Jan-2024 16:35 by rmk")
                                                             (* ; "Edited 30-Dec-2023 16:25 by rmk")
                                                             (* ; "Edited 23-Aug-2023 22:27 by rmk")
                                                             (* ; "Edited 24-Jul-2023 17:21 by rmk")
                                                             (* ; "Edited  8-Sep-2022 22:54 by rmk")
                                                             (* ; "Edited 30-May-91 21:45 by jds")

    (* ;; "Put a description of PREVPC's charlooks into FORMATSTREAM.  The looks apply to bytes OLDBYTE# thru CURBYTE#-1")

    (\DTEST PREVPC 'PIECE)
    (\TEDIT.PUT.CHARLOOKS1 FORMATSTREAM BYTELEN (GETHASH (PLOOKS PREVPC)
                                                       LOOKSHARRAY)
           (AND EDITSTENTATIVE PREVPC (PNEW PREVPC))
           (EQ FATFILE2.PTYPE (PTYPE PREVPC])

(\TEDIT.PUT.CHARLOOKS1
  [LAMBDA (FORMATSTREAM BYTELEN CHARLOOKSINDEX NEW FAT)      (* ; "Edited 13-Jan-2024 16:36 by rmk")

    (* ;; "Put out the actual bytes to represent a piece with the indicated properties.  This is split out as a separate helper function to hide Tedit innards from Lafite when it makes its dummy piece entries (LA.ADJUST.FORMATTING).")

    (\DWOUT FORMATSTREAM BYTELEN)                            (* ; "The length of this piece run")
    (\WOUT FORMATSTREAM \PieceDescriptorLOOKS)               (* ; 
                                                             "Mark this as setting the piece's looks")

    (* ;; "Flag for newness and fatness")

    (\BOUT FORMATSTREAM (LOGOR (CL:IF NEW
                                   1
                                   0)
                               (CL:IF FAT
                                   2
                                   0)))                      (* ; "The index into the list of fonts")
    (\WOUT FORMATSTREAM CHARLOOKSINDEX])
)
(DEFINEQ

(\TEDIT.PUT.PARALOOKS.LIST
  [LAMBDA (LOOKSFILE PARAHASH PARALOOKS)                     (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:25 by rmk")
                                                             (* ; "Edited  1-Sep-87 20:34 by jds")

    (* ;; "Write out the looks in a no-characters pseudo-piece, producing a hashtable of their arbitrary indexes for future reference.")

    (\DWOUT LOOKSFILE 0)
    (\WOUT LOOKSFILE \PieceDescriptorPARALOOKSLIST)
    (\WOUT LOOKSFILE (FLENGTH PARALOOKS))
    (for I from 1 as PL in PARALOOKS do (\TEDIT.PUT.SINGLE.PARALOOKS LOOKSFILE PL)
                                        (PUTHASH PL I PARAHASH])

(\TEDIT.PUT.SINGLE.PARALOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 16-Aug-2023 22:11 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:25 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:30 by sybalskY:MV:ENVOS")

    (* ;; "Put a description of LOOKS into FILE.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          DEFTAB TABSPECS LEN)
         (\WOUT FONTFILE 0)                                  (* ; 
                                                             "Reserve space to store the look length")
         (\WOUT FONTFILE (fetch (FMTSPEC 1STLEFTMAR) of LOOKS))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEFTMAR) of LOOKS)) (* ; 
                                                          "Left margin for the rest of the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC RIGHTMAR) of LOOKS))(* ; "Right margin for the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEADBEFORE) of LOOKS))
                                                             (* ; "Leading before the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEADAFTER) of LOOKS))
                                                             (* ; "Lead after the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LINELEAD) of LOOKS))(* ; "inter-line leading")
         (SETQ DEFTAB (CAR (fetch (FMTSPEC TABSPEC) of LOOKS)))
         (SETQ TABSPECS (CDR (fetch (FMTSPEC TABSPEC) of LOOKS)))

         (* ;; "Indicate whether there are tab specs  or a default tab setting to save")

         (\BOUT FONTFILE (CL:IF (OR DEFTAB TABSPECS)
                             3
                             2))
         (\BOUT FONTFILE (SELECTQ (fetch (FMTSPEC QUAD) of LOOKS)
                             (LEFT 1)
                             (RIGHT 2)
                             ((CENTER CENTERED) 
                                  3)
                             ((JUST JUSTIFIED) 
                                  4)
                             (SHOULDNT)))
         (CL:WHEN (OR TABSPECS DEFTAB)                       (* ; "There are tab specs to save.")
             (\WOUT FONTFILE (OR DEFTAB 0))
             (CL:WHEN (IGREATERP (LENGTH TABSPECS)
                             255)
                    (SHOULDNT "Paragraph has more than 255 TABs set--can't be saved."))
             (\BOUT FONTFILE (LENGTH TABSPECS))
             [for TAB in TABSPECS do (\WOUT FONTFILE (fetch TABX of TAB)) 
                                                             (* ; "Setting and tab type.")
                                     (\BOUT FONTFILE (SELECTQ (fetch TABKIND of TAB)
                                                         (LEFT 0)
                                                         (RIGHT 1)
                                                         (CENTERED 2)
                                                         (DECIMAL 3)
                                                         (DOTTEDLEFT 4)
                                                         (DOTTEDRIGHT 5)
                                                         (DOTTEDCENTERED 
                                                              6)
                                                         (DOTTEDDECIMAL 7)
                                                         (SHOULDNT])
         (\WOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALX) of LOOKS)
                             0))
         (\WOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALY) of LOOKS)
                             0))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTUSERINFO) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARATYPE) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARASUBTYPE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTSTYLE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEAFTER) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTHEADINGKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTBASETOBASE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTREVISED) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCOLUMN) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))

(* ;;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Write the length field")
         (\WOUT FONTFILE LEN)                                (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.PARALOOKS
  [LAMBDA (LOOKSFILE PC PARAHASH)                            (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:41 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:28 by rmk")
                                                             (* ; "Edited 30-May-91 21:44 by jds")

    (* ;; 
  "Put the identifier of PC's paralooks into LOOKSFILE.  This applies to characters CH1 thru CHLIM-1")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
             "Place holder for number of characters in the piece -- really taken from the charlooks.")
    (\WOUT LOOKSFILE \PieceDescriptorPARA)                   (* ; 
                                                           "Identify this as a paragraph looks piece")
    (\WOUT LOOKSFILE (OR (FIXP PC)
                         (GETHASH (PPARALOOKS PC)
                                PARAHASH])
)
(DEFINEQ

(TEDIT.PUT.OBJECT
  [LAMBDA (PIECE CHARSTREAM FORMATSTREAM CURFILEBYTE#)       (* ; "Edited 13-Jan-2024 12:20 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 26-Aug-2023 15:13 by rmk")
                                                             (* ; "Edited 17-Jul-2023 16:39 by rmk")
                                                             (* ; "Edited  6-Aug-2022 10:02 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:49 by mitani")

    (* ;; "Given a piece which describes an object, put the object out there.")

    (LET ((OBJECT (PCONTENTS PIECE))
          (ORIGFILEPTR (GETFILEPTR FORMATSTREAM))
          BYTELEN)
         (\DWOUT FORMATSTREAM 0)                             (* ; 
                                            "Placeholder for byte-length of the object's description")
         (\WOUT FORMATSTREAM \PieceDescriptorOBJECT)         (* ; 
                                                             "Mark this as setting the piece's looks")
         (\ATMOUT FORMATSTREAM (IMAGEOBJPROP OBJECT 'GETFN)) (* ; 
                                                          "The FN to apply to reconstruct the object")
         (APPLY* (IMAGEOBJPROP OBJECT 'PUTFN)
                OBJECT CHARSTREAM)
         (SETQ BYTELEN (ADD1 (IDIFFERENCE (GETEOFPTR CHARSTREAM)
                                    CURFILEBYTE#)))
         (SETFILEPTR FORMATSTREAM ORIGFILEPTR)               (* ; 
                          "Now go back and fill in the length of the text description of the object.")
         (\DWOUT FORMATSTREAM BYTELEN)
         (SETFILEPTR FORMATSTREAM -1)                        (* ; 
                                                             "Move back to the end of the looks file")
         (CL:WHEN (RANDACCESSP CHARSTREAM)                   (* ; "And the end of CHARSTREAM")
             (SETFILEPTR CHARSTREAM -1))
         BYTELEN])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
)
(DEFINEQ

(TEDITFROMLISPSOURCE
  [LAMBDA (SOURCEFILE TSTREAM PROPS USERTEMP START END)      (* ; "Edited 25-Dec-2023 12:28 by rmk")
                                                             (* ; "Edited  5-Dec-2023 23:46 by rmk")
                                                             (* ; "Edited 26-Oct-2023 11:22 by rmk")
                                                             (* ; "Edited 22-Oct-2023 22:55 by rmk")
                                                             (* ; "Edited 22-Sep-2023 09:07 by rmk")

    (* ;; "This is called because OPENTEXTSTREAM recognized that SOURCESTREAM is a LISPSOURCEP foreign-format file.  TSTREAM may have a partially instantiated attached window with region and prompt, etc., but may not yet have the properties of a text or process.")

    (* ;; 
    "TSTREAM and its window are available to provide default looks and region for the empty stream")

    (* ;; "USERTEMP is the reader environment returned by LISPSOURCEFILEP")

    (CL:UNLESS TSTREAM
        (SETQ TSTREAM (OPENTEXTSTREAM)))

    (* ;; "An empty window for TSTREAM may already be up on the screen.  Since this conversion can take awhile, we tell the user what's going on")

    (TEDIT.PROMPTPRINT TSTREAM (CONCAT "Fetching " (FULLNAME SOURCEFILE)
                                      " ...")
           T)
    (COPY.TEXT.TO.IMAGE SOURCEFILE TSTREAM)
    (TEDIT.PROMPTCLEAR TSTREAM)
    (TEXTPROP TSTREAM 'BOUNDTABLE (TEDIT.ATOMBOUND.READTABLE (fetch (READER-ENVIRONMENT REREADTABLE)
                                                                of USERTEMP)))
    TSTREAM])
)

(ADDTOVAR TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE))

(RPAQ? *TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (4271 29125 (TEDIT.GET 4281 . 8852) (TEDIT.FORMATTEDFILEP 8854 . 9706) (TEDIT.FILEDATE 
9708 . 11236) (\TEDIT.GET.IDATE3 11238 . 12633) (TEDIT.INCLUDE 12635 . 19376) (TEDIT.RAW.INCLUDE 19378
 . 20186) (TEDIT.PUT 20188 . 29123)) (29187 47884 (\TEDIT.GET.FOREIGN.FILE 29197 . 32261) (
\TEDIT.GET.UNFORMATTED.FILE 32263 . 35816) (\TEDIT.GET.FORMATTED.FILE 35818 . 39208) (
\TEDIT.FORMATTEDSTREAMP 39210 . 41897) (\ARBIN 41899 . 42619) (\ATMIN 42621 . 43158) (\DWIN 43160 . 
43539) (\STRINGIN 43541 . 44249) (\TEDIT.GET.TRAILER 44251 . 46353) (\TEDIT.CACHEFILE 46355 . 47882)) 
(48050 70276 (\TEDIT.GET.PIECES3 48060 . 57587) (\TEDIT.MAKE.STRINGPIECE 57589 . 58293) (
\TEDIT.MAKE.SAFE.PIECES 58295 . 60866) (\TEDIT.MAKE.SAFE.BUFFERS 60868 . 70274)) (70277 81489 (
\TEDIT.GET.UNFORMATTED.FILE.XCCS 70287 . 76177) (\TEDIT.INTERPRET.XCCS.SHIFTS 76179 . 81487)) (81511 
89092 (\TEDIT.GET.UNFORMATTED.FILE.UTF8 81521 . 86867) (\TEDIT.ADJUST.EOLPIECES 86869 . 89090)) (89115
 96952 (\TEDIT.GET.CHARLOOKS.LIST 89125 . 89630) (\TEDIT.GET.SINGLE.CHARLOOKS 89632 . 93764) (
\TEDIT.GET.CHARLOOKS 93766 . 95096) (\TEDIT.GET.PARALOOKS.INDEX 95098 . 95642) (
\TEDIT.GET.CHARLOOKS.INDEX 95644 . 96950)) (96953 105012 (\TEDIT.GET.PARALOOKS.LIST 96963 . 97476) (
\TEDIT.GET.SINGLE.PARALOOKS 97478 . 104420) (\TEDIT.GET.PARALOOKS 104422 . 105010)) (105013 108411 (
TEDIT.GET.OBJECT 105023 . 108409)) (108473 137560 (\TEDIT.PUT.PCTB 108483 . 120711) (
\TEDIT.PUT.TRAILER 120713 . 121480) (\TEDIT.PUT.PCTB.MERGEABLE 121482 . 125051) (
\TEDIT.PUT.UTF8.SPLITPIECES 125053 . 129842) (\TEDIT.PUT.PCTB.NEXTNEW 129844 . 132852) (
\TEDIT.INSERT.NEWPIECES 132854 . 135158) (\TEDIT.PUTRESET 135160 . 135402) (\ARBOUT 135404 . 136128) (
\ATMOUT 136130 . 136735) (\DWOUT 136737 . 137016) (\STRINGOUT 137018 . 137558)) (137561 146380 (
\TEDIT.PUT.CHARLOOKS.LIST 137571 . 139243) (\TEDIT.PUT.SINGLE.CHARLOOKS 139245 . 144179) (
\TEDIT.PUT.CHARLOOKS 144181 . 145325) (\TEDIT.PUT.CHARLOOKS1 145327 . 146378)) (146381 154065 (
\TEDIT.PUT.PARALOOKS.LIST 146391 . 147293) (\TEDIT.PUT.SINGLE.PARALOOKS 147295 . 152990) (
\TEDIT.PUT.PARALOOKS 152992 . 154063)) (154066 156243 (TEDIT.PUT.OBJECT 154076 . 156241)) (156338 
158020 (TEDITFROMLISPSOURCE 156348 . 158018)))))
STOP
