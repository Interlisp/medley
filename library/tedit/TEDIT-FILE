(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "22-Dec-2023 10:41:33" {WMEDLEY}<library>tedit>TEDIT-FILE.;375 202238 

      :EDIT-BY rmk

      :CHANGES-TO (FNS TEDIT.PUT \TEDIT.PUT.PCTB \TEDIT.PUT.SINGLE.CHARLOOKS 
                       \TEDIT.GET.SINGLE.CHARLOOKS)
                  (VARS TEDIT-FILECOMS)

      :PREVIOUS-DATE "20-Dec-2023 10:56:08" {WMEDLEY}<library>tedit>TEDIT-FILE.;372)


(PRETTYCOMPRINT TEDIT-FILECOMS)

(RPAQQ TEDIT-FILECOMS
       ((DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (\PieceDescriptorLOOKS 0)
                                                (\PieceDescriptorOBJECT 1)
                                                (\PieceDescriptorPARA 2)
                                                (\PieceDescriptorPAGEFRAME 3)
                                                (\PieceDescriptorCHARLOOKSLIST 4)
                                                (\PieceDescriptorPARALOOKSLIST 5)
                                                (\PieceDescriptorSAFEOBJECT 6)
                                                (\PieceDescriptorMETAINFO 7)))
        (COMS 
              (* ;; "Public entries ")

              (FNS TEDIT.GET TEDIT.FORMATTEDFILEP TEDIT.FILEDATE \TEDIT.GET.IDATE3 TEDIT.INCLUDE 
                   TEDIT.RAW.INCLUDE TEDIT.PUT)
              
              (* ;; "Getting (pageframe functions on TEDIT-PAGE)")

              (FNS \TEDIT.GET.FOREIGN.FILE \TEDIT.GET.UNFORMATTED.FILE \TEDIT.GET.FORMATTED.FILE 
                   \TEDIT.FORMATTEDSTREAMP \ARBIN \ATMIN \DWIN \STRINGIN \TEDIT.FORMATTEDP1 
                   \TEDIT.CACHEFILE)
              (FNS \TEDIT.GET.PIECES3 \TEDIT.MAKE.SAFE.BUFFERS \TEDIT.MAKE.SAFE.PIECES 
                   \TEDIT.INTERPRET.XCCS.SHIFTS)
              (FNS \TEDIT.GET.UNFORMATTED.FILE.XCCS \TEDIT.GET.UNFORMATTED.FILE.UTF8)
              (FNS \TEDIT.GET.CHARLOOKS.LIST \TEDIT.GET.SINGLE.CHARLOOKS \TEDIT.GET.CHARLOOKS)
              (FNS \TEDIT.GET.PARALOOKS.LIST \TEDIT.GET.SINGLE.PARALOOKS \TEDIT.GET.PARALOOKS)
              (FNS TEDIT.GET.OBJECT))
        (COMS 
              (* ;; "Putting (pageframe functions on TEDIT-PAGE)")

              (FNS \TEDIT.PUT.PCTB \TEDIT.PUT.PCTB.MERGEABLE \TEDIT.INSERT.NEWPIECES \TEDIT.PUTRESET
                   \ARBOUT \ATMOUT \DWOUT \STRINGOUT)
              (FNS \TEDIT.PUT.CHARLOOKS.LIST \TEDIT.PUT.SINGLE.CHARLOOKS \TEDIT.PUT.CHARLOOKS)
              (FNS \TEDIT.PUT.PARALOOKS.LIST \TEDIT.PUT.SINGLE.PARALOOKS \TEDIT.PUT.PARALOOKS)
              (FNS TEDIT.PUT.OBJECT))
        (GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
        (FNS TEDITFROMLISPSOURCE)
        (ADDVARS (TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE)))
        (INITVARS (*TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))
                                                             (* ; 
                                         "For consistent reading and writing of info on TEdit files.")
               )
        (COMS 
              (* ;; 
        "For converting old incoming format.  Cutover 5/22/85 to permit looks changes in the future.")

              (FNS \TEDIT.GET.PCTB2 \TEDIT.PARSE.PAGEFRAMES2 \TEDIT.GET.CHARLOOKS.LIST2 
                   \TEDIT.GET.SINGLE.CHARLOOKS2 \TEDIT.PUT.SINGLE.PARALOOKS2 
                   \TEDIT.PUT.SINGLE.CHARLOOKS2 \TEDIT.GET.PARALOOKS.LIST2 
                   \TEDIT.GET.SINGLE.PARALOOKS2 \TEDIT.PUT.CHARLOOKS.LIST2 \TEDIT.PUT.PARALOOKS.LIST2
                   ))
        (COMS 
              (* ;; "For converting incoming old-format files (1/27/85 cutover)")

              (FNS \TEDIT.GET.PCTB1 \TEDIT.GET.PAGEFRAMES1 \TEDIT.PARSE.PAGEFRAMES1 
                   \TEDIT.GET.CHARLOOKS1 \TEDIT.GET.PARALOOKS1 TEDIT.GET.OBJECT1))
        (COMS 
              (* ;; "VERSION 0 Compatibility reading functions")

              (FNS TEDIT.GET.PCTB0 TEDIT.GET.CHARLOOKS0 TEDIT.GET.OBJECT0 TEDIT.GET.PARALOOKS0))))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ \PieceDescriptorLOOKS 0)

(RPAQQ \PieceDescriptorOBJECT 1)

(RPAQQ \PieceDescriptorPARA 2)

(RPAQQ \PieceDescriptorPAGEFRAME 3)

(RPAQQ \PieceDescriptorCHARLOOKSLIST 4)

(RPAQQ \PieceDescriptorPARALOOKSLIST 5)

(RPAQQ \PieceDescriptorSAFEOBJECT 6)

(RPAQQ \PieceDescriptorMETAINFO 7)


(CONSTANTS (\PieceDescriptorLOOKS 0)
       (\PieceDescriptorOBJECT 1)
       (\PieceDescriptorPARA 2)
       (\PieceDescriptorPAGEFRAME 3)
       (\PieceDescriptorCHARLOOKSLIST 4)
       (\PieceDescriptorPARALOOKSLIST 5)
       (\PieceDescriptorSAFEOBJECT 6)
       (\PieceDescriptorMETAINFO 7))
)
)



(* ;; "Public entries ")

(DEFINEQ

(TEDIT.GET
  [LAMBDA (TSTREAM FILE UNFORMATTED? PROPS)                  (* ; "Edited 22-Sep-2023 20:16 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:41 by rmk")
                                                             (* ; "Edited  9-Sep-2023 17:24 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:12 by jds")

    (* ;; "A new file overwrites the textstream,textobj, and window of the one being edited.  We have to make a new TEXTOBJ because we don't want the new file to inherit random properties (like READONLY etc.  (Not sure about BEING-EDITED, that may only have been used for window-creation)")

    (SETQ TSTREAM (TEXTSTREAM TSTREAM))
    (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
           FSTREAM GETFN MAINWINDOW BEINGEDITED PROC NTSTREAM NTEXTOBJ TEDITCREATED BEING-EDITED)
          (CL:WHEN [AND (GETTOBJ TEXTOBJ \DIRTY)
                        (PROGN (TEDIT.PROMPTCLEAR TEXTOBJ)
                               (NOT (MOUSECONFIRM "Not saved yet; LEFT go Get anyway." T
                                           (GETTOBJ TEXTOBJ PROMPTWINDOW]

              (* ;; "Only do the GET if he knows he'll zorch himself.")

              (RETURN))
          (CL:UNLESS FILE
              [SETQ FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ "File to GET:  "
                                                     (OR (GETTEXTPROP TEXTOBJ 'LASTGETFILENAME)
                                                         (\TEXTSTREAM.FILENAME TEXTOBJ])
          (CL:WHEN [AND (SETQ GETFN (GETTEXTPROP TEXTOBJ 'GETFN))
                        (EQ 'DON'T (APPLY* GETFN (GETTOBJ TEXTOBJ STREAMHINT)
                                          (FULLNAME FSTREAM)
                                          'BEFORE]           (* ; 
                                                      "He doesn't want this document put.  Bail out.")
              (RETURN))

     (* ;; "")

          (SETQ FSTREAM (\TEDIT.OPENTEXTFILE FILE))
          (CL:UNLESS (\GETSTREAM FSTREAM 'INPUT T)           (* ; 
                                        "Didn't find it but save the name as a hint for the next try")
              (PUTTEXTPROP TEXTOBJ 'LASTGETFILENAME FILE)
              (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FILE " not found--aborted")
                     T)
              (RETURN NIL))
          (RESETLST
              (RESETSAVE (TTYDISPLAYSTREAM (OR (AND (NEQ 'DON'T (GETTOBJ TEXTOBJ PROMPTWINDOW)
                                                         'DON'T)
                                                    (GETTOBJ TEXTOBJ PROMPTWINDOW))
                                               PROMPTWINDOW)))

              (* ;; "New file is good, clean out the old stuff")

              (\SHOWSEL (TEXTSEL TEXTOBJ)
                     NIL)
              (\TEXTCLOSEF TEXTOBJ)                          (* ; 
                                                             "Close the old files, still in TXTFILE")

              (* ;; "")

              (* ;; "Open a textstream NTSTREAM on the new file, then reconnect its textobj to the old TSTREAM and window")

              (SETQ MAINWINDOW (\TEDIT.MAINW TEXTOBJ))
              (SETQ BEING-EDITED (GETTEXTPROP TEXTOBJ 'BEING-EDITED))
              (CL:WHEN MAINWINDOW
                  (SETQ TEDITCREATED (WINDOWPROP MAINWINDOW 'TEDITCREATED)))
              (CL:WHEN UNFORMATTED?
                  (push PROPS 'CLEARGET T))
              (SETQ NTSTREAM (OPENTEXTSTREAM FSTREAM MAINWINDOW NIL NIL PROPS))
              (SETQ NTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of NTSTREAM))
              (replace (TEXTSTREAM TEXTOBJ) of TSTREAM with NTEXTOBJ)
              (SETTOBJ NTEXTOBJ STREAMHINT TSTREAM)
              (\TEXTSETFILEPTR TSTREAM 0)
              (CL:WHEN MAINWINDOW
                  (\TEDIT.UPDATE.TITLE NTEXTOBJ)
                  (WINDOWPROP MAINWINDOW 'TEDITCREATED TEDITCREATED)
                                                             (* ; "To keep the default region")
                  (WINDOWPROP MAINWINDOW 'TEXTSTREAM TSTREAM))
              (CL:WHEN BEING-EDITED (TEDIT TSTREAM)))        (* ; "find and set the title")
          (CL:WHEN GETFN
              (APPLY* GETFN TSTREAM (FULLNAME (GETTOBJ TEXTOBJ TXTFILE))
                     'AFTER))
          (RETURN TSTREAM])

(TEDIT.FORMATTEDFILEP
  [LAMBDA (FILE)                                             (* ; "Edited 12-Jul-2023 23:35 by rmk")

    (* ;; "If FILE is a Tedit formatted stream or the name of a Tedit formatted file, returns a pair consistening of its version number and piececount.  Piececount is probably useless.")

    (RESETLST
        (if (STREAMP FILE)
            then [RESETSAVE (GETFILEPTR FILE)
                        `(PROGN (SETFILEPTR ,FILE OLDVALUE]
                 (\TEDIT.FORMATTEDP1 FILE)
          else (LET (STREAM)
                    [RESETSAVE (SETQ STREAM (OPENSTREAM FILE 'INPUT))
                           `(PROGN (CLOSEF? OLDVALUE]
                    (\TEDIT.FORMATTEDP1 STREAM))))])

(TEDIT.FILEDATE
  [LAMBDA (FILE INTEGER)                                     (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  6-Dec-2023 20:11 by rmk")
                                                             (* ; "Edited 28-Sep-2023 22:47 by rmk")

    (* ;; "If FILE is a Tedit-format file, returns its save date if it is stamped in the file, otherwise its file-system creation date as an integer or string.  NIL if not a Tedit file.")

    (* ;; "FILE must be random access.  If not, then presumably we first have to fetch the last 5+4+8 bytes to someplace else.")

    (CL:WHEN FILE
        (RESETLST
            [PROG ((STREAM (\GETSTREAM FILE 'INPUT T))
                   END IDATE)
                  [if STREAM
                      then [RESETSAVE (GETFILEPTR STREAM)
                                  `(PROGN (SETFILEPTR ,STREAM OLDVALUE]
                    else (RESETSAVE (SETQ STREAM (OPENSTREAM FILE 'INPUT))
                                `(PROGN (CLOSEF? OLDVALUE]
                  (SETQ END (GETEOFPTR STREAM))
                  (CL:WHEN (IGREATERP END 8)
                      (SETFILEPTR STREAM (IDIFFERENCE END 2))(* ; "Check the password")
                      (SELECTQ (IDIFFERENCE (\WIN STREAM)
                                      31415)
                          (3 (SETQ IDATE (\TEDIT.GET.IDATE3 STREAM END)))
                          ((0 1 2))
                          (RETURN NIL))                      (* ; "Return if not recognized")
                      (CL:UNLESS IDATE
                          (SETQ IDATE (GETFILEINFO STREAM 'ICREATIONDATE)))
                      (RETURN (CL:IF INTEGER
                                  IDATE
                                  (GDATE IDATE))))]))])

(\TEDIT.GET.IDATE3
  [LAMBDA (STREAM END)                                       (* ; "Edited  6-Dec-2023 16:55 by rmk")

    (* ;; "Returns the integer IDATE for slightly updated version 3 files, otherwise NIL.  4 for the bytes of the IDATE, 8 for the header. Leaves resets to starting position (assumes an error wouldn't matter).")

    (CL:WHEN (IGREATERP END (IPLUS (CONSTANT (NCHARS "DATE:"))
                                   4 8))
        (LET ((FILEPTR (GETFILEPTR STREAM)))
             (SETFILEPTR STREAM (IDIFFERENCE END (IPLUS (CONSTANT (NCHARS "DATE:"))
                                                        4 8)))

             (* ;; 
     "DATE: is the marker for this extension to version 3 (could be removed if version is update).  ")

             (PROG1 (CL:WHEN (AND (EQ (CHARCODE D)
                                      (BIN STREAM))
                                  (EQ (CHARCODE A)
                                      (BIN STREAM))
                                  (EQ (CHARCODE T)
                                      (BIN STREAM))
                                  (EQ (CHARCODE E)
                                      (BIN STREAM))
                                  (EQ (CHARCODE %:)
                                      (BIN STREAM)))
                           (\DWIN STREAM))
                    (SETFILEPTR STREAM FILEPTR))))])

(TEDIT.INCLUDE
  [LAMBDA (TSTREAM FILE START END SAFE PLAINTEXT)            (* ; "Edited 12-Nov-2023 12:29 by rmk")
                                                             (* ; "Edited 23-Jul-2023 15:30 by rmk")
                                                             (* ; "Edited 16-Jul-2023 10:18 by rmk")
                                                             (* ; "Edited 21-Jun-2023 17:46 by rmk")
                                                            (* ; "Edited 19-May-2001 11:43 by rmk:")
                                                             (* ; 
                                                        "Edited  1-Jun-93 11:31 by sybalsky:mv:envos")

    (* ;; "Obtain a file name, and include that file's contents at the place where the caret is.")

    (* ;; "This is a documented entry, but SAFE wasn't described there and I (RMK) added PLAINTEXT to collapse with TEDIT.INCLUDE.RAW.")

    (* ;; 
   "Returns the length of the input, if the insertion happened, NIL if there was no place to put it.")

    (* ;; "")

    (* ;; "This assumes that START and END are file positions (defaulting to 0 and length), not character numbers.")

    (* ;; "")

    (* ;; "If SAFE, the caller is taking responsibility for closing FILE when its contents are no longer needed (e.g. DOC-OBJECTS inclusions).  Otherwise, the contents are copied to a NODIRCORE that is owned by this TSTREAM, and then FILE is closed here if it wasn't previously open.  (This may not be accurate, unless FILE was actually an open stream and not a name?)")

    (CL:UNLESS (\TEDIT.READONLY TSTREAM)
        (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
               TSEL FSEL WASOPEN FTSTREAM NDCSTREAM (FROMFILE FILE))
              (SETQ TSEL (TEXTSEL TEXTOBJ))
              (CL:UNLESS (GETSEL TSEL SET)
                  (TEDIT.PROMPTPRINT TEXTOBJ "Please select a destination for the included text" T)
                  (RETURN NIL))

         (* ;; "We know where the new text is supposed to go. Where is it coming from?")

              (CL:UNLESS FROMFILE
                  (SETQ FROMFILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT TEXTOBJ 
                                                             "Name of the file to include:  ")))
                  (CL:UNLESS FROMFILE
                      (TEDIT.PROMPTPRINT TEXTOBJ "No file to include--aborted]" T)
                      (RETURN)))
              (CL:UNLESS (OR (STREAMP FROMFILE)
                             (INFILEP FROMFILE))             (* ; "File not found")
                  (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT FROMFILE " not found--include aborted")
                         T T)
                  (RETURN))

         (* ;; "")

         (* ;; "Now we have the FROMFILE, which may be a stream.")

              (CL:UNLESS START (SETQ START 0))
              (CL:UNLESS END
                  (SETQ END (GETFILEINFO FILE 'LENGTH)))
              (CL:UNLESS (IGEQ END START)
                  (TEDIT.PROMPTPRINT TEXTOBJ "Negative number of characters to include--aborted" T T)
                  (RETURN))

         (* ;; "")

         (* ;; "If the caller says SAFE, he's guranteeing that the file will be there at least as long as we need it.  Otherwise, we take ownership of the information by copying it to a NODIRCORE. ")

              (CL:UNLESS SAFE
                  [if (\GETSTREAM FROMFILE 'INPUT T)
                      then (SETQ WASOPEN T)
                    else                                     (* ; 
                                                        "Wasn't open -- need to open it for input...")
                         (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT NIL '((TYPE TEXT]

                  (* ;; "Create our holding file and copy the file-section into it.")

                  (SETQ NDCSTREAM (OPENSTREAM '{NODIRCORE} 'OUTPUT 'NEW))

                  (* ;; "Have to explicitly fill in 0 and EOFPTR, because if the file was open already, NILs would only copy from current fileptr to EOF.")

                  (* ;; 
            "Use COPYBYTES for formatted files, otherwise allow natural EOL conversion to take place")

                  (if (\TEDIT.FORMATTEDP1 FROMFILE)
                      then (COPYBYTES FROMFILE NDCSTREAM START END)
                    else (COPYCHARS FROMFILE NDCSTREAM START END))
                  (CL:UNLESS WASOPEN (CLOSEF FROMFILE))      (* ; 
                                                      "If the file didn't come to us open, close it.")
                  (CLOSEF NDCSTREAM)
                  (SETQ START 0)                             (* ; 
                                                             "But we now want everything we copied")
                  (SETQ END (GETFILEINFO NDCSTREAM 'LENGTH))
                  (SETQ FROMFILE NDCSTREAM))

         (* ;; "")

         (* ;; "FROMFILE is now a safe file or stream, possibly already open.  If it wasn't open before, we want to make sure it gets closed if/when this event gets undone.")

              (CL:UNLESS (\GETSTREAM FROMFILE 'INPUT T)
                  (SETQ FROMFILE (OPENSTREAM FROMFILE 'INPUT))
                  (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                    THACTION _ :Closefile
                                                    THOLDINFO _ FROMFILE)))
              [SETQ FTSTREAM (OPENTEXTSTREAM FROMFILE NIL NIL NIL
                                    `(FONT ,(\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ TSEL)
                                           PARALOOKS
                                           ,(GETTOBJ TEXTOBJ FMTSPEC)
                                           PLAINTEXT
                                           ,PLAINTEXT]

         (* ;; "")

         (* ;; "FTSTREAM is now a text stream for the source.")

              (SETQ FSEL (TEXTSEL (TEXTOBJ FTSTREAM)))       (* ; "Select START to END")
              (\TEDIT.UPDATE.SEL FSEL (ADD1 START)
                     (IDIFFERENCE END START)
                     NIL NIL T)                              (* ; "ADD1 takes filepos to charno")
              (TEDIT.MOVE FSEL TSEL T)

         (* ;; "The exit conditions are not documented, but we set the fileptr to the end of the insertion and  return the length of the insertion.")

              (\TEXTSETFILEPTR (GETTOBJ TEXTOBJ STREAMHINT)
                     (SUB1 (GETSEL TSEL CHLIM)))
              (RETURN (GETSEL FSEL DCH))))])

(TEDIT.RAW.INCLUDE
  [LAMBDA (TSTREAM INFILE START END SAFE)                    (* ; "Edited  1-May-2023 08:46 by rmk")
                                                             (* ; 
                                                        "Edited 27-May-93 16:36 by sybalsky:mv:envos")

    (* ;; "Inserts the INFILE characters betwen START and END into TSTREAM,  treating INFILE as a plain text file.  This is a documented entry, motivated by now-silly speed considerations.  But it really amounts to just calling TEDIT.INCLUDE with a (new) PLAINTEXT flag and let the OPENTEXTSTREAM plaintext reader do its thing.  I (RMK) added the SAFE argument here, consistent with the (undocumented) SAFE argument of TEDIT.INCLUDE.")

    (TEDIT.INCLUDE TSTREAM INFILE START END SAFE T])

(TEDIT.PUT
  [LAMBDA (TSTREAM FILE FORCENEW UNFORMATTED?)               (* ; "Edited 22-Dec-2023 10:41 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:18 by rmk")
                                                             (* ; "Edited 21-Jun-99 19:02 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:04 by jds")

    (* ;; "If the guy was editing a file, make a new updated version;  else, ask for a file name")

    (* ;; "If FILE is specd, it's used;  else the user must give us one")

    (* ;; "Returns an open stream on the file you PUT to.")

    (CL:UNLESS (\TEDIT.READONLY TSTREAM)
        (RESETLST
            (PROG ((TEXTOBJ (TEXTOBJ TSTREAM))
                   CHARSTREAM NEWPIECES PUTFN TEDIT.PUT.FINISHEDFORMS)
                  (CL:WHEN (AND (SETQ PUTFN (GETTEXTPROP TEXTOBJ 'PUTFN))
                                (EQ (APPLY* PUTFN TSTREAM (FULLNAME FILE)
                                           'BEFORE)
                                    'DON'T))

                      (* ;; "PUTFN BEFORE says it can't be saved, even though asked.  Let him know")

                      (TEDIT.PROMPTPRINT "This document cannot be saved" T T)
                      (RETURN NIL))
                  (CL:UNLESS (OR (IGREATERP (TEXTLEN TEXTOBJ)
                                        0)
                                 (TEDIT.GETINPUT TEXTOBJ "Document is empty.  Save anyway? " "Yes"))
                         (RETURN NIL))
                  [if (AND (STREAMP FILE)
                           (\GETSTREAM FILE 'OUTPUT T))
                      then (SETQ CHARSTREAM FILE)
                    else (CL:UNLESS UNFORMATTED?
                             (if (\TEDIT.FORMATTEDSTREAMP TEXTOBJ)
                                 then [SETQ UNFORMATTED?
                                       (AND (GETTEXTPROP TEXTOBJ 'CLEARGET)
                                            (EQ 'N (U-CASE (NTHCHAR (TEDIT.GETINPUT TEXTOBJ 
                                                              "Convert plaintext to formatted file? "
                                                                           "No")
                                                                  1]
                               else (SETQ UNFORMATTED? T)))
                         (CL:UNLESS FILE
                             (CL:UNLESS FORCENEW             (* ; "Forcenew for templates?")
                                 (CL:WHEN [AND (TEXTPROP TEXTOBJ 'TEMPLATE)
                                               (EQ 'N (U-CASE (NTHCHAR (TEDIT.GETINPUT TEXTOBJ 
                                                                              "Overwrite template? "
                                                                              "No")
                                                                     1]
                                     (SETQ FORCENEW 'DETEMPLATE)))

                             (* ;; "Offer TXT for plaintext, TEDIT for formatted (including BRAVO)")

                             [SETQ FILE (\TEDIT.MAKEFILENAME (TEDIT.GETINPUT
                                                              TEXTOBJ "File to PUT to:  "
                                                              (CL:UNLESS FORCENEW
                                                                  (PACKFILENAME 'EXTENSION
                                                                         (CL:IF UNFORMATTED?
                                                                             'TXT
                                                                             'TEDIT)
                                                                         'BODY
                                                                         (\TEXTSTREAM.FILENAME 
                                                                                TEXTOBJ)))])
                         (CL:UNLESS FILE                     (* ; "No file to put to.")
                             (TEDIT.PROMPTPRINT TEXTOBJ "No output file--aborted" T T)
                             (RETURN))
                         (RESETSAVE [SETQ CHARSTREAM
                                     (OPENSTREAM FILE 'OUTPUT 'NEW
                                            `([TYPE ,(CL:IF UNFORMATTED?
                                                         'TEXT
                                                         'BINARY)]
                                              (LINELENGTH T]
                                '(AND RESETSTATE (DELFILE (CLOSEF? OLDVALUE]

             (* ;; "")

             (* ;; "Ready to save")

                  [RESETSAVE (\TEDIT.PUTRESET (CONS (THIS.PROCESS)
                                                    'DON'T]
                  (TEDIT.PROMPTPRINT TEXTOBJ (CONCAT "PUTting file " (FULLNAME CHARSTREAM)
                                                    "...")
                         T)

             (* ;; "CHARSTREAM is open, we're ready to go.")

             (* ;; "The text part of the file is always unformatted.  If UNFORMATTED? the looks part is created but is not appended.  We fix up NEWPIECES below for continued editing in this TEXTOBJ.")

                  (SETQ NEWPIECES (\TEDIT.PUT.PCTB TEXTOBJ CHARSTREAM UNFORMATTED?))

             (* ;; 
       "TEDIT.PUT.FINISHEDFORMS is not documented.  Are we supposed to supply some defined specvars?")

             (* ;; "STREAM isn't closed yet, for the benefit of the finish forms?")

                  (for FORM in TEDIT.PUT.FINISHEDFORMS do (EVAL FORM))
                  (SETQ CHARSTREAM (CLOSEF CHARSTREAM))      (* ; 
                                                   "Close the output stream , below reopen for input")
                  (CL:UNLESS UNFORMATTED?                    (* ; 
                                         "Make the directory date the same as the internal Tedi date")
                      (SETFILEINFO CHARSTREAM 'ICREATIONDATE (TEDIT.FILEDATE CHARSTREAM T)))

             (* ;; "The file is written, nothing can be lost.")

             (* ;; "")

             (* ;; "The rest of this is for continued editing.")

                  (CL:UNLESS (GETTEXTPROP TEXTOBJ 'CACHE)

                      (* ;; "If we are caching, then we continue to operate on the incore cache and ignore the new pieces.  Otherwise, the new CHARSTREAM becomes the TXTFILE that backs the new pieces.  So, close the old TXTFILE, open CHARSTREAM for input, and insert the pieces that now point to it. ")

                      (* ;; "Declare as type text, even if it has been specified as a binary file--could simply be an unformatted stream.")

                      (CLOSEF? (FGETTOBJ TEXTOBJ TXTFILE))
                      [SETQ CHARSTREAM (OPENSTREAM CHARSTREAM 'INPUT NIL '((TYPE TEXT]
                      (\TEDIT.INSERT.NEWPIECES CHARSTREAM TEXTOBJ NEWPIECES))
                  (CL:WHEN (EQ FORCENEW 'DETEMPLATE)
                      (TEXTPROP TEXTOBJ 'TEMPLATE NIL))
                  (FSETTOBJ TEXTOBJ TXTFILE CHARSTREAM)
                  (FSETTOBJ TEXTOBJ \DIRTY NIL)
                  (\TEDIT.UPDATE.TITLE TEXTOBJ CHARSTREAM)
                  (\TEDIT.HISTORYADD TEXTOBJ
                         (create TEDITHISTORYEVENT
                                THACTION _ :Put
                                THCH# _ 0
                                THLEN _ 0
                                THFIRSTPIECE _ NIL))         (* ; "Remember we did this.")
                  (CL:WHEN PUTFN
                      (APPLY* PUTFN TSTREAM (FULLNAME CHARSTREAM)
                             'AFTER))                        (* ; 
                                                "Changed to not presume ofile is the txtfile anymore")
                  (TEDIT.PROMPTPRINT TEXTOBJ "done")
                  (RETURN CHARSTREAM))))])
)



(* ;; "Getting (pageframe functions on TEDIT-PAGE)")

(DEFINEQ

(\TEDIT.GET.FOREIGN.FILE
  [LAMBDA (TEXT TSTREAM START END PROPS)                     (* ; "Edited 22-Oct-2023 20:40 by rmk")
                                                             (* ; "Edited 18-Sep-2023 16:40 by rmk")
                                                             (* ; "Edited 10-Aug-2023 17:26 by rmk")
                                                             (* ; "Edited  6-Sep-2022 12:18 by rmk")
                                                             (* ; "Edited 26-Aug-2022 08:43 by rmk")
                                                             (* ; "Edited 25-Jul-2022 21:21 by rmk")

    (* ;; "If TEXT is recognized as a file in a user format, convert it into a new text stream. It could be that the foreign file is coming from a TEDIT.GET on an existing stream. There may be a window attached to TSTREAM, and that's where the edit will eventually take place.  Its dimensions are available, e.g. for width and height, but it may not yet have been initialized for TEDIT (because the source text is being installed here). ")

    (* ;; "")

    (* ;; "The foreign function returns a textstream  FSTREAM.  If FSTREAM=TSTREAM then we assume that the foreign function filled in everything completely.  If it is a different stream, then we assume that its pieces are safe and its looks are good, we copy that information back into TSTREAM.")

    (* ;; "")

    (* ;; "Either way, the foreign function guarantees that file pieces, if any, are safe wrt buffer boundaries.")

    (LET (USERFILEFORMAT USERTEMP FSTREAM FTEXTOBJ (TTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
                )

         (* ;; "Do the predicate and the converter agree that they can handle this?")

         (CL:WHEN (AND (SETQ USERFILEFORMAT (for FILETYPE in TEDIT.INPUT.FORMATS
                                               when (SETQ USERTEMP (APPLY* (CAR FILETYPE)
                                                                          TEXT TSTREAM PROPS))
                                               do (RETURN FILETYPE)))
                       (SETQ FSTREAM (APPLY* (CADR USERFILEFORMAT)
                                            TEXT TSTREAM PROPS USERTEMP START END))
                       (TEXTSTREAMP FSTREAM))                (* ; "Return NIL if we couldn't convert")
             (CL:UNLESS (EQ TSTREAM FSTREAM)
                 (SETQ FTEXTOBJ (TEXTOBJ FSTREAM))
                 (\INSERTPIECES (\FIRSTPIECE FTEXTOBJ)
                        NIL TTEXTOBJ)
                 (FSETTOBJ TTEXTOBJ LASTPIECE (FGETTOBJ FTEXTOBJ LASTPIECE))
                                                             (* ; "Last piece  have different looks")
                 (FSETTOBJ TTEXTOBJ TXTPAGEFRAMES (FGETTOBJ FTEXTOBJ TXTPAGEFRAMES))
                 (FSETTOBJ TTEXTOBJ FMTSPEC (FGETTOBJ FTEXTOBJ FMTSPEC))
                 (FSETTOBJ TTEXTOBJ DEFAULTCHARLOOKS (FGETTOBJ FTEXTOBJ DEFAULTCHARLOOKS)))
             TSTREAM)])

(\TEDIT.GET.UNFORMATTED.FILE
  [LAMBDA (STREAM TSTREAM START END PROPS)                   (* ; "Edited 20-Dec-2023 10:55 by rmk")
                                                             (* ; "Edited 17-Dec-2023 22:15 by rmk")
                                                             (* ; "Edited 22-Oct-2023 22:59 by rmk")
                                                             (* ; "Edited 12-Sep-2023 16:45 by rmk")
                                                             (* ; "Edited 30-Aug-2023 23:48 by rmk")
                                                             (* ; "Edited 29-Aug-2023 21:53 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:04 by rmk")
                                                             (* ; "Edited  3-May-2023 17:38 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:09 by rmk")
    (RESETLST
        [RESETSAVE NIL `(STREAMPROP ,STREAM ENDOFSTREAMOP ,(STREAMPROP STREAM 'ENDOFSTREAMOP
                                                                  (FUNCTION NILL]
        (CL:UNLESS START (SETQ START 0))
        (CL:UNLESS END
            (SETQ END (GETEOFPTR STREAM)))
        (\SETFILEPTR STREAM START)
        (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
              (FORMAT (STREAMPROP STREAM 'FORMAT))
              DEFAULTCHARLOOKS DEFAULTPARALOOKS PIECES)
             (PUTTEXTPROP TEXTOBJ 'CLEARGET T)
             (SETQ DEFAULTCHARLOOKS (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
             (SETQ DEFAULTPARALOOKS (GETTOBJ TEXTOBJ FMTSPEC))
             (CL:WHEN (AND (EQ FORMAT :STRING)
                           (\IOMODEP STREAM 'OUTPUT T))
                 (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))
             (SETQ PIECES
              (SELECTQ FORMAT
                  (:XCCS (\TEDIT.GET.UNFORMATTED.FILE.XCCS STREAM START END DEFAULTCHARLOOKS 
                                DEFAULTPARALOOKS))
                  (:UTF-8 (\TEDIT.GET.UNFORMATTED.FILE.UTF8 STREAM START END DEFAULTCHARLOOKS 
                                 DEFAULTPARALOOKS))
                  (:STRING (CL:WHEN (\IOMODEP STREAM 'OUTPUT T)

                               (* ;; 
            "Protect against somebody smashing the string. (Should also protect other files, but...)")

                               (SETQ STREAM (COPYFILE STREAM '{NODIRCORE})))

                           (* ;; "String format is known to be fat.  Eventually it should be sufficient to know the byesperchar of the piece to figure out the PFILEPOS byte pointers, and just use the generic \OUTCHAR to get the characters.")

                           (create PIECE
                                  PCONTENTS _ STREAM
                                  PFPOS _ START
                                  PLEN _ (FOLDLO (IDIFFERENCE END START)
                                                2)
                                  PLOOKS _ DEFAULTCHARLOOKS
                                  PPARALAST _ NIL
                                  PPARALOOKS _ DEFAULTPARALOOKS
                                  PTYPE _ FATFILE2.PTYPE
                                  PEXTERNALFORMAT _ FORMAT
                                  PBYTESPERCHAR _ 2))
                  (create PIECE
                         PCONTENTS _ STREAM
                         PFPOS _ START
                         PLEN _ (IDIFFERENCE END START)
                         PLOOKS _ DEFAULTCHARLOOKS
                         PPARALAST _ NIL
                         PPARALOOKS _ DEFAULTPARALOOKS
                         PTYPE _ THINFILE.PTYPE
                         PEXTERNALFORMAT _ FORMAT
                         PBYTESPERCHAR _ 1
                         PBINABLE _ T)))
             (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES PIECES)
                    NIL TEXTOBJ)))])

(\TEDIT.GET.FORMATTED.FILE
  [LAMBDA (TEXT TSTREAM START END PROPS)                     (* ; "Edited  6-Dec-2023 19:57 by rmk")
                                                             (* ; "Edited  1-Dec-2023 22:14 by rmk")
                                                             (* ; "Edited 30-Nov-2023 00:02 by rmk")
                                                             (* ; "Edited 26-Nov-2023 00:37 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:48 by rmk")
                                                             (* ; "Edited 11-Jun-99 14:37 by rmk:")
                                                             (* ; "Edited 19-Apr-93 13:46 by jds")

    (* ;; "TEXT is an open stream that knows its external format, TEXTOBJ is the TEXTOBJ to be filled in.  If specified, START and END define the byte positions in TEXT to be included.")

    (* ;; 
   "If TSTREAM is a formatted file, it is included in TEXTOBJ and TEXTOBJ is returned, otherwise NIL")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          (PCCOUNT (\TEDIT.FORMATTEDP1 TEXT END))
          IDATE PC)
         (CL:WHEN PCCOUNT
             (SETTOBJ TEXTOBJ TXTPAGEFRAMES NIL)
             [if (OR (GETTEXTPROP TEXTOBJ 'CACHE)
                     (NOT (RANDACCESSP TEXT)))
                 then                                        (* ; 
                                    "If the file device isn't random access, cache the file locally.")
                                                             (* ; 
                                                         "Also do this if he asks for a local cache.")
                      (SETQ TEXT (\TEDIT.CACHEFILE TEXT TEXTOBJ START END)) 

                      (* ;; 
 "Since we only copied the relevant part of the file into the cache, the whole file is now relevant.")

                      (SETQ START 0)
                      (SETQ END (GETEOFPTR TEXT))
               else (CL:UNLESS START (SETQ START 0))
                    (CL:UNLESS END
                        (SETQ END (GETEOFPTR TEXT)))]
             (SELECTQ (CAR PCCOUNT)
                 (3                                          (* ; "Version 3")
                    (CL:WHEN (\TEDIT.GET.IDATE3 TEXT END)    (* ; 
                                                           "IDATE means 3.1, LINELEADING above-hack.")
                        (FSETTOBJ TEXTOBJ TXTLINELEADINGABOVE T))
                    (\INSERTPIECES (\TEDIT.MAKE.SAFE.PIECES (\TEDIT.GET.PIECES3 TEXT TEXTOBJ
                                                                   (CADR PCCOUNT)
                                                                   START END))
                           NIL TEXTOBJ))
                 (2                                          (* ; "Version 2;  obsoleted 5/22/85")
                    (\TEDIT.GET.PCTB2 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END)
                    (\TEDIT.UNIQUIFY.ALL TEXTOBJ))
                 (1                                          (* ; 
                                                   "Version 1;  obsoleted at INTERMEZZO release 2/85")
                    (\TEDIT.GET.PCTB1 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END)
                    (\TEDIT.UNIQUIFY.ALL TEXTOBJ))
                 (0                                          (* ; "VERSION 0")
                    (TEDIT.GET.PCTB0 TEXT TEXTOBJ (CADR PCCOUNT)
                           START END))
                 (SHOULDNT "File format version incompatible with this version of TEdit."))
             (CL:WHEN (SETQ PC (PREVPIECE (\LASTPIECE TEXTOBJ)))
                    (FSETPC PC PPARALAST T))
             (\TEDIT.TRANSLATE.ASCIICHARS TEXTOBJ NIL)
             TEXTOBJ)])

(\TEDIT.FORMATTEDSTREAMP
  [LAMBDA (TSTREAM)                                          (* ; "Edited 22-Sep-2023 20:17 by rmk")
                                                             (* ; "Edited 15-Sep-2023 00:09 by rmk")
                                                             (* ; "Edited 15-Aug-2023 17:35 by rmk")
                                                             (* ; "Edited 16-Sep-2022 21:00 by rmk")
                                                             (* ; "Edited  1-Sep-2022 08:54 by rmk")
                                                             (* ; "Edited 19-Apr-93 11:57 by jds")

    (* ;; 
   "Test to see if this stream's text would need a TEdit-format file (T) or is just plain text (NIL)")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM)))
         (for PC (FORMATLEVEL _ 0)
              (DEFAULTCLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
              (DEFAULTPLOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC))
              (TENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE)) inpieces (\FIRSTPIECE TEXTOBJ)
            do [COND
                  ((EQ OBJECT.PTYPE (PTYPE PC))              (* ; 
                                                             "OBJECTS require the special format")
                   (SETQ FORMATLEVEL 4)
                   (GO $$OUT))
                  ([OR (AND (PPARALAST PC)
                            (NEXTPIECE PC))
                       (NOT (EQFMTSPEC DEFAULTPLOOKS (PPARALOOKS PC]
                                                             (* ; 
                                                   "A paragraph break not at the end, or a new plook")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 3)))
                  ((OR (NOT (EQCLOOKS DEFAULTCLOOKS (PLOOKS PC)))
                       (AND TENTATIVE (PNEW PC)))            (* ; "Change in font, size, etc.")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 2)))
                  ((MEMB (PTYPE PC)
                         (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE)))
                                                             (* ; "16-bit chars in the piece")
                   (SETQ FORMATLEVEL (IMAX FORMATLEVEL 1]
            finally 

                  (* ;; 
             "1 originally meant NSCHARS.  But that's not a %"look%", just an external format issue.")

                  (RETURN (SELECTQ FORMATLEVEL
                              (0 NIL)
                              (2 'CHARLOOKS)
                              (3 'PARALOOKS)
                              (4 'IMAGEOBJ)
                              NIL])

(\ARBIN
  [LAMBDA (STREAM)                                           (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "13-Nov-86 20:21")
                                                             (* ; 
                                     "Read an arbitrary object from a file, parse it, and return it.")
    (PROG ((LEN (\WIN STREAM))
           USERSTR)
          (COND
             ((NOT (ZEROP LEN))
              (SETQ USERSTR (OPENSTRINGSTREAM (\STRINGIN STREAM LEN)
                                   'INPUT))
              (RETURN (PROG1 (READ USERSTR *TEDIT-FILE-READTABLE*)
                             (CLOSEF? USERSTR])

(\ATMIN
  [LAMBDA (STREAM)                                           (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-Apr-84 10:41")
    (PROG ((LEN (\WIN STREAM)))
          (RETURN (COND
                     ((ZEROP LEN)
                      NIL)
                     (T (PACK (for I from 1 to LEN collect (CHARACTER (BIN STREAM])

(\DWIN
  [LAMBDA (FILE)                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* jds " 3-JAN-83 16:08")
    (IPLUS (LLSH (BIN FILE)
                 24)
           (LLSH (BIN FILE)
                 16)
           (LLSH (BIN FILE)
                 8)
           (BIN FILE])

(\STRINGIN
  [LAMBDA (STREAM SETLEN)                                    (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 20-Apr-88 19:54 by jds")

         (* Read a string in length-contents form%: One word for the length, and one byte 
         per character contained. However, the length may be specified by the caller 
         instead of being read from the file.)

    (PROG ((LEN (OR SETLEN (\WIN STREAM)))
           STR)
          (SETQ STR (ALLOCSTRING LEN))
          [OR (ZEROP LEN)
              (for I from 1 to LEN do (RPLCHARCODE STR I (READCCODE STREAM]
          (RETURN STR])

(\TEDIT.FORMATTEDP1
  [LAMBDA (FILE LEN)

    (* ;; "Edited 19-Dec-2023 10:13 by rmk")

    (* ;; "Edited 22-Jul-2022 12:04 by rmk: Returns the version as well as the piece-count in the current-version case, to be consistent.  Also, return is a LIST instead of a CONS, so more information (like a date) can eventually be provided.")

    (* ;; "Edited 21-Jul-2022 22:41 by rmk")

    (* ;; "Edited 12-Feb-88 11:43 by jds")
                                                             (* ; 
                                                             "Checks for a version-1 formatted file")

    (* ;; "Returns NIL if it isn't a formatted file. Leaves file at start of text or of piece descriptions, resp.")

    (SETQ LEN (OR LEN (GETEOFPTR FILE)))
    (CL:WHEN (IGREATERP LEN 8)
        (LET (DESCPTR PCCOUNT VERSION)
             (SETFILEPTR FILE (IDIFFERENCE LEN 8))           (* ; 
                                                           "Move to start of FILEPTR to descriptions")
             (SETQ DESCPTR (\DWIN FILE))                     (* ; 
                                                             "Read the file pos of the descriptions")
             (SETQ PCCOUNT (\WIN FILE))
             (SETQ VERSION (IDIFFERENCE (\WIN FILE)
                                  31415))
             (SELECTQ VERSION
                 ((3 1 2 0)                                  (* ; "The known versions.  3 is current")
                      (SETFILEPTR FILE DESCPTR)
                      (LIST VERSION PCCOUNT))
                 (PROGN                                      (* ; "NOT A FORMATTED FILE")
                        (SETFILEPTR FILE 0)
                        NIL))))])

(\TEDIT.CACHEFILE
  [LAMBDA (TEXT TEXTOBJ START END)                           (* ; "Edited 22-Sep-2023 20:15 by rmk")
                                                             (* ; "Edited 31-Aug-2023 15:35 by rmk")
                                                             (* ; "Edited 14-Jul-2022 08:44 by rmk")

    (* ;; "If TEXT is not a random-access file, we copy it into local storage (NODIRCORE)")

    (LET (CACHE)

         (* ;; "Sets the external format and its EOL.")

         [SETQ CACHE (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((TYPE TEXT)
                                                           (:EXTERNAL-FORMAT ,(GETSTREAMPROP TEXT 
                                                                                     :EXTERNAL-FORMAT
                                                                                     ]
         (COND
            ((OR START END)
             (COPYBYTES TEXT CACHE (OR START 0)
                    (OR END -1)))
            (T (COPYBYTES TEXT CACHE)))                      (* ; "Copy the text there")

         (* ;; "COPYBYTES can only have start/end args of NIL if the file is not random access.  So it's impossible to grab out of the middle of a file on an NS server.  Sorry.")

         (CLOSEF TEXT)
         (CL:WHEN TEXTOBJ

             (* ;; 
             "REMEMBER THAT THIS TEXT WAS CACHED, SO THAT LATER PUTS DON'T INVALIDATE THE CACHE.")

             (PUTTEXTPROP TEXTOBJ 'CACHE T))
         CACHE])
)
(DEFINEQ

(\TEDIT.GET.PIECES3
  [LAMBDA (TEXT TEXTOBJ PCCOUNT CURFILEBYTE# END)            (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  8-Dec-2023 22:49 by rmk")
                                                             (* ; "Edited  7-Nov-2023 13:10 by rmk")
                                                             (* ; "Edited 24-Sep-2023 22:00 by rmk")
                                                             (* ; "Edited  2-Sep-2023 11:12 by rmk")
                                                             (* ; "Edited 29-Aug-2023 00:18 by rmk")

    (* ;; "This runs through the Looks table portion of the TEXT file, gathering the looks and  installing pointers to positions in the character section of the file.  It doesn't actually examine the characters in the file.  It returns a piece chain that covers the text but that hasn't been installed in the btree.  The pieces need further adjustment for character encoding and to prevent mutlibyte characters from crossing buffer boundaries before they are installed in the btree.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                            8))
    (SETFILEPTR TEXT (\DWIN TEXT))                           (* ; "Pieceinfo char #")
    (for PCNO PC BYTELEN PREVPC FIRSTPC PARAMAP LOOKSMAP (ORIGBYTE# _ CURFILEBYTE#)
         (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
         (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) from 1 to PCCOUNT first (SETQ FIRSTPC
                                                                              (CREATE PIECE)) 
                                                             (* ; "Throw away at the end")
                                                                             (SETQ PREVPC FIRSTPC)
       do (SETQ PC NIL)                                      (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
          (SETQ BYTELEN (\DWIN TEXT))
          [SELECTC (\WIN TEXT)
              (\PieceDescriptorLOOKS                         (* ; 
                                  "New character looks.  Build a piece to describe those characters.")
                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PLEN _ BYTELEN
                           PBYTELEN _ BYTELEN
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ THINFILE.PTYPE
                           PCHARSET _ 0
                           PBYTESPERCHAR _ 1
                           PREVPIECE _ PREVPC))
                   (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSMAP)   (* ; 
                                                             "Get its looks and character-pointers")
                   (add CURFILEBYTE# BYTELEN))
              (\PieceDescriptorPARA                          (* ; 
                                                             "Reading a new set of paragraph looks.")
                   (CL:WHEN PREVPC (FSETPC PREVPC PPARALAST T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                   (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAMAP))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                              "Mark the document as containing paragraph formatting ")
                   (SETTOBJ TEXTOBJ FORMATTEDP T))
              (\PieceDescriptorOBJECT 
                                      (* ;; 
                             "BYTELEN is the number of bytes on the file, PLEN is always 1 character")

                   (SETQ PC
                    (create PIECE
                           PCONTENTS _ TEXT
                           PFPOS _ CURFILEBYTE#
                           PBYTELEN _ BYTELEN
                           PLEN _ 1
                           PPARALOOKS _ OLDPARALOOKS
                           PTYPE _ OBJECT.PTYPE
                           PREVPIECE _ PREVPC))
                   (TEDIT.GET.OBJECT (GETTOBJ TEXTOBJ STREAMHINT)
                          PC TEXT CURFILEBYTE#)
                   (add CURFILEBYTE# BYTELEN)
                   [FSETPC PC PLOOKS (if (ZEROP (BIN TEXT))
                                         then 
                                              (* ;; 
                    "No new looks;  steal them from the prior piece.  RMK: Goofy part of this format")

                                              (OR (AND PREVPC (PLOOKS PREVPC))
                                                  DEFAULTCHARLOOKS)
                                       else 
                                            (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                            (FSETPC PC PLOOKS (\TEDIT.GET.SINGLE.CHARLOOKS TEXT])
              (\PieceDescriptorPAGEFRAME                     (* ; 
                                                             "This is page layout info for the file")
                   (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (\TEDIT.PARSE.PAGEFRAMES (READ TEXT))))
              (\PieceDescriptorCHARLOOKSLIST                 (* ; 
                                                 "Read the list of CHARLOOKSs used in this document.")
                   (add PCNO -1)                             (* ; 
                                                             "Lists don't count, in this format.")
                   (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST TEXT))
                   [SETQ LOOKSMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                      do (SETA LOOKSMAP J LOOKS)))
              (\PieceDescriptorPARALOOKSLIST                 (* ; 
                                                 "Read the list of PARALOOKSs used in this document.")
                   (add PCNO -1)                             (* ; "Lists don't count in this format")
                   (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST TEXT TEXTOBJ))
                   [SETQ PARAMAP (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                   (for J from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                      do (SETA PARAMAP J LOOKS)))
              (PROGN (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Unknown-type piece skipped." T)
                     (SETFILEPTR TEXT (IPLUS (GETFILEPTR TEXT)
                                             (\WIN TEXT]
          (CL:WHEN PC                                        (* ; 
                                               "Chain them together without putting them in the tree")
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ PREVPC PC)) finally (SETQ PC (NEXTPIECE FIRSTPC)) 
                                                             (* ; "Throw out the dummy FIRSTPC")
                                      (FSETPC PC PREVPIECE NIL)
                                      (RETURN PC])

(\TEDIT.MAKE.SAFE.BUFFERS
  [LAMBDA (PC ONECHARFN)                                     (* ; "Edited  9-Dec-2023 13:13 by rmk")
                                                             (* ; "Edited 23-Sep-2023 00:19 by rmk")
                                                             (* ; "Edited 16-Sep-2023 12:32 by rmk")
                                                             (* ; "Edited  5-Sep-2023 00:00 by rmk")
                                                             (* ; "Edited 30-Aug-2023 19:09 by rmk")

    (* ;; "This chops PC into a sequence of pieces such that no piece has a character whose bytes cross a PFILE buffer boundary.  Any offending character is placed in a string piece that is linked into the chain.  The return value is the piece that holds the last characters of PC, so the caller's iteration can continue to the next problematic piece in a higher-level chain.")

    (* ;; "This works mostly on PBYTELEN using PBYTESPERCHAR for the granularity, and using PBYTESPERCHAR also to recalculate the output PLENs. PBYTELEN should be a multiple of PBYTESPERCHAR")

    (bind BYTESLEFTINBUFFER BUFPOS BUFSIZE CROSSCHAR STRINGPC PREFIXCHARS PREFIXPC (PREFIXBYTES
                                                                                    _ 0)
          (SUFFIXPC _ PC)
          (PFILE _ (PCONTENTS PC))
          (BYTESPERCHAR _ (PBYTESPERCHAR PC))
          (BYTESLEFT _ (PBYTELEN PC))
          (FPOS _ (PFPOS PC))
          (BYTELEN _ (PBYTELEN PC)) first (SETQ BUFSIZE (fetch (STREAM CBUFMAXSIZE) of PFILE))
                                          (CL:WHEN (AND (EVENP BUFSIZE BYTESPERCHAR)
                                                        (EVENP FPOS BYTESPERCHAR))

                                  (* ;; "A piece with 2-byte characters would always be aligned, for example, if PFPOS and BUFSIZE are both even--nothing to worry about.")

                                              (RETURN PC))
                                          (SETQ BUFPOS FPOS) eachtime (SETQ BYTESLEFTINBUFFER
                                                                       (IDIFFERENCE BUFSIZE
                                                                              (IREMAINDER BUFPOS 
                                                                                     BUFSIZE)))
       do (CL:WHEN (ILEQ BYTESLEFT BYTESLEFTINBUFFER)
              (CL:WHEN (FGETPC SUFFIXPC NEXTPIECE)           (* ; 
                                                            "Point the original next at its new prev")
                  (FSETPC (FGETPC SUFFIXPC NEXTPIECE)
                         PREVPIECE SUFFIXPC))
              (RETURN SUFFIXPC)) 

          (* ;; "The current SUFFIXPC has a character that crosses a buffer boundary (but maybe not the very first boundary--a prefix of 4 3-byte characters might initially align with a 512 byte buffer, but it will lose after that). We either have to extend the current piece across the next buffer (if it is aligned), or split off a file piece and a 1-character string piece.")

          (if (EVENP BYTESLEFTINBUFFER BYTESPERCHAR)
              then 
                   (* ;; "The last character doesn't cross so we don't have to split for this buffer and can continue peeling off prefixbytes from the same SUFFIXPC.  We advance BUFFPOS to the start of the next buffer, but don't advance FPOS.")

                   (* ;; "Note that when we finally run up against the boundary, rounding down to characters may back off some prefixbytes--we have to adjust for that below.")

                   (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))
                   (add BUFPOS BYTESLEFTINBUFFER)
                   (add PREFIXBYTES BYTESLEFTINBUFFER)
            else 
                 (* ;; "The current SUFFIXPC has a boundary-crossing character.  In general we have to divide it into 3 pieces")

                 (* ;; 
  "    1.  PREFIXPC represents SUFFIXPC characters before the offender, with the original ptype etc.")

                 (* ;; "    2.  STRINGPC contains the single offending character, read from the file and inserted as a string piece.")

                 (* ;; 
              "    3.  A new SUFFIXPC representing the characters remaining for the next iteration..")

                 (* ;; " PREFIXPC exists only if BYTESLEFTINBUFFER is greater than BYTESPERCHAR. If less, then it is only the string character that crosses the boundary, there are no other prefix chars. ")

                 (* ;; "Note that SUFFIXPC always carries along any properties of the original PC that might remain useful, even though PC is otherwise cannibalized. Looks, paralast, nextpiece...")

                 (* ;; "")

                 (add PREFIXBYTES BYTESLEFTINBUFFER)
                 (add BYTESLEFT (IMINUS BYTESLEFTINBUFFER))  (* ; 
                                                          "Include the last buffer, round down below")
                 (CL:WHEN (IGREATERP PREFIXBYTES BYTESPERCHAR)
                                                             (* ; 
                                                       "There is a prefix to chop off from SUFFIXPC ")
                     (SETQ PREFIXPC SUFFIXPC)
                     (SETQ PREFIXCHARS (IQUOTIENT PREFIXBYTES BYTESPERCHAR))
                     [add BYTESLEFT BYTESPERCHAR (IMINUS (IDIFFERENCE PREFIXBYTES (SETQ PREFIXBYTES
                                                                                   (ITIMES 
                                                                                          PREFIXCHARS
                                                                                          
                                                                                         BYTESPERCHAR
                                                                                          ]
                     (SETQ BUFPOS (IPLUS FPOS PREFIXBYTES))  (* ; 
                                                        "The suffix starts on a character first-byte")
                     (SETQ SUFFIXPC (create PIECE using SUFFIXPC PFPOS _ BUFPOS PBYTELEN _ BYTESLEFT
                                                        PLEN _ (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                                        PREVPIECE _ PREFIXPC))
                     (with PIECE PREFIXPC (SETQ PLEN PREFIXCHARS)
                           (SETQ PBYTELEN PREFIXBYTES)
                           (SETQ PPARALAST NIL)
                           (SETQ NEXTPIECE SUFFIXPC)))
                 (SETQ PREFIXBYTES 0) 

                 (* ;; "")

                 (* ;; 
              "SUFFIXPC now begins with a crosser--convert SUFFIXPC to a one-character string piece ")

                 (SETQ FPOS (FGETPC SUFFIXPC PFPOS))
                 (SETFILEPTR PFILE FPOS)                     (* ; "Fetch the crossing character")
                 (SETQ CROSSCHAR (APPLY* ONECHARFN PFILE))
                 (SETQ STRINGPC SUFFIXPC)
                 (add BYTESLEFT (IMINUS BYTESPERCHAR))
                 (if (IGREATERP BYTESLEFT 0)
                     then                                    (* ; 
                                                             "Create a new SUFFIXPC for the residual")
                          (add FPOS BYTESPERCHAR)            (* ; "Don't include the CROSSCHAR")
                          (SETQ SUFFIXPC
                           (create PIECE using SUFFIXPC PFPOS _ FPOS PBYTELEN _ BYTESLEFT PLEN _
                                               (IQUOTIENT BYTESLEFT BYTESPERCHAR)
                                               PREVPIECE _ STRINGPC))
                          (FSETPC STRINGPC NEXTPIECE SUFFIXPC)
                          (FSETPC STRINGPC PPARALAST NIL)
                          (SETQ BUFPOS FPOS)
                   else (SETQ SUFFIXPC NIL)) 

                 (* ;; "")

                 (* ;; 
       "Convert the previous SUFFIXPC (now STRINGPC) to a string piece containing just the CROSSCHAR")

                 (with PIECE STRINGPC (SETQ PCONTENTS (ALLOCSTRING 1 CROSSCHAR))
                       (SETQ PLEN 1)
                       (if (ILEQ CROSSCHAR 255)
                           then (SETQ PTYPE THINSTRING.PTYPE)
                                (SETQ PCHARSET 0)
                                (SETQ PBYTESPERCHAR 1)
                                (SETQ PBYTELEN 1)
                                (SETQ PBINABLE T)
                         else (SETQ PTYPE FATSTRING.PTYPE)
                              (SETQ PCHARSET \NORUNCODE)
                              (SETQ PBYTESPERCHAR 2)
                              (SETQ PBYTELEN 2)
                              (SETQ PBINABLE NIL)))
                 (CL:UNLESS SUFFIXPC                         (* ; 
                                                          "Didn't need a SUFFIXPC, end with STRINGPC")
                     (CL:WHEN (FGETPC STRINGPC NEXTPIECE)
                         (FSETPC (FGETPC STRINGPC NEXTPIECE)
                                PREVPIECE STRINGPC))
                     (RETURN STRINGPC))])

(\TEDIT.MAKE.SAFE.PIECES
  [LAMBDA (PIECES)                                           (* ; "Edited 19-Dec-2023 13:14 by rmk")
                                                             (* ; "Edited 17-Dec-2023 23:08 by rmk")

    (* ;; "PIECES is the head of a chain of pieces that have not yet been inserted into the BTREE. We make sure here that there are no multi-byte characters on files that straddle the file's buffer boundary.  We accomplish that by splitting the piece before a character that would cross the boundary, and inserting a string piece to hold that character.")

    (CL:WHEN PIECES                                          (* ; 
                                                             "PFILE is  a stream open for input.")
        [LET [(PFILE (for PC inpieces PIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
                        when (\GETSTREAM (PCONTENTS PC)
                                    'INPUT T) do (RETURN (PCONTENTS PC]
             (CL:WHEN PFILE                                  (* ; "At least one file piece")
                 (CL:WHEN (EQ :XCCS (STREAMPROP PFILE :EXTERNAL-FORMAT))
                        (\TEDIT.INTERPRET.XCCS.SHIFTS PIECES PFILE))
                 [for PC inpieces PIECES when (AND (EQ PFILE (PCONTENTS PC))
                                                   (IGREATERP (PBYTESPERCHAR PC)
                                                          1))
                    do 
                       (* ;; 
         "PC may have advanced to the end of a safe insertion, we have to reestablish our iteration.")

                       (SETQ PC (\TEDIT.MAKE.SAFE.BUFFERS PC (SELECTQ (PBYTESPERCHAR PC)
                                                                 (2 [FUNCTION (LAMBDA (PFILE)
                                                                                (\WIN PFILE])
                                                                 (HELP "NEED CHAR READER"])])
    PIECES])

(\TEDIT.INTERPRET.XCCS.SHIFTS
  [LAMBDA (PIECES PFILE)                                     (* ; "Edited 19-Dec-2023 13:13 by rmk")

    (* ;; "PIECES is a chain of pieces read from an XCCS file (formatted or unformatted) but not yet inserted into the BTREE.  Each file piece has PFILE, PFPOS, and PBYTELEN.  This function interprets any XCCS shift characters that prefix the actual characters, coercing the piece properties and bumping the PFPOS/PLEN to hide the shifts. ")

    (for PC BYTE inpieces PIECES when (EQ PFILE (PCONTENTS PC))
       do (SETFILEPTR PFILE (PFPOS PC))
          (if (EQ NSCHARSETSHIFT (BIN PFILE))
              then [SELECTC (SETQ BYTE (BIN PFILE))
                       (0 (add (PBYTELEN PC)
                               -2)                           (* ; 
                                                             "The shift characters really disappear")
                          (FSETPC PC PLEN (PBYTELEN PC))
                          (FSETPC PC PTYPE THINFILE.PTYPE)
                          (FSETPC PC PBINABLE T)
                          (FSETPC PC PCHARSET 0)
                          (add (PFPOS PC)
                               2))
                       (\NORUNCODE (CL:UNLESS (EQ 0 (BIN PFILE))
                                          (SHOULDNT "XCCS CHARACTER NOT IN PLANE 0"))
                                   (FSETPC PC PTYPE FATFILE2.PTYPE)
                                   (FSETPC PC PBYTESPERCHAR 2)
                                   (add (PFPOS PC)
                                        3)
                                   (add (PBYTELEN PC)
                                        -3)
                                   (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                                          2)))
                       (PROGN 
                              (* ;; "A run in a non-zero charset.    ")

                              (add (PBYTELEN PC)
                                   -2)
                              (add (PFPOS PC)
                                   2)
                              (FSETPC PC PLEN (PBYTELEN PC))
                              (FSETPC PC PBINABLE NIL)
                              (if T
                                  then (FSETPC PC PTYPE FATFILE1.PTYPE) 
                                                             (* ; "Convert it to FATFILE1.")
                                       (FSETPC PC PBYTESPERCHAR 1)
                                       (FSETPC PC PCHARSET BYTE)
                                else 

                                 (* ;; "Could also read into a FATSTRING instead, get rid of on-file FATFILE1. A string piece could hold adjacent  substrings in different charsets.")

                                     (FSETPC PC PTYPE FATSTRING.PTYPE)
                                     (FSETPC PC PTYPE \NORUNCODE)
                                     (FSETPC PC PBYTESPERCHAR 2)
                                     (for I (CHARSET _ (LLSH BYTE 8))
                                          (STRING _ (ALLOCSTRING (PLEN PC)
                                                           NIL NIL T)) from 1
                                        to (PLEN PC) first (FSETPC PC PCONTENTS STRING)
                                        do (RPLCHARCODE STRING I (LOGOR CHARSET (BIN PFILE]
            elseif (EQ 2 (PBYTESPERCHAR PC))
              then (FSETPC PC PTYPE FATFILE2.PTYPE)          (* ; "This is the continuation of an XCCS 2-byte run that was broken up presumably for looks or paragraphs")
                   (FSETPC PC PCHARSET \NORUNCODE)
                   (FSETPC PC PLEN (FOLDLO (PBYTELEN PC)
                                          2))
            else (FSETPC PC PTYPE THINFILE.PTYPE)            (* ; "A charset 0 1-byte run")
                 (FSETPC PC PCHARSET 0)
                 (FSETPC PC PBINABLE T)
                 (FSETPC PC PLEN (PBYTELEN PC))
                 (FSETPC PC PBYTESPERCHAR 1)))
    PIECES])
)
(DEFINEQ

(\TEDIT.GET.UNFORMATTED.FILE.XCCS
  [LAMBDA (STREAM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS)
                                                             (* ; "Edited  8-Dec-2023 23:01 by rmk")
                                                             (* ; "Edited 25-Nov-2023 17:39 by rmk")
                                                             (* ; "Edited 31-Aug-2023 00:22 by rmk")
                                                             (* ; "Edited 29-Aug-2023 22:06 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:05 by rmk")
                                                             (* ; "Edited 19-Aug-2022 22:34 by rmk")

    (* ;; "We build a chain of pieces one for each NS stringlet.  All pieces start on the charset shift byte as THINFILE pieces with BYTESPERCHAR=1. We don't interpret those bytes here, they wlll be decoded and made buffer-safe later.")

    (* ;; "We assume that caller has positioned the stream at the intended start byte has set the ENDOFSTREAMOP to return NIL on EOF. We have to worry about END: it is the ptr to the last byte")

    (for I PC BYTE PREVPC BYTELEN NEXTPTR (BEGINPTR _ (GETFILEPTR STREAM))
         (FIRSTPC _ (create PIECE))
         (EXTFORMAT _ (ffetch (STREAM EXTERNALFORMAT) of STREAM)) from 0
       to (ADD1 (IDIFFERENCE END START)) first (SETQ PREVPC FIRSTPC) 
                                                             (* ; "FIRSTPC is a throwaway")
       eachtime (SETQ BYTE (BIN STREAM)) when (OR (EQ NSCHARSETSHIFT BYTE)
                                                  (NULL BYTE))
       do (SETQ NEXTPTR (\GETFILEPTR STREAM))
          (CL:WHEN BYTE                                      (* ; 
                    "Back up to point of the just-read shift byte (but stream didn't advance at EOF)")
              (add NEXTPTR -1))
          (SETQ BYTELEN (IDIFFERENCE NEXTPTR BEGINPTR))
          (CL:UNLESS (ZEROP BYTELEN)                         (* ; 
                                                     "Empty piece, possibly a charset shift at START")
              (SETQ PC
               (create PIECE
                      PCONTENTS _ STREAM
                      PFPOS _ BEGINPTR
                      PLEN _ BYTELEN
                      PLOOKS _ DEFAULTCHARLOOKS
                      PPARALOOKS _ DEFAULTPARALOOKS
                      PEXTERNALFORMAT _ EXTFORMAT
                      PTYPE _ THINFILE.PTYPE
                      PCHARSET _ 0
                      PBYTESPERCHAR _ 1
                      PBYTELEN _ BYTELEN
                      PREVPIECE _ PREVPC))
              (FSETPC PREVPC NEXTPIECE PC)
              (SETQ BEGINPTR NEXTPTR)
              (SETQ PREVPC PC))
          (CL:WHEN (EQ \NORUNCODE (\PEEKBIN STREAM T))       (* ; "We don't want to trip on a following \NORUNCODE, which happens to look like the just binned \NSCHARSETSHIFT")
              (add I 1)
              (BIN STREAM)) finally (RETURN (NEXTPIECE FIRSTPC])

(\TEDIT.GET.UNFORMATTED.FILE.UTF8
  [LAMBDA (STREAM START END DEFAULTCHARLOOKS DEFAULTPARALOOKS)
                                                             (* ; "Edited 31-Aug-2023 15:20 by rmk")

    (* ;; 
    "We build a separate piece for each sequence of UTF8 characters with the same number of bytes.")

    (for I PC PREVPC FIRSTPC NBYTES PREVNBYTES PFPOS BYTELEN (EXTFORMAT _ (ffetch (STREAM 
                                                                                       EXTERNALFORMAT
                                                                                         )
                                                                             of STREAM))
         (PREVFPOS _ START) from 0 to (ADD1 (IDIFFERENCE END START))
       eachtime (SETQ NBYTES (NUTF8BYTES (BIN STREAM)))
       do (CL:WHEN (AND PREVNBYTES (NEQ NBYTES PREVNBYTES))
              (SETQ BYTELEN (IDIFFERENCE PFPOS PREVFPOS))
              (SETQ PC
               (create PIECE
                      PCONTENTS _ STREAM
                      PFPOS _ BYTELEN
                      PBYTELEN _ BYTELEN
                      PLEN _ (ADD1 (IDIFFERENCE PFPOS LASTPFPOS))
                      PBYTESPERCHAR _ NBYTES
                      PLOOKS _ DEFAULTCHARLOOKS
                      PPARALOOKS _ DEFAULTPARALOOKS
                      PEXTERNALFORMAT _ EXTFORMAT
                      PREVPIECE _ PREVPC
                      PTYPE _ (SELECTQ PREVNBYTES
                                  (1 THINFILE.PTYPE)
                                  (2 UTF8-2.PTYPE)
                                  (3 UTF8-3.PTYPE)
                                  (4 UTF8-4.PTYPE)
                                  (SHOULDNT))
                      PBINABLE _ (EQ NBYTES 1)))
              (CL:WHEN PREVPC (SETPC PREVPC NEXTPIECE PC))
              (SETQ PREVFPOS PFPOS)
              (SETQ PREVNBYTES NBYTES)
              (SETQ PREVPC PC)
              (CL:UNLESS FIRSTPC (SETQ FIRSTPC PC)))
          (FRPTQ (SUB1 NBYTES)
                 (BIN STREAM))
          (add I (SUB1 NBYTES))
          (add PFPOS NBYTES) finally (RETURN FIRSTPC])
)
(DEFINEQ

(\TEDIT.GET.CHARLOOKS.LIST
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "28-Jan-85 17:50")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.CHARLOOKS FILE])

(\TEDIT.GET.SINGLE.CHARLOOKS
  [LAMBDA (FILE)                                             (* ; "Edited 21-Dec-2023 23:54 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 25-Nov-2023 23:21 by rmk")
                                                             (* ; "Edited 24-Aug-2023 15:05 by rmk")
                                                           (* ; "Edited 20-Feb-2022 12:42 by larry")
                                                             (* ; "Edited 30-May-91 20:25 by jds")

    (* ;; "Read one CHARLOOKS from FILE.  This gets and then sets the file pointer, based on the stored length.  But that won't work if the file is not random access.  Maybe that's not necessary?")

    (PROG* ((LOOKS (create CHARLOOKS))
            (FILEPOS (GETFILEPTR FILE))
            (LOOKSLEN (\WIN FILE))
            FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR)
           (SETQ NAME (\ARBIN FILE))                         (* ; "The font name")
           (SETQ SIZE (\WIN FILE))                           (* ; "Size of the type, in points")
           (SETQ SUPER (\WIN FILE))                          (* ; "Superscripting distance")
           (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                          0))
           (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE))
           (SETQ PROPS (\WIN FILE))
           (with CHARLOOKS LOOKS [SETQ CLUNBREAKABLE (NOT (ZEROP (LOGAND 4096 PROPS]
                 [SETQ CLLEADER (NOT (ZEROP (LOGAND 2048 PROPS]
                 [SETQ CLINVERTED (NOT (ZEROP (LOGAND 1024 PROPS]
                 [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                 [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                 [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                 [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                 [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                 [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                 [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                 [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                 [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                 [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                 (SETQ CLSIZE SIZE)
                 (SETQ CLOFFSET SUPER))
           [SETQ FONT (COND
                         ((LISTP NAME)                       (* ; 
                                                             "This was a font class.  Restore it.")
                          (FONTCLASS (pop NAME)
                                 NAME))
                         ((AND NAME (NOT (ZEROP SIZE)))
                          (FONTCREATE NAME SIZE (COND
                                                   ((AND (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                         (fetch (CHARLOOKS CLITAL) of LOOKS))
                                                    'BOLDITALIC)
                                                   ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                    'BOLD)
                                                   ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                                    'ITALIC]
           (replace (CHARLOOKS CLNAME) of LOOKS
              with (if (type? FONTCLASS FONT)
                       then 
                            (* ;; "Put the display family in the CLNAME spot.  Better than NIL.")

                            (CL:WHEN [SETQ NAME (FONTCOPY FONT '(DEVICE DISPLAY NOERROR T]
                                (FONTPROP NAME 'FAMILY))
                     else NAME))
           (replace (CHARLOOKS CLFONT) of LOOKS with FONT)
           (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN))
           (RETURN LOOKS])

(\TEDIT.GET.CHARLOOKS
  [LAMBDA (PC FILE LOOKSARRAY)                               (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Sep-2023 23:31 by rmk")
                                                             (* ; "Edited 28-Aug-2023 22:19 by rmk")
                                                             (* ; "Edited 26-Aug-2023 23:22 by rmk")
                                                             (* ; "Edited 30-May-91 21:43 by jds")

    (* ;; "Set the PLOOKS for the current piece, PC, according to what the file says")

    (* ;; "The incoming PLEN field of this piece is the number of FILE BYTES taken to describe the piece.  There may be a flag to indicate whether this is a fat or thin XCCS piece, here we only record the fatness by changing the PBYTESPERCHAR.  Stripping possible charset shifts for XCCS fat pieces is done by \TEDIT.MAKE.SAFE.PIECES--those shift might not appear at the front of pieces that continue the encoding from a previous piece.")

    (* ;; "We also ")

    (LET ((FLAGS (BIN FILE))
          BYTE LOOKSFILEPOS)
         (FSETPC PC PLOOKS (ELT LOOKSARRAY (\WIN FILE)))
         (SETQ LOOKSFILEPOS (GETFILEPTR FILE))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 1))
                (FSETPC PC PNEW T))
         (CL:UNLESS (ZEROP (LOGAND FLAGS 2))                 (* ; 
                                         "XCSS FAT. It may be a continuation of a previous fat piece")
             (FSETPC PC PLEN (IQUOTIENT (FGETPC PC PLEN)
                                    2))
             (FSETPC PC PTYPE FATFILE2.PTYPE)
             (FSETPC PC PBYTESPERCHAR 2))])
)
(DEFINEQ

(\TEDIT.GET.PARALOOKS.LIST
  [LAMBDA (FILE TEXTOBJ)                                     (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "13-Jun-85 11:14")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.PARALOOKS FILE TEXTOBJ])

(\TEDIT.GET.SINGLE.PARALOOKS
  [LAMBDA (FILE TEXTOBJ)                                     (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:16 by rmk")
                                                             (* ; "Edited 11-Oct-2022 15:23 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:31 by sybalskY:MV:ENVOS")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           (FILEPOS (GETFILEPTR FILE))
           (LOOKSLEN (\WIN FILE))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC TABTYPE QUAD)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\WIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\WIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\WIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (SETQ QUAD (BIN FILE))
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 1))               (* ; "There are tabs to read")
              (SETQ DEFTAB (\WIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\WIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (SETQ TABTYPE
                                                                               (BIN FILE))
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (4 'DOTTEDLEFT)
                                                                         (5 'DOTTEDRIGHT)
                                                                         (6 'DOTTEDCENTERED)
                                                                         (7 'DOTTEDDECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS))
          (CL:UNLESS (ZEROP (LOGAND TABFLG 2))               (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\WIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTHEADINGKEEP) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTKEEP) of LOOKS with (\ARBIN FILE))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTBASETOBASE) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTREVISED) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCOLUMN) of LOOKS with (\ARBIN FILE)))
              (CL:WHEN (ILESSP (GETFILEPTR FILE)
                              (IPLUS FILEPOS LOOKSLEN))
                  (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))))
          (CL:WHEN (ILESSP (GETFILEPTR FILE)
                          (IPLUS FILEPOS LOOKSLEN))          (* ; 
                               "There is more PARALOOKS info in this piece -- we probably lost data.")
              (TEDIT.PROMPTPRINT TEXTOBJ "WARNING: Newer file version; you lost PARALOOKS info" T)
              (SETFILEPTR FILE (IPLUS FILEPOS LOOKSLEN)))
          (RETURN LOOKS])

(\TEDIT.GET.PARALOOKS
  [LAMBDA (FILE PARAHASH)                                    (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 18-Dec-88 17:47 by jds")

    (* ;; "Read a paragraph format spec from the FILE, and return it for later use.")

    (* ;; "Paragraph format # of 0 indicates an end-of-file dummy, used to preserve the paralooks of EOF para break.")

    (LET ((LOOKS# (\WIN FILE)))
         (COND
            ((ZEROP LOOKS#)
             NIL)
            (T (ELT PARAHASH LOOKS#])
)
(DEFINEQ

(TEDIT.GET.OBJECT
  [LAMBDA (TSTREAM PIECE FILE CURFILEBYTE# BYTELEN)          (* ; "Edited  5-Dec-2023 12:28 by rmk")
                                                             (* ; "Edited 26-Nov-2023 10:22 by rmk")
                                                             (* ; "Edited 21-Nov-2023 17:53 by rmk")
                                                             (* ; "Edited 25-Aug-2023 23:07 by rmk")
                                                             (* ; "Edited 12-Oct-2022 14:10 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:50 by mitani")

    (* ;; "Get an object from FILE")

    (* ;; "TSTREAM =TEXTOBJ are used for the error message and (possibly for default charlooks)")

    (* ;; "CURFILEBYTE# = fileptr within the text section of the file where the object's text starts. On entry the file is positioned just before the object's GETFN in the looks section of the file. On exit, the fileptr points just after the GETFN in the looks section, after having been detoured to the text section for the getfn to read the object's data.")

    (LET ((TEXTOBJ (TEXTOBJ TSTREAM))
          FILEPTRSAVE GETFN OBJ)

         (* ;; "rrb 10-AUG-87 --- calculate the length of the image object's data.  This assumes that the file is currently pointed at the end of the data which is where the GETFN is written {I think}.")

         (* ;; "RMK:  Originally, BYTELEN was calculated here as (DIFFERENCE (GETFILEPTR FILE) CURFILEBYTE#).  But this is garbage: (GETFILEPTR FILE) is in the looks section, CURFILEBYTE# is in the text section. The caller knows the true value, now passes it in. ")

         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURFILEBYTE#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN NIL BYTELEN))
         (CL:WHEN (IMAGEOBJPROP OBJ 'UNKNOWNGETFN)           (* ; 
      "If the object has an unknown getfn property, then it's an encapsulated object.  Warn the user")
             (TEDIT.PROMPTPRINT TSTREAM (CONCAT (CL:IF (GETD (IMAGEOBJPROP OBJ 'UNKNOWNGETFN))
                                                    "Cannot read image object with GETFN "
                                                    "Image object with unknown GETFN ")
                                               (IMAGEOBJPROP OBJ 'UNKNOWNGETFN))
                    T))
         (SETFILEPTR FILE FILEPTRSAVE)
         (SETPC PIECE PCONTENTS OBJ)
         [FSETPC PIECE PLOOKS (COND
                                 ((PREVPIECE PIECE)
                                  (PLOOKS (PREVPIECE PIECE)))
                                 (T (OR (GETTOBJ TEXTOBJ DEFAULTCHARLOOKS)
                                        (\TEDIT.UNIQUIFY.CHARLOOKS (CHARLOOKS.FROM.FONT DEFAULTFONT)
                                               TEXTOBJ]
         (FSETPC PIECE PTYPE (CL:IF (IMAGEOBJPROP OBJ 'SUBSTREAM)
                                 SUBSTREAM.PTYPE
                                 OBJECT.PTYPE))
         OBJ])
)



(* ;; "Putting (pageframe functions on TEDIT-PAGE)")

(DEFINEQ

(\TEDIT.PUT.PCTB
  [LAMBDA (TEXTOBJ CHARSTREAM LOOKS)                         (* ; "Edited 22-Dec-2023 09:08 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited  9-Dec-2023 11:13 by rmk")
                                                             (* ; "Edited 27-Sep-2023 23:50 by rmk")
                                                             (* ; "Edited  7-Sep-2023 23:43 by rmk")
                                                            (* ; "Edited 30-Apr-2021 14:46 by rmk:")
                                                             (* ; "Edited 19-May-99 21:58 by rmk:")
                                                             (* ; 
                                                        "Edited 27-May-93 16:00 by sybalsky:mv:envos")

    (* ;; "Put a representation of a piece table as plaintext on CHARSTREAM, preserving font changes and paragraph looks in a binary LOOKSTREAM. The LOOKSTREAM is passed as as a stream LOOKS in the call from COERCETEXTOBJ, otherwise it is created here.  Otherwise (calls from TEDIT.PUT), the LOOKSTREAM is created here.  In that case, LOOKS is NIL for a formatted file, and LOOKSTREAM is appended to CHARSTREAM.  If T (unformatted), the LOOKSTREAM is thrown away.")

    (* ;; "")

    (* ;; "The characters and objects in the pieces are put out in the plaintext CHARSTREAM.  At the end of each sequence, when the byte positions are known, the hashed look-identifiers are put out to connect the looks back to the character sequences.")

    (* ;; "")

    (* ;; "If a sequence of pieces have equivalent piece properties (same character representation (fat, thin, utf-8 size) and looks) then the the characters of those pieces are concatenated and a single looks record is posted for the whole sequence.  For example, a sequence of THINFILE THINSTRING THINFILE pieces may be collapsed if they have the same font, new, etc. (but objects always have individual pieces).  Concatenation also stops at paralast sequences. ")

    (* ;; "WHAT ABOUT CACHE??")

    (* ;; "PLEN is the number of characters in the piece, but they occupy different numbers of bytes depending on thin, fat, utf-8...      ")

    (* ;; "")

    (* ;; "For continued editing, NEWPIECES is the head of a  chain of new pieces that characterize the merged pieces on the file, to reestablish the correspondence between memory pieces and file pieces for continued editing. It is initialized to a throwaway dummy, and NEXTNEW slides down to link in subsequent new pieces.  However, if we are caching, there will be no future editing in CHARSTREAM, no need to build new pieces.")

    (for PC PREVPC CURBYTE# OLDBYTE# PFILE NEXTNEW (UNFORMATTED? _ (EQ LOOKS T))
         [LOOKSTREAM _ (OR (STREAMP LOOKS)
                           (OPENSTREAM '{NODIRCORE} 'BOTH 'NEW `((LINELENGTH ,MAX.SMALLP]
         (NEWPIECES _ (CL:UNLESS (GETTEXTPROP TEXTOBJ 'CACHE)
                             (create PIECE)))
         (PCCOUNT _ 0)
         (EDITSTENTATIVE _ (GETTEXTPROP TEXTOBJ 'TEDIT.TENTATIVE))
         (LOOKSHASH _ (HASHARRAY 50))
         (PARAHASH _ (HASHARRAY 50))
         (*READTABLE* _ *TEDIT-FILE-READTABLE*)
         (*PRINT-BASE* _ 10) inpieces (\FIRSTPIECE TEXTOBJ)
       first (SETQ NEXTNEW NEWPIECES) 

             (* ;; "All the layout and looks information goes into the LOOKSTREAM, CHARSTREAM is essentally plaintext.  Unless SEPARATEFORMAT, LOOKSTREAM is appended to the end of CHARSTREAM.")

             (* ;; "It seems that PCCOUNT isn't incremented for the PARA and CHARLOOKS lists, just for the page frame and the actual document pieces.dd")

             (CL:WHEN (FGETTOBJ TEXTOBJ TXTPAGEFRAMES)
                 (\TEDIT.PUT.PAGEFRAMES LOOKSTREAM (FGETTOBJ TEXTOBJ TXTPAGEFRAMES))
                 (add PCCOUNT 1))
             (\TEDIT.FLUSH.UNUSED.LOOKS TEXTOBJ)
             (\TEDIT.UNIQUIFY.ALL TEXTOBJ)                   (* ; "We can now use EQ tests on looks")
             (\TEDIT.PUT.PARALOOKS.LIST LOOKSTREAM PARAHASH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST))
             (\TEDIT.PUT.CHARLOOKS.LIST LOOKSTREAM LOOKSHASH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)) 

             (* ;; "The hash-tables map char and parlooks to unique id numbers")

             (* ;; "")

             (* ;; " We're ready put the pieces on the output file.  We set its external format to XCCS for now--it is supposed to look like a plain-text file.")

             (STREAMPROP CHARSTREAM :EXTERNAL-FORMAT :XCCS)
             (SETQ CURBYTE# (ADD1 (GETFILEPTR CHARSTREAM)))  (* ; 
                                                   "Why ADD1 ? Always pointing at the %"next%" byte?")
             (SETQ OLDBYTE# CURBYTE#)
             (CHARSET CHARSTREAM 0 T) unless (ZEROP (PLEN PC))
       do 
          (* ;; "If there are undescribed characters and PC can't be merged with PREVPC, then finish off PREVPC by writing its character looks.  And if PREVPC was the last of a pargraph, put out its PARALOOKS.  ")

          (CL:UNLESS (OR (IEQP CURBYTE# OLDBYTE#)
                         (\TEDIT.PUT.PCTB.MERGEABLE PREVPC PC EDITSTENTATIVE))
              (\TEDIT.PUT.CHARLOOKS LOOKSTREAM OLDBYTE# CURBYTE# PREVPC EDITSTENTATIVE LOOKSHASH)
              (add PCCOUNT 1)

              (* ;; "We've put out all the preceding characters in a sequence of mergeable pieces.  Make a new piece that describes how they reside on CHARSTREAM, effectively a compacting garbage collector for continued editing.")

              (CL:WHEN NEWPIECES
                  (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW (create PIECE using PREVPC PTYPE _
                                                                              (SELECTQ (PTYPE PREVPC)
                                                                                  (THINSTRING.PTYPE 
                                                                                       THINFILE.PTYPE)
                                                                                  (FATSTRING.PTYPE 
                                                                                       FATFILE2.PTYPE)
                                                                                  (PTYPE PREVPC))
                                                                              PFPOS _ (SUB1 OLDBYTE#)
                                                                              PBYTELEN _
                                                                              (IDIFFERENCE CURBYTE# 
                                                                                     OLDBYTE#)
                                                                              PREVPIECE _ NEXTNEW))))
              (SETQ OLDBYTE# CURBYTE#))
          (CL:WHEN (OR (NULL PREVPC)
                       (PPARALAST PREVPC))                   (* ; 
                                            "Last piece of a paragraph terminates with its paralooks")
              (\TEDIT.PUT.PARALOOKS LOOKSTREAM PC PARAHASH)
              (add PCCOUNT 1))
          (CL:WHEN (MEMB (PTYPE PC)
                         FILE.PTYPES)
              (SETQ PFILE (PCONTENTS PC))
              (CL:UNLESS (\GETSTREAM PFILE 'INPUT T)         (* ; "Make sure the input file is open.")
                  (SETQ PFILE (\TEDIT.REOPEN.STREAM TEXTOBJ PFILE)))
              (SETFILEPTR PFILE (PFPOS PC)))
          (SELECTC (PTYPE PC)
              ((LIST THINFILE.PTYPE FATFILE1.PTYPE) 
                   [for I (CSET _ (PCHARSET PC)) from 1 to (PLEN PC) first (CHARSET CHARSTREAM CSET)
                      do (\OUTCHAR CHARSTREAM (LOGOR CSET (BIN PFILE])
              (FATFILE2.PTYPE                                (* ; 
                                             "COPYCHARS automatically deals with external formats.  ")
                   (CHARSET CHARSTREAM T)
                   (for I from 1 to (PLEN PC) do (\OUTCHAR CHARSTREAM (\WIN PFILE))))
              (THINSTRING.PTYPE                              (* ; 
                                                             "\OUTCHAR deals with external format")
                   (CHARSET CHARSTREAM 0)
                   (for CH instring (PCONTENTS PC) do (\OUTCHAR CHARSTREAM CH)))
              (FATSTRING.PTYPE                               (* ; 
                                                             "\OUTCHAR deals with external format")
                   (CHARSET CHARSTREAM T)
                   (for CH instring (PCONTENTS PC) do (\OUTCHAR CHARSTREAM CH)))
              (OBJECT.PTYPE                                  (* ; 
                  "It's an object, use its PUTFN. Byte positions don't matter for continued editing.")
                            (TEDIT.PUT.OBJECT PC CHARSTREAM LOOKSTREAM CURBYTE#)
                            (CL:WHEN NEWPIECES
                                (FSETPC NEXTNEW NEXTPIECE (SETQ NEXTNEW
                                                           (create PIECE using PC PREVPIECE _ NEXTNEW
                                                                  ))))
                            (add PCCOUNT 1)

                            (* ;; "0 indicates that nothing special needs to be done to recover the looks of this piece, its index will be written on the next iteration.  In earlier versions the value 1 indicated that the looks were not indexed and therefore had to be written explicitly here. This byte won't be needed in the next version of the format.")

                            (BOUT LOOKSTREAM 0)

                            (* ;; "RMK: Upping OLDBYTE# suppresses the natural charlooks that ought to happen on the next iteration if we just go around the loop. But things get screwed up if we take this out, even though OLDBYTE#.  Possibly the extra 0 byte makes it think that the object is bigger than it is?  I really don't understand why it fails if this is left out.")

                            (SETQ OLDBYTE# (ADD1 (GETFILEPTR CHARSTREAM)))
                            (CL:WHEN NIL (\TEDIT.PUT.CHARLOOKS LOOKSTREAM OLDBYTE# CURBYTE# PC 
                                                EDITSTENTATIVE LOOKSHASH)))
              (SHOULDNT "OTHER PTYPES")) 

          (* ;; "Record the file positions of the pieces in the file, so that pieces of the current text can be redirected to their filed-equivalents. We defer this until we know that every thing has settled down.  This records thenew position of every piece, even pieces that have been merged as suffixes of earlier ones, so  updating some old pieces may cause them to point into the middle of new file pieces.The updating code has to worry about NS charset shifts and buffer-crossing.")

          (SETQ CURBYTE# (ADD1 (GETFILEPTR CHARSTREAM)))
          (SETQ PREVPC PC) finally (CL:UNLESS (IEQP OLDBYTE# CURBYTE#)
                                                             (* ; 
                                                         "The charlooks for the final piece sequence")
                                       (\TEDIT.PUT.CHARLOOKS LOOKSTREAM OLDBYTE# CURBYTE# PREVPC 
                                              EDITSTENTATIVE LOOKSHASH)
                                       (CL:WHEN NEWPIECES
                                           (FSETPC NEXTNEW NEXTPIECE
                                                  (SETQ NEXTNEW (create PIECE using PREVPC PFPOS _
                                                                                    (SUB1 OLDBYTE#)
                                                                                    PBYTELEN _
                                                                                    (IDIFFERENCE
                                                                                     CURBYTE# 
                                                                                     OLDBYTE#)
                                                                                    PREVPIECE _ 
                                                                                    NEXTNEW))))
                                       (add PCCOUNT 1)) 

                                 (* ;; 
             "Do any user-specific cleanup? Never documented or implemented, assume it's a property?")

                                 (for FORM in (GETTEXTPROP TEXTOBJ 'TEDIT.PUT.FINISHEDFORMS)
                                    do (EVAL FORM)) 

                                 (* ;; "Finalize LOOKSTREAM.  We sneak in the date here--at the end of the looks, after the last look but before the final pointers, so that it doesn't interfere with anything.  TEDIT.FILEDATE pulls it out if it's there.")

                                 (PRIN1 "DATE:" LOOKSTREAM)
                                 (\DWOUT LOOKSTREAM (IDATE))
                                 (\DWOUT LOOKSTREAM (GETFILEPTR CHARSTREAM)) 
                                                             (* ; 
                                                         "The end of the plain-text part of the file")
                                 (\WOUT LOOKSTREAM PCCOUNT)  (* ; "Number of pieces")
                                 (\WOUT LOOKSTREAM 31418)    (* ; 
                                                          "Password for format-file version 3: 31418")
                                 (CL:UNLESS UNFORMATTED?

                                     (* ;; "Append LOOKSTREAM to the end of CHARSTREAM unless UNFORMATTED?. This is undocumented but used internally by COERECETEXTOBJ. ")

                                     (COPYBYTES LOOKSTREAM CHARSTREAM 0 (GETEOFPTR LOOKSTREAM))) 

                                 (* ;; "Throw away the dummy head of the new piece chain (NEWPIECES is NIL if caching). The caller must make newpieces safe and then installed them.")

                                 (RETURN (AND NEWPIECES (NEXTPIECE NEWPIECES])

(\TEDIT.PUT.PCTB.MERGEABLE
  [LAMBDA (PREVPC PC EDITSTENTATIVE)                         (* ; "Edited 22-Sep-2023 10:12 by rmk")
                                                             (* ; "Edited  6-Sep-2023 00:03 by rmk")
                                                             (* ; "Edited 24-Aug-2023 11:03 by rmk")

    (* ;; "True if PREVPC and PC have enough properties in common so they can be concatenated together into a single new piece on a file.  The PPARALOOKS test allows for the possibility that different pieces in a paragraph might have different formatting (e.g. tab stops)--but that will mess up assumptions that the paragraph menu and maybe other things depend on.  PBYTESPERCHAR is a good first filter.")

    (AND (EQ (PBYTESPERCHAR PREVPC)
             (PBYTESPERCHAR PC))
         (SELECTC (PTYPE PREVPC)
             ((LIST THINFILE.PTYPE THINSTRING.PTYPE) 
                  (MEMB (PTYPE PC)
                        (CONSTANT (LIST THINFILE.PTYPE THINSTRING.PTYPE))))
             ((LIST FATFILE2.PTYPE FATSTRING.PTYPE) 
                  (MEMB (PTYPE PC)
                        (CONSTANT (LIST FATFILE2.PTYPE FATSTRING.PTYPE))))
             (OBJECT.PTYPE NIL)
             NIL)
         (EQ (PLOOKS PREVPC)
             (PLOOKS PC))
         (EQ (PPARALOOKS PREVPC)
             (PPARALOOKS PC))
         (NOT (PPARALAST PREVPC))
         (OR (NOT EDITSTENTATIVE)
             (EQ (PNEW PREVPC)
                 (PNEW PC])

(\TEDIT.INSERT.NEWPIECES
  [LAMBDA (STREAM TEXTOBJ NEWPIECES)                         (* ; "Edited 18-Dec-2023 17:00 by rmk")
                                                             (* ; "Edited 11-Nov-2023 16:31 by rmk")
                                                             (* ; "Edited  8-Sep-2023 16:32 by rmk")

    (* ;; "This makes the pieces and BTREE of TEXTOBJ consistent with the NEWPIECES chain and the new OFILE.  The character numbers of old and new pieces correspond, so editing should continue without updating panes, lines, or selections (which are all based on character numbers, not particular pieces).  This puts STREAM as the PFILE of each new piece, insures safety (which fixes the ptypes etc), and then installs NEWPIECES in TEXTOBJ, replacing the BTREE and pieces already there.")

    (\DTEST TEXTOBJ 'TEXTOBJ)

    (* ;; "The \SETFILEPTR translates TSTREAM's buffer parameters to the new file. ")

    (LET ((TSTREAM (GETTOBJ TEXTOBJ STREAMHINT))
          FILEPTR)
         (SETQ FILEPTR (\TEXTGETFILEPTR TSTREAM))
         (for PC inpieces NEWPIECES unless (EQ OBJECT.PTYPE (PTYPE PC))
            do (FSETPC PC PCONTENTS STREAM))                 (* ; "Non-object pieces are on OFILE")
         (SETQ NEWPIECES (\TEDIT.MAKE.SAFE.PIECES NEWPIECES))

         (* ;; "Here, finally, we toss the out-of-date pieces to install the new ones. For complete safety, the rest should be uninterruptable (although the file has just been saved, so nothing would really be lost)")

         (\MAKEPCTB TEXTOBJ)
         (\INSERTPIECES NEWPIECES NIL TEXTOBJ)               (* ; 
                                                             "Build the tree, then fix the stream")

         (* ;; "This guards agains the possiblity that a sequence of edits somehow got the positioning parameters cached in the stream out of step with the document.  This ensures that they are consistent after all the pieces have been written out.")

         (\TEXTSETFILEPTR TSTREAM (IMAX 0 (IMIN FILEPTR (FGETTOBJ TEXTOBJ TEXTLEN])

(\TEDIT.PUTRESET
  [LAMBDA (PROC&VALUE)                                       (* jds "15-May-85 16:38")
    (CONS (CAR PROC&VALUE)
          (PROCESSPROP (CAR PROC&VALUE)
                 'BEFOREEXIT
                 (CDR PROC&VALUE])

(\ARBOUT
  [LAMBDA (STREAM ITEM)                                      (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited  7-Sep-2023 09:06 by rmk")
                                                             (* ; "Edited 20-Apr-88 19:55 by jds")

    (* ;; "Write an arbitrary MKSTRING-able thing in length-contents form.  SIZE is in characters, not bytes, which is OK because \STRINGIN uses READCCODE.")

    (LET [(SIZE (AND ITEM (NCHARS ITEM T *TEDIT-FILE-READTABLE*]
         (\WOUT STREAM (OR SIZE 0))
         (OR (NOT ITEM)
             (ZEROP SIZE)
             (PRIN2 ITEM STREAM *TEDIT-FILE-READTABLE*))
         NIL])

(\ATMOUT
  [LAMBDA (STREAM ATOM)                                      (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds "30-Jan-85 14:46")
                                                             (* Write an atom's characters in 
                                                             length-contents form.)
    (\WOUT STREAM (COND
                     (ATOM (NCHARS ATOM))
                     (T 0)))
    (OR (NOT ATOM)
        (ZEROP (NCHARS ATOM))
        (for CH inatom ATOM do (\BOUT STREAM CH])

(\DWOUT
  [LAMBDA (FILE NUMBER)                                      (* jds " 3-JAN-83 15:30")
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 24)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 16)))
    (\BOUT FILE (LOGAND 255 (LRSH NUMBER 8)))
    (\BOUT FILE (LOGAND 255 NUMBER])

(\STRINGOUT
  [LAMBDA (STREAM STRING LEN)                                (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds " 1-May-84 11:58")

         (* Write a string on a file in length-contents form;
         one word for the length, and one byte per character contained.)

    (SETQ LEN (OR LEN (NCHARS STRING)))
    (\WOUT STREAM LEN)
    (OR (ZEROP LEN)
        (for CH instring STRING as I from 1 to LEN do (\BOUT STREAM CH])
)
(DEFINEQ

(\TEDIT.PUT.CHARLOOKS.LIST
  [LAMBDA (LOOKSFILE LOOKSHASH LOOKSLIST LOOKSHASH)          (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:08 by rmk")
                                                             (* jds " 5-Mar-85 15:58")
                                                             (* ; 
                                                   "Write the list of CHARLOOKSs into the font file.")

    (* ;; "Returns a hasharray that will map from a given CHARLOOKS to its index in the list.  Those position numbers are then written in the individual piece descriptions, and are used to reconstruct the piece looks when the file is read back in.  These descriptions are written in a 0-character pseudo-piece")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
                                         "No characters, marked as containing the list of CHARLOOKSs")
    (\WOUT LOOKSFILE \PieceDescriptorCHARLOOKSLIST)
    (\WOUT LOOKSFILE (FLENGTH LOOKSLIST))                    (* ; "Number of charlooks to follow")
    (for I from 1 as LOOKS in LOOKSLIST do 
                                           (* ;; 
                                        "Write each charlooks, in the order they appear in the list.")

                                           (\TEDIT.PUT.SINGLE.CHARLOOKS LOOKSFILE LOOKS)
                                           (PUTHASH LOOKS I LOOKSHASH])

(\TEDIT.PUT.SINGLE.CHARLOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 21-Dec-2023 23:54 by rmk")
                                                             (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 26-Aug-2023 11:29 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:17 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")

    (* ;; "Put out a single CHARLOOKS description.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          (FONT (fetch (CHARLOOKS CLFONT) of LOOKS))
          LEN)
         (\WOUT FONTFILE 0)                                  (* ; 
                                                         "Reserve space for the length of this looks")
         [COND
            ((type? FONTCLASS FONT)                          (* ; 
                                         "For font classes, we need to save a list of device-FD sets")
             (\ARBOUT FONTFILE (FONTCLASSUNPARSE FONT)))
            (T                                               (* ; 
                                                            "For FONTDESCRIPTORs, do it the easy way")
               (\ATMOUT FONTFILE (FONTPROP FONT 'FAMILY]     (* ; "The font family")
         (\WOUT FONTFILE (OR (FONTPROP FONT 'SIZE)
                             0))                             (* ; "Size of the type, in points")
         (\WOUT FONTFILE (OR (fetch (CHARLOOKS CLOFFSET) of LOOKS)
                             0))                             (* ; "Super/subscripting distance")
         (COND
            ([AND (fetch (CHARLOOKS CLSTYLE) of LOOKS)
                  (NOT (ZEROP (fetch (CHARLOOKS CLSTYLE) of LOOKS]
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLSTYLE) of LOOKS)))
            (T (\WOUT FONTFILE 0)))
         (COND
            ((fetch (CHARLOOKS CLUSERINFO) of LOOKS)
             (\ARBOUT FONTFILE (fetch (CHARLOOKS CLUSERINFO) of LOOKS)))
            (T (\WOUT FONTFILE 0)))
         (\WOUT FONTFILE (LOGOR (CL:IF (fetch (CHARLOOKS CLUNBREAKABLE) of LOOKS)
                                    4096
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLLEADER) of LOOKS)
                                    2048
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLINVERTED) of LOOKS)
                                    1024
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                    512
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLITAL) of LOOKS)
                                    256
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLULINE) of LOOKS)
                                    128
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLOLINE) of LOOKS)
                                    64
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSTRIKE) of LOOKS)
                                    32
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSMALLCAP) of LOOKS)
                                    16
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLPROTECTED) of LOOKS)
                                    8
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLINVISIBLE) of LOOKS)
                                    4
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLSELHERE) of LOOKS)
                                    2
                                    0)
                                (CL:IF (fetch (CHARLOOKS CLCANCOPY) of LOOKS)
                                    1
                                    0)))

         (* ;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Go write the length field")
         (\WOUT FONTFILE LEN)                                (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.CHARLOOKS
  [LAMBDA (LOOKSFILE OLDBYTE# CURBYTE# PREVPC EDITSTENTATIVE LOOKSHARRAY)
                                                             (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 26-Aug-2023 19:53 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:40 by rmk")
                                                             (* ; "Edited 23-Aug-2023 22:27 by rmk")
                                                             (* ; "Edited 24-Jul-2023 17:21 by rmk")
                                                             (* ; "Edited  8-Sep-2022 22:54 by rmk")
                                                             (* ; "Edited 30-May-91 21:45 by jds")

    (* ;; "Put a description of PREVPC's charlooks into LOOKSFILE.  The looks apply to bytes OLDBYTE# thru CURBYTE#-1")

    (\DWOUT LOOKSFILE (IDIFFERENCE CURBYTE# OLDBYTE#))       (* ; "The length of this run of looks")
    (\WOUT LOOKSFILE \PieceDescriptorLOOKS)                  (* ; 
                                                             "Mark this as setting the piece's looks")

    (* ;; "Flag for newness and fatness")

    (\BOUT LOOKSFILE (LOGOR (CL:IF (AND EDITSTENTATIVE PREVPC (PNEW PREVPC))
                                1
                                0)
                            (CL:IF (AND PREVPC (EQ FATFILE2.PTYPE (PTYPE PREVPC)))
                                2
                                0)))                         (* ; "The index into the list of fonts")
    (\WOUT LOOKSFILE (GETHASH (PLOOKS PREVPC)
                            LOOKSHARRAY])
)
(DEFINEQ

(\TEDIT.PUT.PARALOOKS.LIST
  [LAMBDA (LOOKSFILE PARAHASH PARALOOKS)                     (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:39 by rmk")
                                                             (* ; "Edited 15-Aug-2023 23:25 by rmk")
                                                             (* ; "Edited  1-Sep-87 20:34 by jds")

    (* ;; "Write out the looks in a no-characters pseudo-piece, producing a hashtable of their arbitrary indexes for future reference.")

    (\DWOUT LOOKSFILE 0)
    (\WOUT LOOKSFILE \PieceDescriptorPARALOOKSLIST)
    (\WOUT LOOKSFILE (FLENGTH PARALOOKS))
    (for I from 1 as PL in PARALOOKS do (\TEDIT.PUT.SINGLE.PARALOOKS LOOKSFILE PL)
                                        (PUTHASH PL I PARAHASH])

(\TEDIT.PUT.SINGLE.PARALOOKS
  [LAMBDA (FONTFILE LOOKS)                                   (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 16-Aug-2023 22:11 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:25 by rmk")
                                                             (* ; 
                                                        "Edited  2-Jul-93 21:30 by sybalskY:MV:ENVOS")

    (* ;; "Put a description of LOOKS into FILE.")

    (LET ((FILEPOS (GETFILEPTR FONTFILE))
          DEFTAB TABSPECS LEN)
         (\WOUT FONTFILE 0)                                  (* ; 
                                                             "Reserve space to store the look length")
         (\WOUT FONTFILE (fetch (FMTSPEC 1STLEFTMAR) of LOOKS))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEFTMAR) of LOOKS)) (* ; 
                                                          "Left margin for the rest of the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC RIGHTMAR) of LOOKS))(* ; "Right margin for the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEADBEFORE) of LOOKS))
                                                             (* ; "Leading before the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LEADAFTER) of LOOKS))
                                                             (* ; "Lead after the paragraph")
         (\WOUT FONTFILE (fetch (FMTSPEC LINELEAD) of LOOKS))(* ; "inter-line leading")
         (SETQ DEFTAB (CAR (fetch (FMTSPEC TABSPEC) of LOOKS)))
         (SETQ TABSPECS (CDR (fetch (FMTSPEC TABSPEC) of LOOKS)))

         (* ;; "Indicate whether there are tab specs  or a default tab setting to save")

         (\BOUT FONTFILE (CL:IF (OR DEFTAB TABSPECS)
                             3
                             2))
         (\BOUT FONTFILE (SELECTQ (fetch (FMTSPEC QUAD) of LOOKS)
                             (LEFT 1)
                             (RIGHT 2)
                             ((CENTER CENTERED) 
                                  3)
                             ((JUST JUSTIFIED) 
                                  4)
                             (SHOULDNT)))
         (CL:WHEN (OR TABSPECS DEFTAB)                       (* ; "There are tab specs to save.")
             (\WOUT FONTFILE (OR DEFTAB 0))
             (CL:WHEN (IGREATERP (LENGTH TABSPECS)
                             255)
                    (SHOULDNT "Paragraph has more than 255 TABs set--can't be saved."))
             (\BOUT FONTFILE (LENGTH TABSPECS))
             [for TAB in TABSPECS do (\WOUT FONTFILE (fetch TABX of TAB)) 
                                                             (* ; "Setting and tab type.")
                                     (\BOUT FONTFILE (SELECTQ (fetch TABKIND of TAB)
                                                         (LEFT 0)
                                                         (RIGHT 1)
                                                         (CENTERED 2)
                                                         (DECIMAL 3)
                                                         (DOTTEDLEFT 4)
                                                         (DOTTEDRIGHT 5)
                                                         (DOTTEDCENTERED 
                                                              6)
                                                         (DOTTEDDECIMAL 7)
                                                         (SHOULDNT])
         (\WOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALX) of LOOKS)
                             0))
         (\WOUT FONTFILE (OR (fetch (FMTSPEC FMTSPECIALY) of LOOKS)
                             0))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTUSERINFO) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARATYPE) of LOOKS))
         (\ATMOUT FONTFILE (fetch (FMTSPEC FMTPARASUBTYPE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTSTYLE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTNEWPAGEAFTER) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTHEADINGKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTKEEP) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTBASETOBASE) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTREVISED) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCOLUMN) of LOOKS))
         (\ARBOUT FONTFILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))

(* ;;; "Now go fill in the length field at the front of the LOOKS.  (ALL looks info should be written out BEFORE this comment.)")

         (SETQ LEN (IDIFFERENCE (GETFILEPTR FONTFILE)
                          FILEPOS))                          (* ; "The length of this set of looks")
         (SETFILEPTR FONTFILE FILEPOS)                       (* ; "Write the length field")
         (\WOUT FONTFILE LEN)                                (* ; "And back to the end of the file")
         (SETFILEPTR FONTFILE -1])

(\TEDIT.PUT.PARALOOKS
  [LAMBDA (LOOKSFILE PC PARAHASH)                            (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 25-Aug-2023 11:41 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:28 by rmk")
                                                             (* ; "Edited 30-May-91 21:44 by jds")

    (* ;; 
  "Put the identifier of PC's paralooks into LOOKSFILE.  This applies to characters CH1 thru CHLIM-1")

    (\DWOUT LOOKSFILE 0)                                     (* ; 
             "Place holder for number of characters in the piece -- really taken from the charlooks.")
    (\WOUT LOOKSFILE \PieceDescriptorPARA)                   (* ; 
                                                           "Identify this as a paragraph looks piece")
    (\WOUT LOOKSFILE (OR (FIXP PC)
                         (GETHASH (PPARALOOKS PC)
                                PARAHASH])
)
(DEFINEQ

(TEDIT.PUT.OBJECT
  [LAMBDA (PIECE OFILE LOOKSFILE CURFILEBYTE#)               (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 26-Aug-2023 15:13 by rmk")
                                                             (* ; "Edited 17-Jul-2023 16:39 by rmk")
                                                             (* ; "Edited  6-Aug-2022 10:02 by rmk")
                                                            (* ; "Edited 12-Jun-90 17:49 by mitani")

    (* ;; "Given a piece which describes an object, put the object out there.")

    (LET ((OBJECT (fetch (PIECE PCONTENTS) of PIECE))
          (ORIGFILEPTR (GETFILEPTR LOOKSFILE))
          BYTELEN)
         (\DWOUT LOOKSFILE 0)                                (* ; 
                                            "Placeholder for byte-length of the object's description")
         (\WOUT LOOKSFILE \PieceDescriptorOBJECT)            (* ; 
                                                             "Mark this as setting the piece's looks")
         (\ATMOUT LOOKSFILE (IMAGEOBJPROP OBJECT 'GETFN))    (* ; 
                                                          "The FN to apply to reconstruct the object")
         (APPLY* (IMAGEOBJPROP OBJECT 'PUTFN)
                OBJECT OFILE)
         (SETQ BYTELEN (ADD1 (IDIFFERENCE (GETEOFPTR OFILE)
                                    CURFILEBYTE#)))
         (SETFILEPTR LOOKSFILE ORIGFILEPTR)                  (* ; 
                          "Now go back and fill in the length of the text description of the object.")
         (\DWOUT LOOKSFILE BYTELEN)
         (SETFILEPTR LOOKSFILE -1)                           (* ; 
                                                             "Move back to the end of the looks file")
         (CL:WHEN (RANDACCESSP OFILE)                        (* ; "And the end of OFILE")
             (SETFILEPTR OFILE -1))
         BYTELEN])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.INPUT.FORMATS *TEDIT-FILE-READTABLE*)
)
(DEFINEQ

(TEDITFROMLISPSOURCE
  [LAMBDA (SOURCEFILE TSTREAM PROPS USERTEMP START END)      (* ; "Edited  5-Dec-2023 23:46 by rmk")
                                                             (* ; "Edited 26-Oct-2023 11:22 by rmk")
                                                             (* ; "Edited 22-Oct-2023 22:55 by rmk")
                                                             (* ; "Edited 22-Sep-2023 09:07 by rmk")

    (* ;; "This is called because OPENTEXTSTREAM recognized that SOURCESTREAM is a LISPSOURCEP foreign-format file.  TSTREAM may have a partially instantiated attached window with region and prompt, etc., but may not yet have the properties of a text or process.")

    (* ;; 
    "TSTREAM and its window are available to provide default looks and region for the empty stream")

    (CL:UNLESS TSTREAM
        (SETQ TSTREAM (OPENTEXTSTREAM)))

    (* ;; "An empty window for TSTREAM may already be up on the screen.  Since this conversion can take awhile, we tell the user what's going on")

    (TEDIT.PROMPTPRINT TSTREAM (CONCAT "Fetching " (FULLNAME SOURCEFILE)
                                      " ...")
           T)
    (COPY.TEXT.TO.IMAGE SOURCEFILE TSTREAM)
    (TEDIT.PROMPTCLEAR TSTREAM)
    (TEXTPROP TSTREAM 'BOUNDTABLE TEDIT.ATOMBOUND.READTABLE)
    TSTREAM])
)

(ADDTOVAR TEDIT.INPUT.FORMATS (LISPSOURCEFILEP TEDITFROMLISPSOURCE))

(RPAQ? *TEDIT-FILE-READTABLE* (COPYREADTABLE \ORIGREADTABLE))



(* ;; "For converting old incoming format.  Cutover 5/22/85 to permit looks changes in the future.")

(DEFINEQ

(\TEDIT.GET.PCTB2
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 25-Nov-2023 23:18 by rmk")
                                                             (* ; "Edited  8-Nov-2023 13:48 by rmk")
                                                             (* ; "Edited  4-Oct-2022 16:58 by rmk")
                                                             (* ; "Edited  8-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited  5-Sep-2022 21:33 by rmk")
                                                             (* ; "Edited  4-May-93 16:27 by jds")

    (* ;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (* ;; "START = 1st char of file to read from, if specified")

    (* ;; "END = use this as eofptr of file.  For use in reading files within files.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (LET (PIECEINFOCH# (CURFILECH# (OR START 0))
                LOOKSHASH PARAHASH)
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
               (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) for I from 1 to PCCOUNT
            do (SETQ PC NIL)                                 (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
               (SETQ PCLEN (\DWIN TEXT))
               (SETQ TYPECODE (\WIN TEXT))                   (* ; "What kind of piece is it?")
               (SELECTC TYPECODE
                   (\PieceDescriptorPAGEFRAME                (* ; 
                                                             "This is page layout info for the file")
                        (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (\TEDIT.PARSE.PAGEFRAMES2 (READ TEXT))))
                   (\PieceDescriptorCHARLOOKSLIST            (* ; 
                                              "This is the list of CHARLOOKSs used in this document.")
                        (FSETTOBJ TEXTOBJ TXTCHARLOOKSLIST (\TEDIT.GET.CHARLOOKS.LIST2 TEXT))
                                                             (* ; 
                                                      "Read the list of looks used in this document.")
                        [SETQ LOOKSHASH (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                        (for I from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTCHARLOOKSLIST)
                           do (SETA LOOKSHASH I LOOKS))
                        (add I -1))
                   (\PieceDescriptorPARALOOKSLIST            (* ; 
                                              "This is the list of PARALOOKSs used in this document.")
                        (FSETTOBJ TEXTOBJ TXTPARALOOKSLIST (\TEDIT.GET.PARALOOKS.LIST2 TEXT))
                                                             (* ; 
                                                      "Read the list of looks used in this document.")
                        [SETQ PARAHASH (ARRAY (FLENGTH (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST]
                                                             (* ; 
                                         "Build an array of the looks, so the reader can index them.")
                        (for I from 1 as LOOKS in (FGETTOBJ TEXTOBJ TXTPARALOOKSLIST)
                           do (SETA PARAHASH I LOOKS))
                        (add I -1))
                   (\PieceDescriptorPARA                     (* ; 
                                                             "Reading a new set of paragraph looks.")
                        (CL:WHEN OLDPC (FSETPC OLDPC PPARALAST T))
                                                             (* ; 
                                                           "Mark the end of the preceding paragraph.")
                        (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS TEXT PARAHASH))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                          "Mark the document as containing paragraph formatting info")
                        (FSETTOBJ TEXTOBJ FORMATTEDP T))
                   (\PieceDescriptorLOOKS 
                                          (* ;; 
       "New character looks.  Build a piece to describe those characters, assuming THINFILE to begin")

                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PBYTELEN _ PCLEN
                                PLEN _ PCLEN
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE
                                PBYTESPERCHAR _ 1
                                PBINABLE _ 1))               (* ; "Build the new piece")
                        (\TEDIT.GET.CHARLOOKS PC TEXT LOOKSHASH)
                                                             (* ; 
                                                             "Read the character looks for this guy.")
                        (COND
                           [OLDPC                            (* ; 
                                              "If there's a prior piece, hook this one on the chain.")
                                  (COND
                                     ([AND (EQ FATFILE2.PTYPE (PTYPE PC))
                                           (NOT (EQ FATFILE2.PTYPE (PTYPE OLDPC]
                                                             (* ; 
                                      "Switching from not-fat to fat.  Add 3 bytes for the 255-255-0")
                                      (add (PFPOS PC)
                                           3)
                                      (add CURFILECH# -3))
                                     ([AND (EQ FATFILE2.PTYPE (PTYPE OLDPC))
                                           (NOT (EQ FATFILE2.PTYPE (PTYPE PC]
                                                             (* ; 
                                          "Switching from fat to not-fat.  Add 3 bytes for the 255-0")
                                      (add (PFPOS PC)
                                           2]
                           ((EQ FATFILE2.PTYPE (PTYPE PC))   (* ; 
                                      "Switching from not-fat to fat.  Add 3 bytes for the 255-255-0")
                            (add (PFPOS PC)
                                 3)
                            (add CURFILECH# -3)))            (* ; 
                                                             "And note the passing of characters.")
                        (add CURFILECH# PCLEN))
                   (\PieceDescriptorOBJECT                   (* ; 
   "It describes an object.  Read that, and perhaps some description of the charlooks to go with it.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ 1
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ OBJECT.PTYPE
                                PBYTESPERCHAR _ PCLEN))
                        (TEDIT.GET.OBJECT (FGETTOBJ TEXTOBJ STREAMHINT)
                               PC TEXT CURFILECH# PCLEN)
                        (add CURFILECH# PCLEN)
                        (FSETPC PC PLOOKS (if (ZEROP (BIN TEXT))
                                              then 
                                                   (* ;; 
                                                   "No new looks;  steal them from the prior piece.")

                                                   (OR (AND OLDPC (PLOOKS OLDPC))
                                                       DEFAULTCHARLOOKS)
                                            else 
                                                 (* ;; 
                                      "There are new character looks for this object.  Read them in.")

                                                 (\TEDIT.GET.SINGLE.CHARLOOKS2 TEXT))))
                   (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))
               (CL:WHEN PC                                   (* ; 
                                                       "If we created a piece, save it in the table.")
                   (\INSERTPIECE PC NIL TEXTOBJ)
                   (SETQ OLDPC PC))])

(\TEDIT.PARSE.PAGEFRAMES2
  [LAMBDA (PAGELIST PARENT)                                  (* ; "Edited 13-Nov-2023 00:21 by rmk")
                                                             (* ; "Edited  7-Nov-2023 13:24 by rmk")
                                                             (* ; "Edited  4-Oct-2022 16:57 by rmk")
                                                             (* jds "31-Jul-84 15:30")

    (* ;; "Internalize an external pageframe.")

    (* ;; "Exactly like \TEDIT.PARSE.PAGEFRAMES1, except this doesn't scale the region specs.  Except that if it looks like a PAGE region appears to be the result of mistakenly treating points as micas and scaling them down, we scale them back up.")

    (LET (FRAMETYPE PAGEFRAME)
         (COND
            ((type? PAGEREGION PAGELIST)
             PAGELIST)
            ((NEQ 'LIST (SETQ FRAMETYPE (pop PAGELIST)))
             [SETQ PAGEFRAME (create PAGEREGION
                                    REGIONFILLMETHOD _ FRAMETYPE
                                    REGIONTYPE _ (pop PAGELIST)
                                    REGIONLOCALINFO _ (pop PAGELIST)
                                    REGIONSPEC _ (OR (pop PAGELIST)
                                                     (LIST 0 0 0 0]
             (CL:WHEN (AND (EQ 'PAGE (fetch (PAGEREGION REGIONFILLMETHOD) of PAGEFRAME))
                           (LESSP (fetch (REGION WIDTH) of (fetch (PAGEREGION REGIONSPEC)
                                                              of PAGEFRAME))
                                  18))
                 (change (fetch (PAGEREGION REGIONSPEC) of PAGEFRAME)
                        (SELECTQ (fetch (REGION HEIGHT) of DATUM)
                            (22                              (* ; "Letter")
                                (CREATEREGION 0 0 612 792))
                            (29                              (* ; "Legal")
                                (CREATEREGION 0 0 612 1008))
                            (24                              (* ; "A4")
                                (CREATEREGION 0 0 595 842))
                            (fetch (PAGEREGION REGIONSPEC) of DATUM))))
             (replace REGIONSUBBOXES of PAGEFRAME with (for ALIST in (pop PAGELIST)
                                                          collect (\TEDIT.PARSE.PAGEFRAMES2 ALIST 
                                                                         PAGEFRAME)))
             PAGEFRAME)
            (T (for FRAMESPEC in (CAR PAGELIST) collect (\TEDIT.PARSE.PAGEFRAMES2 FRAMESPEC NIL])

(\TEDIT.GET.CHARLOOKS.LIST2
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "22-May-85 14:28")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.CHARLOOKS2 FILE])

(\TEDIT.GET.SINGLE.CHARLOOKS2
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 25-Nov-2023 23:22 by rmk")
                                                             (* ; "Edited  7-Nov-2023 22:00 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* ; "Read a set of CHARLOOKS from FILE")
    (PROG* ((LOOKS (create CHARLOOKS))
            FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR)
           (SETQ NAME (\ARBIN FILE))                         (* ; "The font name")
           (SETQ SIZE (\WIN FILE))                           (* ; "Size of the type, in points")
           (SETQ SUPER (\WIN FILE))                          (* ; "Superscripting distance")
           (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                          0))
           (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE))
           (SETQ PROPS (\WIN FILE))
           (with CHARLOOKS LOOKS [SETQ CLLEADER (NOT (ZEROP (LOGAND 2048 PROPS]
                 [SETQ CLINVERTED (NOT (ZEROP (LOGAND 1024 PROPS]
                 [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                 [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                 [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                 [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                 [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                 [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                 [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                 [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                 [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                 [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                 (SETQ CLSIZE SIZE)
                 (SETQ CLOFFSET SUPER))
           [SETQ FONT (COND
                         ((LISTP NAME)                       (* ; 
                                                             "This was a font class.  Restore it.")
                          (FONTCLASS (pop NAME)
                                 NAME))
                         ((AND NAME (NOT (ZEROP SIZE)))
                          (FONTCREATE NAME SIZE (COND
                                                   ((AND (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                         (fetch (CHARLOOKS CLITAL) of LOOKS))
                                                    'BOLDITALIC)
                                                   ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                    'BOLD)
                                                   ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                                    'ITALIC]
           (replace (CHARLOOKS CLNAME) of LOOKS
              with (if (type? FONTCLASS FONT)
                       then 
                            (* ;; "Put the display family in the CLNAME spot.  Better than NIL.")

                            (CL:WHEN [SETQ NAME (FONTCOPY FONT '(DEVICE DISPLAY NOERROR T]
                                (FONTPROP NAME 'FAMILY))
                     else NAME))
           (replace (CHARLOOKS CLFONT) of LOOKS with FONT)
           (RETURN LOOKS])

(\TEDIT.PUT.SINGLE.PARALOOKS2
  [LAMBDA (FILE LOOKS)                                       (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:23 by rmk")
                                                             (* ; "Edited 30-May-91 20:33 by jds")
                                                             (* ; 
                  "Put a description of LOOKS into FILE.  LOOKS apply to characters CH1 thru CHLIM-1")
    (PROG (DEFTAB TABSPECS OUTPUTFORMAT LEN)
          (\WOUT FILE (fetch (FMTSPEC 1STLEFTMAR) of LOOKS)) (* ; 
                                                    "Left margin for the first line of the paragraph")
          (\WOUT FILE (fetch (FMTSPEC LEFTMAR) of LOOKS))    (* ; 
                                                          "Left margin for the rest of the paragraph")
          (\WOUT FILE (fetch (FMTSPEC RIGHTMAR) of LOOKS))   (* ; "Right margin for the paragraph")
          (\WOUT FILE (fetch (FMTSPEC LEADBEFORE) of LOOKS)) (* ; "Leading before the paragraph")
          (\WOUT FILE (fetch (FMTSPEC LEADAFTER) of LOOKS))  (* ; "Lead after the paragraph")
          (\WOUT FILE (fetch (FMTSPEC LINELEAD) of LOOKS))   (* ; "inter-line leading")
          (SETQ DEFTAB (CAR (fetch (FMTSPEC TABSPEC) of LOOKS)))
          (SETQ TABSPECS (CDR (fetch (FMTSPEC TABSPEC) of LOOKS)))
          (COND
             ((AND (fetch (FMTSPEC TABSPEC) of LOOKS)
                   (OR DEFTAB TABSPECS))                     (* ; 
                             "There are tab specs to save, or there is a default tab setting to save")
              (\BOUT FILE 3))
             (T                                              (* ; 
                                                          "There are no tab looks.  Just let him go.")
                (\BOUT FILE 2)))
          (\BOUT FILE (SELECTQ (fetch (FMTSPEC QUAD) of LOOKS)
                          (LEFT 1)
                          (RIGHT 2)
                          ((CENTER CENTERED) 
                               3)
                          ((JUST JUSTIFIED) 
                               4)
                          (SHOULDNT)))
          [COND
             ((OR TABSPECS DEFTAB)                           (* ; "There are tab specs to save.")
              (COND
                 (DEFTAB (\WOUT FILE DEFTAB))
                 (T (\WOUT FILE 0)))
              (\BOUT FILE (LENGTH TABSPECS))
              (COND
                 (TABSPECS                                   (* ; "# of tab settings <256!")
                        (for TAB in TABSPECS do (\WOUT FILE (fetch TABX of TAB)) 
                                                             (* ; "And setting.")
                                                (\BOUT FILE (SELECTQ (fetch TABKIND of TAB)
                                                                (LEFT 0)
                                                                (RIGHT 1)
                                                                (CENTERED 2)
                                                                (DECIMAL 3)
                                                                (SHOULDNT))) 
                                                             (* ; "Tab type")]
          (\WOUT FILE (OR (fetch (FMTSPEC FMTSPECIALX) of LOOKS)
                          0))
          (\WOUT FILE (OR (fetch (FMTSPEC FMTSPECIALY) of LOOKS)
                          0))
          (\ARBOUT FILE (fetch (FMTSPEC FMTUSERINFO) of LOOKS))
          (\ATMOUT FILE (fetch (FMTSPEC FMTPARATYPE) of LOOKS))
          (\ATMOUT FILE (fetch (FMTSPEC FMTPARASUBTYPE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTSTYLE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTCHARSTYLES) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS))
          (\ARBOUT FILE (fetch (FMTSPEC FMTNEWPAGEAFTER) of LOOKS])

(\TEDIT.PUT.SINGLE.CHARLOOKS2
  [LAMBDA (FILE LOOKS)                                       (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Put out a single CHARLOOKS 
                                                             description.)
    (PROG ((FONT (fetch (CHARLOOKS CLFONT) of LOOKS))
           STR LEN)
          [COND
             ((type? FONTCLASS FONT)                         (* For font classes, we need to save a 
                                                             list of device-FD sets)
              (\ARBOUT FILE (FONTCLASSUNPARSE FONT)))
             (T                                              (* For FONTDESCRIPTORs, do it the easy 
                                                             way)
                (\ATMOUT FILE (FONTPROP FONT 'FAMILY]        (* The font family)
          (\WOUT FILE (OR (FONTPROP FONT 'SIZE)
                          0))                                (* Size of the type, in points)
          (\WOUT FILE (OR (fetch (CHARLOOKS CLOFFSET) of LOOKS)
                          0))                                (* Super/subscripting distance)
          (COND
             ([AND (fetch (CHARLOOKS CLSTYLE) of LOOKS)
                   (NOT (ZEROP (fetch (CHARLOOKS CLSTYLE) of LOOKS]
              (\ARBOUT FILE (fetch (CHARLOOKS CLSTYLE) of LOOKS)))
             (T (\WOUT FILE 0)))
          (COND
             ((fetch (CHARLOOKS CLUSERINFO) of LOOKS)
              (\ARBOUT FILE (fetch (CHARLOOKS CLUSERINFO) of LOOKS)))
             (T (\WOUT FILE 0)))
          (\WOUT FILE (LOGOR (COND
                                ((fetch (CHARLOOKS CLLEADER) of LOOKS)
                                                             (* Dotted-leader; relevant only to 
                                                             TABs)
                                 2048)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLINVERTED) of LOOKS)
                                                             (* Inverse-video)
                                 1024)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                 512)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                 256)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLULINE) of LOOKS)
                                 128)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLOLINE) of LOOKS)
                                 64)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLSTRIKE) of LOOKS)
                                 32)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLSMALLCAP) of LOOKS)
                                 16)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLPROTECTED) of LOOKS)
                                 8)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLINVISIBLE) of LOOKS)
                                 NIL 4)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLSELHERE) of LOOKS)
                                 2)
                                (T 0))
                             (COND
                                ((fetch (CHARLOOKS CLCANCOPY) of LOOKS)
                                 1)
                                (T 0])

(\TEDIT.GET.PARALOOKS.LIST2
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* jds "22-May-85 14:28")
                                                             (* Read the list of CHARLOOKSs from 
                                                             the file.)
    (for I from 1 to (\WIN FILE) collect (\TEDIT.GET.SINGLE.PARALOOKS2 FILE])

(\TEDIT.GET.SINGLE.PARALOOKS2
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:18 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:33 by jds")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (PROG ((LOOKS (create FMTSPEC))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\WIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\WIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\WIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (COND
             ((NOT (ZEROP (LOGAND TABFLG 1)))                (* ; "There are tabs to read")
              (SETQ DEFTAB (\WIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\WIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (BIN FILE)
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (SHOULDNT]
              (CL:UNLESS (ZEROP DEFTAB)
                     (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS)))
          [COND
             ((NOT (ZEROP (LOGAND TABFLG 2)))                (* ; 
                                                   "There are other paragraph parameters to be read.")
              (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
              (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\WIN FILE))
              (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
              (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
              (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE]
          (RETURN LOOKS])

(\TEDIT.PUT.CHARLOOKS.LIST2
  [LAMBDA (FILE LOOKSLIST)                                   (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds "22-May-85 15:12")
                                                             (* Write the list of CHARLOOKSs into 
                                                             the font file.)

         (* Returns a hasharray that will map from a given CHARLOOKS to that CHARLOOKS' 
         position in the list we wrote on the file.
         Those position numbers are then written in the individual looks descriptions, and 
         are used to reconstruct the piece looks when the file is read back in.)

    (PROG ((LOOKSHASH (HASHARRAY 50)))
          (\DWOUT FILE 0)                                    (* No characters are described by this 
                                                             pseudo-piece entry.)
          (\WOUT FILE \PieceDescriptorCHARLOOKSLIST)         (* Mark it as containing the list of 
                                                             CHARLOOKSs)
          (\WOUT FILE (FLENGTH LOOKSLIST))                   (* How many CHARLOOKSs there are in 
                                                             the list)
          (for I from 1 as LOOKS in LOOKSLIST do             (* Write each charlooks, in the order 
                                                             they appear in the list.)
                                                 (\TEDIT.PUT.SINGLE.CHARLOOKS2 FILE LOOKS) 
                                                             (* Write out the description)
                                                 (PUTHASH LOOKS I LOOKSHASH) 
                                                             (* And save it in the hash table so 
                                                             people can find its index.))
          (RETURN LOOKSHASH])

(\TEDIT.PUT.PARALOOKS.LIST2
  [LAMBDA (FILE LOOKSLIST)                                   (* ; "Edited 19-Dec-2023 10:14 by rmk")
                                                             (* jds "22-May-85 15:09")
                                                             (* Write the list of FMTSPECs into the 
                                                             font file.)
    (PROG ((LOOKSHASH (HASHARRAY 50)))
          (\DWOUT FILE 0)
          (\WOUT FILE \PieceDescriptorPARALOOKSLIST)
          (\WOUT FILE (FLENGTH LOOKSLIST))
          (for I from 1 as LOOKS in LOOKSLIST do (\TEDIT.PUT.SINGLE.PARALOOKS2 FILE LOOKS) 
                                                             (* Write out the description)
                                                 (PUTHASH LOOKS I LOOKSHASH) 
                                                             (* And save it in the hash table so 
                                                             people can find its index.))
          (RETURN LOOKSHASH])
)



(* ;; "For converting incoming old-format files (1/27/85 cutover)")

(DEFINEQ

(\TEDIT.GET.PCTB1
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  8-Nov-2023 13:48 by rmk")
                                                             (* ; "Edited  7-Nov-2023 13:17 by rmk")
                                                             (* ; "Edited  6-Nov-2023 08:43 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:54 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:08 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:18 by rmk")
                                                             (* ; "Edited  5-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited 22-May-92 18:00 by jds")

(* ;;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (* ;; "START = 1st char of file to read from, if specified")

    (* ;; "END = use this as eofptr of file.  For use in reading files within files.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (LET (PIECEINFOCH# TSTREAM (CURFILECH# (OR START 0)))
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTCHARLOOKS _ (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS))
               (OLDPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) for I from 1 to PCCOUNT
            do (SETQ PC NIL)                                 (* ; 
                        "This loop may not really read a piece, so we have to distinguish that case.")
               (SETQ PCLEN (\DWIN TEXT))
               (SETQ TYPECODE (\WIN TEXT))                   (* ; "What kind of piece is it?")
               (SELECTC TYPECODE
                   (\PieceDescriptorPAGEFRAME                (* ; 
                                                             "This is page layout info for the file")
                        (FSETTOBJ TEXTOBJ TXTPAGEFRAMES (\TEDIT.GET.PAGEFRAMES1 TEXT)))
                   (\PieceDescriptorPARA                     (* ; 
                                                             "Reading a new set of paragraph looks.")
                        (CL:WHEN OLDPC                       (* ; 
                                                           "Mark the end of the preceding paragraph.")
                            (FSETPC OLDPC PPARALAST T))
                        (SETQ OLDPARALOOKS (\TEDIT.GET.PARALOOKS1 TEXT))
                                                             (* ; 
                                                 "Get the new set of looks, for use by later pieces.")
                                                             (* ; 
                                                    "The document contains paragraph formatting info")
                        (FSETTOBJ TEXTOBJ FORMATTEDP T))
                   (\PieceDescriptorLOOKS 
                                          (* ;; "New character looks.  Build a piece to describe those characters.  This format doesn't have fat characters.")

                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PBYTELEN _ PCLEN
                                PLEN _ PCLEN
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE
                                PBYTESPERCHAR _ 1))
                        (\TEDIT.GET.CHARLOOKS1 PC TEXT)      (* ; 
                                                             "Read the character looks for this guy.")
                        (add CURFILECH# (PLEN PC))           (* ; 
                                                             "And note the passing of characters.")
                        )
                   (\PieceDescriptorOBJECT                   (* ; 
   "It describes an object.  Read that, and perhaps some description of the charlooks to go with it.")
                        (SETQ PC
                         (create PIECE
                                PCONTENTS _ TEXT
                                PFPOS _ CURFILECH#
                                PLEN _ 1
                                PPARALOOKS _ OLDPARALOOKS
                                PTYPE _ THINFILE.PTYPE
                                PBYTESPERCHAR _ PCLEN))
                        (TEDIT.GET.OBJECT1 (FGETTOBJ TEXTOBJ STREAMHINT)
                               PC TEXT CURFILECH#)
                        (add CURFILECH# PCLEN)
                        [COND
                           ((NOT (ZEROP (BIN TEXT)))         (* ; 
                                      "There are new character looks for this object.  Read them in.")
                            (\DWIN TEXT)
                            (\WIN TEXT)                      (* ; 
                                              "Skip over the piece-type code we know has to be here.")
                            (\TEDIT.GET.CHARLOOKS1 PC TEXT))
                           (T                                (* ; 
                                                    "No new looks;  steal them from the prior piece.")
                              (FSETPC PC PLOOKS (OR (AND OLDPC (PLOOKS OLDPC))
                                                    DEFAULTCHARLOOKS])
                   (SHOULDNT "Impossible piece-type code"))
               (CL:WHEN PC
                   (\INSERTPIECE PC NIL TEXTOBJ)
                   (SETQ OLDPC PC))])

(\TEDIT.GET.PAGEFRAMES1
  [LAMBDA (FILE)                                             (* ; "Edited  7-Nov-2023 12:35 by rmk")
                                                             (* jds " 1-Feb-85 14:55")
                                                             (* ; 
                                          "Read a bunch of page frames from the file, and return it.")
    (\TEDIT.PARSE.PAGEFRAMES1 (READ FILE])

(\TEDIT.PARSE.PAGEFRAMES1
  [LAMBDA (PAGELIST PARENT)                                  (* ; "Edited  7-Nov-2023 13:27 by rmk")
                                                             (* ; "Edited  8-Mar-2023 18:14 by rmk")
                                                             (* ; "Edited  4-Oct-2022 16:57 by rmk")
                                                             (* ; "Edited  1-Oct-2022 16:02 by rmk")

    (* ;; "Internalize an external pageframe.")

    (* ;; "Exactly like \TEDIT.PARSE.PAGEFRAMES, except this scales the region specs from Micas to points.  However, that scaling is suppress if it looks like the PAGE regions are already in points")

    (LET (FRAMETYPE PAGEFRAME RSPEC)
         (COND
            ((type? PAGEREGION PAGELIST)
             PAGELIST)
            ((NEQ 'LIST (SETQ FRAMETYPE (pop PAGELIST)))
             [SETQ PAGEFRAME (create PAGEREGION
                                    REGIONFILLMETHOD _ FRAMETYPE
                                    REGIONTYPE _ (pop PAGELIST)
                                    REGIONLOCALINFO _ (pop PAGELIST)
                                    REGIONSPEC _
                                    (if (AND (SETQ RSPEC (OR (pop PAGELIST)
                                                             (CREATEREGION 0 0 0 0)))
                                             (EQ FRAMETYPE 'PAGE)
                                             (IGEQ (fetch (REGION WIDTH) of RSPEC)
                                                   595))
                                        then 
                                             (* ;; 
                       "595 is A4, US letter and legal are greater, 612. RSPEC is already in points.")

                                             RSPEC
                                      else (HCUNSCALE MICASPERPT RSPEC]
             (replace REGIONSUBBOXES of PAGEFRAME with (for ALIST in (pop PAGELIST)
                                                          collect (\TEDIT.PARSE.PAGEFRAMES1 ALIST 
                                                                         PAGEFRAME)))
             PAGEFRAME)
            (T (for FRAMESPEC in (CAR PAGELIST) collect (\TEDIT.PARSE.PAGEFRAMES1 FRAMESPEC NIL])

(\TEDIT.GET.CHARLOOKS1
  [LAMBDA (PC FILE)                                          (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 25-Nov-2023 23:21 by rmk")
                                                             (* ; "Edited  7-Nov-2023 22:02 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:04 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")

    (* ;; "Read a description of PC's CHARLOOKS from FILE. The looks are here stored in PC, not in the TEXTOBJ (uniquify later?)")

    (LET (FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR (LOOKS (create CHARLOOKS)))
         (FSETPC PC PLOOKS LOOKS)
         (SETQ NAME (\ARBIN FILE))                           (* ; "The font name")
         (SETQ SIZE (\WIN FILE))                             (* ; "Size of the type, in points")
         (SETQ SUPER (\WIN FILE))                            (* ; "Superscripting distance")
         (SETQ SUB (\WIN FILE))                              (* ; "former Subscripting distance")
         (OR (ZEROP SUB)
             (SETQ SUPER (IMINUS SUB)))

         (* ;; "If this is an old file, it'll have a subscript value not zero.  Let those past and do the right thing.")

         (CL:UNLESS (ZEROP (BIN FILE))                       (* ; "This text is NEW.  Mark it so.")
             (FSETPC PC PNEW T))
         (CL:UNLESS (ZEROP (BIN FILE))                       (* ; 
                                                      "There is style or user information to be read")
             (replace (CHARLOOKS CLSTYLE) of LOOKS with (OR (\ARBIN FILE)
                                                            0))
             (replace (CHARLOOKS CLUSERINFO) of LOOKS with (\ARBIN FILE)))
         (SETQ PROPS (\WIN FILE))
         (with CHARLOOKS LOOKS [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
               [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
               [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
               [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
               [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
               [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
               [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
               [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
               [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
               [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
               (SETQ CLSIZE SIZE)
               (SETQ CLOFFSET SUPER))
         [SETQ FONT (COND
                       ((LISTP NAME)                         (* ; 
                                                             "This was a font class.  Restore it.")
                        (FONTCLASS (pop NAME)
                               NAME))
                       ((AND NAME (NOT (ZEROP SIZE)))
                        (FONTCREATE NAME SIZE (COND
                                                 ((AND (fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                       (fetch (CHARLOOKS CLITAL) of LOOKS))
                                                  'BOLDITALIC)
                                                 ((fetch (CHARLOOKS CLBOLD) of LOOKS)
                                                  'BOLD)
                                                 ((fetch (CHARLOOKS CLITAL) of LOOKS)
                                                  'ITALIC]
         (replace (CHARLOOKS CLNAME) of LOOKS
            with (if (type? FONTCLASS FONT)
                     then 
                          (* ;; "Put the display family in the CLNAME spot.  Better than NIL.")

                          (CL:WHEN [SETQ NAME (FONTCOPY FONT '(DEVICE DISPLAY NOERROR T]
                              (FONTPROP NAME 'FAMILY))
                   else NAME))
         (replace (CHARLOOKS CLFONT) of LOOKS with FONT])

(\TEDIT.GET.PARALOOKS1
  [LAMBDA (FILE)                                             (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:00 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:20 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:34 by jds")
                                                             (* ; 
                           "Read a paragraph format spec from the FILE, and return it for later use.")
    (LET ((LOOKS (create FMTSPEC))
          TABFLG DEFTAB TABCOUNT TABS TABSPEC)
         (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
         (replace (FMTSPEC LEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
         (replace (FMTSPEC RIGHTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; "Right margin for the paragraph")
         (replace (FMTSPEC LEADBEFORE) of LOOKS with (\WIN FILE))
                                                             (* ; "Leading before the paragraph")
         (replace (FMTSPEC LEADAFTER) of LOOKS with (\WIN FILE))
                                                             (* ; "Lead after the paragraph")
         (replace (FMTSPEC LINELEAD) of LOOKS with (\WIN FILE))
                                                             (* ; "inter-line leading")
         (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
         (SETQ TABFLG (BIN FILE))
         (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                   (1 'LEFT)
                                                   (2 'RIGHT)
                                                   (3 'CENTERED)
                                                   (4 'JUSTIFIED)
                                                   (SHOULDNT)))
         (CL:UNLESS (ZEROP (LOGAND TABFLG 1))                (* ; "There are tabs to read")
             (SETQ DEFTAB (\WIN FILE))
             (SETQ TABCOUNT (BIN FILE))
             [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                    TABX _ (\WIN FILE)
                                                                    TABKIND _
                                                                    (SELECTQ (BIN FILE)
                                                                        (0 'LEFT)
                                                                        (1 'RIGHT)
                                                                        (2 'CENTERED)
                                                                        (3 'DECIMAL)
                                                                        (SHOULDNT]
             (CL:UNLESS (ZEROP DEFTAB)
                    (RPLACA TABSPEC DEFTAB))
             (RPLACD TABSPEC TABS))
         (CL:UNLESS (ZEROP (LOGAND TABFLG 2))                (* ; 
                                                   "There are other paragraph parameters to be read.")
             (replace (FMTSPEC FMTSPECIALX) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                      "Special X location on page for this paragraph")
             (replace (FMTSPEC FMTSPECIALY) of LOOKS with (\WIN FILE))
             (replace (FMTSPEC FMTUSERINFO) of LOOKS with (\ARBIN FILE))
             (replace (FMTSPEC FMTPARATYPE) of LOOKS with (\ATMIN FILE))
             (replace (FMTSPEC FMTPARASUBTYPE) of LOOKS with (\ATMIN FILE))
             (replace (FMTSPEC FMTSTYLE) of LOOKS with (\ARBIN FILE))
             (replace (FMTSPEC FMTCHARSTYLES) of LOOKS with (\ARBIN FILE))
             (replace (FMTSPEC FMTNEWPAGEBEFORE) of LOOKS with (\ARBIN FILE))
             (replace (FMTSPEC FMTNEWPAGEAFTER) of LOOKS with (\ARBIN FILE)))
         LOOKS])

(TEDIT.GET.OBJECT1
  [LAMBDA (STREAM PIECE FILE CURCH#)                         (* ; "Edited 27-Oct-2023 12:58 by rmk")
                                                             (* ; "Edited  6-Aug-2022 09:11 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:17 by mitani")

    (* ;; "Get an object from the file")

    (* ;; "CURCH# = fileptr within the text section of the file where the object's text starts.")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
          FILEPTRSAVE GETFN OBJ)
         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURCH#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN))
         (SETFILEPTR FILE FILEPTRSAVE)
         (FSETPC PIECE PCONTENTS OBJ)
         (FSETPC PIECE PTYPE OBJECT.PTYPE)
         (FSETPC PIECE PLOOKS (if (PREVPIECE PIECE)
                                  then (PLOOKS (PREVPIECE PIECE))
                                elseif (FGETTOBJ TEXTOBJ DEFAULTCHARLOOKS)
                                else (\TEDIT.UNIQUIFY.CHARLOOKS (CHARLOOKS.FROM.FONT DEFAULTFONT)
                                            TEXTOBJ)))
         (PCONTENTS PIECE])
)



(* ;; "VERSION 0 Compatibility reading functions")

(DEFINEQ

(TEDIT.GET.PCTB0
  [LAMBDA (TEXT TEXTOBJ PCCOUNT START END)                   (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited 27-Oct-2023 13:47 by rmk")
                                                             (* ; "Edited  3-Aug-2023 22:09 by rmk")
                                                             (* ; "Edited 26-Apr-2023 14:21 by rmk")
                                                             (* ; "Edited  5-Sep-2022 23:06 by rmk")
                                                             (* ; "Edited 22-May-92 18:01 by jds")

(* ;;; "READ OBSOLETE FORMATS OF TEDIT FILE")

    (LET (OLDPC TYPECODE PCLEN PIECEINFOCH# TSTREAM USERFILEFORMAT USERTEMP (CURFILECH# (OR START 0))
                )
         (SETFILEPTR TEXT (IDIFFERENCE (OR END (GETEOFPTR TEXT))
                                 8))
         (SETQ PIECEINFOCH# (\DWIN TEXT))
         (SETFILEPTR TEXT PIECEINFOCH#)
         (bind PC TYPECODE PCLEN OLDPC (DEFAULTPARALOOKS _ (FGETTOBJ TEXTOBJ FMTSPEC)) for I
            from 1 to PCCOUNT
            do (SETQ PCLEN (\DWIN TEXT))
               (SETQ PC
                (create PIECE
                       PCONTENTS _ TEXT
                       PFPOS _ CURFILECH#
                       PLEN _ PCLEN
                       PREVPIECE _ OLDPC
                       PPARALOOKS _ DEFAULTPARALOOKS
                       PTYPE _ THINFILE.PTYPE
                       PBYTESPERCHAR _ 1))
               [COND
                  (OLDPC (FSETPC OLDPC NEXTPIECE PC)
                         (FSETPC PC PPARALOOKS (PPARALOOKS OLDPC]
               (SETQ TYPECODE (\WIN TEXT))
               (SELECTC TYPECODE
                   (\PieceDescriptorLOOKS 
                        (TEDIT.GET.CHARLOOKS0 PC TEXT)
                        (add CURFILECH# (PLEN PC)))
                   (\PieceDescriptorOBJECT 
                        (TEDIT.GET.OBJECT0 (AND TEXTOBJ (FGETTOBJ TEXTOBJ STREAMHINT))
                               PC TEXT CURFILECH#)
                        (add CURFILECH# (PLEN PC))           (* ; 
                                            "Only object--can't be followed by either of the others.")
                        (FSETPC PC PLEN 1))
                   (\PieceDescriptorPARA 
                        (AND OLDPC (FSETPC OLDPC PPARALAST T))
                        (TEDIT.GET.PARALOOKS0 PC TEXT)
                        (FSETPC PC PLEN (\DWIN TEXT))        (* ; 
                                                  "Set this piece's length from the character looks.")
                        (\WIN TEXT)                          (* ; 
                                                "Skip the piece-type code, since we know what's next")
                        (TEDIT.GET.CHARLOOKS0 PC TEXT)       (* ; "This document is 'formatted' .")
                        (add CURFILECH# (PLEN PC))
                        (AND TEXTOBJ (FSETTOBJ TEXTOBJ FORMATTEDP T)))
                   (SHOULDNT "Impossible piece-type code in BUILD.PCTB"))
               (SETQ OLDPC PC)
               (\INSERTPIECE PC NIL TEXTOBJ])

(TEDIT.GET.CHARLOOKS0
  [LAMBDA (PC FILE)                                          (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:26 by jds")
                                                             (* Put a description of LOOKS into 
                                                             FILE. LOOKS apply to characters CH1 
                                                             thru CHLIM-1)
    (PROG (FONT STR NAME NAMELEN SIZE SUPER SUB PROPS STYLESTR USERSTR (LOOKS (create CHARLOOKS)))
          (replace (PIECE PLOOKS) of PC with LOOKS)
          (SETQ NAMELEN (\WIN FILE))                         (* The length of the description which 
                                                             follows)
          [SETQ NAME (PACK (for I from 1 to NAMELEN collect (CHARACTER (BIN FILE]
                                                             (* The font name)
          (SETQ SIZE (\WIN FILE))                            (* Size of the type, in points)
          (SETQ SUPER (\WIN FILE))                           (* Superscripting distance)
          (SETQ SUB (\WIN FILE))                             (* former Subscripting distance)
          (OR (ZEROP SUB)
              (SETQ SUPER (IMINUS SUB)))

         (* If this is an old file, it'll have a subscript value not zero.
         Let those past and do the right thing.)

          (COND
             ((NOT (ZEROP (BIN FILE)))                       (* This text is NEW.
                                                             Mark it so.)
              (replace (PIECE PNEW) of PC with T)))
          [COND
             ((NOT (ZEROP (BIN FILE)))                       (* There is style or user information 
                                                             to be read)
              (SETQ STYLESTR (\STRINGIN FILE))
              (SETQ USERSTR (\STRINGIN FILE))
              (COND
                 ((NOT (ZEROP (NCHARS STYLESTR)))            (* There IS style info)
                  (replace (CHARLOOKS CLSTYLE) of LOOKS with (READ STYLESTR)))
                 (T (replace (CHARLOOKS CLSTYLE) of LOOKS with 0)))
              (COND
                 ((NOT (ZEROP (NCHARS USERSTR)))             (* There IS user info)
                  (replace (CHARLOOKS CLUSERINFO) of LOOKS with (READ USERSTR]
          (SETQ PROPS (\WIN FILE))
          (with CHARLOOKS LOOKS [SETQ CLBOLD (NOT (ZEROP (LOGAND 512 PROPS]
                [SETQ CLITAL (NOT (ZEROP (LOGAND 256 PROPS]
                [SETQ CLULINE (NOT (ZEROP (LOGAND 128 PROPS]
                [SETQ CLOLINE (NOT (ZEROP (LOGAND 64 PROPS]
                [SETQ CLSTRIKE (NOT (ZEROP (LOGAND 32 PROPS]
                [SETQ CLSMALLCAP (NOT (ZEROP (LOGAND 16 PROPS]
                [SETQ CLPROTECTED (NOT (ZEROP (LOGAND 8 PROPS]
                [SETQ CLINVISIBLE (NOT (ZEROP (LOGAND 4 PROPS]
                [SETQ CLSELHERE (NOT (ZEROP (LOGAND 2 PROPS]
                [SETQ CLCANCOPY (NOT (ZEROP (LOGAND 1 PROPS]
                (SETQ CLSIZE SIZE)
                (SETQ CLOFFSET SUPER))
          (replace (CHARLOOKS CLFONT) of LOOKS with (AND NAME (NOT (ZEROP SIZE))
                                                         (FONTCREATE NAME SIZE
                                                                (COND
                                                                   ((AND (fetch (CHARLOOKS CLBOLD)
                                                                            of LOOKS)
                                                                         (fetch (CHARLOOKS CLITAL)
                                                                            of LOOKS))
                                                                    'BOLDITALIC)
                                                                   ((fetch (CHARLOOKS CLBOLD)
                                                                       of LOOKS)
                                                                    'BOLD)
                                                                   ((fetch (CHARLOOKS CLITAL)
                                                                       of LOOKS)
                                                                    'ITALIC])

(TEDIT.GET.OBJECT0
  [LAMBDA (STREAM PIECE FILE CURCH#)                         (* ; "Edited  6-Aug-2022 15:57 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:17 by mitani")

    (* ;; "Get an object from the file")

    (* ;; "CURCH# = fileptr within the text section of the file where the object's text starts.")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
          FILEPTRSAVE NAMELEN GETFN OBJ)
         (SETQ GETFN (\ATMIN FILE))                          (* ; 
                                                             "The GETFN for this kind of IMAGEOBJ")
         (SETQ FILEPTRSAVE (GETFILEPTR FILE))                (* ; 
                                             "Save our file location thru the building of the object")
         (SETFILEPTR FILE CURCH#)
         (SETQ OBJ (READIMAGEOBJ FILE GETFN))
         (SETFILEPTR FILE FILEPTRSAVE)
         (replace (PIECE PCONTENTS) of PIECE with OBJ)
         [replace (PIECE PLOOKS) of PIECE with (COND
                                                  ((fetch (PIECE PREVPIECE) of PIECE)
                                                   (fetch (PIECE PLOOKS) of (fetch (PIECE PREVPIECE)
                                                                               of PIECE)))
                                                  (T (OR (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                            of TEXTOBJ)
                                                         (\TEDIT.UNIQUIFY.CHARLOOKS (
                                                                                  CHARLOOKS.FROM.FONT
                                                                                     DEFAULTFONT)
                                                                TEXTOBJ]
         OBJ])

(TEDIT.GET.PARALOOKS0
  [LAMBDA (PC FILE)                                          (* ; "Edited 19-Dec-2023 10:13 by rmk")
                                                             (* ; "Edited  3-Mar-2023 23:14 by rmk")
                                                             (* ; "Edited  1-Aug-2022 12:04 by rmk")
                                                             (* ; "Edited 30-May-91 20:34 by jds")
                                                             (* ; 
                  "Put a description of LOOKS into FILE.  LOOKS apply to characters CH1 thru CHLIM-1")
    (PROG ((LOOKS (create FMTSPEC))
           TABFLG DEFTAB TABCOUNT TABS TABSPEC)
          (replace (PIECE PPARALOOKS) of PC with LOOKS)
          (replace (FMTSPEC 1STLEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                    "Left margin for the first line of the paragraph")
          (replace (FMTSPEC LEFTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; 
                                                          "Left margin for the rest of the paragraph")
          (replace (FMTSPEC RIGHTMAR) of LOOKS with (\WIN FILE))
                                                             (* ; "Right margin for the paragraph")
          (replace (FMTSPEC LEADBEFORE) of LOOKS with (\WIN FILE))
                                                             (* ; "Leading before the paragraph")
          (replace (FMTSPEC LEADAFTER) of LOOKS with (\WIN FILE))
                                                             (* ; "Lead after the paragraph")
          (replace (FMTSPEC LINELEAD) of LOOKS with (\WIN FILE))
                                                             (* ; "inter-line leading")
          (replace (FMTSPEC TABSPEC) of LOOKS with (SETQ TABSPEC (CONS DEFAULTTAB NIL)))
                                                             (* ; "Will be tab specs")
          (SETQ TABFLG (BIN FILE))
          (replace (FMTSPEC QUAD) of LOOKS with (SELECTC (BIN FILE)
                                                    (1 'LEFT)
                                                    (2 'RIGHT)
                                                    (3 'CENTERED)
                                                    (4 'JUSTIFIED)
                                                    (SHOULDNT)))
          (COND
             ((NOT (ZEROP TABFLG))                           (* ; "There are tabs to read")
              (SETQ DEFTAB (\WIN FILE))
              (SETQ TABCOUNT (BIN FILE))
              [SETQ TABS (for TAB# from 1 to TABCOUNT collect (create TAB
                                                                     TABX _ (\WIN FILE)
                                                                     TABKIND _
                                                                     (SELECTQ (BIN FILE)
                                                                         (0 'LEFT)
                                                                         (1 'RIGHT)
                                                                         (2 'CENTERED)
                                                                         (3 'DECIMAL)
                                                                         (SHOULDNT]
              (OR (ZEROP DEFTAB)
                  (RPLACA TABSPEC DEFTAB))
              (RPLACD TABSPEC TABS])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (4701 28811 (TEDIT.GET 4711 . 9282) (TEDIT.FORMATTEDFILEP 9284 . 10027) (TEDIT.FILEDATE 
10029 . 11885) (\TEDIT.GET.IDATE3 11887 . 13282) (TEDIT.INCLUDE 13284 . 19916) (TEDIT.RAW.INCLUDE 
19918 . 20726) (TEDIT.PUT 20728 . 28809)) (28873 48241 (\TEDIT.GET.FOREIGN.FILE 28883 . 31947) (
\TEDIT.GET.UNFORMATTED.FILE 31949 . 35936) (\TEDIT.GET.FORMATTED.FILE 35938 . 39919) (
\TEDIT.FORMATTEDSTREAMP 39921 . 42608) (\ARBIN 42610 . 43330) (\ATMIN 43332 . 43869) (\DWIN 43871 . 
44250) (\STRINGIN 44252 . 44960) (\TEDIT.FORMATTEDP1 44962 . 46710) (\TEDIT.CACHEFILE 46712 . 48239)) 
(48242 71975 (\TEDIT.GET.PIECES3 48252 . 56387) (\TEDIT.MAKE.SAFE.BUFFERS 56389 . 65795) (
\TEDIT.MAKE.SAFE.PIECES 65797 . 67841) (\TEDIT.INTERPRET.XCCS.SHIFTS 67843 . 71973)) (71976 77310 (
\TEDIT.GET.UNFORMATTED.FILE.XCCS 71986 . 75123) (\TEDIT.GET.UNFORMATTED.FILE.UTF8 75125 . 77308)) (
77311 83704 (\TEDIT.GET.CHARLOOKS.LIST 77321 . 77826) (\TEDIT.GET.SINGLE.CHARLOOKS 77828 . 81960) (
\TEDIT.GET.CHARLOOKS 81962 . 83702)) (83705 91764 (\TEDIT.GET.PARALOOKS.LIST 83715 . 84228) (
\TEDIT.GET.SINGLE.PARALOOKS 84230 . 91172) (\TEDIT.GET.PARALOOKS 91174 . 91762)) (91765 95163 (
TEDIT.GET.OBJECT 91775 . 95161)) (95225 115610 (\TEDIT.PUT.PCTB 95235 . 109594) (
\TEDIT.PUT.PCTB.MERGEABLE 109596 . 111090) (\TEDIT.INSERT.NEWPIECES 111092 . 113208) (\TEDIT.PUTRESET 
113210 . 113452) (\ARBOUT 113454 . 114178) (\ATMOUT 114180 . 114785) (\DWOUT 114787 . 115066) (
\STRINGOUT 115068 . 115608)) (115611 124011 (\TEDIT.PUT.CHARLOOKS.LIST 115621 . 117293) (
\TEDIT.PUT.SINGLE.CHARLOOKS 117295 . 122229) (\TEDIT.PUT.CHARLOOKS 122231 . 124009)) (124012 131696 (
\TEDIT.PUT.PARALOOKS.LIST 124022 . 124924) (\TEDIT.PUT.SINGLE.PARALOOKS 124926 . 130621) (
\TEDIT.PUT.PARALOOKS 130623 . 131694)) (131697 133764 (TEDIT.PUT.OBJECT 131707 . 133762)) (133859 
135224 (TEDITFROMLISPSOURCE 133869 . 135222)) (135475 168916 (\TEDIT.GET.PCTB2 135485 . 144892) (
\TEDIT.PARSE.PAGEFRAMES2 144894 . 147633) (\TEDIT.GET.CHARLOOKS.LIST2 147635 . 148142) (
\TEDIT.GET.SINGLE.CHARLOOKS2 148144 . 151764) (\TEDIT.PUT.SINGLE.PARALOOKS2 151766 . 156013) (
\TEDIT.PUT.SINGLE.CHARLOOKS2 156015 . 160380) (\TEDIT.GET.PARALOOKS.LIST2 160382 . 160889) (
\TEDIT.GET.SINGLE.PARALOOKS2 160891 . 165769) (\TEDIT.PUT.CHARLOOKS.LIST2 165771 . 167819) (
\TEDIT.PUT.PARALOOKS.LIST2 167821 . 168914)) (168993 188549 (\TEDIT.GET.PCTB1 169003 . 174987) (
\TEDIT.GET.PAGEFRAMES1 174989 . 175441) (\TEDIT.PARSE.PAGEFRAMES1 175443 . 177819) (
\TEDIT.GET.CHARLOOKS1 177821 . 182096) (\TEDIT.GET.PARALOOKS1 182098 . 186999) (TEDIT.GET.OBJECT1 
187001 . 188547)) (188609 202215 (TEDIT.GET.PCTB0 188619 . 191893) (TEDIT.GET.CHARLOOKS0 191895 . 
196535) (TEDIT.GET.OBJECT0 196537 . 198490) (TEDIT.GET.PARALOOKS0 198492 . 202213)))))
STOP
