(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED " 6-Nov-2022 20:18:47" {WMEDLEY}<library>tedit>TEDIT-HCPY.;110 71123  

      :CHANGES-TO (FNS \TEDIT.HARDCOPY.FORMATLINE)

      :PREVIOUS-DATE "29-Oct-2022 19:45:45" {WMEDLEY}<library>tedit>TEDIT-HCPY.;109)


(PRETTYCOMPRINT TEDIT-HCPYCOMS)

(RPAQQ TEDIT-HCPYCOMS
       ((COMS 
              (* ;; "Generic interface functions and common code")

              (FNS TEDIT.HARDCOPY TEDIT.HCPYFILE \TEDIT.HARDCOPY.DISPLAYLINE 
                   \TEDIT.HARDCOPY.FORMATLINE \HARDCOPY.FORMATLINE.JUSTIFY 
                   \HARDCOPY.FORMATLINE.HEADINGS \TEDIT.HARDCOPY.MODIFYLOOKS \TEDIT.HCPYLOOKS.UPDATE
                   \TEDIT.HCPYFMTSPEC \TEDIT.INTEGER.IMAGEBOX))
        (COMS 
              (* ;; "Functions for scaling distances and regions as needed during hardcopy.")

              (FNS \TEDIT.SCALE \TEDIT.SCALEREGION))
        (COMS 
              (* ;; "PRESS-specific code")

              (VARS (TEDIT.DEFAULTPAGEREGION (CREATEREGION 2794 1905 16256 23495)))
                                                             (* ; 
                                                             "0.75 inches from bottom, 1 from top"))
        [COMS 
              (* ;; "Support for the window-menu's HARDCOPY button, LISTFILES, etc.")

              (FNS TEDIT.HARDCOPYFN \TEDIT.HARDCOPY \TEDIT.PRESS.HARDCOPY)
              [P (LET [(IPVALUES (ASSOC 'CONVERSION (ASSOC 'INTERPRESS PRINTFILETYPES]
                      (COND (IPVALUES                        (* ; 
                                          "Only install INTERPRESS printing if INTERPRESS is loaded.")
                                   (LISTPUT IPVALUES 'TEDIT (FUNCTION \TEDIT.HARDCOPY]
              (P (LET [(PRESSVALUES (ASSOC 'CONVERSION (ASSOC 'PRESS PRINTFILETYPES]
                      (COND (PRESSVALUES                     (* ; 
                                                    "Only install PRESS printing if PRESS is loaded.")
                                   (LISTPUT PRESSVALUES 'TEDIT (FUNCTION \TEDIT.PRESS.HARDCOPY]
        [COMS 
              (* ;; "vars for Japanese Line Break")

              (INITVARS (TEDIT.DONT.BREAK.CHARS (CHARCODE ("41,42" "41,43" "41,53" "41,54" "41,74" 
                                                                 "41,115" "41,133" "41,131" "41,127"
                                                                 "Hira,41" "Hira,43" "Hira,45" 
                                                                 "Hira,47" "Hira,51" "Hira,103" 
                                                                 "Hira,143" "Hira,145" "Hira,147" 
                                                                 "Hira,156" "Kata,41" "Kata,43" 
                                                                 "Kata,45" "Kata,47" "Kata,51" 
                                                                 "Kata,103" "Kata,143" "Kata,145" 
                                                                 "Kata,147" "Kata,156")))
                     (TEDIT.DONT.LAST.CHARS (CHARCODE ("41,114" "41,132" "41,130" "41,126"]
        (COMS 
              (* ;; "Support for hardcopying several files as one document")

              (FNS TEDIT-BOOK))))



(* ;; "Generic interface functions and common code")

(DEFINEQ

(TEDIT.HARDCOPY
  [LAMBDA (STREAM FILE DONTSEND BREAKPAGETITLE SERVER PRINTOPTIONS)
                                                             (* ; "Edited  5-Jan-88 16:09 by jds")

    (* ;; "Send the text to the printer.")

    (COND
       [(OR SERVER DEFAULTPRINTINGHOST)

        (* ;; "We can only hardcopy if there is a server specified, or the system will give us a reasonable default one.")

        (for IMAGETYPE in (PRINTERPROP (PRINTERTYPE SERVER)
                                 'CANPRINT)
           do (RETURN (TEDIT.FORMAT.HARDCOPY STREAM FILE DONTSEND BREAKPAGETITLE SERVER PRINTOPTIONS
                             IMAGETYPE)) finally (ERROR (CONCAT "Can't print TEDIT documents on a "
                                                               (PRINTERTYPE SERVER)
                                                               " printer."]
       (T (TEDIT.PROMPTPRINT (TEXTOBJ STREAM)
                 "Can't HARDCOPY:  No print server specified." T])

(TEDIT.HCPYFILE
  [LAMBDA (TSTREAM FILE BREAKPAGETITLE)                      (* ; "Edited  4-Oct-2022 09:23 by rmk")
                                                             (* ; "Edited  1-Oct-2022 22:12 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:36 by mitani")

    (* ;; "Create a hardcopy-format FILE from the text on TSTREAM, with the file type depending on what the default printer is.")

    (LET ([IMAGETYPE (CAR (PRINTERPROP (PRINTERTYPE)
                                 'CANPRINT]
          (TEXTOBJ (TEXTOBJ TSTREAM))
          FILENM TXTFILE)
         (CL:WHEN [SETQ FILENM (OR FILE (\TEDIT.MAKEFILENAME
                                         (TEDIT.GETINPUT TEXTOBJ (CONCAT IMAGETYPE " file name:  ")
                                                (COND
                                                   ((type? STREAM (SETQ TXTFILE (fetch (TEXTOBJ
                                                                                        TXTFILE)
                                                                                   of TEXTOBJ)))
                                                             (* ; 
                                                             "There was a file, so supply default")
                                                    (PACKFILENAME 'VERSION NIL 'EXTENSION
                                                           (OR (CAR (PRINTFILETYPE IMAGETYPE
                                                                           'EXTENSION))
                                                               'HCPY)
                                                           'BODY
                                                           (fetch (STREAM FULLFILENAME) of TXTFILE]
                (TEDIT.FORMAT.HARDCOPY TSTREAM FILENM T BREAKPAGETITLE NIL NIL IMAGETYPE])

(\TEDIT.HARDCOPY.DISPLAYLINE
  [LAMBDA (TEXTOBJ LINE REGION PRSTREAM FORMATTINGSTATE)     (* ; "Edited  9-Oct-2022 17:30 by rmk")
                                                             (* ; "Edited  5-Oct-2022 09:28 by rmk")
                                                             (* ; "Edited  3-Oct-2022 18:11 by rmk")
                                                             (* ; "Edited 29-Mar-94 13:44 by jds")

    (* ;; "Display LINE on the HARDCOPY file under way. Original FORM-terminated lines end with EOL.")

    (* ;; "If possible, use the information cached in THISLINE")

    (\DTEST TEXTOBJ 'TEXTOBJ)

    (* ;; "Only display the line if it appears before the end of the text!")

    (CL:UNLESS (IGREATERP (ffetch (LINEDESCRIPTOR CHAR1) of LINE)
                      (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
        [LET ((THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)))
             (CL:UNLESS (EQ LINE (fetch DESC of THISLINE))
                 (\TEDIT.HARDCOPY.FORMATLINE TEXTOBJ REGION (ffetch (LINEDESCRIPTOR CHAR1)
                                                               of LINE)
                        LINE PRSTREAM FORMATTINGSTATE))

             (* ;; "Use the characters cached in THISLINE.")

             (for CHARSLOT CLOOKS CURY KERN LOOKSTARTX SCALESPACES (SPACEFACTOR _ (fetch (THISLINE
                                                                                          
                                                                                        TLSPACEFACTOR
                                                                                          )
                                                                                     of THISLINE))
                  (FIRST-SCALEDSPACE-SLOT _ (ffetch (THISLINE TLFIRSTSPACE) of THISLINE))
                  (SCALE _ (DSPSCALE NIL PRSTREAM))
                  (TX _ (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)) incharslots THISLINE
                first (DSPSPACEFACTOR 1 PRSTREAM)
                      (DSPXPOSITION TX PRSTREAM)
                do 
                   (* ;; 
              "Display the line character by character.  CHAR and CHARW are bound to CHARSLOT values")

                   (SELCHARQ CHAR
                        (SPACE (CL:WHEN (EQ CHARSLOT FIRST-SCALEDSPACE-SLOT)
                                                             (* ; "Time to turn on space scaling.")
                                   (DSPSPACEFACTOR SPACEFACTOR PRSTREAM)
                                   (SETQ SCALESPACES T))
                               (\OUTCHAR PRSTREAM (CHARCODE SPACE))
                               (add TX (CL:IF SCALESPACES
                                           (HCSCALE SPACEFACTOR CHARW)
                                           CHARW)))
                        ((TAB Meta,TAB)                      (* ; 
                                                  "Dotted leaders are meta-TAB, or are DOTTEDLEADER.")
                             (CL:WHEN (OR (EQ CHAR (CHARCODE Meta,TAB))
                                          (fetch CLLEADER of CLOOKS)
                                          (EQ (fetch CLUSERINFO of CLOOKS)
                                              'DOTTEDLEADER))
                                 (LET* [(DOTWIDTH (CHARWIDTH (CHARCODE %.)
                                                         (FONTCOPY (fetch (CHARLOOKS CLFONT)
                                                                      of CLOOKS)
                                                                'DEVICE PRSTREAM)))
                                        (TTX (IPLUS TX DOTWIDTH (IDIFFERENCE DOTWIDTH
                                                                       (IREMAINDER TX DOTWIDTH]
                                       (DSPXPOSITION (IDIFFERENCE TTX DOTWIDTH)
                                              PRSTREAM)      (* ; 
                                              "Move over to the next even multiple of a dot's width.")
                                       (while (ILEQ TTX (IPLUS TX CHARW))
                                          do (\OUTCHAR PRSTREAM (CHARCODE %.))
                                             (add TTX DOTWIDTH))))
                             (add TX CHARW)
                             (DSPXPOSITION TX PRSTREAM))
                        ((EOL LF CR) 
                             NIL)
                        (NIL 
                             (* ;; 
    "LOOKS or SMALLP-invisibles. Line-start looks are guaranteed to come before any character/object")

                             (if (type? CHARLOOKS CHARW)
                                 then (CL:WHEN CLOOKS

                                          (* ;; 
                                          "Underline/overline/strike the just-finished looks run")
                                                             (* ; "DISPLAY ALSO PASES LINE DESCENT")
                                          (\TEDIT.HARDCOPY.MODIFYLOOKS LINE LOOKSTARTX TX
                                                 (fetch (LINEDESCRIPTOR YBASE) of LINE)
                                                 CLOOKS PRSTREAM))
                                      (SETQ CLOOKS CHARW)
                                      (DSPFONT (fetch CLFONT of CLOOKS)
                                             PRSTREAM)
                                      [SETQ CURY (COND
                                                    [(AND (fetch (CHARLOOKS CLOFFSET) of CLOOKS)
                                                          (NEQ 0 (fetch (CHARLOOKS CLOFFSET)
                                                                    of CLOOKS)))
                                                     (IPLUS (fetch (LINEDESCRIPTOR YBASE)
                                                               of LINE)
                                                            (HCSCALE SCALE (fetch (CHARLOOKS CLOFFSET
                                                                                         )
                                                                              of CLOOKS]
                                                    (T (fetch (LINEDESCRIPTOR YBASE) of LINE]
                                      (DSPYPOSITION CURY PRSTREAM)
                                      (CL:WHEN (SETQ KERN (LISTGET (fetch (CHARLOOKS CLUSERINFO)
                                                                      of CLOOKS)
                                                                 'KERN))
                                          (SETQ KERN (HCSCALE SCALE KERN))) 

                                      (* ;; "LOOKSTARTX: Starting X position for this CLOOKS.")

                                      (SETQ LOOKSTARTX TX)
                               elseif (SMALLP CHARW)
                               else (HELP "UNRECOGNIZED CHARW" CHARW)))
                        (PROGN (if (IMAGEOBJP CHAR)
                                   then 
                                        (* ;; "Go to the base line, left edge of the image region.")

                                        (SETQ CURY (DSPYPOSITION NIL PRSTREAM))
                                        (APPLY* (IMAGEOBJPROP CHAR 'DISPLAYFN)
                                               CHAR PRSTREAM (IMAGESTREAMTYPE PRSTREAM)
                                               (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                                        (DSPFONT (fetch CLFONT of CLOOKS)
                                               PRSTREAM)     (* ; "Restore the font")
                                        (DSPYPOSITION CURY PRSTREAM) 
                                                             (* ; 
                                                             "Restore the Y position, assume X is OK")
                                 elseif (AND (IGEQ CHAR 192)
                                             (ILEQ CHAR 207))
                                   then 

                                 (* ;; "This is an NS accent character.  Readjust our position with MOVETO, so that the accent is centered over the middle of the next character.")

                                        (MOVETO (+ TX (FOLDLO (- (CHARW (NEXTCHARSLOT CHARSLOT))
                                                                 CHARW)
                                                             2))
                                               CURY PRSTREAM)
                                        (\OUTCHAR PRSTREAM CHAR)
                                        (MOVETO TX CURY PRSTREAM) 
                                                             (* ; "Stay where we were")
                                        (SETQ CHARW 0)
                                 else (\OUTCHAR PRSTREAM CHAR))
                               (add TX CHARW))) finally 

                                                (* ;; "Do any last-minute underlining or similar looks fix-ups, and print a revision mark, if one is needed:")

                                                      (\TEDIT.HARDCOPY.MODIFYLOOKS
                                                       LINE LOOKSTARTX TX (fetch (LINEDESCRIPTOR
                                                                                  YBASE) of LINE)
                                                       CLOOKS PRSTREAM)
                                                      (CL:WHEN (fetch (FMTSPEC FMTREVISED)
                                                                  of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                        of LINE))
                                                             (* ; 
                                                       "This paragraph has been revised, so mark it.")
                                                          (\TEDIT.MARK.REVISION TEXTOBJ
                                                                 (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                    of LINE)
                                                                 PRSTREAM LINE))])])

(\TEDIT.HARDCOPY.FORMATLINE
  [LAMBDA (TEXTOBJ REGION CH#1 LINE IMAGESTREAM FORMATTINGSTATE)
                                                             (* ; "Edited  6-Nov-2022 20:18 by rmk")
                                                             (* ; "Edited 29-Oct-2022 19:45 by rmk")
                                                             (* ; "Edited 23-Oct-2022 14:44 by rmk")

    (* ;; "Given a starting place, format the next line of text.  Return the LINEDESCRIPTOR;  reusing LINE if it's given.")

    (* ;; "If CH#1 is past end of document, \FORMATLINE returns an empty line descriptor that is set up correctly wrt leading and font.  This is used by \FILLWINDOW to create the dummy line at end of document when you hit an EOL there. The SPECVARS may be reset under the BIN, by the LOOKSUPDATEFN.")

    (* ;; "")

    (* ;; "The objective of this body of code is to find")

    (* ;; "   CHAR1:  The CHNO of the first visible character/object of this line")

    (* ;; "   CHARTOP:  The CHNO of the last character on this line.  CHARTOP+1 is the CHNO of the first character of the next line.")

    (* ;; "   LXLIM:   The X coordinate of the right edge of character/object CHARTOP")

    (* ;; "   PREVSP:  The slot position in THISLINE of the right most scalable space.")

    (* ;; "  THISLINE:  The CHARSLOT vector that contains the actual characters and widths, together with their looks, as abstracted from the piece sequences of the underlying text.")

    (* ;; "")

    (* ;; "CHARTOP is the rightmost of a run of spaces or a hyphen such that there is no space or hyphen breakpoint before the subsequent characters overflow the right margin.")

    (* ;; " ")
                                                             (* ; "")

    (* ;; "At the end, \FORMATLINE.JUSTIFYmodifies LINE and THISLINE to deal with the vagaries of justification.")

    (BTVALIDATE '\TEDIT.HARDCOPY.FORMATLINE 'START TEXTOBJ)
    (SETQ CH#1 (IMAX CH#1 1))
    (PROG ((TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
           (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (ASCENT 0)
           (DESCENT 0)
           (ASCENTB 0)
           (DESCENTB 0)
           (DEFAULTTAB 36)
           (LEFTEDGE 0)
           (SCALE (DSPSCALE NIL IMAGESTREAM))
           (DEVICE IMAGESTREAM)
           (WIDTH (fetch (REGION WIDTH) of REGION))
           FMTSPEC KERN CTRL\L\SEEN PC CHARSLOT PREVSP 1STLN LEFTMARGIN RIGHTMARGIN PROTECTED CHNOB 
           CHARTOP CR\END LSTLN CHNO TX TXB FONT CHARSLOTB TABPENDING TABSPEC PREVHYPH PREVDHYPH 
           *TEDIT-CACHED-FMTSPEC* START-OF-PIECE)
          (DECLARE (SPECVARS CHARSLOT CHNO ASCENT DESCENT FONT DEVICE KERN START-OF-PIECE))

     (* ;; "Variables (TLEN = Current character count on the line")

     (* ;; "CHNO = Current character # in the text")

     (* ;; "CHARSLOT = Pointer to the next available slot in THISLINE's CHARS.")

     (* ;; "DX = width of current char/object")

     (* ;; "TX = Right end of current text")

     (* ;; "PREVSP = CHARPOS of the last space of the most recent space-run")

     (* ;; "ASCENT, DESCENT = The ascent and descent values at the current character position")

     (* ;; 
    "ASCENTB, DESCENTB, CHNOB, TXB,  CHARSLOTB = The values at the most recent potential break-point")

     (* ;; "Maybe *TEDIT-CACHED-FMTSPEC* is supposed to be free, held over between calls?  If so, INITVARS in TEDIT-SCREEN")

          (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
          (SETQ PC (\CHTOPC CH#1 TEXTOBJ T))
          (CL:WHEN (AND PC (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC))
                        (SETQ PC (\NEXT.VISIBLE.PIECE PC)))
              (SETQ CH#1 (\PCTOCH PC))                       (* ; 
                                                     "Unusual, simpler than keeping track on the fly")
              (SETQ START-OF-PIECE CH#1))                    (* ; "Ready to go")
          (SETQ CHNO CH#1)
          [COND
             [PC                                             (* ; "We have a visible piece")

              (* ;; "The paragraph looks of a line are the same for every piece of every line in a paragraph, only the character looks can change from piece to piece.  If FMTSPEC is not provided, we extract it from the starting piece, or the stream's default.")

              (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC (\TEDIT.APPLY.PARASTYLES (OR (PPARALOOKS PC)
                                                                             (fetch (TEXTOBJ FMTSPEC)
                                                                                of TEXTOBJ))
                                                       PC TSTREAM)
                                   IMAGESTREAM))
              (CL:UNLESS (OR (EQ FMTSPEC *TEDIT-CACHED-FMTSPEC*)
                             (NOT (fetch (FMTSPEC FMTCHARSTYLES) of FMTSPEC)))

                  (* ;; "The cache of character styles for the current paragraph is invalid; flush it, and note the new paragraph to cache for.")

                  (SETQ *TEDIT-CURRENTPARA-CACHE* NIL)
                  (SETQ *TEDIT-CACHED-FMTSPEC* FMTSPEC))

              (* ;; "This line starts a paragraph if it starts the document or it is at the beginning of a piece just after a last-paragraph piece. This assumes that only visible pieces matter; otherwise, use PREVPIECE.")

              (SETQ TABSPEC (fetch TABSPEC of FMTSPEC))
              (SETQ DEFAULTTAB (HCSCALE SCALE DEFAULTTAB))
              [SETQ 1STLN (OR (IEQP CH#1 1)
                              (AND (IEQP CH#1 START-OF-PIECE)
                                   (OR (NOT (\PREV.VISIBLE.PIECE PC))
                                       (PPARALAST (\PREV.VISIBLE.PIECE PC]
              (SETQ LEFTMARGIN (CL:IF 1STLN
                                   (fetch 1STLEFTMAR of FMTSPEC)
                                   (fetch LEFTMAR of FMTSPEC)))
              (SETQ RIGHTMARGIN (CL:IF (ZEROP (fetch (FMTSPEC RIGHTMAR) of FMTSPEC))
                                    WIDTH
                                    (fetch (FMTSPEC RIGHTMAR) of FMTSPEC)))
              (if [AND (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC)
                       (NOT (ZEROP (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC]
                  then (add LEFTMARGIN (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC))
                       (add RIGHTMARGIN (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC))
                else (add LEFTMARGIN (fetch (REGION LEFT) of REGION))
                     (add RIGHTMARGIN (fetch (REGION LEFT) of REGION)))

              (* ;; "The unchanging paragraph looks have now been established ")

              (* ;; 
          "Set up the LOOKSUPDATEFN to initialize with the character looks of the starting piece PC.")

              (replace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with (FUNCTION \TEDIT.HCPYLOOKS.UPDATE))

              (* ;; " LOOKSUPDATEFN is called at piece boundaries, sets up looks variables, returns NIL from BIN (= \TEXTBIN) if the stream runs out of characters.")

              (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with NIL)
              (\INSTALL.PIECE TSTREAM PC (- CH#1 START-OF-PIECE))
                                                             (* ; "Set up starting piece for BIN")
              (SETQ TX LEFTMARGIN)

              (* ;; 
              "TEXTLEN anticipates the EOL error.  Wouldn't need it if we reset the ENDOFSTREAMOP.")

              (bind CH BOX DX INSPACES INWORD (LASTCHARSLOT _ (LASTCHARSLOT THISLINE))
                    (TEXTLEN _ (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)) as old CHNO by 1
                 while (ILEQ CHNO TEXTLEN) while (SETQ CH (BIN TSTREAM))
                 do

                 (* ;; "Get CH's X width.")

                 [SETQ DX (COND
                             [(SMALLP CH)                    (* ; "CH is really a character")
                              (COND
                                 ((AND (IGEQ CH 192)
                                       (ILEQ CH 207))        (* ; 
                                                       "This is an NS accent character.  Space it 0.")
                                  0)
                                 (T                          (* ; 
                                                             "Regular character.  Get it's width.")
                                    (\FGETCHARWIDTH FONT CH]
                             (T                              (* ; "CH is an object, get its size.")
                                (SETQ BOX (APPLY* (IMAGEOBJPROP CH 'IMAGEBOXFN)
                                                 CH IMAGESTREAM TX RIGHTMARGIN))
                                (CL:WHEN (IEQP CHNO CH#1)

                                 (* ;; "Ignore the line-start-font height parameters if the object is first on the line.  It may be the only thing on the line and its height may be smaller than the font height (e.g. an HRULE).")

                                    (SETQ ASCENT (SETQ DESCENT 0)))
                                [SETQ ASCENT (IMAX ASCENT (IDIFFERENCE (fetch YSIZE of BOX)
                                                                 (fetch YDESC of BOX]
                                (SETQ DESCENT (IMAX DESCENT (fetch YDESC of BOX)))
                                (IMAGEOBJPROP CH 'BOUNDBOX BOX)
                                (fetch XSIZE of BOX]
                 (CL:WHEN KERN (add DX KERN))
                 [SELCHARQ CH
                      (SPACE (CL:UNLESS INSPACES             (* ; "First of a space run.  ")
                                 (FORGETHYPHENBREAK)

                                 (* ;; "We don't do the overflow test as long as we are in a space run, since space runs can protrude into the right margin. We continue to advance TX and CHNO, and we record the space charslots for future expansion.")

                                 (SETQ INWORD NIL)
                                 (SETQ INSPACES T))

                             (* ;; 
    "CHAR is the slot of the previous space, not the space character, PREVSP is the new chain-header")

                             (PUSHCHAR CHARSLOT (PROG1 PREVSP (SETQ PREVSP CHARSLOT))
                                    DX)
                             (add TX DX))
                      ((EOL CR LF FORM)                      (* ; 
                                                    " Force an end to the line. Should FORM do more.")
                           (SETQ CTRL\L\SEEN (EQ CH (CHARCODE FORM)))
                           (SETQ DX 0)                       (* ; 
                                                            "Minimum 6 gives something to point at??")
                           (FILLCHARSLOT CHARSLOT (CHARCODE EOL)
                                  DX)                        (* ; 
                                   "Don't add to TX, EOL is beyond the margin (esp. for right-tabs).")
                           (SETQ CR\END T)
                           (SETQ LSTLN T)
                           (RETURN))
                      (TAB 
                           (* ;; "Try to be reasonable with tabs.  This will create trouble when doing fast-case insert/delete, but Pah! for now.")

                           (FORGETHYPHENBREAK)               (* ; 
                                                            "Remove all prior candidate break points")
                           (\FORMATLINE.PURGE.SPACES PREVSP) (* ; "Pre-tab spaces don't expand")
                           (SETQ PREVSP NIL)
                           (SETQ INSPACES NIL)

                           (* ;; "Now for this tab:")

                           (FILLCHARSLOT CHARSLOT CH 0)      (* ; "0 width to start")
                                                             (* ; "Find and interpret the next tab")
                           (SETQ TABPENDING (\FORMATLINE.TABS TEXTOBJ TABSPEC CHARSLOT TX DEFAULTTAB
                                                   LEFTMARGIN TABPENDING SCALE))
                           [COND
                              ((FIXP TABPENDING)             (* ; 
                                                             "The new TX, adjusted for prior tabs")
                               (SETQ TX TABPENDING)
                               (SETQ TABPENDING NIL))
                              (TABPENDING                    (* ; "PENDINGTAB has the new TX")
                                     (SETQ TX (fetch PTNEWTX of TABPENDING]
                           (SETQ DX (CHARW CHARSLOT))        (* ; "Just computed tab width")
                           (add TX DX)
                           (SAVEBREAK CHNO CHARSLOT)         (* ; "Tabs are possible breaks")
                           (SETQ CHARSLOT (NEXTCHARSLOT CHARSLOT)))
                      (PROGN

                       (* ;; "Not a space-formatting character.  If this ends a space run (INSPACES=T), then the last character was the end of the run.  It goes on the current line (if we have over flowed), the first word character goes on the next line.  ")

                       (CL:UNLESS INWORD                     (* ; "Remember the start of a word")
                           (CL:WHEN INSPACES                 (* ; 
                                            "The immediately last character was a space ending at TX")
                               (SAVEBREAK (SUB1 CHNO)
                                      PREVSP)
                               (SETQ INSPACES NIL))
                           (SETQ INWORD T))
                       (add TX DX)
                       (CL:WHEN (IGREATERP TX RIGHTMARGIN)
                           (if (OR (AND PREVSP (EQ CHARSLOTB PREVSP))
                                   PREVHYPH PREVDHYPH TABPENDING)
                               then (DOBREAK)                (* ; "We can break at space/hyphen/tab")
                             elseif (IGREATERP DX RIGHTMARGIN)
                               then 

                                 (* ;; "This character will never fit (e.g. a large image object).  No point in going to the next line, just continue and hope for a later break point.")

                                    (FILLCHARSLOT CHARSLOT CH DX)
                             elseif (IGREATERP CHNO CH#1)
                               then 
                                    (* ;; 
      "We've seen at least one real character, line is not empty, but no good candidate break point.")

                                 (* ;; "If the overflow CH cannot appear as the first of the next line. or the previous character cannot appear at the end of this line, look back for an acceptable point to break.  We haven't yet pushed (CH, DX).")

                                 (* ;; "If we run back to the beginning without finding a good break, we just take the original overflowed line. (Or, we could just chop at the end, and push the residue to the next line?")

                                    (* ;; "TOO BAD WE DON'T HAVE A HEURISTIC HYPHENATOR")

                                    (add TX (IMINUS DX))
                                    [for CS PCS (X _ TX) backcharslots (PREVCHARSLOT CHARSLOT)
                                       as CN from (SUB1 CHNO)
                                       do (if CS
                                              then (CL:UNLESS (OR (MEMB CS TEDIT.DONT.BREAK.CHARS)
                                                                  (AND (SETQ PCS (PREVCHARSLOT!
                                                                                  CS)))
                                                                  (MEMB PCS TEDIT.DONT.LAST.CHARS))
                                                       (SETQ CHNO CN)
                                                       (SETQ CHARSLOT CS)
                                                       (SETQ TX X)
                                                       (RETURN))
                                                   (add CN -1)
                                                   (add X CHARW)
                                            else (add CN (IMINUS (OR (SMALLP CS)
                                                                     0]
                                    (FILLCHARSLOT CHARSLOT CH DX)
                             else 
                                  (* ;; "Keep going: can't split BEFORE the first thing on the line!")

                                  (FILLCHARSLOT CHARSLOT CH DX))
                           (RETURN))

                       (* ;; "")

                       (* ;; 
                      "Not past the rightmargin yet. Save the character and width, then maybe adjust")

                       (* ;; "In the sequence %"xx yyzz%", TBX1 and TXB are pointing to the space.   TX is pointing to the last y. If z is the overflow (tested above), we want to go back to TXB")

                       (SELCHARQ CH
                            (%.                              (* ; 
                                                      "Check for decimal tabs, immediately after TAB")
                                (PUSHCHAR CHARSLOT CH DX)
                                (CL:WHEN (AND TABPENDING (EQ (fetch PTTYPE of TABPENDING)
                                                             'DECIMAL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                                    (add (fetch (PENDINGTAB PTTABX) of TABPENDING)
                                         DX)                 (* ; 
               "Adjust the tab stop's X value so that the LEFT edge of the decimal point goes there.")
                                    (SETQ TABPENDING
                                     (\FORMATLINE.TABS TEXTOBJ TABSPEC CHARSLOT TX DEFAULTTAB 
                                            LEFTMARGIN TABPENDING SCALE T))
                                                             (* ; 
                                                    "Tab over to the LEFT side of the decimal point.")
                                    [COND
                                       ((FIXP TABPENDING)    (* ; 
                            "If it returns a number, that is the new TX, adjusted for any prior tabs")
                                        (SETQ TX TABPENDING)
                                        (SETQ TABPENDING NIL))
                                       (TABPENDING           (* ; 
                                                   "Otherwise, look in the PENDINGTAB for the new TX")
                                              (SETQ TX (fetch PTNEWTX of TABPENDING]
                                    (\FORMATLINE.PURGE.SPACES PREVSP)
                                                             (* ; 
                                        "Spaces before a tab don't take part in later justification.")
                                    (SETQ PREVSP NIL)
                                    (SAVEBREAK CHNO CHARSLOT)))
                            ((- EM-DASH)                     (* ; "Hyphen, M-dash")
                                 (FORGETHYPHENBREAK)
                                 (SETQ PREVHYPH CHARSLOT)
                                 (SETQ INSPACES NIL)
                                 (SAVEBREAK CHNO CHARSLOT)   (* ; 
                                                             "Save the hyphen slot, then fill it")
                                 (PUSHCHAR CHARSLOT CH DX))
                            (NONBREAKING-HYPHEN 
                                                (* ;; 
                            "Switch the character code and width in case font doesn't have a glyph??")

                                 (PUSHCHAR CHARSLOT (CHARCODE -)
                                        (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                            (SOFT-HYPHEN                     (* ; 
                                                          "Discretionary hyphen may become invisible")
                                         (SETQ INSPACES NIL)
                                         (SETQ PREVDHYPH CHARSLOT)
                                         (SETQ PREVHYPH NIL)
                                         (SAVEBREAK CHNO CHARSLOT)
                                                             (* ; 
                                                "If this is the break, it will show as a real hyphen")
                                         (PUSHCHAR CHARSLOT (CHARCODE -)
                                                (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                            (PUSHCHAR CHARSLOT CH DX] 

                 (* ;; "BOUNDS CHECKING!")

                 (CL:WHEN (EQ CHARSLOT LASTCHARSLOT)

                     (* ;; 
        "If too long, we let it roll over to the next line.  Should we put something in the margin??")

                     (TEDIT.PROMPTPRINT TEXTOBJ "Line too long to format." T)
                     (RETURN)) finally (SETQ CHARSLOT (PREVCHARSLOT CHARSLOT)) 
                                                             (* ; "Ran off the end of the text")
                                     (add CHNO -1))

              (* ;; "End of character loop.  Fix up last tab?")

              (CL:WHEN TABPENDING
                  (\FORMATLINE.PURGE.SPACES PREVSP)          (* ; "Ignore spaces before tabs")
                  (SETQ PREVSP NIL)
                  (SETQ TX (\FORMATLINE.TABS TEXTOBJ TABSPEC (FETCH (PENDINGTAB PTCHARSLOT)
                                                                OF TABPENDING)
                                  TX DEFAULTTAB LEFTEDGE TABPENDING SCALE T)))]
             (T 
                (* ;; "No starting  PC: empty or beyond the end. Get looks from the TSTREAM, so that \DISPLAYLINE works.  Original code asked for the piece at TEXTLEN (last piece?) to get its looks, but those looks would be the TEXTOBJ default looks anyway.")

                (* ;; "NOTE: this follows the original in not distinguishing hardcopy-display mode. Presumably empty is empty.")

                (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ)))
                (PUSHCHAR CHARSLOT NIL (fetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))

                (* ;; 
         "Font preferences: the caret looks, else the default for this text, else the system default")

                (SETQ CHNO CH#1)
                (SETQ FONT (OR (AND (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)))
                               (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)))
                               DEFAULTFONT))
                (SETQ ASCENT (FONTPROP FONT 'ASCENT))
                (SETQ DESCENT (FONTPROP FONT 'DESCENT))
                (SETQ 1STLN T)
                (SETQ LEFTMARGIN (IPLUS LEFTEDGE (fetch (FMTSPEC LEFTMAR) of FMTSPEC)))
                (SETQ TX LEFTMARGIN)
                (SETQ RIGHTMARGIN (CL:IF (ZEROP (fetch (FMTSPEC RIGHTMAR) of FMTSPEC))
                                      WIDTH
                                      (fetch (FMTSPEC RIGHTMAR) of FMTSPEC))]

     (* ;; "")

     (* ;; 
     "All the line information is now in our variables.  Migrate to the LINE and THISLINE fields. ")

          (CL:UNLESS CHARTOP (SETQ CHARTOP CHNO))
          (freplace (LINEDESCRIPTOR CHAR1) of LINE with CH#1)
          (freplace (LINEDESCRIPTOR CHARLIM) of LINE with CHARTOP)
                                                             (* ; "LET JUSTIFIER FIGURE THIS OUT?")
          (freplace (LINEDESCRIPTOR CHARTOP) of LINE with CHARTOP)
          (freplace (LINEDESCRIPTOR 1STLN) of LINE with 1STLN)

     (* ;; "First line of a paragraph.  Special paragraph types get marked in the margin.")

          (freplace (LINEDESCRIPTOR LMARK) of LINE
             with (CL:WHEN [AND 1STLN (OR (EQ (fetch FMTPARATYPE of FMTSPEC)
                                              'PAGEHEADING)
                                          (fetch FMTNEWPAGEBEFORE of FMTSPEC)
                                          (fetch FMTNEWPAGEAFTER of FMTSPEC)
                                          [AND (fetch FMTSPECIALX of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALX of FMTSPEC]
                                          (AND (fetch FMTSPECIALY of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALY of FMTSPEC]
                         'GREY))
          (freplace (LINEDESCRIPTOR LSTLN) of LINE with LSTLN)
          (freplace (LINEDESCRIPTOR CR\END) of LINE with CR\END)
          (freplace (LINEDESCRIPTOR DIRTY) of LINE with NIL)
          (freplace (LINEDESCRIPTOR LHASPROT) of LINE with PROTECTED)
          (freplace (LINEDESCRIPTOR LEFTMARGIN) of LINE with LEFTMARGIN)
          (freplace (LINEDESCRIPTOR RIGHTMARGIN) of LINE with RIGHTMARGIN)
          (freplace (LINEDESCRIPTOR LHEIGHT) of LINE
             with (CL:IF (ZEROP (IPLUS ASCENT DESCENT))
                      (FONTPROP (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                         (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ)))
                                    DEFAULTFONT)
                             'HEIGHT)
                      (IPLUS ASCENT DESCENT)))
          (freplace (LINEDESCRIPTOR ASCENT) of LINE with ASCENT)
          (freplace (LINEDESCRIPTOR DESCENT) of LINE with DESCENT)
          (freplace (LINEDESCRIPTOR LXLIM) of LINE with TX)
          (freplace (LINEDESCRIPTOR LFMTSPEC) of LINE with FMTSPEC)

     (* ;; "LINE is complete")

     (* ;; "")

          (freplace (THISLINE DESC) of THISLINE with LINE)
          (freplace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with NIL)
          (IF T
              THEN (\HARDCOPY.FORMATLINE.JUSTIFY TEXTOBJ LINE FMTSPEC THISLINE PREVSP T)
            ELSE (\FORMATLINE.JUSTIFY TEXTOBJ LINE FMTSPEC THISLINE PREVSP T))
          (RETURN CTRL\L\SEEN])

(\HARDCOPY.FORMATLINE.JUSTIFY
  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE PREVSP)             (* ; "Edited 23-Oct-2022 23:15 by rmk")
                                                             (* ; "Edited 19-Oct-2022 09:07 by rmk")
                                                             (* ; "Edited  8-Oct-2022 16:49 by rmk")
                                                             (* ; "Edited  5-Oct-2022 00:37 by rmk")
                                                             (* ; "Edited 29-Mar-94 12:36 by jds")

    (* ;; "Do the formatting work for justified, centered, etc.  lines")

    (PROG ((QUAD (fetch QUAD of FMTSPEC))
           SPACELEFT NATURALWIDTHS LINELEAD)
          (replace (LINEDESCRIPTOR LTRUEDESCENT) of LINE with (fetch (LINEDESCRIPTOR DESCENT)
                                                                 of LINE))
          (replace (LINEDESCRIPTOR LTRUEASCENT) of LINE with (fetch (LINEDESCRIPTOR ASCENT)
                                                                of LINE))
                                                             (* ; 
                                                    "Save the true ascent value for display purposes")
          (replace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
                                                             (* ; 
                                               "Start by assuming that we want a space factor of 1.0")
          (CL:WHEN (SETQ LINELEAD (fetch LINELEAD of FMTSPEC))
                                                             (* ; 
                                                             "If line leading was specified, set it")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   LINELEAD)                                 (* ; 
                                                          "And adjust the line's descent accordingly")
              (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                   LINELEAD))
          (CL:WHEN (AND (fetch (LINEDESCRIPTOR 1STLN) of LINE)
                        (fetch LEADBEFORE of FMTSPEC))       (* ; 
                                                     "If paragraph pre-leading was specified, set it")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC))            (* ; 
                                                          "And adjust the line's ascent accordingly.")
              (add (fetch (LINEDESCRIPTOR ASCENT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC)))
          (CL:WHEN (AND (fetch (LINEDESCRIPTOR LSTLN) of LINE)
                        (fetch LEADAFTER of FMTSPEC))        (* ; 
                                                     "If paragraph pre-leading was specified, set it")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADAFTER of FMTSPEC))             (* ; 
                                                          "And adjust the line's ascent accordingly.")
              (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                   (fetch LEADAFTER of FMTSPEC)))

     (* ;; "")

     (* ;; "Now for the horizontal alignment.  First we adjust THISLINE to remove any trailing spaces, and their natural widths.")

          (CL:WHEN (EQ PREVSP (PREVCHARSLOT! (fetch (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE)))

              (* ;; "At least one trailing space, back up PREVSP and LXLIM.  Use PREVCHARSLOT! to be sure that any invisibles or looks don't interfere with a contiguous space-run.  (May never happen, but...)")

              (bind OPREVSP (LXLIM _ (ffetch (LINEDESCRIPTOR LXLIM) of LINE)) while PREVSP
                 do (SETQ OPREVSP PREVSP)
                    (SETQ PREVSP (CHAR OPREVSP))             (* ; 
                                                             "Back up to the next previous space")
                    (freplace (CHARSLOT CHAR) of OPREVSP with (CHARCODE SPACE))
                    (add LXLIM (IMINUS (CHARW OPREVSP))) repeatwhile (EQ PREVSP (PREVCHARSLOT! 
                                                                                       OPREVSP))
                 finally (freplace (LINEDESCRIPTOR LXLIM) of LINE with LXLIM)))
          [SETQ SPACELEFT (IMAX 0 (IDIFFERENCE (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE)
                                         (ffetch (LINEDESCRIPTOR LXLIM) of LINE]
          (replace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
          (SELECTQ QUAD
              (LEFT                                          (* ; 
                                                             "Just purge spaces below, no stretching")
                    (RETURN))
              (RIGHT                                         (* ; "Move the right margin over")
                     (add (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                          SPACELEFT)
                     (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                                     of LINE))
                     (RETURN))
              (CENTERED                                      (* ; 
                                                "Split the difference for centering: 32 x value form")
                        (add (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                             (FOLDLO SPACELEFT 2))
                        (add (fetch (LINEDESCRIPTOR LXLIM) of LINE)
                             (FOLDLO SPACELEFT 2))
                        (RETURN))
              (JUSTIFIED (CL:UNLESS PREVSP                   (* ; "No spaces to stretch")
                             (RETURN))
                         (CL:WHEN (EQ 0 SPACELEFT)           (* ; "Nothing to use up")
                             (RETURN))
                         (CL:WHEN (OR (fetch (LINEDESCRIPTOR CR\END) of LINE)
                                      (IGEQ (ffetch (LINEDESCRIPTOR CHARLIM) of LINE)
                                            (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                                                             (* ; 
                                                          "Don't stretch last line in the paragraph.")
                             (RETURN))

                         (* ;; "At least one possibly stretchable space.  ")

                         (* ;; 
          "Spread what's left proportionately among spaces, pushing LXLIM out to the right margin.  ")

                         (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR 
                                                                                    RIGHTMARGIN)
                                                                         of LINE))

                         (* ;; "The amount added to each space is proportional to its natural width such that the final total is NATURALWIDTHS+SPACELEFT. Spaces in bigger fonts have bigger natural widths.")

                         [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP) by (CHAR SPSLOT) while SPSLOT
                                                sum (PROG1 (CHARW SPSLOT)
                                                        (CL:UNLESS (CHAR SPSLOT)
                                                            (replace (THISLINE TLFIRSTSPACE)
                                                               of THISLINE with SPSLOT)))]

                         (* ;; "Unlike for display, we don't update the CHARW's for the different spaces since the TLSPACEFACTOR  and DSPSPACEFACTOR actually control how the underlying hardcopystream advances. ")

                         (freplace (THISLINE TLSPACEFACTOR) of THISLINE
                            with (FQUOTIENT (IPLUS NATURALWIDTHS SPACELEFT)
                                        NATURALWIDTHS))
                         (RETURN))
              NIL))

    (* ;; 
    "Change all the space-slots--chained for justification--back into regular spaces, for display.")

    (\FORMATLINE.PURGE.SPACES PREVSP])

(\HARDCOPY.FORMATLINE.HEADINGS
  [LAMBDA (TEXTOBJ TSTREAM LINE FMTSPEC CHNO IMAGESTREAM FORMATTINGSTATE)
                                                             (* ; "Edited  3-Oct-2022 13:05 by rmk")

    (* ;; "Return setup LINE to skip a sequence of heading pieces STATE")

    (SELECTQ (fetch (FMTSPEC FMTPARATYPE) of FMTSPEC)
        (PAGEHEADING 
                     (* ;; "This paragraph is the content for a page heading. The pieces are stashed away in the FORMATTING STATE.")

                     (TEDIT.HARDCOPY.PAGEHEADING TEXTOBJ TSTREAM LINE FMTSPEC CHNO IMAGESTREAM 
                            FORMATTINGSTATE)
                     T)
        (EVEN                                                (* ; "Skip an odd page.")
              (CL:WHEN (ODDP (fetch (PAGEFORMATTINGSTATE PAGE#) of FORMATTINGSTATE))
                  (TEDIT.SKIP.SPECIALCOND TSTREAM LINE FMTSPEC CHNO)
                  T))
        (ODD                                                 (* ; "Skip an even page")
             (CL:WHEN (EVENP (fetch (PAGEFORMATTINGSTATE PAGE#) of FORMATTINGSTATE))
                 (TEDIT.SKIP.SPECIALCOND TSTREAM LINE FMTSPEC CHNO)
                 T))
        NIL])

(\TEDIT.HARDCOPY.MODIFYLOOKS
  [LAMBDA (LINE STARTX CURX CURY LOOKS PRSTREAM)             (* ; "Edited 30-May-91 21:17 by jds")

    (* ;; "Do underlining, overlining, etc.  for hardcopy files")

    [PROG ((STREAMSCALE (DSPSCALE NIL PRSTREAM))
           [RULEWIDTH (FIXR (FTIMES 0.75 (DSPSCALE NIL PRSTREAM]
           (ONEPOINT (FIXR (DSPSCALE NIL PRSTREAM)))
           YOFFSET)
          (COND
             ((fetch (CHARLOOKS CLULINE) of LOOKS)           (* ; "It's underlined.")
              (DRAWLINE STARTX (IDIFFERENCE (fetch (LINEDESCRIPTOR YBASE) of LINE)
                                      (fetch (LINEDESCRIPTOR LTRUEDESCENT) of LINE))
                     CURX
                     (IDIFFERENCE (fetch (LINEDESCRIPTOR YBASE) of LINE)
                            (fetch (LINEDESCRIPTOR LTRUEDESCENT) of LINE))
                     RULEWIDTH
                     'PAINT PRSTREAM)                        (* ; "A 1/2-pt underline")
              ))
          (COND
             ((fetch (CHARLOOKS CLOLINE) of LOOKS)           (* ; "Over-line")
              (DRAWLINE STARTX (IPLUS (fetch (LINEDESCRIPTOR YBASE) of LINE)
                                      (fetch (LINEDESCRIPTOR LTRUEASCENT) of LINE))
                     CURX
                     (IPLUS (fetch (LINEDESCRIPTOR YBASE) of LINE)
                            (fetch (LINEDESCRIPTOR LTRUEASCENT) of LINE))
                     RULEWIDTH
                     'PAINT PRSTREAM)))
          (COND
             ((fetch (CHARLOOKS CLSTRIKE) of LOOKS)          (* ; "Struch-thru")
              (DRAWLINE STARTX (SETQ YOFFSET (IPLUS (fetch (LINEDESCRIPTOR YBASE) of LINE)
                                                    (IQUOTIENT
                                                     [FIXR (FTIMES STREAMSCALE
                                                                  (FONTPROP (fetch (CHARLOOKS CLFONT)
                                                                               of LOOKS)
                                                                         'ASCENT]
                                                     3)))
                     CURX YOFFSET RULEWIDTH 'PAINT PRSTREAM]
    (MOVETO CURX CURY PRSTREAM])

(\TEDIT.HCPYLOOKS.UPDATE
  [LAMBDA (TSTREAM PC)                                       (* ; "Edited  2-Oct-2022 11:54 by rmk")
                                                             (* ; "Edited 29-Sep-2022 23:12 by rmk")
                                                             (* ; "Edited 25-Sep-2022 18:21 by rmk")
                                                             (* ; "Edited 22-Sep-2022 14:36 by rmk")
                                                             (* ; "Edited 20-Sep-2022 15:10 by rmk")
                                                             (* ; "Edited 30-May-91 21:47 by jds")

(* ;;; "Called from \INSTALL.PIECE under \FORMATLINE only when the new piece has different looks than the previous piece. This updates the line formatting fields such as ASCENT, DESCENT, etc.  ")

    (DECLARE (USEDFREE CHARSLOT CHNO ASCENT DESCENT FONT KERN DEVICE))
    (CL:UNLESS PC                                            (* ; 
                                                          "Ran off the end ? Skips the ENDOFSTREAMOP")
        (RETFROM (FUNCTION \TEXTBIN)
               NIL))
    (LET (PLOOKS INVISIBLERUN OFFSET)

         (* ;; "")

         (* ;; "We have to adjust the CHNO to pass over invisible pieces, and to record the number of characters we passed over in THISLINE's character vector.  This maintains the correspondence between the indexing of actual characters in the vector and characters positions in the stream.  This information isn't need for display, but TEDIT.SCAN.LINE requires that mapping.")

         (* ;; "Invisible runs are coded in a character slot, like other non-character entries (looks, objects) by putting a NIL in the CHAR field of a slot and putting the non-character information in the CHARWIDTH field.  Thus, an invisible run is represented as a pair (NIL,runlength).")

         (SETQ INVISIBLERUN (for old PC by (NEXTPIECE PC) while PC
                               while (OR (ZEROP (PLEN PC))
                                         (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC)))
                               sum (PLEN PC)))
         (if (EQ 0 INVISIBLERUN)
             then 
                  (* ;; "If the looks are the same as current looks, we don't need to change anything.  APPLY STYLES AT PIECE CREATION??")

                  (SETQ PLOOKS (PLOOKS PC))
                  (CL:UNLESS (EQ PLOOKS (ffetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))
                      (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with PLOOKS)
                      (SETQ FONT (FONTCOPY (fetch (CHARLOOKS CLFONT) of PLOOKS)
                                        'DEVICE DEVICE))
                      (SETQ OFFSET (OR (AND (fetch (CHARLOOKS CLOFFSET) of PLOOKS)
                                            (HCSCALE (DSPSCALE NIL DEVICE)
                                                   (fetch (CHARLOOKS CLOFFSET) of PLOOKS)))
                                       0))
                      (SETQ ASCENT (IMAX ASCENT (IPLUS (fetch \SFAscent of FONT)
                                                       OFFSET)))
                      (SETQ DESCENT (IMAX DESCENT (IDIFFERENCE (fetch \SFDescent of FONT)
                                                         OFFSET)))
                      (SETQ KERN (LISTGET (fetch (CHARLOOKS CLUSERINFO) of PLOOKS)
                                        'KERN))
                      (CL:WHEN KERN
                          (SETQ KERN (HCSCALE (DSPSCALE NIL DEVICE)
                                            KERN)))
                      (STREAMPROP TSTREAM 'KERN KERN)        (* ; "For e.g. POSTSCRIPTSTREAM")
                      (PUSHCHAR CHARSLOT NIL PLOOKS))
           else (PUSHCHAR CHARSLOT NIL INVISIBLERUN)
                (add CHNO INVISIBLERUN)
                (\INSTALL.PIECE PC 0))
         PC])

(\TEDIT.HCPYFMTSPEC
  [LAMBDA (SPEC IMAGESTREAM)                                 (* ; "Edited 20-Oct-2022 22:35 by rmk")
                                                             (* ; "Edited 29-Sep-2022 23:32 by rmk")
                                                             (* ; "Edited 30-May-91 21:18 by jds")

    (* ;; "Given a display-type FMTSPEC, create a hardcopy equivalent.  (Special positions are made paper-relative first.)")

    (LET ((SCALE (DSPSCALE NIL IMAGESTREAM)))
         (create FMTSPEC using SPEC FMTHARDCOPYSCALE _ SCALE 1STLEFTMAR _ (HCSCALE
                                                                           SCALE
                                                                           (fetch (FMTSPEC 1STLEFTMAR
                                                                                         )
                                                                              of SPEC))
                               LEFTMAR _ (HCSCALE SCALE (fetch (FMTSPEC LEFTMAR) of SPEC))
                               RIGHTMAR _ (HCSCALE SCALE (fetch (FMTSPEC RIGHTMAR) of SPEC))
                               LEADBEFORE _ (HCSCALE SCALE (fetch (FMTSPEC LEADBEFORE) of SPEC))
                               LEADAFTER _ (HCSCALE SCALE (fetch (FMTSPEC LEADAFTER) of SPEC))
                               LINELEAD _ (HCSCALE SCALE (fetch (FMTSPEC LINELEAD) of SPEC))
                               FMTBASETOBASE _ (AND (fetch (FMTSPEC FMTBASETOBASE) of SPEC)
                                                    (HCSCALE SCALE (fetch (FMTSPEC FMTBASETOBASE)
                                                                      of SPEC)))
                               QUAD _ (fetch (FMTSPEC QUAD) of SPEC)
                               TABSPEC _ [CONS [AND (CAR (fetch (FMTSPEC TABSPEC) of SPEC))
                                                    (HCSCALE SCALE (CAR (fetch (FMTSPEC TABSPEC)
                                                                           of SPEC]
                                               (for TAB in (CDR (fetch (FMTSPEC TABSPEC) of SPEC))
                                                  collect (CONS (HCSCALE SCALE (CAR TAB))
                                                                (CDR TAB]
                               FMTSPECIALX _ (AND (fetch (FMTSPEC FMTSPECIALX) of SPEC)
                                                  (HCSCALE SCALE (SCALEPAGEUNITS (fetch (FMTSPEC
                                                                                         FMTSPECIALX)
                                                                                    of SPEC)
                                                                        1.0 NIL)))
                               FMTSPECIALY _ (AND (fetch (FMTSPEC FMTSPECIALY) of SPEC)
                                                  (HCSCALE SCALE (SCALEPAGEUNITS (fetch (FMTSPEC
                                                                                         FMTSPECIALY)
                                                                                    of SPEC)
                                                                        1.0 NIL])

(\TEDIT.INTEGER.IMAGEBOX
  [LAMBDA (OLDBOX)                                           (* jds "23-Oct-84 13:52")
                                                             (* Take an IMAGEBOX, and assure that 
                                                             its contents are integers)
    (replace XKERN of OLDBOX with (FIXR (fetch XKERN of OLDBOX)))
    (replace YDESC of OLDBOX with (FIXR (fetch YDESC of OLDBOX)))
    (replace YSIZE of OLDBOX with (FIXR (fetch YSIZE of OLDBOX)))
    (replace XSIZE of OLDBOX with (FIXR (fetch XSIZE of OLDBOX)))
    OLDBOX])
)



(* ;; "Functions for scaling distances and regions as needed during hardcopy.")

(DEFINEQ

(\TEDIT.SCALE
  [LAMBDA (VALUE SCALEFACTOR)                                (* ; "Edited  2-Jan-87 12:11 by jds")

(* ;;; "Scale VALUE by SCALEFACTOR, and round it to the nearest integer.  Used for scaling distances, etc. during hardcopy.")

    (FIXR (FTIMES VALUE SCALEFACTOR])

(\TEDIT.SCALEREGION
  [LAMBDA (REGION SCALEFACTOR)                               (* ; "Edited  2-Jan-87 12:13 by jds")

(* ;;; "Scale the region REGION by SCALEFACTOR, rounding all the dimensions to integers.  Used to scale page-boundary regions during hardcopy.")

    (create REGION
           LEFT _ (\TEDIT.SCALE (fetch (REGION LEFT) of REGION)
                         SCALEFACTOR)
           BOTTOM _ (\TEDIT.SCALE (fetch (REGION BOTTOM) of REGION)
                           SCALEFACTOR)
           WIDTH _ (\TEDIT.SCALE (fetch (REGION WIDTH) of REGION)
                          SCALEFACTOR)
           HEIGHT _ (\TEDIT.SCALE (fetch (REGION HEIGHT) of REGION)
                           SCALEFACTOR])
)



(* ;; "PRESS-specific code")


(RPAQ TEDIT.DEFAULTPAGEREGION (CREATEREGION 2794 1905 16256 23495))



(* ; "0.75 inches from bottom, 1 from top")




(* ;; "Support for the window-menu's HARDCOPY button, LISTFILES, etc.")

(DEFINEQ

(TEDIT.HARDCOPYFN
  [LAMBDA (WINDOW IMAGESTREAM)                              (* ; "Edited 21-Sep-2021 15:33 by rmk:")

    (* ;; 
   "This is the TEdit HARDCOPYFN, hooking into the system's standard Hardcopy window-menu operation.")

    (PROG ((TEXTOBJ (TEXTOBJ WINDOW))
           (TEXTSTREAM (TEXTSTREAM WINDOW)))

     (* ;; "TEXTSTREAM is bound here so we don't drop the steam on the floor if the window goes away, since the TEXTOBJ only has an XPOINTER to the stream in it.  Please don't remove this binding!")

          (RESETLST
              [RESETSAVE (\TEDIT.MARKACTIVE TEXTOBJ)
                     '(AND (\TEDIT.MARKINACTIVE OLDVALUE]
              (replace (TEXTOBJ EDITOPACTIVE) of TEXTOBJ with 'Hardcopy)
                                                             (* ; "Build the hardcopy")
              (TEDIT.FORMAT.HARDCOPY TEXTOBJ IMAGESTREAM))])

(\TEDIT.HARDCOPY
  [LAMBDA (FILE PFILE)                                       (* ; "Edited  4-Oct-2022 10:40 by rmk")
                                                             (* ; "Edited  1-Oct-2022 22:08 by rmk")
                                                            (* ; "Edited 12-Jun-90 18:35 by mitani")

    (* ;; "Send the document FILE to the printer (or to a print file, as determined by PFILE).")

    (CL:WITH-OPEN-STREAM (TEXT-STREAM (OPENTEXTSTREAM FILE))
           (RESETLST
               [RESETSAVE (\TEDIT.MARKACTIVE (TEXTOBJ TEXT-STREAM))
                      '(AND (\TEDIT.MARKINACTIVE OLDVALUE]
               [RESETSAVE NIL `(AND (CLOSEF? ',PFILE]
               (replace (TEXTOBJ EDITOPACTIVE) of (TEXTOBJ TEXT-STREAM) with 'Hardcopy)
               (TEDIT.FORMAT.HARDCOPY TEXT-STREAM PFILE T NIL NIL NIL 'POSTSCRIPT)
               PFILE)])

(\TEDIT.PRESS.HARDCOPY
  [LAMBDA (FILE PFILE)                                      (* ; "Edited 12-Jun-90 18:36 by mitani")
                                                             (* Send the text to the printer.)
    [SETQ FILE (OPENTEXTSTREAM (COND
                                  ((STRINGP FILE)
                                   (MKATOM FILE))
                                  (T FILE]
    (RESETLST
        [RESETSAVE (\TEDIT.MARKACTIVE (TEXTOBJ FILE))
               '(AND (\TEDIT.MARKINACTIVE OLDVALUE]
        (replace (TEXTOBJ EDITOPACTIVE) of (TEXTOBJ FILE) with 'Hardcopy)
        (TEDIT.FORMAT.HARDCOPY FILE PFILE T NIL NIL NIL 'PRESS)
        (CLOSEF? PFILE)
        PFILE)])
)

[LET [(IPVALUES (ASSOC 'CONVERSION (ASSOC 'INTERPRESS PRINTFILETYPES]
     (COND
        (IPVALUES                                            (* ; 
                                          "Only install INTERPRESS printing if INTERPRESS is loaded.")
               (LISTPUT IPVALUES 'TEDIT (FUNCTION \TEDIT.HARDCOPY]

[LET [(PRESSVALUES (ASSOC 'CONVERSION (ASSOC 'PRESS PRINTFILETYPES]
     (COND
        (PRESSVALUES                                         (* ; 
                                                    "Only install PRESS printing if PRESS is loaded.")
               (LISTPUT PRESSVALUES 'TEDIT (FUNCTION \TEDIT.PRESS.HARDCOPY]



(* ;; "vars for Japanese Line Break")


(RPAQ? TEDIT.DONT.BREAK.CHARS
       (CHARCODE ("41,42" "41,43" "41,53" "41,54" "41,74" "41,115" "41,133" "41,131" "41,127" 
                        "Hira,41" "Hira,43" "Hira,45" "Hira,47" "Hira,51" "Hira,103" "Hira,143" 
                        "Hira,145" "Hira,147" "Hira,156" "Kata,41" "Kata,43" "Kata,45" "Kata,47" 
                        "Kata,51" "Kata,103" "Kata,143" "Kata,145" "Kata,147" "Kata,156")))

(RPAQ? TEDIT.DONT.LAST.CHARS (CHARCODE ("41,114" "41,132" "41,130" "41,126")))



(* ;; "Support for hardcopying several files as one document")

(DEFINEQ

(TEDIT-BOOK
  [LAMBDA (FILES DIRECTORY PRINT-FILE DONT-SEND)             (* ; "Edited 22-Mar-93 23:55 by jds")
    (LET ((DOC (OPENTEXTSTREAM (MKATOM (CAR FILES))
                      NIL)))

         (* ;; "Gather all the files into one document:")

         (for FILE in (CDR FILES) do (TEDIT.SETSEL DOC 1 (fetch (TEXTOBJ TEXTLEN) of (TEXTOBJ DOC))
                                            'RIGHT NIL NIL)
                                     (TEDIT.INCLUDE DOC (PACK* (OR DIRECTORY "")
                                                               FILE)))
                                                             (* ; "Set page layout")
         (TEDIT.FORMAT.HARDCOPY DOC PRINT-FILE DONT-SEND NIL NIL NIL NIL NIL)
         (CLOSEF DOC])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (3381 65031 (TEDIT.HARDCOPY 3391 . 4407) (TEDIT.HCPYFILE 4409 . 6349) (
\TEDIT.HARDCOPY.DISPLAYLINE 6351 . 16966) (\TEDIT.HARDCOPY.FORMATLINE 16968 . 44650) (
\HARDCOPY.FORMATLINE.JUSTIFY 44652 . 53326) (\HARDCOPY.FORMATLINE.HEADINGS 53328 . 54574) (
\TEDIT.HARDCOPY.MODIFYLOOKS 54576 . 56923) (\TEDIT.HCPYLOOKS.UPDATE 56925 . 60966) (\TEDIT.HCPYFMTSPEC
 60968 . 64356) (\TEDIT.INTEGER.IMAGEBOX 64358 . 65029)) (65120 66204 (\TEDIT.SCALE 65130 . 65424) (
\TEDIT.SCALEREGION 65426 . 66202)) (66447 69019 (TEDIT.HARDCOPYFN 66457 . 67368) (\TEDIT.HARDCOPY 
67370 . 68290) (\TEDIT.PRESS.HARDCOPY 68292 . 69017)) (70299 71100 (TEDIT-BOOK 70309 . 71098)))))
STOP
