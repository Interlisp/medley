(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED " 6-Sep-2023 23:32:40" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;492 172214 

      :EDIT-BY rmk

      :CHANGES-TO (VARS TEDIT-SCREENCOMS)

      :PREVIOUS-DATE "22-Aug-2023 16:56:28" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;491)


(PRETTYCOMPRINT TEDIT-SCREENCOMS)

(RPAQQ TEDIT-SCREENCOMS
       ([DECLARE%: EVAL@COMPILE DONTCOPY
               (EXPORT (RECORDS THISLINE LINECACHE)
                      (COMS                                  (* ; "LINEDESCRIPTORS")
                            (RECORDS LINEDESCRIPTOR)
                            (I.S.OPRS inlines backlines)
                            (MACROS GETLD FGETLD SETLD FSETLD SETYPOS LINKLD))
                      (MACROS HCSCALE HCUNSCALE)
                      (GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
                      (ADDVARS (CHARACTERNAMES (EM-DASH "357,045")
                                      (SOFT-HYPHEN "357,043")
                                      (NONBREAKING-HYPHEN "357,042")
                                      (NONBREAKING-SPACE "357,041")))
                      (COMS                                  (* ; "Formatting slots held by THISLINE")
                            (RECORDS CHARSLOT)
                            (MACROS CHAR CHARW PREVCHARSLOT PREVCHARSLOT! NEXTCHARSLOT FIRSTCHARSLOT
                                   NTHCHARSLOT LASTCHARSLOT FILLCHARSLOT BACKCHARS PUSHCHAR POPCHAR 
                                   CHARSLOTP)
                            (CONSTANTS (CELLSPERCHARSLOT 2)
                                   (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
                                   (MAXCHARSLOTS 256))
                            
                            (* ;; "incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards.")

                            (I.S.OPRS incharslots backcharslots]
        (FNS \TEDIT.LINEDESCRIPTOR.DEFPRINT)
        (INITRECORDS THISLINE LINEDESCRIPTOR LINECACHE)
        (DECLARE%: EVAL@COMPILE DONTCOPY                     (* ; "Not exported")
               (MACROS SPACEBREAK SAVEBREAK DOBREAK FORCEBREAK FORGETHYPHENBREAK FORGETPREVIOUSBREAK)
               (RECORDS PENDINGTAB))
        (INITRECORDS PENDINGTAB)
        (FNS \FORMATLINE \FORMATLINE.SETUP \FORMATLINE.ALIGN \FORMATLINE.JUSTIFY \FORMATLINE.TABS 
             \FORMATLINE.SCALETABS \FORMATLINE.PURGE.SPACES \FORMATLINE.EMPTY \FORMATLINE.UPDATELOOKS
             \FORMATLINE.LASTLEGAL \FORMATBLOCK)
        (FNS \CLEARTHISLINE \TLVALIDATE)
                                                             (* ; "Consistency checking")
        (INITVARS *TEDIT-CACHED-FMTSPEC*)
                                                             (* ; "Heuristic for \FORMATLINE")
        (GLOBALVARS *TEDIT-CACHED-FMTSPEC*)
        (FNS \DISPLAYLINE \DISPLAYLINE.TABS \TEDIT.LINECACHE \TEDIT.CREATE.LINECACHE \TEDIT.BLTCHAR)
        (DECLARE%: EVAL@COMPILE DONTCOPY 

               (* ;; "Machine independent version of \TEDIT.BLTCHAR")

               (MACROS MI-TEDIT.BLTCHAR))
        (FNS TEDIT.UPDATE.SCREEN \BACKFORMAT \TEDIT.PREVIOUS.LINEBREAK \FILLPANE \TEDIT.UPDATE.LINES
             \TEDIT.FIND.DIRTYCHARS \FORMAT.GAP.LINES \TEDIT.LOWER.LINES \TEDIT.RAISE.LINES 
             \TEDIT.VALID.LINES \SHOWTEXT \TEDIT.CLEAR.SCREEN.BELOW.LINE \CLEARPANE.BELOW.LINE 
             \TEDIT.INSERTLINE \TEDIT.INSURE.TRAILING.LINE \TEDIT.LINE.LIST \TEDIT.MARK.LINES.DIRTY 
             \TEDIT.NEXT.LINE.BOTTOM)))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE THISLINE (
                    (* ;; 
        "Cache for line-related character location info, for selection and line-display code to use.")

                    (DESC FULLXPOINTER)                      (* ; 
                                                    "Line descriptor for the line this describes now")
                    TLSPACEFACTOR                            (* ; 
                                                   "The SPACEFACTOR to be used in printing this line")
                    TLFIRSTSPACE                             (* ; "The first space to which SPACEFACTOR is to apply.  This is used sothat spaces to the left of a TAB have their default width.")
                    CHARSLOTS                                (* ; "Pointer block holdomg char/width slots MAXCHARSLOTS (with an extra slot so that there is always storage behind NEXTAVAILABLECHARSLOT")
                    NEXTAVAILABLECHARSLOT)                   (* ; 
                                  "The last used CHARSLOT is at (PREVCHARSLOT NEXTAVAILABLECHARSLOT)")
                   CHARSLOTS _ (\ALLOCBLOCK (ITIMES (ADD1 MAXCHARSLOTS)
                                                   CELLSPERCHARSLOT)
                                      PTRBLOCK.GCT))

(DATATYPE LINECACHE (
                     (* ;; "Image cache for display lines.")

                     LCBITMAP                                (* ; 
                                         "The bitmap that will be used by this instance of the cache")
                     (LCNEXTCACHE FULLXPOINTER)              (* ; 
                                                   "The next cache in the chain, for screen updates.")
                     ))
)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)



(* ; "LINEDESCRIPTORS")

(DECLARE%: EVAL@COMPILE

(DATATYPE LINEDESCRIPTOR 
          (
           (* ;; 
       "Description of a single line of formatted text, either on the display or for a printed page.")

           YBOT                                              (* ; 
                                             "Y value for the bottom of the line (below the descent)")
           YBASE                                             (* ; 
                                                     "Yvalue for the base line the characters sit on")
           LEFTMARGIN                                        (* ; "Left margin, in screen points")
           RIGHTMARGIN                                       (* ; "Right margin, in screen points")
           LXLIM                                             (* ; "X value of right edge of LCHARLIM character on the line (may exceed right margin, if char is a space.). In natural stream units")
           LX1                                               (* ; 
                  "X value of the left edge of LCHAR1 from the left margin, in stream natural units.")
           LHEIGHT                                           (* ; 
                                                          "Total height of hte line, Ascent+Descent.")
           ASCENT                                            (* ; 
                                          "Ascent of the line above YBASE, adjusted for line leading")
           DESCENT                                           (* ; 
                                       "How far line descends below YBASE, adjusted for line leading")
           LTRUEDESCENT                                      (* ; 
                                       "The TRUE DESCENT for this line, unadjusted for line leading.")
           LTRUEASCENT                                       (* ; 
                               "The TRUE ASCENT for this line, unadjusted for pre-paragraph leading.")
           LCHAR1                                            (* ; 
                                                            "CH# of the first character on the line.")
           LCHARLIM                                          (* ; 
                                                             "CH# of the last character on the line")
           NIL                                               (* ; 
          "Was CHARTOP: CH# of the character which forced the line break (may be less than  CHARLIM)")
           NEXTLINE                                          (* ; "Next line chain pointer")
           (PREVLINE FULLXPOINTER)                           (* ; "Previous line chain pointer")
           LMARK                                             (* ; "One of SOLID, GREY, NIL.  Tells what kind of special-line marker should be put in the left margin for this paragraph.  (For hardcopy, can also be an indicator for special processing?)")
           LTEXTOBJ                                          (* ; "A cached TEXTOBJ that this line took its text from.  Used in hardcopy to disambiguate when chno's should be updated...")
           NIL                                               (* ; "Was CACHE: A cached THISLINE, for keeping hardcopy info around while we crunch with the line descriptors to make things fit.  Now:  THISLINE comes from TEXTOBJ")
           NIL                                               (* ; 
                      "Was LDOBJ: The object which lies behind this line of text, for updating, etc.")
           LFMTSPEC                                          (* ; 
                                             "The format spec for this line's paragraph (eventually)")
           (DIRTY FLAG)                                      (* ; 
                                            "T if this line has changed since it was last formatted.")
           (FORCED-END FLAG)                                 (* ; 
                                                             "T if this line ends with EOL or FORM.")
           (DELETED FLAG)                                    (* ; "T if this line has been completely deleted since it was last formatted or displayed.  (Used by deletion routines to detect garbage lines)")
           (LHASPROT FLAG)                                   (* ; 
                                                             "This line contains protected text.")
           (LDUMMY FLAG)                                     (* ; "This is a dummy line. Was: LHASTABS.  But never fetched and this descriptions wasn't true: If this line has a tab in it, this is the line-relative ch# of the final tab.  This is to let us punt properly with tabs in a line.")
           (1STLN FLAG)                                      (* ; 
                                                         "This line is the first line in a paragraph")
           (LSTLN FLAG)                                      (* ; 
                                                             "This is the last line in a paragraph")
           )
          (INIT (DEFPRINT 'LINEDESCRIPTOR (FUNCTION \TEDIT.LINEDESCRIPTOR.DEFPRINT)))
          [ACCESSFNS (YTOP (AND (FIXP (fetch (LINEDESCRIPTOR YBOT) of DATUM))
                                (IPLUS (fetch (LINEDESCRIPTOR YBOT) of DATUM)
                                       (fetch (LINEDESCRIPTOR LHEIGHT) of DATUM]
          LCHARLIM _ 1000000 NEXTLINE _ NIL PREVLINE _ NIL DIRTY _ NIL YBOT _ 0 YBASE _ 0 LEFTMARGIN
          _ 0 DELETED _ NIL)
)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(DEFPRINT 'LINEDESCRIPTOR (FUNCTION \TEDIT.LINEDESCRIPTOR.DEFPRINT))
(DECLARE%: EVAL@COMPILE 

[I.S.OPR 'inlines NIL '(bind $$PREVLINE declare (LOCALVARS $$PREVLINE)
                          first (SETQ I.V. (OR BODY (GO $$OUT)))
                          by (PROGN (SETQ $$PREVLINE I.V.)
                                    (OR (fetch (LINEDESCRIPTOR NEXTLINE) of I.V.)
                                        (GO $$OUT]

[I.S.OPR 'backlines NIL '(first (SETQ I.V. (OR BODY (GO $$OUT)))
                            by (OR (fetch (LINEDESCRIPTOR PREVLINE) of I.V.)
                                   (GO $$OUT]
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS GETLD MACRO ((L FIELD)
                       (fetch (LINEDESCRIPTOR FIELD) of L)))

(PUTPROPS FGETLD MACRO ((L FIELD)
                        (ffetch (LINEDESCRIPTOR FIELD) of L)))

(PUTPROPS SETLD MACRO ((L FIELD NEWVALUE)
                       (replace (LINEDESCRIPTOR FIELD) of L with NEWVALUE)))

(PUTPROPS FSETLD MACRO ((L FIELD NEWVALUE)
                        (freplace (LINEDESCRIPTOR FIELD) of L with NEWVALUE)))

(PUTPROPS SETYPOS MACRO [OPENLAMBDA (LINE BOTTOM)
                          (SETLD LINE YBASE (IPLUS (SETLD LINE YBOT BOTTOM)
                                                   (GETLD LINE DESCENT])

(PUTPROPS LINKLD MACRO (OPENLAMBDA (LINE1 LINE2)
                         (CL:WHEN LINE1 (SETLD LINE1 NEXTLINE LINE2))
                         (CL:WHEN LINE2 (SETLD LINE2 PREVLINE LINE1))))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS HCSCALE MACRO ((SCALE ITEM)
                         (FIXR (FTIMES SCALE ITEM))))

(PUTPROPS HCUNSCALE MACRO [OPENLAMBDA (SCALE ITEM)
                            (CL:IF (LISTP ITEM)
                                (for I in ITEM collect (FIXR (FQUOTIENT I SCALE)))
                                (FIXR (FQUOTIENT ITEM SCALE)))])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
)

(ADDTOVAR CHARACTERNAMES (EM-DASH "357,045")
                         (SOFT-HYPHEN "357,043")
                         (NONBREAKING-HYPHEN "357,042")
                         (NONBREAKING-SPACE "357,041"))



(* ; "Formatting slots held by THISLINE")

(DECLARE%: EVAL@COMPILE

(BLOCKRECORD CHARSLOT (CHAR CHARW                            (* ; 
             "If CHAR is NIL, then (SMALLP CHARW) is an invisible ron, otherwise CHARW is CHARLOOKS.")
                            ))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS CHAR MACRO ((CSLOT)
                      (ffetch (CHARSLOT CHAR) of CSLOT)))

(PUTPROPS CHARW MACRO ((CSLOT)
                       (ffetch (CHARSLOT CHARW) of CSLOT)))

(PUTPROPS PREVCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT (IMINUS WORDSPERCHARSLOT))))

(PUTPROPS PREVCHARSLOT! MACRO ((CSLOT)

                               (* ;; "Backs over looks and invisibles to the last character slot")

                               (find CS _ (PREVCHARSLOT CSLOT) by (PREVCHARSLOT CS) while CS
                                  suchthat (CHAR CS))))

(PUTPROPS NEXTCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT WORDSPERCHARSLOT)))

(PUTPROPS FIRSTCHARSLOT MACRO ((TLINE)
                               (fetch (THISLINE CHARSLOTS) of TLINE)))

(PUTPROPS NTHCHARSLOT MACRO ((TLINE N)
                             (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                    (ITIMES N WORDSPERCHARSLOT))))

(PUTPROPS LASTCHARSLOT MACRO ((TLINE)
                              (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                     (TIMES (SUB1 MAXCHARSLOTS)
                                            WORDSPERCHARSLOT))))

(PUTPROPS FILLCHARSLOT MACRO ((CSLOT C W)
                              (freplace (CHARSLOT CHAR) of CSLOT with C)
                              (freplace (CHARSLOT CHARW) of CSLOT with W)))

(PUTPROPS BACKCHARS MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                           (SETQ CSLOTVAR (PREVCHARSLOT CSLOTVAR))
                           (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                           (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))))

(PUTPROPS PUSHCHAR MACRO ((CSLOTVAR C W)
                          (FILLCHARSLOT CSLOTVAR C W)
                          (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS POPCHAR MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                         (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                         (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))
                         (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS CHARSLOTP MACRO [OPENLAMBDA (X TL)

                            (* ;; "True if TL is a THISLINE and X is a pointer into its CHARSLOTS block.  A tool for consistency assertions.")

                            (CL:WHEN (TYPE? THISLINE TL)
                                [LET ((FIRSTSLOT (FIRSTCHARSLOT TL))
                                      (LASTSLOT (LASTCHARSLOT TL)))
                                     (AND [OR (IGREATERP (\HILOC X)
                                                     (\HILOC FIRSTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC FIRSTSLOT))
                                                   (IGEQ (\LOLOC X)
                                                         (\LOLOC FIRSTSLOT]
                                          (OR (ILESSP (\HILOC X)
                                                     (\HILOC LASTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC LASTSLOT))
                                                   (ILEQ (\LOLOC X)
                                                         (\LOLOC LASTSLOT])])
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ CELLSPERCHARSLOT 2)

(RPAQ WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))

(RPAQQ MAXCHARSLOTS 256)


(CONSTANTS (CELLSPERCHARSLOT 2)
       (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
       (MAXCHARSLOTS 256))
)



(* ;; 
"incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards."
)

(DECLARE%: EVAL@COMPILE 

(I.S.OPR 'incharslots NIL '[SUBST (GETDUMMYVAR)
                                  '$$STARTSLOT
                                  '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                      declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                      first (SETQ I.V. (COND
                                                          ((TYPE? THISLINE $$STARTSLOT)
                                                           (FIRSTCHARSLOT $$STARTSLOT))
                                                          (T $$STARTSLOT)))
                                            (SETQ $$CHARSLOTLIMIT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                ) of THISLINE))
                                      by (NEXTCHARSLOT I.V.) until (EQ I.V. $$CHARSLOTLIMIT)
                                      eachtime (SETQ CHAR (fetch (CHARSLOT CHAR) of I.V.))
                                            (SETQ CHARW (fetch (CHARSLOT CHARW) of I.V.]
       T)

(I.S.OPR 'backcharslots NIL '[SUBST (GETDUMMYVAR)
                                    '$$STARTSLOT
                                    '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                        declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                        first (SETQ I.V. (COND
                                                            ((TYPE? THISLINE $$STARTSLOT)
                                                             (PREVCHARSLOT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                         )
                                                                              of THISLINE)))
                                                            (T $$STARTSLOT)))
                                              (SETQ $$CHARSLOTLIMIT (FIRSTCHARSLOT THISLINE))
                                        by (PREVCHARSLOT I.V.) eachtime (SETQ CHAR
                                                                         (fetch (CHARSLOT CHAR)
                                                                            of I.V.))
                                                                     (SETQ CHARW (fetch (CHARSLOT
                                                                                         CHARW)
                                                                                    of I.V.))
                                        repeatuntil (EQ I.V. $$CHARSLOTLIMIT]
       T)
)

(* "END EXPORTED DEFINITIONS")

)
(DEFINEQ

(\TEDIT.LINEDESCRIPTOR.DEFPRINT
  [LAMBDA (LINE STREAM)                                      (* ; "Edited  3-Jul-2023 22:02 by rmk")
                                                             (* ; "Edited 22-May-2023 14:42 by rmk")
                                                             (* ; "Edited 21-May-2023 09:15 by rmk")
    (LET ((TEXTOBJ (GETLD LINE LTEXTOBJ LINE))
          INFO LOC)
         (SETQ INFO (CONCAT (CL:IF (GETLD LINE 1STLN)
                                "*"
                                "")
                           (GETLD LINE LCHAR1)
                           "-"
                           (GETLD LINE LCHARLIM)
                           (CL:IF (GETLD LINE LSTLN)
                               "*"
                               "")
                           (CL:IF (GETLD LINE FORCED-END)
                               " FE"
                               "")))
         (SETQ LOC (LOC LINE))
         (CONS (CONCAT "{L" (CL:IF (GETLD LINE DIRTY)
                                "D"
                                "")
                      ":" INFO " " (CAR LOC)
                      "/"
                      (CDR LOC)
                      "}"])
)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(DEFPRINT 'LINEDESCRIPTOR (FUNCTION \TEDIT.LINEDESCRIPTOR.DEFPRINT))

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS SPACEBREAK MACRO (NIL 
                                (* ;; "TX is the beginning of the first space of a run. Needed for SPACELEFT in DOBREAK. FIRSTWHITEX is updated on the first space after one or more non-spaces. ")

                                (CL:WHEN INWORD
                                    (FORGETHYPHENBREAK)
                                    (SETQ FIRSTWHITEX TX)    (* ; "The beginning of the space")
                                    (SETQ FIRSTWHITESLOT CHARSLOT)
                                    (SETQ INWORD NIL)
                                    (SETQ INSPACES T))))

(PUTPROPS SAVEBREAK MACRO (NIL 
                               (* ;; "Values including the character just before a break")

                               (SETQ ASCENTB TRUEASCENT)
                               (SETQ DESCENTB TRUEDESCENT)
                               (SETQ CHNOB CHNO)
                               (SETQ CHARSLOTB CHARSLOT)
                               (SETQ TXB TX)))

(PUTPROPS DOBREAK MACRO [(SPACERUN)

                         (* ;; 
                     "SPACERUN if we are backing up to a space run with unexpandable overhang spaces")

                         (SETQ TRUEASCENT ASCENTB)
                         (SETQ TRUEDESCENT DESCENTB)
                         (SETQ TX TXB)
                         (SETQ CHNO CHNOB)
                         (SETQ CHARSLOT CHARSLOTB)
                         (COND
                            ((AND SPACERUN FIRSTWHITESLOT)   (* ; "Clear/register the overhangs")
                             (CL:WHEN PREVSP
                                 (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP (fetch (CHARSLOT
                                                                                       CHAR)
                                                                                  of FIRSTWHITESLOT))
                                  ))
                             (SETQ SPACELEFT (IDIFFERENCE WIDTH FIRSTWHITEX))
                             (SETQ OVERHANG (IDIFFERENCE TX FIRSTWHITEX)))
                            (T (SETQ SPACELEFT (IDIFFERENCE WIDTH TX))
                               (SETQ OVERHANG 0])

(PUTPROPS FORCEBREAK MACRO [NIL (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))
                                                             (* ; "All spaces are natural")

                                (* ;; "If the EOL comes right after a word-character that was preceded by a space run, those earlier spaces don't count in our overhang.  INSPACES tracks that. ")

                                (add TX DX)
                                (SETQ OVERHANG (CL:IF INSPACES
                                                   (IDIFFERENCE TX FIRSTWHITEX)
                                                   DX))
                                (SETQ SPACELEFT (IDIFFERENCE WIDTH (IDIFFERENCE TX OVERHANG])

(PUTPROPS FORGETHYPHENBREAK MACRO (NIL (CL:WHEN PREVDHYPH    (* ; 
                                                             "Previous soft hyphen becomes invisible")
                                           (add TX (IMINUS (CHARW PREVDHYPH)))
                                           (FILLCHARSLOT PREVDHYPH NIL 1))
                                       (SETQ PREVDHYPH (SETQ PREVHYPH NIL))))

(PUTPROPS FORGETPREVIOUSBREAK MACRO (NIL (CL:WHEN PREVDHYPH  (* ; 
                                                             "Previous soft hyphen becomes invisible")
                                             (add TX (IMINUS (CHARW PREVDHYPH)))
                                             (FILLCHARSLOT PREVDHYPH NIL 1))
                                         (SETQ PREVDHYPH (SETQ PREVHYPH NIL))
                                                             (* ; "Forget hyphens")
                                         (SETQ FIRSTWHITEX 0)
                                         (SETQ FIRSTWHITESLOT NIL)))
)

(DECLARE%: EVAL@COMPILE

(DATATYPE PENDINGTAB (
                      (* ;; "The data structure for a tab, within the line formatter, that we haven't finished dealing with yet, e.g. a centered tab where you need to wait for AFTER the centered text to do the formatting.")

                      PTRESOLVEDWIDTH

                      (* ;; "Width resolved for a prior tab.  This results from the resolution of an old RIGHT, CENTERED, or DECIMAL tab.")

                      PTOLDTAB                               (* ; "The pending tab")
                      PTTYPE                                 (* ; "Its tab type")
                      PTTABX                                 (* ; "Its nominal X position")
                      (PTCHARSLOT FULLXPOINTER)              (* ; "The CHARSLOT that may need to be updated later.  (RMK:  I don't know why this is a FULLXPOINTER--maybe an issue in the older THISLINE implementation?)")
                      PTOLDTX                                (* ; 
                                                         "The TX as of when the tab was encountered.")
                      ))
)

(/DECLAREDATATYPE 'PENDINGTAB '(POINTER POINTER POINTER POINTER FULLXPOINTER POINTER)
       '((PENDINGTAB 0 POINTER)
         (PENDINGTAB 2 POINTER)
         (PENDINGTAB 4 POINTER)
         (PENDINGTAB 6 POINTER)
         (PENDINGTAB 8 FULLXPOINTER)
         (PENDINGTAB 10 POINTER))
       '12)
)

(/DECLAREDATATYPE 'PENDINGTAB '(POINTER POINTER POINTER POINTER FULLXPOINTER POINTER)
       '((PENDINGTAB 0 POINTER)
         (PENDINGTAB 2 POINTER)
         (PENDINGTAB 4 POINTER)
         (PENDINGTAB 6 POINTER)
         (PENDINGTAB 8 FULLXPOINTER)
         (PENDINGTAB 10 POINTER))
       '12)
(DEFINEQ

(\FORMATLINE
  [LAMBDA (TEXTOBJ CH#1 LINE REGION IMAGESTREAM FORMATTINGSTATE)
                                                             (* ; "Edited 24-Jul-2023 23:13 by rmk")
                                                             (* ; "Edited  3-Jul-2023 13:33 by rmk")
                                                             (* ; "Edited 28-Jun-2023 22:49 by rmk")
                                                             (* ; "Edited 23-Jun-2023 08:51 by rmk")
                                                             (* ; "Edited 23-Oct-2022 09:11 by rmk")
    (DECLARE (SPECVARS IMAGESTREAM FORMATTINGSTATE))

    (* ;; 
 "Format the next line of text starting at CH#1.  Return the LINEDESCRIPTOR;  reusing LINE if given.")

    (* ;; "The SPECVARS are accessed and reset under the subfunctions, particularly \FORMATLINE.UPDATELOOKS.  IMAGESTREAM and FORMATTINGSTATE are passed only for hardcopy. ")

    (* ;; "")

    (* ;; "The objective of this body of code is to find")

    (* ;; "   LCHAR1:  The CHNO of the first visible character/object of this line.  LCHAR1=0 for empty/dummy line.")

    (* ;; "   LCHARLIM: The CHNO of the last character in the line-vector, including final EOL or last of run of spaces that overflows.")

    (* ;; "    LXLIM:   The X coordinate of the right edge of character/object LCHARLIM")

    (* ;; "   PREVSP:  The slot position in THISLINE of the right most scalable space.")

    (* ;; "   SPACELEFT:  How much unoccupied space is to be allocated according to justified, right, center alignments.")

    (* ;; "   OVERHANG:  How far beyond the right margin will trailing spaces/EOL occupy")

    (* ;; "  THISLINE:  The CHARSLOT vector that contains the actual characters and widths, together with their looks, as abstracted from the piece sequences of the underlying text.")

    (* ;; " ")

    (* ;; "At the end, \FORMATLINE.JUSTIFYmodifies LINE and THISLINE to deal with the vagaries of justification. The overhanging right-margin spaces don't get fattened even though justifying might fatten earlier spaces on the line.")

    (* ;; "")

    (* ;; "If a (visible) word crosses the margin |, then the line ends at the space just before the beginning of that word.  For x==yz==ab|cd, LCHARLIM goes to the space before a, LXLIM is its right edge. The justifier will leave the spaces between z and a alone, but might fatten the spaces between x and y based on the SPACELEFT between z and margin |.  The spaces after z OVERHANG. An EOL or FORM force a line-end and also overhang with along with any immediately preceding spaces--they are essentially treated as line-breaking spaces.")

    (* ;; "     abc123#45|6 => abc[123]#$|  (456 on next line--leading white space only after EOL)")

    (CL:UNLESS LINE

        (* ;; "Not needed until the end, but then we might not get the starting values for WRIGHT and WBOTTOM, if those change from piece to piece--check this.")

        [SETQ LINE (create LINEDESCRIPTOR
                          YBOT _ (SUB1 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ])
    (PROG ((TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
           (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (OFFSET 0)
           (TRUEASCENT -1)
           (TRUEDESCENT -1)
           (ASCENTB 0)
           (DESCENTB 0)
           (ASCENTC 0)
           (DESCENTC 0)
           (OVERHANG 0)
           (SPACELEFT 0)
           LINETYPE DISPLAYSTREAM WIDTH WMARGIN SCALE FMTSPEC RIGHTMARGIN TABSPEC KERN FIRSTWHITEX 
           FIRSTWHITESLOT PC CHARSLOT PREVSP 1STLN PROTECTED CHNOB FORCED-END CHNO LX1 TX TXB FONT 
           CHARSLOTB TABPENDING PREVHYPH PREVDHYPH START-OF-PIECE UNBREAKABLE)
          (DECLARE (SPECVARS LINETYPE CHARSLOT CHNO OFFSET ASCENTC DESCENTC FONT START-OF-PIECE KERN
                          UNBREAKABLE))

     (* ;; "CHNO = Current character # in the text")

     (* ;; "CHARSLOT = Pointer to the next available slot in THISLINE's CHARS.")

     (* ;; "DX = width of current char/object")

     (* ;; "TX = Right end of current text")

     (* ;; "PREVSP = CHARPOS of the last space of the most recent space-run")

     (* ;; 
     "ASCENT, DESCENT = The ascent and descent values of the line at the current character position")

     (* ;; "ASCENTC, DESCENTC = The ascent and descent from the last CLOOKS (including OFFSET)")

     (* ;; 
     "ASCENTB, DESCENTB, CHNOB, TXB, CHARSLOTB = The values at the most recent potential break-point")

     (* ;; "LX1 = theoffset from the true left margin of the first character, in native units, accounting for the first-line indentation.")

     (* ;; "")

          (replace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (LASTCHARSLOT THISLINE))

     (* ;; "Start with LASTCHARSLOT just so STL debugger will show everything before the true end has been determined.")

          (SETQ LINETYPE (if IMAGESTREAM
                             then 'TRUEHARDCOPY
                           else (SETQ DISPLAYSTREAM (WINDOWPROP (CAR (ffetch (TEXTOBJ \WINDOW)
                                                                        of TEXTOBJ))
                                                           'DSP))
                                (SETQ IMAGESTREAM DISPLAYSTREAM)
                                'TRUEDISPLAY))               (* ; 
                                                   "DISPLAYSTREAM needed for HARDCOPYDISPLAY objects")
          [if (REGIONP REGION)
              then (SETQ WMARGIN (ffetch (REGION LEFT) of REGION)) 
                                                             (* ; 
                                                     "Presumably hardcopy in different page regions.")
                   (SETQ WIDTH (ffetch (REGION WIDTH) of REGION))
            else (SETQ WMARGIN 8)                            (* ; 
                                                         "A little more display margin on both sides")
                 (SETQ WIDTH (IDIFFERENCE (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                    (UNFOLD WMARGIN 2]

     (* ;; "")

          (SETQ PC (\CHTOPC CH#1 TEXTOBJ T))
          (CL:WHEN (OR (NULL PC)
                       (EQ PC (fetch (TEXTOBJ LASTPIECE) of TEXTOBJ)))
              (RETURN (\FORMATLINE.EMPTY TEXTOBJ CH#1 LINE)))

     (* ;; "")

     (* ;; "We have a visible starting piece.  ")

          (CL:WHEN (AND (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC))
                        (SETQ PC (\NEXT.VISIBLE.PIECE PC)))
              (SETQ CH#1 (\PCTOCH PC))                       (* ; 
                                                     "Unusual, simpler than keeping track on the fly")
              (SETQ START-OF-PIECE CH#1))
          (SETQ CHNO CH#1)
          (SETQ IMAGESTREAM (\FORMATLINE.SETUP TEXTOBJ PC LINE IMAGESTREAM))
          (SETQ FMTSPEC (FGETLD LINE LFMTSPEC))

     (* ;; "Display stream could have switched for hardcopy font widths.")

          (CL:WHEN (AND (EQ LINETYPE 'TRUEDISPLAY)
                        (ffetch (FMTSPEC FMTHARDCOPY) of FMTSPEC))
              (SETQ LINETYPE 'HARDCOPYDISPLAY))
          (SETQ SCALE (ffetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC))

     (* ;; "This line starts a paragraph if it starts the document or it is at the beginning of a piece just after a last-paragraph piece. This assumes that only visible pieces matter; otherwise, use PREVPIECE.")

          [SETQ 1STLN (OR (IEQP CH#1 1)
                          (AND (IEQP CH#1 START-OF-PIECE)
                               (OR (NOT (\PREV.VISIBLE.PIECE PC))
                                   (PPARALAST (\PREV.VISIBLE.PIECE PC]

     (* ;; "Account for first-line indentation from the true left margin (LEFTMAR), in natural units")

          (SETQ LX1 (CL:IF 1STLN
                        (ffetch (FMTSPEC 1STLEFTMAR) of FMTSPEC)
                        (ffetch (FMTSPEC LEFTMAR) of FMTSPEC)))
          (SETQ RIGHTMARGIN (if (ZEROP (ffetch (FMTSPEC RIGHTMAR) of FMTSPEC))
                                then 
                                     (* ;; "RIGHTMAR = 0 => follow the window/region's width")

                                     WIDTH
                              else (ffetch (FMTSPEC RIGHTMAR) of FMTSPEC)))
          (SETQ WIDTH (IDIFFERENCE RIGHTMARGIN LX1))
          (SETQ TABSPEC (ffetch (FMTSPEC TABSPEC) of FMTSPEC))
          (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)            (* ; "Scale points to hardcopy")
              (SETQ LX1 (HCSCALE SCALE LX1))
              (SETQ WIDTH (HCSCALE SCALE WIDTH))
              (SETQ TABSPEC (\FORMATLINE.SCALETABS TABSPEC SCALE)))

     (* ;; "")

     (* ;; "The unchanging paragraph looks have now been established. Set up starting piece for BINNING characters")

     (* ;; "The LOOKSUPDATEFN will initialize the character looks of the starting piece PC. It is also called at piece boundaries to reset the character-looks variables when BIN (=\TEXTBIN) moves from piece to piece.")

          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with (FUNCTION \FORMATLINE.UPDATELOOKS))
          (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with NIL)
          (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
          (\INSTALL.PIECE TSTREAM PC (- CH#1 START-OF-PIECE))

     (* ;; "")

     (* ;; "Note:  the character looks of the first piece establish the initial FONT, ASCENTC, DESCENTC in anticipation of  the first as yet unseen character, and these are reset when the PLOOKS of each piece change.  These character ASCENTC and DESCENTC values apply only to actual characters, not to image objects, which have their own intrinsic values.  The character values and image values together determine the ASCENT and DESCENT for the line.  But importantly: the initial character-looks or the looks at each piece-transition don't affect the line values until at least one character with those looks has been seen. That's why the line values are computed for each BIN, using character or object values as appropriate..")

     (* ;; "")

     (* ;; "TEXTLEN anticipates the EOL error.  Wouldn't need it if we reset the ENDOFSTREAMOP.")

     (* ;; 
     " INWORD=T if we haven't just seen a space, INSPACES=T if we are in the middle of a space run.")

          (SETQ TX 0)
          (SETQ FIRSTWHITEX TX)
          (bind CH DX BOX INSPACES (INWORD _ T)
                (LASTCHARSLOT _ (LASTCHARSLOT THISLINE))
                (TEXTLEN _ (TEXTLEN TEXTOBJ)) for old CHNO by 1 while (ILEQ CHNO TEXTLEN)
             while (SETQ CH (BIN TSTREAM))
             do 
                (* ;; "Get CH's X width and maintain line ascent and descent.")

                [SETQ DX (COND
                            [(SMALLP CH)                     (* ; "CH is a character, ")
                             (SELCHARQ CH
                                  ((EOL LF CR FORM) 

                                                   (* ;; 
   " Force an end to the line. BIN shouldn't produce CR or LF. Should FORM do morein display mode?  ")

                                       

                                 (* ;; "If the EOL is the only character on the line, we want to use the current font's ascent/descent.  But if only preceded by objects, use the objects values.")

                                       [SETQ DX (IMAX 6 (\FGETCHARWIDTH FONT (CHARCODE EOL]
                                       (FILLCHARSLOT CHARSLOT (CL:IF (EQ CH (CHARCODE FORM))
                                                                  (CHARCODE FORM)
                                                                  (CHARCODE EOL))
                                              DX)
                                       (SETQ FORCED-END CH)  (* ; "Remember whether EOL or FORM")
                                       (FORCEBREAK)
                                       (RETURN))
                                  NIL)
                             (SETQ TRUEASCENT (IMAX TRUEASCENT (IDIFFERENCE ASCENTC OFFSET)))
                             (SETQ TRUEDESCENT (IMAX TRUEDESCENT (IDIFFERENCE DESCENTC OFFSET)))
                                                             (* ; "ASCENTC may have changed")
                             (COND
                                ((AND (IGEQ CH 192)
                                      (ILEQ CH 207))         (* ; 
                                                       "This is an NS accent character.  Space it 0.")
                                 0)
                                (T                           (* ; 
                                                             "Regular character.  Get it's width.")
                                   (\FGETCHARWIDTH FONT CH]
                            (T                               (* ; "CH is an object, get its size.")

                               (* ;; "If this isn't TRUEHARDCOPY, we want to do the imageobject in the displaystream with displaystream coordinates, because we don't know what internal size computations the imageobject might make based on its displaystream and fonts.  But we do have to scale is width to be compatible with other HARDCOPYDISPLAY measurements.")

                               (SETQ BOX (APPLY* (IMAGEOBJPROP CH 'IMAGEBOXFN)
                                                CH
                                                (CL:IF (EQ LINETYPE 'TRUEHARDCOPY)
                                                    IMAGESTREAM
                                                    DISPLAYSTREAM)
                                                TX WIDTH))
                               (SETQ TRUEASCENT (IMAX TRUEASCENT (IDIFFERENCE
                                                                  (IDIFFERENCE (fetch (IMAGEBOX
                                                                                       YSIZE)
                                                                                  of BOX)
                                                                         (fetch (IMAGEBOX YDESC)
                                                                            of BOX))
                                                                  OFFSET)))
                               (SETQ TRUEDESCENT (IMAX TRUEDESCENT (IDIFFERENCE (fetch (IMAGEBOX
                                                                                        YDESC)
                                                                                   of BOX)
                                                                          OFFSET)))
                               (IMAGEOBJPROP CH 'BOUNDBOX BOX)
                               (SETQ DX (IPLUS (fetch (IMAGEBOX XSIZE) of BOX)
                                               (fetch (IMAGEBOX XKERN) of BOX)))
                               (CL:IF (EQ LINETYPE 'HARDCOPYDISPLAY)
                                   (HCSCALE SCALE DX)
                                   DX)]
                (CL:WHEN KERN                                (* ; "Unlikely for display")
                    (add DX KERN))
                [SELCHARQ CH
                     (SPACE 
                            (* ;; "White space and EOL can overhang the right margin, but no visible character can. The only white-space leading a line must follow an [EOL]")

                            (* ;; 
            "    123abc456xy|z  =>  123abc|[456]$xyz  Line break in front of x, 456 overhangs margin")

                            (if UNBREAKABLE
                                then (add TX DX)
                              else (SPACEBREAK)
                                   (add TX DX)
                                   (SAVEBREAK))

                            (* ;; "CHAR will be the slot of the previous space, not this space character, CHARW is the natural width of this space. PREVSP is the new chain-header.")

                            (PUSHCHAR CHARSLOT (PROG1 PREVSP (SETQ PREVSP CHARSLOT))
                                   DX))
                     (TAB 
                          (* ;; "Try to be reasonable with tabs.  This will create trouble when doing fast-case insert/delete, but Pah! for now.")

                          (* ;; "Remove all prior candidate break points and expandable spaces")

                          (FORGETHYPHENBREAK)
                          (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))

                          (* ;; "Now for this tab:")
                                                             (* ; 
                                                       "Start with 0 width, then set up the next tab")
                          (FILLCHARSLOT CHARSLOT CH 0)
                          (SETQ TABPENDING (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE CHARSLOT LX1 TX 
                                                  TABPENDING))
                                                             (* ; 
                                                             "Proper width is already in CHARSLOT")
                          (SETQ DX (CL:IF (FIXP TABPENDING)
                                       (PROG1 TABPENDING (SETQ TABPENDING NIL))
                                       (fetch (PENDINGTAB PTRESOLVEDWIDTH) of TABPENDING)))
                          (add TX DX)
                          (CL:WHEN (IGREATERP TX WIDTH)      (* ; "Tab pushed beyond the margin")
                              (SETQ OVERHANG (IDIFFERENCE TX WIDTH))
                              (SETQ SPACELEFT 0)
                              (RETURN))
                          (SETQ CHARSLOT (NEXTCHARSLOT CHARSLOT)))
                     (PROGN 
                            (* ;; "Not an EOL, space, or tab character.    ")

                            (SETQ INWORD T)                  (* ; "Space run has ended")
                            (SETQ INSPACES NIL)
                            (add TX DX)
                            (CL:WHEN (IGREATERP TX WIDTH)    (* ; "Overflow")
                                (CL:WHEN FIRSTWHITESLOT      (* ; "Back to previous space run")
                                    (DOBREAK T)
                                    (RETURN))
                                (CL:WHEN (OR PREVHYPH PREVDHYPH TABPENDING)

                                    (* ;; 
           "A good break-point not followed by spaces. NOTE: Right-tab maybe should go on next line?")

                                    (DOBREAK)
                                    (RETURN))
                                (if (IGREATERP DX WIDTH)
                                    then 

                                 (* ;; "This character will never fit (e.g. a large image object). Move it to next line, by itself, if this line isn't empty.  Otherwise, dump it here by itself.")

                                         (if (IGREATERP CHNO CH#1)
                                             then 

                                 (* ;; "Move the offender to the next line, by itself.  For this line it essentially acts like an EOL wrt breaking and justifying, except that it doesn't get tacked on to the end.  There was no good earlier break, otherwise we would have done it.  ")

                                                  (add TX (IMINUS DX))
                                                  (add CHNO -1) 
                                                             (* ; "back up to preceding character")
                                                  (SETQ CHARSLOT (PREVCHARSLOT! CHARSLOT))
                                                  (SETQ CH (CHAR CHARSLOT))
                                                  (SETQ DX (CHARW CHARSLOT)) 

                                      (* ;; "ASCENT/DESCENT for the previous CLOOKS. BUT: if the previous character is an object, it has to back out its box parameters")

                                                  (SETQ TRUEASCENT ASCENTC)
                                                  (SETQ TRUEDESCENT DESCENTC)
                                           else 
                                                (* ;; "Dump it here")

                                                (FILLCHARSLOT CHARSLOT CH DX))
                                         (SETQ OVERHANG 0)
                                         (SETQ SPACELEFT 0)
                                  elseif (IGREATERP CHNO CH#1)
                                    then 

                                 (* ;; "We've seen at least one real character, line is not empty, but no good candidate break point. Back up to the last legal break (or add a real hyphenator). ")

                                         (CL:UNLESS (\FORMATLINE.LASTLEGAL)

                                             (* ;; 
                                             "Didn't find one, the offender protrudes on this line")

                                             (FILLCHARSLOT CHARSLOT CH DX))
                                  else 
                                       (* ;; 
                                       "Don't break: can't split before the first thing on the line!")

                                       (PUSHCHAR CHARSLOT CH DX))
                                (RETURN))

                            (* ;; "")

                            (* ;; 
                     "Not past the rightmargin yet. Save the character and width, then maybe adjust.")

                            (SELCHARQ CH
                                 (%.                         (* ; 
                                                      "Check for decimal tabs, immediately after TAB")
                                     (PUSHCHAR CHARSLOT CH DX)
                                     (CL:WHEN (AND TABPENDING (EQ (fetch PTTYPE of TABPENDING)
                                                                  'DECIMAL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                                         (add (fetch (PENDINGTAB PTTABX) of TABPENDING)
                                              DX)            (* ; 
               "Adjust the tab stop's X value so that the LEFT edge of the decimal point goes there.")
                                         (SETQ TABPENDING
                                          (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE CHARSLOT LX1 TX 
                                                 TABPENDING T))
                                                             (* ; 
                                                    "Tab over to the LEFT side of the decimal point.")
                                         (add TX (CL:IF (FIXP TABPENDING)
                                                     (PROG1 TABPENDING (SETQ TABPENDING NIL))
                                                     (fetch (PENDINGTAB PTRESOLVEDWIDTH) of 
                                                                                           TABPENDING
                                                            )))
                                         (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))
                                                             (* ; 
                                        "Spaces before a tab don't take part in later justification.")
                                         (SAVEBREAK)))
                                 ((- EM-DASH SOFT-HYPHEN)    (* ; 
                                                             "Hyphen, M-dash, discretionary hyphen")
                                      (FORGETPREVIOUSBREAK)
                                      (SETQ PREVHYPH CHARSLOT)
                                      (CL:WHEN (EQ CH (CHARCODE SOFT-HYPHEN))
                                          (SETQ PREVDHYPH CHARSLOT)
                                                             (* ; 
                                                          "Discretionary hyphen may become invisible")
                                          (SETQ CH (CHARCODE))
                                                             (* ; 
                                                             "Otherwise, it shows as a real hyphen")
                                          (SETQ DX (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                                      (SAVEBREAK)            (* ; 
                                                             "Save the hyphen slot, then fill it")
                                      (PUSHCHAR CHARSLOT CH DX))
                                 (NONBREAKING-HYPHEN 
                                                     (* ;; 
                            "Switch the character code and width in case font doesn't have a glyph??")

                                      (PUSHCHAR CHARSLOT (CHARCODE -)
                                             (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                                 (NONBREAKING-SPACE          (* ; 
                                                             "This will eventually convert to SPACE")
                                      (PUSHCHAR CHARSLOT (PROG1 PREVSP (SETQ PREVSP CHARSLOT))
                                             DX))
                                 (PUSHCHAR CHARSLOT CH DX] 

                (* ;; "BOUNDS CHECKING!")

                (CL:WHEN (EQ CHARSLOT LASTCHARSLOT)

                    (* ;; 
        "If too long, we let it roll over to the next line.  Should we put something in the margin??")

                    (TEDIT.PROMPTPRINT TEXTOBJ "Line too long to format." T)
                    (RETURN)) finally 

                                    (* ;; 
         "Ran out of TEXTLEN (and paragraph). Back up and force a break. Are ASCENT/DESCENT correct?")

                                    (SETQ CHARSLOT (PREVCHARSLOT! CHARSLOT))
                                    (add CHNO -1)
                                    (SETQ DX 0)              (* ; "TX is already correct")
                                    (FORCEBREAK))

     (* ;; "End of character loop.  ")

          (freplace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with NIL)

     (* ;; "Fix up last tab?")

          (CL:WHEN TABPENDING
              (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))(* ; "Ignore spaces before tabs")
              (add TX (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE (FETCH (PENDINGTAB PTCHARSLOT)
                                                                 OF TABPENDING)
                             LX1
                             (IDIFFERENCE TX OVERHANG)
                             TABPENDING T)))

     (* ;; "")

     (* ;; 
     "All the line information is now in our variables.  Migrate to the LINE and THISLINE fields. ")

          (FSETLD LINE LCHAR1 CH#1)
          (FSETLD LINE LCHARLIM CHNO)
          (FSETLD LINE LX1 LX1)                              (* ; 
                                                            "Still maybe scaled for hardcopy display")
          (FSETLD LINE LXLIM (IPLUS LX1 TX))
          (FSETLD LINE 1STLN 1STLN)                          (* ; "First line of a paragraph")
          [FSETLD LINE LSTLN (AND FORCED-END (PPARALAST (\CHTOPC CHNO TEXTOBJ]
                                                             (* ; "Last line of a paragraph")

     (* ;; "For display, the value of LMARK (GREY) just causes the little grey box to show up in the left margin, but is not interpreted in any other way. The hardcopy code uses this field for other purposes.")

          (FSETLD LINE LMARK (CL:WHEN [AND 1STLN (NEQ LINETYPE 'TRUEHARDCOPY)
                                           (OR (EQ (fetch FMTPARATYPE of FMTSPEC)
                                                   'PAGEHEADING)
                                               (fetch FMTNEWPAGEBEFORE of FMTSPEC)
                                               (fetch FMTNEWPAGEAFTER of FMTSPEC)
                                               [AND (fetch FMTSPECIALX of FMTSPEC)
                                                    (NOT (ZEROP (fetch FMTSPECIALX of FMTSPEC]
                                               (AND (fetch FMTSPECIALY of FMTSPEC)
                                                    (NOT (ZEROP (fetch FMTSPECIALY of FMTSPEC]
                                    'GREY))
          (FSETLD LINE FORCED-END FORCED-END)
          (FSETLD LINE LHASPROT PROTECTED)
          (FSETLD LINE LEFTMARGIN (fetch (FMTSPEC LEFTMAR) of FMTSPEC))
          (FSETLD LINE RIGHTMARGIN RIGHTMARGIN)
          (CL:UNLESS FONT

              (* ;; "Use TEXTOBJ defaults if empty charlooks. Maybe this never happens?")

              (SETQ FONT (FONTCOPY (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                            (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                                of TEXTOBJ)))
                                       DEFAULTFONT)
                                'DEVICE IMAGESTREAM)))
          (CL:WHEN (EQ -1 TRUEASCENT)
              (SETQ TRUEASCENT (FONTPROP FONT 'ASCENT))
              (SETQ TRUEDESCENT (FONTPROP FONT 'DESCENT)))
          (FSETLD LINE LTRUEASCENT TRUEASCENT)               (* ; 
                                               "|FORMATLINE.ALIGNED adjusts ASCENT, DESCENT, LHEIGHT")
          (FSETLD LINE LTRUEDESCENT TRUEDESCENT)

     (* ;; "")

          (FSETLD LINE LFMTSPEC FMTSPEC)
          (FSETLD LINE LTEXTOBJ TEXTOBJ)
          (freplace (THISLINE DESC) of THISLINE with LINE)
          (\FORMATLINE.ALIGN TEXTOBJ LINE FMTSPEC THISLINE PREVSP SPACELEFT OVERHANG LINETYPE)

     (* ;; "Finally translate to the left edge, perhsps a specialx if true hardcopy.")

          (CL:WHEN [AND (EQ LINETYPE 'TRUEHARDCOPY)
                        (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC)
                        (NOT (ZEROP (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC]

              (* ;; "Maybe SETQ instead of add ??")

              (add WMARGIN (ffetch (FMTSPEC FMTSPECIALX) of FMTSPEC)))
          (add (FGETLD LINE LEFTMARGIN)
               WMARGIN)
          (add (FGETLD LINE RIGHTMARGIN)
               WMARGIN)
          (add (FGETLD LINE LX1)
               WMARGIN)
          (add (FGETLD LINE LXLIM)
               WMARGIN)
          (RETURN LINE])

(\FORMATLINE.SETUP
  [LAMBDA (TEXTOBJ PC LINE IMAGESTREAM)                      (* ; "Edited 14-Jun-2023 16:43 by rmk")
                                                             (* ; "Edited  8-Mar-2023 22:15 by rmk")
                                                             (* ; "Edited  7-Mar-2023 16:52 by rmk")
                                                             (* ; "Edited  6-Mar-2023 00:25 by rmk")
                                                             (* ; "Edited  2-Mar-2023 12:06 by rmk")

    (* ;; "The paragraph looks of a line are the same for every piece of every line in a paragraph, only the character looks can change from piece to piece.  We retrieve the para looks from the starting piece, or the stream's default.   ")

    (* ;; "The global variable *TEDIT-CACHED-FMTSPEC* is a heuristic optimization")

    (* ;; "In hardcopy-display mode, the verticals (lineleading etc.) are in screen points, only the horizontals are upscaled according to the points-to-hardcopy scalefactor installed in the retrieved FMTSPEC.")

    (* ;; "See comments in TEDIT-LOOKSCOMS about the style-cache variables.  Probably not completely or correctly coordinated with this code.")

    (* ;; "The global variable *TEDIT-CACHED-FMTSPEC* offers a heuristic optimization to speed up construction of the FMTSPEC for successive lines in the same paragraph (or maybe even in a sequence of same-format paragraphs. ")

    (LET [(FMTSPEC (OR (AND PC (PPARALOOKS PC))
                       (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ]
         (SETQ FMTSPEC (\TEDIT.APPLY.PARASTYLES FMTSPEC PC TEXTOBJ))
         (if (NOT (DISPLAYSTREAMP IMAGESTREAM))
             then (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC FMTSPEC IMAGESTREAM))
           elseif (fetch (FMTSPEC FMTHARDCOPY) of FMTSPEC)
             then 
                  (* ;; "Coerce the image stream and FMTSPEC for chracter-width scaling. ")

                  [SETQ IMAGESTREAM (OR (fetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ)
                                        (replace (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ
                                           with (OPENIMAGESTREAM '{NODIRCORE} 'POSTSCRIPT]
                  (SETQ FMTSPEC (create FMTSPEC using FMTSPEC FMTHARDCOPYSCALE _ (DSPSCALE NIL 
                                                                                        IMAGESTREAM))
                   )
           elseif (NULL (fetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC))
             then                                            (* ; "Should be done at create")
                  (replace (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC with 1))
         (CL:UNLESS (OR (EQ FMTSPEC *TEDIT-CACHED-FMTSPEC*)
                        (NOT (fetch (FMTSPEC FMTCHARSTYLES) of FMTSPEC)))

             (* ;; "The cache of styles for the current paragraph is invalid; flush it, and note the new paragraph to cache for.")

             (SETQ *TEDIT-CURRENTPARA-CACHE* NIL)
             (SETQ *TEDIT-CACHED-FMTSPEC* FMTSPEC))
         (SETLD LINE LFMTSPEC FMTSPEC)
         IMAGESTREAM])

(\FORMATLINE.ALIGN
  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE PREVSP SPACELEFT OVERHANG LINETYPE)
                                                             (* ; "Edited  2-Jul-2023 15:15 by rmk")
                                                             (* ; "Edited  6-Apr-2023 10:13 by rmk")
                                                             (* ; "Edited  8-Mar-2023 12:45 by rmk")

    (* ;; "Do the formatting work for justified, centered, etc.  lines.  We calculate how much space between LX0 and right margin is not occupied by the natural widths of the characters cached in THISLINE.  For this calculation we back out spaces at the end of the line.  They are present for later display and selection, but are ignored for purposes of right, centered, and justified alignment.")

    (* ;; "")

    (* ;; "In HARDCOPYDISPLAY, LX1, LXLIM, SPACELEFT, and OVERHANG are all in scaled units, otherwise in natural stream units.  SPACELEFT+LXLIM-OVERHANG should be the right margin.")

    (* ;; "")

    (* ;; "The display-alignment is controlled by LX0 (offset from LEFTMARGIN) and LXLIM.  At entry, LXLIM is the natural width of the line-characters. LXLIM may embrace the extra spaces, but they are out in the right margin or beyond the window, invisible unless selected")

    (* ;; "SPACELEFT is what it takes to push the last visible character out to the right margin.  This is done by expanding spaces.  OVERHANG is what gets added to LXLIM because of white space after the last visible.  The OVERHANG white space is not expanded.")

    (* ;; "")

    (* ;; "Also for HARDCOPYDISPLAY the horizontal positions (margins and character widths) are in hardcopy units.  At the end we scale them back to screen points.  The vertical parameters (line-leading etc.) have not been up-scaled and don't need to be down-scaled. For other modes the vertical dimensions are already appropriately scaled.")

    (LET ((SCALE (ffetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC))
          (ASCENT (GETLD LINE LTRUEASCENT))
          (DESCENT (FGETLD LINE LTRUEDESCENT)))

         (* ;; 
  "Vertical stuff first.   TRUEASCENT reflects font, ASCENT is adjusted for paragraph/line leading. ")

         (add DESCENT (fetch (FMTSPEC LINELEAD) of FMTSPEC))
         (CL:WHEN (FGETLD LINE 1STLN LINE)                   (* ; "Set pre-paragraph leading")
             (add ASCENT (ffetch (FMTSPEC LEADBEFORE) of FMTSPEC)))
         (CL:WHEN (FGETLD LINE LSTLN)                        (* ; "Set post-paragraph leading")
             (add DESCENT (ffetch (FMTSPEC LEADAFTER) of FMTSPEC)))
         (FSETLD LINE ASCENT ASCENT)
         (FSETLD LINE DESCENT DESCENT)
         (FSETLD LINE LHEIGHT (IPLUS ASCENT DESCENT))

         (* ;; "")

         (* ;; "Horizontal alignment--distribute SPACELEFT according to QUAD.   ")

         (freplace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
         (CL:WHEN (EQ 'JUSTIFIED (fetch (FMTSPEC QUAD) of FMTSPEC))
                (\FORMATLINE.JUSTIFY LINE THISLINE PREVSP SPACELEFT LINETYPE))
         (\FORMATLINE.PURGE.SPACES PREVSP)

         (* ;; "")

         (* ;; "Done with spaces, expanded or not.  Down scale if hard-copy display mode")

         (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)
             (change (FGETLD LINE LX1)
                    (HCUNSCALE SCALE DATUM))
             (change (FGETLD LINE LXLIM)
                    (HCUNSCALE SCALE DATUM))
             (SETQ SPACELEFT (HCUNSCALE SCALE SPACELEFT))
             (SETQ OVERHANG (HCUNSCALE SCALE OVERHANG))

             (* ;; "Scale the character widths to points, propagating rounding error along the way. LOST starts at .5 pt so that rounding doesn't clip the last character")

             (for CHARSLOT REDUCED (LOST _ 0.5) incharslots THISLINE when CHAR
                do (SETQ REDUCED (FPLUS LOST (FQUOTIENT CHARW SCALE))) 
                                                             (* ; 
                                                         "Include the previously lost point-fraction")
                   [SETQ LOST (FDIFFERENCE REDUCED (SETQ REDUCED (FIX REDUCED]
                   (replace (CHARSLOT CHARW) of CHARSLOT with REDUCED)))

         (* ;; "")

         (SELECTQ (ffetch (FMTSPEC QUAD) of FMTSPEC)
             (RIGHT                                          (* ; "Move over to the right margin")
                    (add (FGETLD LINE LX1 LINE)
                         SPACELEFT)
                    (add (FGETLD LINE LXLIM)
                         SPACELEFT))
             (CENTERED                                       (* ; "Split the difference ")
                       (add (FGETLD LINE LX1)
                            (FOLDLO SPACELEFT 2))
                       (add (FGETLD LINE LXLIM)
                            (FOLDLO SPACELEFT 2)))
             NIL])

(\FORMATLINE.JUSTIFY
  [LAMBDA (LINE THISLINE PREVSP SPACELEFT LINETYPE)          (* ; "Edited  7-Mar-2023 18:01 by rmk")
                                                             (* ; "Edited  2-Mar-2023 22:45 by rmk")
                                                             (* ; "Edited 22-Oct-2022 00:06 by rmk")
                                                             (* ; "Edited 29-Mar-94 12:36 by jds")

    (* ;; "The spaces in this line are to be expanded to eat up SPACELEFT so that the last visible character will align at the right margin.  SPACELELEFT may be in hardcopy-display scaled units.")

    (CL:WHEN (AND PREVSP (IGREATERP SPACELEFT 0))
        (LET (NATURALWIDTHS COMMONWIDTH)
             [if (EQ LINETYPE 'TRUEHARDCOPY)
                 then 
                      (* ;; "Original code removed overhanging spaces, so that LXLIM and the last charslot of THISLINE are consistent, and SPACELEFT is backed off.  But now, SPACELEFT only measures out to the margin, so doesn't need to be further adjusted (OVERHANG deals with that).  So, if the hardcopy stream doesn't mind printing extra spaces, we don't have to pull things back.  Here we just have to measure the sum of the natural widths, to do the space factor.")

                      [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP) by (CHAR SPSLOT) while SPSLOT
                                             sum (PROG1 (CHARW SPSLOT)
                                                     (CL:UNLESS (CHAR SPSLOT)
                                                             (* ; "Some early spaces may not expand")
                                                         (replace (THISLINE TLFIRSTSPACE)
                                                            of THISLINE with SPSLOT)))]
               else 
                    (* ;; "Typically all the spaces on the line have the same natural width and we can avoid floating point below.")

                    (* ;; "NB we operate in 32 x value form, for rounding ease and accuracy on screen-point display streams.  .")

                    [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP)
                                             CHARW FIRSTWIDTH (NSPACES _ 0)
                                             (ALLSAME _ T) by (CHAR SPSLOT)
                                           first (SETQ FIRSTWIDTH (CHARW SPSLOT)) while SPSLOT
                                           sum (SETQ CHARW (CHARW SPSLOT))
                                               (add NSPACES 1)
                                               (CL:UNLESS (IEQP CHARW FIRSTWIDTH)
                                                      (SETQ ALLSAME NIL))
                                               CHARW
                                           finally (CL:WHEN ALLSAME
                                                       (SETQ COMMONWIDTH
                                                        (IPLUS (UNFOLD FIRSTWIDTH 32)
                                                               (IQUOTIENT (UNFOLD SPACELEFT 32)
                                                                      NSPACES))))]
                    (if COMMONWIDTH
                        then 
                             (* ;; "Fast loop for the more common case where all the spaces on a line are of the same width. Multiply by 32 to keep rounding precision. Avoids floating point allocation.")

                             (for (SPSLOT _ PREVSP)
                                  EXPANDED
                                  (LOST _ 0) by (CHAR SPSLOT) while SPSLOT
                                do (SETQ EXPANDED (IPLUS LOST COMMONWIDTH))
                                   (replace (CHARSLOT CHARW) of SPSLOT with (FOLDLO EXPANDED 32))
                                   (SETQ LOST (IMOD EXPANDED 32)))
                      else 
                           (* ;; "The slow loop is for spaces of difference sizes. It allocates 3 floating point numbers per space.  ")

                           (for (SPSLOT _ PREVSP)
                                EXPANDED NEWW (LOST _ 0.0)
                                (MULTIPLIER _ (FPLUS 1.0 (FQUOTIENT SPACELEFT NATURALWIDTHS)))
                              by (CHAR SPSLOT) while SPSLOT do 

                                 (* ;; "Spaces are in different fonts with different widths. What we lose in rounding at one space we add back in the next, until we finally get resynchronized.  The effect is that a later loss may ripple to a few earlier spaces.")

                                                               (SETQ EXPANDED
                                                                (FPLUS LOST (FTIMES (CHARW SPSLOT)
                                                                                   MULTIPLIER)))
                                                               (SETQ NEWW (FIXR EXPANDED))
                                                               (freplace (CHARSLOT CHARW)
                                                                  of SPSLOT with NEWW)
                                                               (SETQ LOST (FDIFFERENCE EXPANDED NEWW]

             (* ;; "The \DISPLAYLINE for displaystreams does its own (Maiko) BLTCHAR, so the TLSPACEFACTOR  isn't actually used for display, but hardcopy streams make use of it.")

             (add (ffetch (LINEDESCRIPTOR LXLIM) of LINE)
                  SPACELEFT)
             (freplace (THISLINE TLSPACEFACTOR) of THISLINE with (FQUOTIENT (IPLUS NATURALWIDTHS 
                                                                                   SPACELEFT)
                                                                        NATURALWIDTHS))))])

(\FORMATLINE.TABS
  [LAMBDA (TEXTOBJ TABSPEC SCALE CHARSLOT LX1 TX PRIORTAB CLEANINGUP)
                                                             (* ; "Edited  9-Mar-2023 23:25 by rmk")
                                                             (* ; "Edited  5-Mar-2023 22:54 by rmk")
                                                             (* ; "Edited  4-Mar-2023 18:28 by rmk")
                                                             (* ; "Do the formatting work for a tab.")

    (* ;; "PRIORTAB is the outstanding tab, if any, that has to be resolved.  This will be a centered or flush right tab.  ")

    (* ;; "Specific tabs are relative to the true leftmargin; in that coordinate system the current position is LX1+TX (in properly scaled units. The TX entries in the prior tab are also in the scaled margin coordinate system.  TABSPEC is also properly scaled.")

    (* ;; "")

    (* ;; "If CLEANINGUP is non-NIL, then we're at the end of the line, and only need to resolve the outstanding tab.")

    (* ;; "This assumes that every thing except the constants is already hardcopy-scaled")

    (* ;; "")

    (* ;; "The return provides the number of (scaled) width-units that must be added to the TX in \FORMATLINE..  This includes resolving (and updating THISLINE) for the prior tab's now-known width, and adding the width for this tab if it can be resolved.  If it can't be resolved, the returned PENDINGTAB includes the prior width, so that can be discharged into \FORMATLINE's TX.")

    (* ;; "")

    (* ;; "GRAIN is the granularity of the tab spacing; anything within GRAIN will slop over to the next tab.  This is to finesse rounding problems when going among various devices.")

    (* ;; "")

    (add TX LX1)                                             (* ; "Margin relative")
    (PROG (NEXTTAB NEXTTABTYPE NEXTTABX DFLTTABX GRAIN (PRIORTABWIDTH 0)
                 (THISTABWIDTH 0))
          (CL:WHEN PRIORTAB

              (* ;; "If there is a prior tab to resolve, do that first--it affects the perceived current X value, which affects later tabs")

              (* ;; "TX - OLDTX = W, the width of the segment after the prior tab. The target X (right tab)  is TABX - W ")

              [SETQ PRIORTABWIDTH (IMAX (ITIMES SCALE 3)
                                        (IDIFFERENCE
                                         (IDIFFERENCE (fetch (PENDINGTAB PTTABX) of PRIORTAB)
                                                (SELECTQ (fetch (PENDINGTAB PTTYPE) of PRIORTAB)
                                                    ((CENTERED DOTTEDCENTERED) 
                                                             (* ; "Centered around the tab X")
                                                         (FOLDLO (IDIFFERENCE TX (fetch (PENDINGTAB
                                                                                         PTOLDTX)
                                                                                    of PRIORTAB))
                                                                2))
                                                    ((RIGHT DOTTEDRIGHT DECIMAL DOTTEDDECIMAL) 
                                                             (* ; "Snug up against the tab X")
                                                         (IDIFFERENCE TX (fetch (PENDINGTAB PTOLDTX)
                                                                            of PRIORTAB)))
                                                    (SHOULDNT)))
                                         (fetch (PENDINGTAB PTOLDTX) of PRIORTAB]
              (replace (CHARSLOT CHARW) of (fetch (PENDINGTAB PTCHARSLOT) of PRIORTAB) with 
                                                                                        PRIORTABWIDTH
                     )
              (add TX PRIORTABWIDTH))                        (* ; "Done with the past")
          (CL:WHEN CLEANINGUP                                (* ; "Cleaning up at end of line.")
              (RETURN PRIORTABWIDTH))                        (* ; 
                                            "Default Tab width, if there aren't any real tabs to use")
          (SETQ NEXTTAB (find TAB in (CDR TABSPEC) suchthat (IGREATERP (fetch TABX of TAB)
                                                                   TX)))
                                                             (* ; "The next tab on this line, if any")
          (SETQ NEXTTABTYPE (OR (AND NEXTTAB (fetch TABKIND of NEXTTAB))
                                'LEFT))                      (* ; 
                                    "The type of the next tab  is LEFT if we use the default spacing")
          [SETQ NEXTTABX (COND
                            (NEXTTAB                         (* ; 
                                                    "There is a real tab to go to; use its location.")
                                   (fetch TABX of NEXTTAB))
                            (T (SETQ DFLTTABX (OR (FIXP (CAR TABSPEC))
                                                  DEFAULTTAB))
                               (SETQ GRAIN (FOLDLO SCALE 2))

                               (* ;; "No real tab; use the next multiple of the default spacing.")

                               (ITIMES DFLTTABX (ADD1 (IQUOTIENT (IPLUS GRAIN TX)
                                                             DFLTTABX]
                                                             (* ; "The next tab's X value")
          (CL:WHEN (FMEMB NEXTTABTYPE '(DOTTEDLEFT DOTTEDCENTERED DOTTEDRIGHT DOTTEDDECIMAL))

              (* ;; "Change a dotted-leader tab to Meta,TAB, so the line displayers can recognize that they need to do special output that can't be precomputed here.  By the same token, we could replace the resolved tab with a widened space, since we know that space-expansion is suppressed when a tab is seen. ")

              (replace (CHARSLOT CHAR) of CHARSLOT with (CHARCODE Meta,TAB)))
          (RETURN (if (FMEMB NEXTTABTYPE '(LEFT DOTTEDLEFT))
                      then 
                           (* ;; 
   "Prior and LEFT tabs are both resolved.  At least 1 point for display-selection?  1 isn't scaled?")

                           (SETQ THISTABWIDTH (IMAX 1 (IDIFFERENCE NEXTTABX TX)))
                           (replace (CHARSLOT CHARW) of CHARSLOT with THISTABWIDTH)
                           (IPLUS PRIORTABWIDTH THISTABWIDTH)
                    else (replace (CHARSLOT CHARW) of CHARSLOT with 0) 
                                                             (* ; "All others:  wait for this width")

                         (* ;; "PTOLDTX and PTTABX in absolute coordinates for future comparisons (on the same line with same LX1).")

                         (create PENDINGTAB
                                PTRESOLVEDWIDTH _ (IPLUS PRIORTABWIDTH THISTABWIDTH)
                                PTTYPE _ NEXTTABTYPE
                                PTTABX _ NEXTTABX
                                PTCHARSLOT _ CHARSLOT
                                PTOLDTX _ TX])

(\FORMATLINE.SCALETABS
  [LAMBDA (TABSPEC SCALE)                                    (* ; "Edited  7-Mar-2023 21:06 by rmk")
                                                             (* ; "Edited  5-Mar-2023 20:39 by rmk")

    (* ;; "Scales tab stops to hardcopy units (possibly hardcopy display)")

    (CL:WHEN (type? FMTSPEC TABSPEC)
        (SETQ TABSPEC (ffetch (FMTSPEC TABSPEC) of TABSPEC)))
    (CL:UNLESS (CAR TABSPEC)
        (SETQ TABSPEC (CONS DEFAULTTAB (CDR TABSPEC))))
    (if (EQ SCALE 1)
        then TABSPEC
      else (CONS (HCSCALE SCALE (CAR TABSPEC))
                 (for TAB in (CDR TABSPEC) collect (create TAB using TAB TABX _
                                                                     (HCSCALE SCALE
                                                                            (fetch (TAB TABX)
                                                                               of TAB])

(\FORMATLINE.PURGE.SPACES
  [LAMBDA (PREVSP UNTILSP)                                   (* ; "Edited 21-Mar-2023 11:28 by rmk")
                                                             (* ; "Edited 10-Mar-2023 12:28 by rmk")
                                                             (* jds " 9-NOV-83 17:12")

    (* ;; "Walks PREVSP back through the chain until it reaches UNTILSP, either NIL or a back up point.  Each of the slots it passes over is reverted to a space, return is the slot of early expandable spaces, if any.")

    (CL:WHEN PREVSP
        (bind OPREVSP until (EQ PREVSP UNTILSP) do (SETQ OPREVSP PREVSP)
                                                   (SETQ PREVSP (CHAR OPREVSP))
                                                   (CL:WHEN (SMALLP PREVSP)
                                                       (HELP 'PURGE))
                                                   (replace (CHARSLOT CHAR) of OPREVSP
                                                      with (CHARCODE SPACE))))
    PREVSP])

(\FORMATLINE.EMPTY
  [LAMBDA (TEXTOBJ CH#1 LINE)                                (* ; "Edited 15-Jul-2023 13:52 by rmk")
                                                             (* ; "Edited  2-Jul-2023 15:20 by rmk")
                                                             (* ; "Edited  7-Mar-2023 23:11 by rmk")
                                                             (* ; "Edited  5-Mar-2023 22:57 by rmk")
                                                             (* ; "Edited  4-Mar-2023 21:40 by rmk")

    (* ;; "CH#1 is presumably beyond the end.   This returns an empty line descriptor that is set up correctly wrt leading and font.  This is used by \FILLPANE to create the dummy line at end of document when you hit an EOL there.  (For safety, \FORMATLINE also calls this if CH#1 doesn't pick out a real piece.)")
                                                             (* ; ".")

    (* ;; "NOTE: this follows the original in not distinguishing hardcopy-display mode. Presumably empty is empty, even thought the ASCENT/DESCENT/LHEIGHT are not scaled.")

    (* ;; "Original code asked for the piece at TEXTLEN (last piece?) to get its looks, but those looks would be the TEXTOBJ default looks anyway. ")

    (CL:UNLESS LINE
        [SETQ LINE (create LINEDESCRIPTOR
                          RIGHTMARGIN _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                          YBOT _ (SUB1 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ])
    (LET (CHARSLOT FONT TRUEASCENT TRUEDESCENT LM FMTSPEC (THISLINE (fetch (TEXTOBJ THISLINE)
                                                                       of TEXTOBJ)))
         (\FORMATLINE.SETUP TEXTOBJ NIL LINE (WINDOWPROP (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                                                    'DSP))
         (SETQ FMTSPEC (GETLD LINE LFMTSPEC))
         (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
         (replace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
         (freplace (THISLINE DESC) of THISLINE with LINE)

         (* ;; "Get looks from the TSTREAM, so that \DISPLAYLINE works.  ")

         (FILLCHARSLOT CHARSLOT NIL (OR (fetch (TEXTSTREAM CURRENTLOOKS) of (fetch (TEXTOBJ 
                                                                                          STREAMHINT)
                                                                               of TEXTOBJ))
                                        (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                        (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)))

         (* ;; "Not sure what might break if even an emptyTHISLINE doesn't start with charlooks.  ")

         (* ;; 
        " Font preferences: the caret looks, else the default for this text, else the system default")

         (SETQ FONT (CL:IF (CHARW CHARSLOT)
                        (fetch CLFONT of (CHARW CHARSLOT))
                        DEFAULTFONT))
         (SETQ TRUEASCENT (FONTPROP FONT 'ASCENT))
         (SETQ TRUEDESCENT (FONTPROP FONT 'DESCENT))
         (SETQ LM (IPLUS 8 (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                         (fetch 1STLEFTMAR of FMTSPEC)))
         (with LINEDESCRIPTOR LINE (SETQ LDUMMY T)
               (SETQ LCHAR1 CH#1)
               (SETQ LCHARLIM CH#1)
               (SETQ 1STLN T)
               (SETQ LSTLN T)
               (SETQ LMARK NIL)
               (SETQ LX1 LM)
               (SETQ LXLIM LM)
               (SETQ FORCED-END CH#1)
               (SETQ DIRTY NIL)
               (SETQ LHASPROT NIL)
               (SETQ LFMTSPEC FMTSPEC)
               (SETQ LEFTMARGIN LM)
               (SETQ RIGHTMARGIN (CL:IF (ZEROP (fetch RIGHTMAR of FMTSPEC))
                                     (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                            8)
                                     (fetch RIGHTMAR of FMTSPEC)))
               (SETQ LTRUEASCENT TRUEASCENT)
               (SETQ LTRUEDESCENT TRUEDESCENT)
               (SETQ LHEIGHT (IPLUS TRUEASCENT TRUEDESCENT)))

         (* ;; "Just to initialize the rest of the fields--no intended transformations.")

         (\FORMATLINE.ALIGN TEXTOBJ LINE FMTSPEC THISLINE NIL 0 0)
         LINE])

(\FORMATLINE.UPDATELOOKS
  [LAMBDA (TSTREAM PC)                                       (* ; "Edited 22-Aug-2023 16:46 by rmk")
                                                             (* ; "Edited 24-Jul-2023 16:39 by rmk")
                                                             (* ; "Edited  7-Mar-2023 20:54 by rmk")
                                                             (* ; "Edited 30-May-91 21:47 by jds")

(* ;;; "Called from \INSTALL.PIECE under \FORMATLINE only when the new piece has different looks than the previous piece. This updates the formatting fields such as ASCENTC, DESCENTC, etc.  This assumes that the \INSTALL.PIECE caller has passed over any invisible pieces, and that TSTREAM is set up consistently with looks that match PC")

    (* ;; "RMK: Storing the  looks in theTEXTSTREAM here seems to be an attempt to avoid calls to the \TEDIT.APPLY.STYLES function in the transition from piece to piece.  Presumably, the looks of each piece may be incomplete, and missing fields are filled in from the current (sequence of?) styles.  If the style is changed dynamically, then (also presumably) all of the currently displayed pieces should be upgraded.  But that doesn't appear to happen.")

    (* ;; "A simpler implementation, whether dynamic or not, would be to expand the looks when the piece is created or the style changes, so that each piece is always references its completed looks.  But the piece also needs to keep track of its partial looks, for restyling and for saving.")

    (* ;; "Style sheets are undocumented, I suspect that this was never really thought through.")

    (DECLARE (USEDFREE LINETYPE CHARSLOT CHNO PROTECTED OFFSET ASCENTC DESCENTC FONT IMAGESTREAM KERN
                    UNBREAKABLE))
    (CL:UNLESS PC                                            (* ; 
                                                          "Ran off the end ? Skips the ENDOFSTREAMOP")
        (RETFROM (FUNCTION \TEXTBIN)
               NIL))
    (LET (PLOOKS INVISIBLERUN SCALE CLOFFSET)

         (* ;; "")

         (* ;; "We have to adjust the CHNO to pass over invisible pieces, and to record the number of characters we passed over in THISLINE's character vector.  This maintains the correspondence between the indexing of actual characters in the vector and characters positions in the stream.  This information isn't need for display, but TEDIT.SCAN.LINE requires that mapping.")

         (* ;; "Invisible runs are coded in a character slot, like other non-character entries (looks, objects) by putting a NIL in the CHAR field of a slot and putting the non-character information in the CHARWIDTH field.  Thus, an invisible run is represented as a pair (NIL,runlength).")

         (SETQ INVISIBLERUN (for old PC inpieces PC while (OR (ZEROP (PLEN PC))
                                                              (fetch (CHARLOOKS CLINVISIBLE)
                                                                 of (PLOOKS PC)))
                               sum (PLEN PC)))
         (if (EQ 0 INVISIBLERUN)
             then 
                  (* ;; "If the looks are the same as current looks, we don't need to change anything.  APPLY STYLES AT PIECE CREATION??")

                  (SETQ PLOOKS (PLOOKS PC))
                  (CL:UNLESS (EQ PLOOKS (ffetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))
                      (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with PLOOKS)

                      (* ;; "")

                      (SETQ OFFSET (OR (ffetch (CHARLOOKS CLOFFSET) of PLOOKS)
                                       0))
                      (SETQ FONT (fetch (CHARLOOKS CLFONT) of PLOOKS))
                                                             (* ; 
                                                             "CLFONT is a display font or a class")
                      [if (EQ LINETYPE 'TRUEHARDCOPY)
                          then (SETQ FONT (FONTCOPY FONT 'DEVICE IMAGESTREAM)) 
                                                             (* ; "Hardcopy widths and verticals")
                               (SETQ ASCENTC (ffetch \SFAscent of FONT))
                               (SETQ DESCENTC (ffetch \SFDescent of FONT))
                               (CL:UNLESS (EQ OFFSET 0)
                                   (SETQ OFFSET (HCSCALE (DSPSCALE NIL IMAGESTREAM)
                                                       OFFSET)))
                        else (CL:WHEN (type? FONTCLASS FONT) (* ; "Display widths and verticals")
                                 (SETQ FONT (FONTCOPY FONT 'DEVICE 'DISPLAY)))
                             (SETQ ASCENTC (ffetch \SFAscent of FONT))
                             (SETQ DESCENTC (ffetch \SFDescent of FONT))
                             (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)
                                                             (* ; "Switch widths to hardcopy")
                                 (SETQ FONT (FONTCOPY FONT 'DEVICE IMAGESTREAM)))]

                      (* ;; "")

                      (SETQ UNBREAKABLE (fetch (CHARLOOKS CLUNBREAKABLE) of PLOOKS))
                      (SETQ KERN (LISTGET (ffetch (CHARLOOKS CLUSERINFO) of PLOOKS)
                                        'KERN))

                      (* ;; "Apparently, KERN's are given in display points, which seems odd.  So here we scale up. Is there just a single kern value? Very strange.")

                      (CL:WHEN KERN
                          (SETQ KERN (HCSCALE (DSPSCALE NIL IMAGESTREAM)
                                            KERN)))
                      (STREAMPROP TSTREAM 'KERN KERN)
                      (CL:WHEN (ffetch (CHARLOOKS CLPROTECTED) of PLOOKS)
                                                             (* ; 
                                                         "Mark the line as containing protected text")
                          (SETQ PROTECTED T))
                      (PUSHCHAR CHARSLOT NIL PLOOKS))
                  (CL:UNLESS T

                      (* ;; "This (with higher spevars for FMTSPEC and TABSPEC) would allow tabspecs to change across a paragraph.  But then what should the paragraph-looks menu show?")

                      (EQ FMTSPEC (PPARALOOKS PC))
                      (SETQ FMTSPEC (PPARALOOKS PC))
                      (SETQ TABSPEC (ffetch (FMTSPEC TABSPEC) of FMTSPEC))
                      (CL:WHEN (EQ LINETYPE 'TRUEHARDCOPY)
                          (SETQ TABSPEC (\FORMATLINE.SCALETABS TABSPEC (DSPSCALE NIL IMAGESTREAM)))))
           else (PUSHCHAR CHARSLOT NIL INVISIBLERUN)
                (add CHNO INVISIBLERUN)
                (\INSTALL.PIECE PC 0))
         PC])

(\FORMATLINE.LASTLEGAL
  [LAMBDA NIL                                                (* ; "Edited  2-Jul-2023 14:39 by rmk")
                                                             (* ; "Edited 17-Mar-2023 05:36 by rmk")

    (* ;; 
 "An overflowing line without the kind of break point we are looking for (spaces, explicit hyphens).")

    (* ;; "Find the last legal break point, given the global TEDIT control variables TEDIT.DONT.BREAK.CHARS and TEDIT.DONT.LAST.CHARS.")

    (* ;; "If we run back to the beginning without finding a good break, we just take the original overflowed line. (Or, we could just chop at the end, and push the residue to the next line?")

    (* ;; "Once we find the break point, we have to sweep through from the beginning in order to accurately know the lines ascent and descent at the break point.")

    (DECLARE (USEDFREE THISLINE TX CHNO CHARSLOT TRUEASCENT TRUEDESCENT LINETYPE IMAGESTREAM 
                    TABPENDING))
    (LET [(BESTSLOT (find SLOT PCS backcharslots (PREVCHARSLOT! CHARSLOT)
                       suchthat (CL:WHEN (AND TABPENDING (EQ SLOT (fetch (PENDINGTAB PTCHARSLOT)
                                                                     of TABPENDING)))
                                       (SETQ TABPENDING NIL))
                             (OR (MEMB CHAR TEDIT.DONT.BREAK.CHARS)
                                 (AND (SETQ PCS (PREVCHARSLOT! SLOT))
                                      (MEMB (CHAR PCS)
                                            TEDIT.DONT.LAST.CHARS]

         (* ;; "BESTSLOT is our last legal  break. Replay to figure out TX, CHNO, ASCENT, DESCENT")

         (CL:WHEN BESTSLOT
             [SETQ TX (SETQ CHNO (SETQ TRUEASCENT (SETQ TRUEDESCENT 0]
             (for old CHARSLOT FONT OFFSET incharslots THISLINE
                do [if CHAR
                       then (add CHNO 1)
                            (add TX CHARW)
                     elseif (SMALLP CHARW)
                       then (add CHNO CHARW)
                     else                                    (* ; "Must be looks")
                          (SETQ OFFSET (OR (fetch (CHARLOOKS CLOFFSET) of CHARW)
                                           0))
                          (SETQ FONT (fetch (CHARLOOKS CLFONT) of CHARW))
                          [SETQ FONT (if (EQ LINETYPE 'TRUEHARDCOPY)
                                         then (SETQ OFFSET (HCSCALE (DSPSCALE NIL IMAGESTREAM)
                                                                  OFFSET))
                                              (FONTCOPY FONT 'DEVICE IMAGESTREAM)
                                       else (FONTCOPY FONT 'DEVICE 'DISPLAY]
                          (SETQ TRUEASCENT (IMAX TRUEASCENT (IDIFFERENCE (ffetch \SFAscent
                                                                            of FONT)
                                                                   OFFSET)))
                          (SETQ TRUEDESCENT (IMAX TRUEDESCENT (IDIFFERENCE (ffetch \SFDescent
                                                                              of FONT)
                                                                     OFFSET]
                repeatuntil (EQ CHARSLOT BESTSLOT))
             T)])

(\FORMATBLOCK
  [LAMBDA (TEXTOBJ CHN YBOTN)                                (* ; "Edited  5-Apr-2023 09:13 by rmk")
                                                             (* ; "Edited  1-Apr-2023 12:02 by rmk")
                                                             (* ; "Edited 30-May-91 23:02 by jds")

    (* ;; "Produces a chain of formatted lines where  LCHAR1 of the first one either starts a paragraph or comes immediately after a forced end. LN, the last line of the chain includes CHN.  The LCHAR's and X positions are good, and their Y positions are set relative to YBOTN, the intended YBOT of LN.  ")

    (* ;; "We assume this is not called on an empty text (TEXTLEN = 0), since we wouldn't know what to return. Caller should check that.")

    (CL:WHEN (IGREATERP CHN (TEXTLEN TEXTOBJ))
        (SETQ CHN (TEXTLEN TEXTOBJ)))
    (CL:UNLESS YBOTN (SETQ YBOTN 0))
    (bind L1 LN LINE HEIGHT (CHNO _ (\TEDIT.PREVIOUS.LINEBREAK TEXTOBJ CHN))
       first (SETQ L1 (\FORMATLINE TEXTOBJ CHNO))            (* ; 
                                                             "CHNO is the first char of the top line")
             (SETQ LN L1)
             (SETQ CHNO (ADD1 (GETLD L1 LCHARLIM))) until (IGREATERP CHNO CHN)
       do (SETQ LINE (\FORMATLINE TEXTOBJ CHNO))             (* ; 
                                                 "The line immediately after a preceding known break")
          (LINKLD LN LINE)
          (SETQ LN LINE)
          (SETQ CHNO (ADD1 (GETLD LINE LCHARLIM))) finally 

                                                         (* ;; 
                                            "Fill in the YBOT's, given that YBOTN is the YBOT of LN.")

                                                         (for L (YB _ YBOTN) backlines LN
                                                            do (SETYPOS L YB)
                                                               (add YB (GETLD L LHEIGHT)))
                                                         (RETURN (LIST L1 LN])
)
(DEFINEQ

(\CLEARTHISLINE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:09 by rmk")

    (* ;; "This sets it up for a consistency checker to determine that something has gone wrong.  Only called in an assertion.")

    (create THISLINE smashing THISLINE DESC _ 'NODESC TLSPACEFACTOR _ 'NOSPACEFACTOR TLFIRSTSPACE _
                           'NOTLFIRSTSPACE NEXTAVAILABLECHARSLOT _ (FIRSTCHARSLOT THISLINE))
    (for CHARSLOT _ (FIRSTCHARSLOT THISLINE)
         (LASTCHARSLOT _ (LASTCHARSLOT THISLINE)) until (EQ CHARSLOT LASTCHARSLOT)
       do (PUSHCHAR CHARSLOT 'BADCHAR 'BADCHARW))
    THISLINE])

(\TLVALIDATE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:16 by rmk")

    (* ;; "Check validity of THISLINE, either just before or anytime after \FORMATLINE.JUSTIFY")

    [with THISLINE THISLINE (CL:WHEN (EQ DESC 'NODESC)
                                   (HELP "INVALID THISLINE" DESC))
          (CL:WHEN (EQ TLSPACEFACTOR 'NOSPACEFACTOR)
                 (HELP "INVALID THISLINE" TLSPACEFACTOR))
          (CL:WHEN (EQ TLFIRSTSPACE 'NOTLFIRSTSPACE)
                 (HELP "INVALID THISLINE" TLFIRSTSPACE))
          (CL:UNLESS (CHARSLOTP NEXTAVAILABLECHARSLOT THISLINE)
              (HELP "INVALID THISLINE" 'NEXTAVAILABLE))]
    (for CHARSLOT incharslots THISLINE do (if CHAR
                                              then (CL:UNLESS (OR (SMALLP CHAR)
                                                                  (CHARSLOTP CHAR THISLINE))

                                                       (* ;; 
                                                      "CHARSLOTP if spaces haven't been instantiated")

                                                       (HELP "INVALID THISLINE" 'BADCHAR))
                                                   (CL:UNLESS (SMALLP CHARW)
                                                       (HELP "INVALID THISLINE" 'BADCHARW))
                                            elseif (OR (SMALLP CHARW)
                                                       (type? CHARLOOKS CHARW))
                                            else (HELP "INVALID THISLINE" 'BADCHARW])
)



(* ; "Consistency checking")


(RPAQ? *TEDIT-CACHED-FMTSPEC* NIL)



(* ; "Heuristic for \FORMATLINE")

(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS *TEDIT-CACHED-FMTSPEC*)
)
(DEFINEQ

(\DISPLAYLINE
  [LAMBDA (TEXTOBJ LINE PANE)                                (* ; "Edited  2-Aug-2023 12:50 by rmk")
                                                             (* ; "Edited 22-Jun-2023 17:37 by rmk")
                                                             (* ; "Edited 24-Apr-2023 00:08 by rmk")
                                                             (* ; "Edited 10-Apr-2023 12:41 by rmk")
                                                             (* ; "Edited 16-Mar-2023 23:30 by rmk")
                                                             (* ; "Edited  9-Mar-2023 14:06 by rmk")
                                                             (* ; "Edited  7-Mar-2023 23:11 by rmk")

    (* ;; "Display the line of text LINE in the edit window where it belongs.")

    (* ;; "Validate the incoming arguments so ffetch can be used consistently for all their field extractions.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (\DTEST LINE 'LINEDESCRIPTOR)
    (LET ((WINDOWDS (WINDOWPROP (OR PANE (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
                           'DSP))
          (THISLINE (\DTEST (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)
                           'THISLINE))
          (OLDCACHE (fetch (LINECACHE LCBITMAP) of (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)))
          (DS (ffetch (TEXTOBJ DISPLAYCACHEDS) of TEXTOBJ))
          CACHE XOFFSET CLIPLEFT CLIPRIGHT DISPLAYDATA DDPILOTBBT CURY LHEIGHT)
         [SETQ LHEIGHT (COND
                          ((FGETLD LINE PREVLINE)            (* ; 
                                    "So if theres a base-to-base measure, we clear everything right.")
                           (IMAX (IDIFFERENCE (FGETLD (FGETLD LINE PREVLINE)
                                                     YBOT)
                                        (FGETLD LINE YBOT))
                                 (FGETLD LINE LHEIGHT)))
                          (T (FGETLD LINE LHEIGHT]
         (SETQ CACHE (\TEDIT.LINECACHE (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)
                            (FGETLD LINE LXLIM)
                            LHEIGHT))
         (CL:UNLESS (EQ CACHE OLDCACHE)                      (* ; 
                 "We changed the bitmaps because this line was bigger--update the displaystream, too")
             (DSPDESTINATION CACHE DS)
             (DSPCLIPPINGREGION (create REGION
                                       LEFT _ 0
                                       BOTTOM _ 0
                                       WIDTH _ (fetch BITMAPWIDTH of CACHE)
                                       HEIGHT _ (fetch BITMAPHEIGHT of CACHE))
                    DS)
             (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE))
         (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE)
                                                             (* ; "Clear the line cache")
         (CL:WHEN [AND (NOT (ZEROP (FGETLD LINE LCHAR1)))
                       (ILEQ (FGETLD LINE LCHAR1)
                             (TEXTLEN TEXTOBJ))
                       (OR (IGEQ (FGETLD LINE YBOT)
                                 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                           (IGREATERP LHEIGHT (fetch HEIGHT of (DSPCLIPPINGREGION NIL PANE]

             (* ;; "Only display the line if it contains text (CHAR1 > 0), appears before the end of the text, and is on-screen. Also display clipped lines if they are bigger than the window")

             (CL:UNLESS (EQ (fetch (THISLINE DESC) of THISLINE)
                            LINE)                            (* ; 
                                                            "No image cache -- re-format and display")
                 (\FORMATLINE TEXTOBJ (FGETLD LINE LCHAR1)
                        LINE))
             (MOVETO (FGETLD LINE LX1)
                    (FGETLD LINE DESCENT)
                    DS)
             (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DS))
                                                             (* ; 
                                                    "IMAGEDATA of the display stream, not textstream")
             (SETQ DDPILOTBBT (fetch DDPILOTBBT of DISPLAYDATA))
             (SETQ XOFFSET (ffetch DDXOFFSET of DISPLAYDATA))

             (* ;; "The X position of the left edge of the window, since \TEDIT.BLTCHAR works on the screen bitmap itself.")

             (SETQ CLIPLEFT (ffetch DDClippingLeft of DISPLAYDATA))
                                                             (* ; 
                       "The left and right edges of the clipping region for the text display window.")
             (SETQ CLIPRIGHT (ffetch DDClippingRight of DISPLAYDATA))

             (* ;; "We know that the line's first CLOOKS comes before the first CHAR")

             (for CHARSLOT incharslots THISLINE bind CLOOKS LOOKSTARTX (TX _ (IPLUS XOFFSET
                                                                                    (FGETLD LINE LX1)
                                                                                    ))
                                                     (TERMSA _ (ffetch (TEXTOBJ TXTTERMSA)
                                                                  of TEXTOBJ))
                do 
                   (* ;; 
              "Display the line character by character.  CHAR and CHARW are bound to CHARSLOT values")

                   (CL:WHEN (FMEMB CHAR (CHARCODE (EOL FORM)))
                                                             (* ; 
                              "\FORMATLINE used space-width for EOL and FORM. Display them that way.")
                       (SETQ CHAR (CHARCODE SPACE)))
                   (SELCHARQ CHAR
                        ((TAB Meta,TAB) 
                             (CL:WHEN (OR (EQ CHAR (CHARCODE Meta,TAB))
                                          (fetch CLLEADER of CLOOKS)
                                          (EQ (ffetch CLUSERINFO of CLOOKS)
                                              'DOTTEDLEADER))

                                 (* ;; "Not just white space, have to fill in with dots.")

                                 (\DISPLAYLINE.TABS CHARW DS TX TERMSA LINE CLOOKS DISPLAYDATA 
                                        DDPILOTBBT CLIPRIGHT TEXTOBJ))
                             (add TX CHARW))
                        (NIL                                 (* ; 
    "LOOKS or SMALLP-invisibles. Line-start looks are guaranteed to come before any character/object")
                             [if (type? CHARLOOKS CHARW)
                                 then (CL:UNLESS LOOKSTARTX
                                          (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET)))
                                      (freplace DDXPOSITION of DISPLAYDATA with (IDIFFERENCE TX 
                                                                                       XOFFSET)) 
                                                             (* ; 
                                              "Make the displaystream reflect our current X position")
                                      (CL:WHEN CLOOKS        (* ; 
                                              "Underline/overline/strike the just-finished looks run")
                                          (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                 (FGETLD LINE DESCENT)))
                                      (SETQ CLOOKS CHARW)
                                      (DSPFONT (fetch CLFONT of CLOOKS)
                                             DS)
                                      (CL:UNLESS (EQ 0 (fetch CLOFFSET of CLOOKS))
                                                             (* ; "Account for super/subscripting")
                                          (RELMOVETO 0 (fetch CLOFFSET of CLOOKS)
                                                 DS))
                                      (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET)) 
                                                             (* ; 
                                        "LOOKSTARTX: Starting X position for the current-looks text.")
                               elseif (SMALLP CHARW)
                               else (SHOULDNT "UNRECOGNIZED CHARW") 

                                    (* ;; 
                           "Discretionary hyphens are invisible (CHARW=1), this should never happen.")

                                 (* ;; "Original comment: A character we've suppressed as part of line formatting (e.g., a discretionary hyphen we didn't use to break the line).  Show it as a thin black line.")

                                    (AND NIL (BLTSHADE BLACKSHADE DS TX 0 1 100 'PAINT])
                        (PROGN (if (IMAGEOBJP CHAR)
                                   then 
                                        (* ;; "Go to the base line, left edge of the image region.")

                                        (SETQ CURY (DSPYPOSITION NIL DS))
                                        (MOVETO (IDIFFERENCE TX XOFFSET)
                                               CURY DS)
                                        (APPLY* (IMAGEOBJPROP CHAR 'DISPLAYFN)
                                               CHAR DS 'DISPLAY (ffetch (TEXTOBJ STREAMHINT)
                                                                   of TEXTOBJ))
                                        (DSPFONT (fetch CLFONT of CLOOKS)
                                               DS)           (* ; 
                                         "Restore the character font, move to just after the object.")
                                        (MOVETO (IDIFFERENCE TX XOFFSET)
                                               CURY DS)
                                 elseif TERMSA
                                   then                      (* ; "Using special instrns from TERMSA")
                                        (\DSPPRINTCHAR DS CHAR)
                                 else                        (* ; "Native charcodes")
                                      (MI-TEDIT.BLTCHAR CHAR DS TX DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                               (add TX CHARW))) finally (replace DDXPOSITION of DISPLAYDATA
                                                           with (IDIFFERENCE TX XOFFSET)) 
                                                             (* ; 
                                        "Make any necessary looks mods to the last run of characters")
                                                      (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                             (FGETLD LINE DESCENT))))
         (BITBLT CACHE 0 0 WINDOWDS 0 (FGETLD LINE YBOT)
                (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                LHEIGHT
                'INPUT
                'REPLACE)                                    (* ; 
                          "Paint the cached image on the screen (this lessens flicker during update)")
         (CL:WHEN (fetch (FMTSPEC FMTREVISED) of (FGETLD LINE LFMTSPEC))
                                                             (* ; 
                                                       "This paragraph has been revised, so mark it.")
             (\TEDIT.MARK.REVISION TEXTOBJ (FGETLD LINE LFMTSPEC)
                    WINDOWDS LINE))
         (SELECTQ (FGETLD LINE LMARK)
             (GREY                                           (* ; 
                "This line has some property that isn't visible to the user.  Tell him to be careful")
                   (BITBLT NIL 0 0 WINDOWDS 0 (FGETLD LINE YBASE)
                          6 6 'TEXTURE 'PAINT 42405))
             (SOLID (BITBLT NIL 0 0 WINDOWDS 0 (FGETLD LINE YBASE)
                           6 6 'TEXTURE 'PAINT BLACKSHADE))
             (BITBLT NIL 0 0 WINDOWDS 0 (FGETLD LINE YBASE)
                    6 6 'TEXTURE 'REPLACE WHITESHADE))
         (FSETLD LINE DIRTY NIL)
         LINE])

(\DISPLAYLINE.TABS
  [LAMBDA (CW DS TX TERMSA LINE CLOOKS DISPLAYDATA DDPILOTBBT CLIPRIGHT TEXTOBJ)
                                                             (* ; "Edited  3-Jul-2023 22:02 by rmk")
                                                             (* ; "Edited  4-Mar-2023 22:17 by rmk")
                                                             (* ; "Edited  1-Oct-2022 11:35 by rmk")
                                                             (* ; "Edited 24-Sep-2022 21:19 by rmk")

    (* ;; "Fills in tab-space CW with dotted leaders.  LINE is only needed to get the FMTSPEC.  TEXTOBJ only needed to get hardcopy-display stream.  LTEXTOBJ seems to be set in hardcopy functions but not in basic setup.  Maybe because FMTSPEC's are cached?")

    (bind TTX DOTWIDTH (FMTSPEC _ (GETLD LINE LFMTSPEC))
       first 
             (* ;; "The dots on successive lines may not align so well, in hardcopy display mode.  But that's not a mode that looks good anyway.  The TERMSA probably screws it anyway.")

             [SETQ DOTWIDTH (CL:IF (fetch (FMTSPEC FMTHARDCOPY) of FMTSPEC)
                                [HCUNSCALE (fetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC)
                                       (CHARWIDTH (CHARCODE %.)
                                              (FONTCOPY (fetch CLFONT of CLOOKS)
                                                     'DEVICE
                                                     (ffetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ]
                                (CHARWIDTH (CHARCODE %.)
                                       (fetch CLFONT of CLOOKS)))]
             [SETQ TTX (IPLUS TX DOTWIDTH (IDIFFERENCE DOTWIDTH (IREMAINDER TX DOTWIDTH]
       while (ILEQ TTX (IPLUS TX CW)) do (if TERMSA
                                             then            (* ; "Using special instrns from TERMSA")
                                                  (\DSPPRINTCHAR DS (CHARCODE %.))
                                           else              (* ; "Native charcodes")
                                                (MI-TEDIT.BLTCHAR (CHARCODE %.)
                                                       DS
                                                       (IDIFFERENCE TTX DOTWIDTH)
                                                       DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                                         (add TTX DOTWIDTH])

(\TEDIT.LINECACHE
  [LAMBDA (CACHE WIDTH HEIGHT)                               (* jds "21-Apr-84 00:52")

         (* Given a candidate line cache, return the bitmap, making sure it's at least 
         WIDTH by HEIGHT big.)

    (PROG ((BITMAP (fetch LCBITMAP of CACHE))
           CW CH)
          (SETQ CW (fetch BITMAPWIDTH of BITMAP))
          (SETQ CH (fetch BITMAPHEIGHT of BITMAP))
          (COND
             ((AND (IGEQ CW WIDTH)
                   (IGEQ CH HEIGHT))
              (RETURN BITMAP))
             (T (RETURN (replace LCBITMAP of CACHE with (BITMAPCREATE (IMAX CW WIDTH)
                                                               (IMAX CH HEIGHT])

(\TEDIT.CREATE.LINECACHE
  [LAMBDA (%#CACHES)                                         (* jds "21-Apr-84 00:58")
                                                             (* Create a linked-together set of 
                                                             LINECACHEs, for saving line images.)
    (PROG [(CACHES (for I from 1 to %#CACHES collect (create LINECACHE
                                                            LCBITMAP _ (BITMAPCREATE 100 15]
          [for CACHE on CACHES do                            (* Link the caches together.)
                                  (replace LCNEXTCACHE of (CAR CACHE) with (OR (CADR CACHE)
                                                                               (CAR CACHES]
          (RETURN CACHES])

(\TEDIT.BLTCHAR
  [LAMBDA (CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                                             (* jds " 9-Jan-86 17:14")

         (* Version of BLTCHAR peculiar to TEdit --
         relies on \DISPLAYLINE to make sure things keep working right.)

         (* puts a character on a guaranteed display stream.
         Much of the information needed by the BitBlt microcode is prestored by the 
         routines that change it. This is kept in the BitBltTable.)
                                                             (* knows about the representation of 
                                                             display stream image data)
                                                             (* MUST NOT POINT AT A WINDOW'S 
                                                             DISPLAYSTREAM!!!)

         (* ASSUMES THAT WE NEVER WANT TO PRINT TO THE LEFT OF ORIGIN 0 ON THE LINE CACHE 
         BITMAP, OR THAT IF WE DO, ALL BETS ARE OFF)

    (DECLARE (LOCALVARS . T))
    (PROG (NEWX LEFT RIGHT IMAGEWIDTH (CHAR8CODE (\CHAR8CODE CHARCODE)))
          [COND
             ((NEQ (ffetch DDCHARSET of DISPLAYDATA)
                   (\CHARSET CHARCODE))
              (\CHANGECHARSET.DISPLAY DISPLAYDATA (\CHARSET CHARCODE]
          (SETQ IMAGEWIDTH (\GETBASE (fetch DDCHARIMAGEWIDTHS of DISPLAYDATA)
                                  (\CHAR8CODE CHARCODE)))
          (SETQ NEWX (IPLUS CURX IMAGEWIDTH))
          (SETQ LEFT (IMAX 0 CURX))
          (SETQ RIGHT (IMIN CLIPRIGHT NEWX))
          (COND
             ((ILESSP LEFT RIGHT)                            (* Only print anything if there is a 
                                                             place to put it)
              (UNINTERRUPTABLY
                  (freplace PBTDESTBIT of DDPILOTBBT with LEFT)
                                                             (* Set up the bitblt-table source left)
                  (freplace PBTWIDTH of DDPILOTBBT with (IMIN IMAGEWIDTH (IDIFFERENCE RIGHT LEFT)))
                  (freplace PBTSOURCEBIT of DDPILOTBBT with (\GETBASE (fetch DDOFFSETSCACHE
                                                                         of DISPLAYDATA)
                                                                   (\CHAR8CODE CHARCODE)))
                  (\PILOTBITBLT DDPILOTBBT 0))
              T])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS MI-TEDIT.BLTCHAR MACRO [(CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                  (COND
                                     ((EQ 'MAIKO (MACHINETYPE))
                                      (SUBRCALL TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA
                                             DDPILOTBBT CLIPRIGHT))
                                     (T (\TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA 
                                               DDPILOTBBT CLIPRIGHT])
)
)
(DEFINEQ

(TEDIT.UPDATE.SCREEN
  [LAMBDA (TEXTOBJ INCREMENTAL? NEXTCARETCH#)                (* ; "Edited 22-May-2023 22:19 by rmk")
                                                             (* ; "Edited 17-May-2023 08:58 by rmk")
                                                             (* ; "Edited  5-May-2023 13:16 by rmk")
                                                             (* ; "Edited  5-Oct-2022 21:30 by rmk")
    (CL:UNLESS (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)
        [LET ((DIRTYCHARS (\TEDIT.FIND.DIRTYCHARS TEXTOBJ)))
             (if DIRTYCHARS
                 then 
                      (* ;; "As long as we have this path, we don't want the line updater to update the selection. Updating the looks affects the line (so we need to know what characters changed), but the characters don't move around.  We want the rest of the insertion callers to avoid this entry.")

                      (\TEDIT.UPDATE.LINES TEXTOBJ 'APPEARANCE (CAR DIRTYCHARS)
                             (CDR DIRTYCHARS))
               else (for PANE inpanes TEXTOBJ do (\FILLPANE (fetch (TEXTWINDOW PLINES) of PANE)
                                                        TEXTOBJ PANE NEXTCARETCH#])])

(\BACKFORMAT
  [LAMBDA (TEXTOBJ DY CH1 HEIGHT)                            (* ; "Edited  6-Apr-2023 16:46 by rmk")
                                                             (* ; "Edited  5-Apr-2023 09:13 by rmk")
                                                             (* ; "Edited 30-May-91 15:58 by jds")

    (* ;; "This computes the shortest seqquence of globally correct lines above and including the line with CH1 whose total height is GEQ DY")

    (* ;; "Returns the head line of the chain whose YBOT is the actual height (possibly a little greater than DY). ")

    (* ;; "This computes block by block, where the first line of a block either starts a paragraph or comes immediately after a forced break.")

    (bind L1 PAIR (CHNO _ CH1) until (IGREATERP HEIGHT DY) while (IGEQ CHNO 1)
       do (SETQ PAIR (\FORMATBLOCK TEXTOBJ CHNO HEIGHT))     (* ; "The block may go beyond DY")
          (LINKLD (CADR PAIR)
                 L1)                                         (* ; 
                                                             "This block's LN links to previous L1")
          (SETQ L1 (CAR PAIR))
          (SETQ HEIGHT (GETLD L1 YTOP))
          (SETQ CHNO (SUB1 (GETLD L1 LCHAR1)))
       finally                                               (* ; "Perhaps the break was beyond DY")
             (RETURN (find L inlines L1 suchthat (ILEQ (GETLD L YBOT)
                                                       DY])

(\TEDIT.PREVIOUS.LINEBREAK
  [LAMBDA (TEXTOBJ CHNO)                                     (* ; "Edited 31-Mar-2023 17:44 by rmk")
                                                             (* ; "Edited 28-Mar-2023 09:03 by rmk")
                                                             (* ; "Edited 26-Mar-2023 12:55 by rmk")

    (* ;; "Returns the character number of the first character at or before CHNO that would follow a forced line-end or a paragraph end.  Line-formatting from that character onward would be consistent with any earlier line-breaks (and wouldn't change if earlier breaks changed).")

    (if (ILEQ CHNO 1)
        then 1
      elseif (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
        then 
             (* ;; "For a para-formatted object, back up to the prior para bound.")

             (CAR (\TEDIT.PARABOUNDS TEXTOBJ CHNO))
      else 
           (* ;; "Otherwise, move back thru the text until we find a for-sure line break. ")

           (CL:WHEN (IGREATERP CHNO (TEXTLEN TEXTOBJ))
               (SETQ CHNO (TEXTLEN TEXTOBJ)))
           (LET ((TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                 NCHARS)
                (\TEXTSETFILEPTR TSTREAM (SUB1 CHNO))        (* ; 
                                 "Start at (SUB1 CHNO) because fileptrs are one back from characters")
                [SETQ NCHARS (find I from 1 suchthat (MEMB (\BACKBIN TSTREAM)
                                                           (CHARCODE (EOL FORM %#EOL Meta,EOL NIL]

                (* ;; 
         "If we didn't find a preceding EOL, we must have backed to the beginning of the file (NIL).")

                (CL:IF NCHARS
                    (ADD1 (IDIFFERENCE CHNO NCHARS))
                    1)])

(\FILLPANE
  [LAMBDA (PREVLINE TEXTOBJ PANE NEXTCARETCH#)               (* ; "Edited  8-May-2023 21:59 by rmk")
                                                             (* ; "Edited  5-May-2023 10:54 by rmk")
                                                             (* ; "Edited 26-Apr-2023 21:02 by rmk")

    (* ;; "Fill out PANE, starting with the line after PREVLINE, whose ybottom is YBOT")

    (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
    (LET ((TEXTLEN (TEXTLEN TEXTOBJ))
          (PREG (DSPCLIPPINGREGION NIL PANE))
          LINE PBOTTOM)

         (* ;; "")

         (* ;; "Find the first on-screen line after PREVLINE, if any.  If none, start with PREVLINE, maybe the dummy.")

         (SETQ PBOTTOM (fetch BOTTOM of PREG))
         (SETQ LINE (find L (PHEIGHT _ (fetch HEIGHT of PREG)) inlines (GETLD PREVLINE NEXTLINE)
                       suchthat (ILESSP (GETLD L YBOT)
                                       PHEIGHT)))

         (* ;; "")

         (CL:WHEN LINE
             (SETQ PREVLINE (GETLD LINE PREVLINE)))

         (* ;; "Display all the existing lines that fit in the pane.")

         (for L (YBOT _ (GETLD PREVLINE YBOT)) inlines LINE eachtime (SETLD L DIRTY NIL)
                                                                  (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM
                                                                              L YBOT))
            while (IGREATERP YBOT PBOTTOM) do 
                                              (* ;; 
                                       "This line fits in the window, adjust its YBOT and display it")

                                              (SETYPOS L YBOT)
                                              (\DISPLAYLINE TEXTOBJ L PANE)
                                              (SETQ PREVLINE L))

         (* ;; "")

         (* ;; "Chop off any lines below the pane. A no-op if we ran out before the bottom--new lines created below.")

         (LINKLD PREVLINE NIL)

         (* ;; "")

         (* ;; 
         "If we haven't yet run out of pane (or text), format new lines, link and display them.   ")

         (for L NEXT LCHARLIM (YBOT _ (GETLD PREVLINE YBOT)) inlines PREVLINE
            eachtime (SETQ LCHARLIM (GETLD L LCHARLIM)) while (ILESSP LCHARLIM TEXTLEN)
            do (SETQ NEXT (\FORMATLINE TEXTOBJ (ADD1 LCHARLIM)))
               (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM NEXT YBOT))
               (SETYPOS NEXT YBOT)
               (CL:UNLESS (IGREATERP YBOT PBOTTOM)
                      (RETURN))
               (LINKLD L NEXT)
               (\DISPLAYLINE TEXTOBJ NEXT PANE)
               (SETQ PREVLINE NEXT))

         (* ;; "")

         (* ;; 
         "If asked, make sure we have formatted lines to cover the caret, even if not displayed. ")

         (CL:WHEN NEXTCARETCH#
             (SETQ NEXTCARETCH# (IMIN NEXTCARETCH# TEXTLEN))
             (for L NEXT LCHARLIM inlines PREVLINE until (ILEQ (SETQ LCHARLIM (GETLD L LCHARLIM))
                                                               NEXTCARETCH#)
                do (SETQ NEXT (\FORMATLINE TEXTOBJ (ADD1 LCHARLIM)))
                   (LINKLD L NEXT)
                   (SETYPOS NEXT (\TEDIT.NEXT.LINE.BOTTOM NEXT))
                   (SETQ PREVLINE L)))
         (CL:WHEN (\TEDIT.INSURE.TRAILING.LINE TEXTOBJ PREVLINE)
             (\DISPLAYLINE TEXTOBJ (GETLD PREVLINE NEXTLINE)
                    PANE))

         (* ;; "")

         (\CLEARPANE.BELOW.LINE PREVLINE PANE TEXTOBJ])

(\TEDIT.UPDATE.LINES
  [LAMBDA (TEXTOBJ REASON FIRSTCHANGEDCHNO NCHARSCHANGED DONTDISPLAY)
                                                             (* ; "Edited 22-Jun-2023 15:50 by rmk")
                                                             (* ; "Edited 11-Jun-2023 18:34 by rmk")
                                                             (* ; "Edited  4-May-2023 10:29 by rmk")

    (* ;; "This updates the lines in each pane given that NCHARSCHANGED characters with respect to FIRSTCHANGEDCHNO have been modified.  It tries to reuse formatting information and screen bitmap images that are valid after the change.")

    (* ;; "See line-segmentation comments in \TEDIT.VALID.LINES.")

    (CL:UNLESS (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)
        (CL:WHEN (type? SELECTION FIRSTCHANGEDCHNO)
            (SETQ NCHARSCHANGED (GETSEL FIRSTCHANGEDCHNO DCH))
            (SETQ FIRSTCHANGEDCHNO (GETSEL FIRSTCHANGEDCHNO CH#)))

        (* ;; 
      "If DONTDISPLAY, we ensure lines that are properly formatted and positioned but not displayed.")

        (for PANE VALIDS LASTVALID NEXTVALID MOVED inpanes TEXTOBJ as VALIDS
           in (\TEDIT.VALID.LINES TEXTOBJ FIRSTCHANGEDCHNO NCHARSCHANGED REASON) when VALIDS
           do 
              (* ;; "Create/format/display new lines between LASTVALID and NEXTVALID  ")

              (SETQ LASTVALID (\FORMAT.GAP.LINES VALIDS PANE TEXTOBJ DONTDISPLAY)) 

              (* ;; "The gap is filled in with formatted and displayed lines, the last of which links to NEXTVALID.  NEXTVALID and later lines have good character positions and good bitmaps, but their YPOS are not correct and their bitmaps are not in the right place.")

              (* ;; "")

              (* ;; "In the deletion case, NEXTVALID's current YPOS  will be at or below its target value as determined by the gap-filler, but the gap-filling hasn't disturbed the image.  The bitmap can be raised and the pane filled in below.")

              (* ;; "")

              (* ;; "In the insertion case, the YPOS maybe above the target, but we don't know what it should be until we fill in and display the gap lines.  The gap line-display may have smashed some of the display bits that we otherwise would be available to move down..")

              (* ;; "")

              (SETQ NEXTVALID (GETLD LASTVALID NEXTLINE))
              (if DONTDISPLAY
                  then (if NEXTVALID
                           then (for L (YBOT _ (GETLD LASTVALID YBOT)) inlines NEXTVALID
                                   do (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM L YBOT))
                                      (SETYPOS L YBOT))
                         else (\TEDIT.INSURE.TRAILING.LINE TEXTOBJ LASTVALID))
                elseif NEXTVALID
                  then (SETQ MOVED (IDIFFERENCE (GETLD NEXTVALID YTOP)
                                          (GETLD LASTVALID YBOT)))
                       (if (ILESSP MOVED 0)
                           then 
                                (* ;; "Deletion case")

                                (\TEDIT.RAISE.LINES NEXTVALID (GETLD LASTVALID YBOT)
                                       PANE TEXTOBJ)
                         elseif (IGREATERP MOVED 0)
                           then 
                                (* ;; "Insertion case: bitmaps of NEXTVALID can be shifted down")

                                (\TEDIT.LOWER.LINES NEXTVALID LASTVALID PANE TEXTOBJ))
                else (\CLEARPANE.BELOW.LINE LASTVALID PANE TEXTOBJ)
                     (\TEDIT.INSURE.TRAILING.LINE TEXTOBJ LASTVALID))))])

(\TEDIT.FIND.DIRTYCHARS
  [LAMBDA (TEXTOBJ)                                          (* ; "Edited  8-May-2023 13:18 by rmk")
                                                             (* ; "Edited 28-Apr-2023 15:30 by rmk")

    (* ;; "Returns a pair (firstdirty . ndirties)  figuring the first and maxium range of dirty characters. For programs that mark DIRTY when they modify lines.  The dirty LCHAR*'s are the same in all panes where they exist.")

    (for PLINES FIRSTDIRTY (LASTDIRTYCHAR _ 0) inpanelines TEXTOBJ
       when (SETQ FIRSTDIRTY (find L inlines (GETLD PLINES NEXTLINE) suchthat (GETLD L DIRTY)))
       do 
          (* ;; "Some panes may have more lines than others--we want to get the largest dirty range.")

          [SETQ LASTDIRTYCHAR (IMAX LASTDIRTYCHAR (for L (PREV _ FIRSTDIRTY) inlines FIRSTDIRTY
                                                     while (GETLD L DIRTY) do (SETQ PREV L)
                                                     finally (RETURN (GETLD PREV LCHARLIM]
       finally (RETURN (CL:WHEN FIRSTDIRTY
                           (CONS (GETLD FIRSTDIRTY LCHAR1)
                                 (IDIFFERENCE (ADD1 LASTDIRTYCHAR)
                                        (GETLD FIRSTDIRTY LCHAR1))))])

(\FORMAT.GAP.LINES
  [LAMBDA (VALIDS PANE TEXTOBJ DONTDISPLAY)                  (* ; "Edited 15-May-2023 17:31 by rmk")
                                                             (* ; "Edited 28-Apr-2023 17:35 by rmk")
                                                             (* ; "Edited 26-Apr-2023 18:39 by rmk")

    (* ;; "VALIDS is a pair (LASTVALID . NEXTVALID) as described in \TEDIT.VALID.LINES. Our job is to format and display the lines between LASTVALID and NEXTVALID, laying them out in the region starting below the given LASTVALID.")

    (* ;; "The screen has valid images for  lines from the top down to LASTVALID (segment 1 as described in \TEDIT.VALID.LINES). We don't touch those lines or their bitmaps.")

    (* ;; "We also don't smash the bitmaps for NEXTVALID lines whose initial YTOP is below the YBOT of the last formatted valid line.  This is guaranteed for deletions, maybe not for insertions where the gap displaying can encroach on the valid bitmaps.  The caller has to sort the bitmap overlaps.")

    (* ;; "Returns the new LASTVALID whose NEXTLINE is the given NEXTVALID.")

    (CL:UNLESS PANE (SETQ DONTDISPLAY T))
    (for L LASTINVALIDCHNO PREG PBOTTOM PHEIGHT LCHARLIM YBOT (LASTVALID _ (CAR VALIDS))
         (NEXTVALID _ (CDR VALIDS)) inlines LASTVALID first (CL:UNLESS DONTDISPLAY
                                                                (SETQ PREG (DSPCLIPPINGREGION NIL 
                                                                                  PANE))
                                                                (SETQ PBOTTOM (fetch BOTTOM
                                                                                 of PREG))
                                                                (SETQ PHEIGHT (fetch HEIGHT
                                                                                 of PREG)))
                                                            (SETQ YBOT (GETLD LASTVALID YBOT))
                                                            (SETQ LCHARLIM (GETLD LASTVALID LCHARLIM)
                                                             ) 
                                                             (* ; 
                                                      "LCHARLIM=0 if change in document's first line")
                                                            (SETQ LASTINVALIDCHNO
                                                             (CL:IF NEXTVALID
                                                                 (SUB1 (GETLD NEXTVALID LCHAR1))
                                                                 (TEXTLEN TEXTOBJ)))
       eachtime (SETQ LCHARLIM (GETLD L LCHARLIM)) until (OR (AND PBOTTOM (ILEQ YBOT PBOTTOM))
                                                             (IEQP LCHARLIM LASTINVALIDCHNO))
       do (if (AND PBOTTOM (ILEQ YBOT PBOTTOM))
              then (LINKLD LASTVALID NIL)                    (* ; 
                                            "Insertion ran off the bottom, flush now-invisible lines")
                   (RETURN LASTVALID)
            elseif (IEQP LCHARLIM LASTINVALIDCHNO)
              then 
                   (* ;; "We reached the end of the gap. But we may have smashed the bitmaps of the initial NEXTVALID lines, so we have to format/display a little bit more until we clear the overlap.  If we are displaying, we first move the non-overlapping bitmap downwards on the screen, out of danger, then reformat and provide fresh images for the overlapping lines.")

                   (CL:WHEN (IGREATERP (GETLD NEXTVALID YTOP)
                                   (GETLD LASTVALID YBOT))
                          (BITBLT)))
          (SETQ LASTVALID (\FORMATLINE TEXTOBJ (ADD1 LCHARLIM)))
          (LINKLD L LASTVALID)
          (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM LASTVALID))
          (SETYPOS LASTVALID YBOT)
          (SETQ LCHARLIM (GETLD LASTVALID LCHARLIM))
          (CL:UNLESS DONTDISPLAY

              (* ;; "The THISLINE cache for  NEXT is good if we display immediately after formatting")

              (\DISPLAYLINE TEXTOBJ LASTVALID PANE)) finally (LINKLD LASTVALID NEXTVALID)
                                                           (RETURN LASTVALID])

(\TEDIT.LOWER.LINES
  [LAMBDA (NEXTVALID LASTVALID PANE TEXTOBJ)                 (* ; "Edited 11-Jun-2023 19:17 by rmk")
                                                             (* ; "Edited  6-Jun-2023 15:19 by rmk")
                                                             (* ; "Edited 15-May-2023 22:43 by rmk")
                                                             (* ; "Edited 11-May-2023 11:34 by rmk")
                                                             (* ; "Edited 28-Apr-2023 08:51 by rmk")

    (* ;; "NEXTVALID is the top line of a region in PANE that extends to the pane-bottom or text end--that is, the pane bitmap in that region correctly reflects the lines (and possibly empty space at text-end).")

    (* ;; "Insertion case.  The inserted gap lines may cover some of the bitmap of the nextvalid lines.  In that case NEXTVALID:YBOT is greater than the new LASTVALID:YBOT")

    (if (NOT (\TEDIT.PANEWITHINSCREEN? PANE))
        then 
             (* ;; "If PANE has been moved so that it is not entirely within the screen, then don't try to find the relevant bits, just repaint the whole window.")

             (\TEDIT.REPAINTFN PANE)
      else 
           (* ;; "Completely on screen, we can take advantage of screen bitmap.")

           (PROG ((NEWTOP (GETLD LASTVALID YBOT))
                  (PREG (DSPCLIPPINGREGION NIL PANE))
                  (LTOP (GETLD NEXTVALID YTOP))
                  (LVBOT 0)
                  LOWER PWIDTH LASTVISIBLE)
                 (SETQ LOWER (IDIFFERENCE LTOP NEWTOP))      (* ; "How far down to go")
                 (CL:UNLESS (IGREATERP LOWER 0)              (* ; "Maybe it's not moving")
                     (RETURN))

            (* ;; "Make the YPOS of the lowered lines consistent with the intended positions of their images.  LASTVISIBLE is the last line that was previously visible (and whose image will be lowered). ")

                 (for L (PBOTTOM _ (fetch BOTTOM of PREG)) inlines NEXTVALID
                    while (IGEQ (IDIFFERENCE (GETLD L YBOT)
                                       LOWER)
                                PBOTTOM) do (SETQ LASTVISIBLE L))

            (* ;; "")

                 (SETQ PWIDTH (fetch WIDTH of PREG))         (* ; "Width of the pane")

            (* ;; "Lower what we think is the image of NEXTVALID and all visible lines below it. This may lower some garbage, if  the LASTVALID printer encroached on NEXTVALID's image.")

                 (CL:WHEN LASTVISIBLE
                     (SETQ LVBOT (IDIFFERENCE (GETLD LASTVISIBLE YBOT)
                                        LOWER)))
                 (BITBLT PANE 0 (IPLUS LVBOT LOWER)
                        PANE 0 LVBOT PWIDTH (IDIFFERENCE (IDIFFERENCE LTOP LVBOT)
                                                   LOWER)
                        'INPUT
                        'REPLACE)

            (* ;; "")

            (* ;; "The bottom of the pane is good.  But if LASTVALID encroached into the bitmap of some of NEXTVALID and some of its descendants, those need to be redisplayed.   And the ypositions of NEXTVALID and all lines down to LASTVISIBLE have to be lowered.  ")

            (* ;; "")

                 (CL:WHEN LASTVISIBLE                        (* ; "Smash the invisible tail")
                     (SETLD LASTVISIBLE NEXTLINE NIL))
                 (for L YBOT inlines NEXTVALID do (SETQ YBOT (IDIFFERENCE (GETLD L YBOT)
                                                                    LOWER))
                                                  (if (IGEQ (GETLD L YTOP)
                                                            NEWTOP)
                                                      then (SETYPOS L YBOT)
                                                           (\DISPLAYLINE TEXTOBJ L PANE)
                                                    else (SETYPOS L YBOT])

(\TEDIT.RAISE.LINES
  [LAMBDA (LINE NEWTOP PANE TEXTOBJ)                         (* ; "Edited 14-May-2023 21:55 by rmk")
                                                             (* ; "Edited 11-May-2023 11:34 by rmk")
                                                             (* ; "Edited 28-Apr-2023 08:51 by rmk")

    (* ;; "LINE is the top line of a region in PANE that extends to the pane-bottom or text end--that is, the pane bitmap in that region correctly reflects the lines (and possibly empty space at text-end).")

    (* ;; "This raises the image of that region so that its new top is at NEWTOP. It then fills in and displays lines below the region's new location that may be neeeded to fill in the pane.")

    (* ;; "If PANE has been moved so that it is not entirely within the screen, then don't try to find the relevant bits, just repaint the whole window.")

    (PROG ((PREG (DSPCLIPPINGREGION NIL PANE))
           (LTOP (GETLD LINE YTOP))
           (TEXTLEN (TEXTLEN TEXTOBJ))
           RAISE PWIDTH PBOTTOM LASTVISIBLE)
          (SETQ RAISE (IDIFFERENCE NEWTOP (GETLD LINE YTOP)))
          (CL:UNLESS (IGREATERP RAISE 0)                     (* ; "Maybe it's not moving")
              (RETURN))

     (* ;; "Make the YPOS of the raised lines consistent with the new positions of their images.  LASTVISIBLE is the last line that was previously visible (and whose image has been raised).  ")

          (SETQ PBOTTOM (fetch BOTTOM of PREG))
          (for L inlines LINE while (IGEQ (GETLD L YBOT)
                                          PBOTTOM) do (SETYPOS L (IPLUS RAISE (GETLD L YBOT)))
                                                      (SETQ LASTVISIBLE L))

     (* ;; "")

          (CL:UNLESS (\TEDIT.PANEWITHINSCREEN? PANE)         (* ; 
                                                      "Lines are positiond, but images may not exist")
              (\TEDIT.REPAINTFN PANE)
              (RETURN))

     (* ;; "")

     (* ;; "Completely on screen, we can take advantage of screen bitmap.")
                                                             (* ; "")
          (SETQ PWIDTH (fetch WIDTH of PREG))                (* ; "Width of the pane")

     (* ;; "Raise the image of LINE and all visible lines below it.")

          (BITBLT PANE 0 0 PANE 0 RAISE PWIDTH LTOP 'INPUT 'REPLACE)

     (* ;; "")
                                                             (* ; "")

     (* ;; "Now for the bottom of the pane.  First clear it.")

          (BITBLT NIL 0 0 PANE 0 0 PWIDTH RAISE 'TEXTURE 'REPLACE WHITESHADE)

     (* ;; "")

     (* ;; "If the last visible line in the pane (whose image is now elevated) is not the last line of the text, we build and display new lines to fill out the pane.")

          (for L NEXT LCHARLIM YBOT inlines LASTVISIBLE first (SETQ YBOT (GETLD LASTVISIBLE YBOT)) 
                                                             (* ; 
                                                           "This is guarded by the inlines NIL test.")
             eachtime (SETQ LCHARLIM (GETLD L LCHARLIM)) while (ILESSP LCHARLIM TEXTLEN)
             do (SETQ NEXT (\FORMATLINE TEXTOBJ (ADD1 LCHARLIM)))
                (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM NEXT YBOT))
                (SETYPOS NEXT YBOT)
                (CL:UNLESS (IGREATERP YBOT PBOTTOM)
                       (RETURN))
                (LINKLD L NEXT)
                (\DISPLAYLINE TEXTOBJ NEXT PANE])

(\TEDIT.VALID.LINES
  [LAMBDA (TEXTOBJ FIRSTCHANGEDCHNO NCHARSCHANGED REASON)    (* ; "Edited 14-Jun-2023 15:55 by rmk")
                                                             (* ; "Edited 17-May-2023 09:32 by rmk")
                                                             (* ; "Edited 15-May-2023 17:51 by rmk")

    (* ;; "Called when changes have been made to the document that affect the lines displayed in each pane. If a change is not visible in a given pane, then NIL is returned for that pane.  Otherwise, this divides the lines in the pane into 3 segments:")

    (* ;; "     1.  a prefix of lines from the top visible line (next of PLINES) to the LASTVALID line, the line just before the first changed line.")

    (* ;; "     2.  an intermediate sequence of lines that are (or may be) no longer valid because of the change.")

    (* ;; 
 "     3.  a suffix of post-chamge lines, starting with NEXTVALID, that are known still to be valid.")

    (* ;; "A line is %"valid%" if its line breaking is unaffected by the change and the bits in the screen bitmap that represented it before the change are still correct.")

    (* ;; "")

    (* ;; "The segmentation information is returned to the caller as a pair of lines (LASTVALID . NEXTVALID).   Segment 1 is then the sequence of lines chained from PLINES to LASTVALID, segment 3 is the sequence beginning at NEXTVALID.  The segment 2 lines originally between LASTVALID and NEXTVALID are useless, so here we just nuke them out (by smashing the NEXTLINE of LASTVALID).")

    (* ;; "")

    (* ;; "This assumes that the change has already been installed in the piece table after character FIRSTCHANGEDCHNO.  The LCHAR1/LIM valus for lines through LASTVALID are unaffected by the change, the values for all later lines are off by NCHARSCHANGED (negative for deletions, positive for insertions).  The positions for NEXTVALID and beyond are adjusted so that they are correct with respect to the revised piece table.  Note that this only deals with the character numbers of lines that will persist.  Although the Y positions for segment 1 lines are good,segment 3 positions cannot be adjusted until the replacements for segment 2 lines have been calculated.")

    (* ;; "")

    (* ;; "Edge conditions:")

    (* ;; "If the first visible line is changed, then there are no existing segment 1 lines and no existing  LASTVALID line to return.  If the first changed line is also the first line of the document, then LASTVALID is NIL.  Otherwise, we fabricate a new a new line with LCHARLIM and YBOT just above the changed top line and returned it as LASTVALID.  Either way, the next of PLINES is set to NIL to indicate that there is no chain of real segment 1 lines with valid formatting and reusable bitmaps.   ")

    (* ;; "")

    (* ;; "If the last visible line is changed, then there is no NEXTVALID line, indicated by NEXTVALID=NIL. The next valid could be a currently non-existent line just below the pane if we are not at the end of the document.  If LCHARLIM of the last visible line is TEXTLEN, there is at best a trailing line.")

    (* ;; "")

    (* ;; "Note that this is mostly an optimization to avoid unnecessary reformatting and redisplaying of still-valid lines in favor of bitbltting a block of their currently visible images.  Smashing all lines to NIL and refilling each pane would also give the correct behavior, but slower.  Intermediate would be smashing all lines below the last valid.")

    (* ;; "")

    (for PANE PLINES FIRSTCHANGEDLINE LASTCHANGEDLINE LASTVALIDLINE NEXTVALIDLINE
         (LASTCHANGEDCHNO _ (SUB1 (IPLUS FIRSTCHANGEDCHNO NCHARSCHANGED))) inpanes TEXTOBJ
       eachtime (SETQ PLINES (fetch (TEXTWINDOW PLINES) of PANE))
             (SETQ LASTVALIDLINE PLINES)
             (SETQ NEXTVALIDLINE NIL)
       collect [SETQ FIRSTCHANGEDLINE (find L inlines (GETLD PLINES NEXTLINE)
                                         suchthat 

                                               (* ;; 
                      "Either within a line or immediately after a line that did not end with an EOL")

                                               (OR (LINESELECTEDP L FIRSTCHANGEDCHNO LASTCHANGEDCHNO)
                                                   (AND (NOT (GETLD L FORCED-END))
                                                        (IEQP FIRSTCHANGEDCHNO
                                                              (ADD1 (GETLD L LCHARLIM]
             [SETQ LASTCHANGEDLINE (find L inlines (OR FIRSTCHANGEDLINE (GETLD PLINES NEXTLINE))
                                      suchthat (OR (WITHINLINEP LASTCHANGEDCHNO L)
                                                   (AND (NOT (GETLD L FORCED-END))
                                                        (IEQP LASTCHANGEDCHNO (ADD1 (GETLD L LCHARLIM
                                                                                           ]
             (CL:WHEN (OR FIRSTCHANGEDLINE LASTCHANGEDLINE)  (* ; 
                                                             "The change is visible in this pane.  ")

                 (* ;; "Figure out the LASTVALIDLINE--somewhere before the FIRSTCHANGEDLINE.  Could be PLINES as initialized above")

                 (CL:WHEN FIRSTCHANGEDLINE                   (* ; "First changed line is visible.")
                     (CL:UNLESS (GETLD FIRSTCHANGEDLINE 1STLN)

                         (* ;; "If FIRSTCHANGEDLINE is not the first line of a paragraph, then adding, subtracting, or relooking could cause changes to flow back to the preceding line.  Since we have a FIRSTCHANGEDLINE, we know it isn't PLINES. so it has a prev.")

                         (SETQ FIRSTCHANGEDLINE (GETLD FIRSTCHANGEDLINE PREVLINE)))
                     (SETQ LASTVALIDLINE (OR (GETLD FIRSTCHANGEDLINE PREVLINE)
                                             PLINES)))

                 (* ;; " If LASTVALIDLINE has landed on the dummy PLINES,we create and format a pre-pane LASTVALIDLINE to hold the effective LCHARLIM and YBOT (both just above the pane). Next of PLINES was implicitly just smashed.")

                 (CL:WHEN (AND (EQ LASTVALIDLINE PLINES)
                               (AND FIRSTCHANGEDLINE (IGREATERP (GETLD FIRSTCHANGEDLINE LCHAR1)
                                                            1)))
                                                             (* ; 
                                           "Top of pane but not top of document, link in a new valid")
                     [SETQ LASTVALIDLINE (CADR (\FORMATBLOCK TEXTOBJ (SUB1 (GETLD FIRSTCHANGEDLINE 
                                                                                  LCHAR1))
                                                      (GETLD FIRSTCHANGEDLINE YTOP]
                     (\TEDIT.INSERTLINE LASTVALIDLINE PLINES T))

                 (* ;; "")

                 (* ;; "The next valid must be somewhere after the last changed line, and after a stable line break. But we will run out of lines if there is no visible paragraph break: the change reached the bottom, or the paragraph break after the change is below the pane, or the document ended.  In that case the last line in the chain is not valid and presumably the gap filler will fill to the end of the window.   ")

                 [SETQ NEXTVALIDLINE (for L inlines LASTCHANGEDLINE
                                        when (OR (GETLD L FORCED-END)
                                                 (GETLD L LSTLN))
                                        do (RETURN (GETLD L NEXTLINE]

                 (* ;; "Translate the character positions of the still-valid lines that are visible later than the change.  ")

                 (for L DELTA inlines NEXTVALIDLINE first (SETQ DELTA (SELECTQ REASON
                                                                          (INSERTION NCHARSCHANGED)
                                                                          (DELETION (IMINUS 
                                                                                        NCHARSCHANGED
                                                                                           ))
                                                                          (APPEARANCE (RETURN))
                                                                          (SHOULDNT 
                                                                        "BAD REASONS FOR VALID LINES"
                                                                                 )))
                    do (add (FGETLD L LCHAR1)
                            DELTA)
                       (add (FGETLD L LCHARLIM)
                            DELTA))

                 (* ;; "")

                 (CL:WHEN LASTVALIDLINE
                     (SETLD LASTVALIDLINE NEXTLINE NIL)      (* ; "Chop off the useless lines")
                     (CONS LASTVALIDLINE NEXTVALIDLINE)))])

(\SHOWTEXT
  [LAMBDA (TEXTOBJ PANE)

    (* ;; "Edited 15-Jul-2023 13:49 by rmk")

    (* ;; "Edited 14-Jun-2023 09:23 by rmk")

    (* ;; "Edited 13-Apr-2023 19:17 by rmk")

    (* ;; "Edited  4-Apr-2023 13:00 by rmk")

    (* ;; "Edited 12-Jan-2022 18:56 by rmk: I took out the WAITINGCURSOR, the resetsave wasn't working for some reason, and it really isn't necessary for modern machines.")

    (* ;; "Edited 12-Jun-90 19:22 by mitani")

    (* ;; "Fill the pane with text, starting from the top of the file.")

    (CL:UNLESS PANE
        (SETQ PANE (\TEDIT.PRIMARYW TEXTOBJ)))
    (CL:WHEN PANE
        (LET (DUMMYLINE)
             (DSPFILL (DSPCLIPPINGREGION NIL PANE)
                    WHITESHADE
                    'REPLACE PANE)                           (* ; "Clear the region within the pane")

             (* ;; "Initialize with a dummy empty first line with LCHAR1 and LCHARLIM=0 above the pane top. 0 means in particular that the LCHARLIM is less than any real first line.  -1 would be one way of recognizing it as not directly in front of any real line, but that make break other assumptions.")

             (SETQ DUMMYLINE
              (create LINEDESCRIPTOR
                     LDUMMY _ T
                     YBOT _ (WINDOWPROP PANE 'HEIGHT)
                     LCHAR1 _ -1
                     LCHARLIM _ 0
                     RIGHTMARGIN _ (SUB1 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
                     NEXTLINE _ NIL
                     LHEIGHT _ 0
                     LX1 _ 0
                     LXLIM _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                     FORCED-END _ T
                     ASCENT _ 0
                     DESCENT _ 0
                     LTRUEASCENT _ 0
                     LFMTSPEC _ TEDIT.DEFAULT.FMTSPEC
                     1STLN _ T
                     LSTLN _ T))
             (replace (TEXTWINDOW PLINES) of PANE with DUMMYLINE)
             (\FILLPANE DUMMYLINE TEXTOBJ PANE)
             (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ PANE)
             DUMMYLINE))])

(\TEDIT.CLEAR.SCREEN.BELOW.LINE
  [LAMBDA (TEXTOBJ PANE LINE)                                (* ; "Edited 25-Apr-2023 20:01 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Clears the edit window to white, clearing only the space below LINE.")

    (LET ((PREG (DSPCLIPPINGREGION NIL PANE)))
         (BITBLT NIL 0 0 PANE 0 (fetch BOTTOM of PREG)
                (fetch WIDTH of PREG)
                (IDIFFERENCE (CL:IF (type? LINEDESCRIPTOR LINE)
                                 (GETLD LINE YBOT)
                                 LINE)
                       (fetch BOTTOM of PREG))
                'TEXTURE
                'REPLACE WHITESHADE])

(\CLEARPANE.BELOW.LINE
  [LAMBDA (LINE PANE TEXTOBJ)                                (* ; "Edited 25-Apr-2023 23:06 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "According to the manual, the user overflow function is called whenever a line falls out of the window (pane?), but it isn't told anything else. The use-case mentioned is coordination with the REGION property wherein TEDIT is running in part of a window.  But how does the userfn know where it is?")

    (CL:UNLESS (AND (TEXTPROP TEXTOBJ 'OVERFLOWFN)
                    (APPLY* (TEXTPROP TEXTOBJ 'OVERFLOWFN)
                           PANE TEXTOBJ))

        (* ;; "Clears the  pane below LINE to white.")

        (LET ((PREG (DSPCLIPPINGREGION NIL PANE)))
             (BITBLT NIL 0 0 PANE 0 (fetch BOTTOM of PREG)
                    (fetch WIDTH of PREG)
                    (IDIFFERENCE (GETLD LINE YBOT)
                           (fetch BOTTOM of PREG))
                    'TEXTURE
                    'REPLACE WHITESHADE)))])

(\TEDIT.INSERTLINE
  [LAMBDA (NEWLINE OLDLINE AFTER)                            (* ; "Edited 31-May-2023 00:18 by rmk")
                                                             (* ; "Edited 26-Feb-2023 22:36 by rmk")
                                                             (* ; "Edited 24-Feb-2023 23:12 by rmk")
                                                             (* ; "Edited 23-Feb-2023 22:41 by rmk")
                                                             (* ; "Edited 30-May-91 16:05 by jds")

    (* ;; 
    "Inserts NEWLINE in the line-descriptor chain either AFTER OLDLINE or before it (AFTER=NIL)")

    (LET (LINE)
         (if AFTER
             then (SETQ LINE (GETLD OLDLINE NEXTLINE))
                  (CL:WHEN LINE (SETLD LINE PREVLINE NEWLINE))
                  (SETLD NEWLINE NEXTLINE LINE)
                  (SETLD NEWLINE PREVLINE OLDLINE)
                  (SETLD OLDLINE NEXTLINE NEWLINE)
           else (SETQ LINE (GETLD OLDLINE PREVLINE))
                (CL:WHEN LINE (SETLD LINE NEXTLINE NEWLINE))
                (SETLD NEWLINE PREVLINE LINE)
                (SETLD NEWLINE NEXTLINE OLDLINE)
                (SETLD OLDLINE PREVLINE NEWLINE])

(\TEDIT.INSURE.TRAILING.LINE
  [LAMBDA (TEXTOBJ LASTLINE)                                 (* ; "Edited 15-Jul-2023 13:53 by rmk")
                                                             (* ; "Edited  8-May-2023 22:00 by rmk")
                                                             (* ; "Edited  5-May-2023 10:54 by rmk")

    (* ;; "Fabricates a final line to insure that there is a place for the caret to blink after the last EOL of the text.  Something for \FIXSEL to move to.")

    (* ;; "\FORMATLINE may be overkill--maybe we really want to construct exactly what we want.  But \FORMATLINE does get the LHEIGHT.")

    (CL:WHEN (AND (GETLD LASTLINE FORCED-END)
                  (NOT (GETLD LASTLINE LDUMMY))
                  (IEQP (GETLD LASTLINE LCHARLIM)
                        (TEXTLEN TEXTOBJ)))
        (LET [(LINE (\FORMATLINE TEXTOBJ (ADD1 (TEXTLEN TEXTOBJ]
             (SETYPOS LINE (IDIFFERENCE (GETLD LASTLINE YBOT)
                                  (GETLD LINE LHEIGHT)))
             (\TEDIT.INSERTLINE LINE LASTLINE T)
             LINE))])

(\TEDIT.LINE.LIST
  [LAMBDA (TEXTOBJ WINDOW)                                   (* ; "Edited 18-Feb-2023 21:19 by rmk")
                                                            (* ; "Edited 12-Jun-90 19:23 by mitani")
    (find LINES inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as WW inside (fetch (TEXTOBJ \WINDOW)
                                                                          of TEXTOBJ)
       suchthat (EQ WW WINDOW])

(\TEDIT.MARK.LINES.DIRTY
  [LAMBDA (TEXTOBJ FIRSTCHAR LASTCHAR)                       (* ; "Edited 28-May-2023 14:05 by rmk")
                                                             (* ; "Edited 20-May-2023 16:44 by rmk")
                                                             (* ; "Edited  7-Apr-2023 19:25 by rmk")
                                                             (* ; "Edited 30-May-91 16:05 by jds")

    (* ;; "Mark as dirty the lines that intersect the range FIRSTCHAR to LASTCHAR  inclusive, and assert that all panes need to be updated.")

    (CL:WHEN (type? SELECTION FIRSTCHAR)
        (SETQ LASTCHAR (SUB1 (GETSEL FIRSTCHAR CHLIM)))
        (SETQ FIRSTCHAR (GETSEL FIRSTCHAR CH#)))
    (SETQ FIRSTCHAR (IMIN FIRSTCHAR (TEXTLEN TEXTOBJ)))
    [SETQ LASTCHAR (CL:IF (EQ LASTCHAR -1)
                       (TEXTLEN TEXTOBJ TEXTOBJ)
                       (IMIN LASTCHAR (TEXTLEN TEXTOBJ)))]
    (for PANE inpanes TEXTOBJ do (for LINES inlines (find L inlines (fetch (TEXTWINDOW PLINES)
                                                                       of PANE)
                                                       suchthat 

                                                             (* ;; 
                                                             "The first line ending after FIRSTCHAR")

                                                             (IGEQ (GETLD L LCHARLIM)
                                                                   FIRSTCHAR))
                                    do (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)
                                       (for L inlines LINES while (ILEQ (GETLD L LCHAR1)
                                                                        LASTCHAR)
                                          do 
                                             (* ;; "All the lines that begin before LASTCHAR")

                                             (FSETLD L DIRTY T])

(\TEDIT.NEXT.LINE.BOTTOM
  [LAMBDA (LINE PREVYBOT PREV)                               (* ; "Edited 25-Apr-2023 23:00 by rmk")
                                                             (* ; "Edited 23-Apr-2023 00:05 by rmk")
                                                             (* ; "Edited 24-Sep-87 10:00 by jds")

(* ;;; "Given a current Y-bottom for PREV, and a LINE to follow it, compute the new line's YBOT value.  Takes into account Base-to-base leading, as well as paragraph leadings.")

    (CL:UNLESS PREV
        (SETQ PREV (GETLD LINE PREVLINE)))
    (CL:UNLESS PREVYBOT
        (SETQ PREVYBOT (GETLD PREV YBOT)))
    (LET (NEWYBOT PARALEADING BASETOBASE (PARALOOKS (GETLD LINE LFMTSPEC)))
         [COND
            [(SETQ BASETOBASE (fetch (FMTSPEC FMTBASETOBASE) of PARALOOKS))

             (* ;; "If base-to-base spacing is specified, we have to do this in two parts: First, compute the proper spacing between the lines;  then add in any paragraph leading.")

             [SETQ NEWYBOT (IDIFFERENCE (IPLUS PREVYBOT (GETLD PREV DESCENT))
                                  (IPLUS BASETOBASE (GETLD LINE DESCENT]
             (COND
                ((GETLD LINE 1STLN)                          (* ; 
                          "This is the first line of a new paragraph.  Add in any paragraph leading.")
                 [SETQ PARALEADING (IPLUS (fetch (FMTSPEC LEADBEFORE) of PARALOOKS)
                                          (fetch (FMTSPEC LEADAFTER) of (GETLD PREV LFMTSPEC]

                 (* ;; "The inter-paragraph space is the sum of the previous para's post-leading and this para's pre-leading.")

                 (SETQ NEWYBOT (IDIFFERENCE NEWYBOT PARALEADING]
            (T 
               (* ;; "If there's no base-to-base spacing, then paragraph leading was taken into account in the line formatter, and is already part of LHEIGHT.")

               (SETQ NEWYBOT (IDIFFERENCE PREVYBOT (GETLD LINE LHEIGHT]
         NEWYBOT])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (22945 24182 (\TEDIT.LINEDESCRIPTOR.DEFPRINT 22955 . 24180)) (31894 104124 (\FORMATLINE 
31904 . 63474) (\FORMATLINE.SETUP 63476 . 66702) (\FORMATLINE.ALIGN 66704 . 71755) (
\FORMATLINE.JUSTIFY 71757 . 77691) (\FORMATLINE.TABS 77693 . 85061) (\FORMATLINE.SCALETABS 85063 . 
86060) (\FORMATLINE.PURGE.SPACES 86062 . 87147) (\FORMATLINE.EMPTY 87149 . 91597) (
\FORMATLINE.UPDATELOOKS 91599 . 98545) (\FORMATLINE.LASTLEGAL 98547 . 101986) (\FORMATBLOCK 101988 . 
104122)) (104125 106431 (\CLEARTHISLINE 104135 . 104804) (\TLVALIDATE 104806 . 106429)) (106625 125770
 (\DISPLAYLINE 106635 . 119153) (\DISPLAYLINE.TABS 119155 . 121677) (\TEDIT.LINECACHE 121679 . 122407)
 (\TEDIT.CREATE.LINECACHE 122409 . 123245) (\TEDIT.BLTCHAR 123247 . 125768)) (126385 172191 (
TEDIT.UPDATE.SCREEN 126395 . 127693) (\BACKFORMAT 127695 . 129231) (\TEDIT.PREVIOUS.LINEBREAK 129233
 . 131072) (\FILLPANE 131074 . 134801) (\TEDIT.UPDATE.LINES 134803 . 138588) (\TEDIT.FIND.DIRTYCHARS 
138590 . 139921) (\FORMAT.GAP.LINES 139923 . 144314) (\TEDIT.LOWER.LINES 144316 . 148378) (
\TEDIT.RAISE.LINES 148380 . 152001) (\TEDIT.VALID.LINES 152003 . 161170) (\SHOWTEXT 161172 . 163274) (
\TEDIT.CLEAR.SCREEN.BELOW.LINE 163276 . 164047) (\CLEARPANE.BELOW.LINE 164049 . 165172) (
\TEDIT.INSERTLINE 165174 . 166432) (\TEDIT.INSURE.TRAILING.LINE 166434 . 167551) (\TEDIT.LINE.LIST 
167553 . 168042) (\TEDIT.MARK.LINES.DIRTY 168044 . 170143) (\TEDIT.NEXT.LINE.BOTTOM 170145 . 172189)))
))
STOP
