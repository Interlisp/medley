(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "11-Mar-2023 22:44:21" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;320 205612 

      :CHANGES-TO (FNS \FILLWINDOW \SHOWTEXT)

      :PREVIOUS-DATE "10-Mar-2023 12:28:33" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;319)


(PRETTYCOMPRINT TEDIT-SCREENCOMS)

(RPAQQ TEDIT-SCREENCOMS
       ([DECLARE%: EVAL@COMPILE DONTCOPY
               (EXPORT (RECORDS THISLINE LINEDESCRIPTOR LINECACHE PENDINGTAB)
                      (MACROS SPACEBREAK SAVEBREAK DOBREAK FORCEBREAK FORGETHYPHENBREAK 
                             FORGETPREVIOUSBREAK)
                      (MACROS HCSCALE HCUNSCALE)
                      (GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
                      (ADDVARS (CHARACTERNAMES (EM-DASH "357,045")
                                      (SOFT-HYPHEN "357,043")
                                      (NONBREAKING-HYPHEN "357,042")))
                      (COMS                                  (* ; "Formatting slots held by THISLINE")
                            (RECORDS CHARSLOT)
                            (MACROS CHAR CHARW PREVCHARSLOT PREVCHARSLOT! NEXTCHARSLOT FIRSTCHARSLOT
                                   NTHCHARSLOT LASTCHARSLOT FILLCHARSLOT BACKCHARS PUSHCHAR POPCHAR 
                                   CHARSLOTP)
                            (CONSTANTS (CELLSPERCHARSLOT 2)
                                   (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
                                   (MAXCHARSLOTS 256))
                            
                            (* ;; "incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards.")

                            (I.S.OPRS incharslots backcharslots inlines]
        (INITRECORDS THISLINE LINEDESCRIPTOR LINECACHE)
        (FNS \FORMATLINE \FORMATLINE.SETUP \FORMATLINE.ALIGN \FORMATLINE.JUSTIFY \FORMATLINE.TABS 
             \FORMATLINE.SCALETABS \FORMATLINE.PURGE.SPACES \FORMATLINE.EMPTY \FORMATLINE.UPDATELOOKS
             \CLEARTHISLINE \TLVALIDATE)
        (INITVARS *TEDIT-CACHED-FMTSPEC*)
                                                             (* ; "Heuristic for \FORMATLINE")
        (GLOBALVARS *TEDIT-CACHED-FMTSPEC*)
        (FNS \DISPLAYLINE \DISPLAYLINE.TABS \TEDIT.LINECACHE \TEDIT.CREATE.LINECACHE \TEDIT.BLTCHAR)
        (DECLARE%: EVAL@COMPILE DONTCOPY 

               (* ;; "Machine independent version of \TEDIT.BLTCHAR")

               (MACROS MI-TEDIT.BLTCHAR))
        (FNS TEDIT.DELETELINE TEDIT.INSERT.DISPLAYTEXT TEDIT.INSERT.UPDATESCREEN TEDIT.UPDATE.SCREEN
             \BACKFORMAT \FILLWINDOW \FIXDLINES \FIXILINES \SHOWTEXT \TEDIT.ADJUST.LINES 
             \TEDIT.CLEAR.SCREEN.BELOW.LINE \TEDIT.CLOSEUPLINES \TEDIT.FIXCHANGEDLINE 
             \TEDIT.FIXCHANGEDPART \TEDIT.INSERTLINE \TEDIT.ADD.TRAILING.LINE \TEDIT.LINE.LIST 
             \TEDIT.MARK.LINES.DIRTY \TEDIT.NEXT.LINE.BOTTOM \TEDIT.COPY.LINEDESCRIPTOR)))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE THISLINE (
                    (* ;; 
        "Cache for line-related character location info, for selection and line-display code to use.")

                    (DESC FULLXPOINTER)                      (* ; 
                                                    "Line descriptor for the line this describes now")
                    TLSPACEFACTOR                            (* ; 
                                                   "The SPACEFACTOR to be used in printing this line")
                    TLFIRSTSPACE                             (* ; "The first space to which SPACEFACTOR is to apply.  This is used sothat spaces to the left of a TAB have their default width.")
                    CHARSLOTS                                (* ; "Pointer block holdomg char/width slots MAXCHARSLOTS (with an extra slot so that there is always storage behind NEXTAVAILABLECHARSLOT")
                    NEXTAVAILABLECHARSLOT)                   (* ; 
                                  "The last used CHARSLOT is at (PREVCHARSLOT NEXTAVAILABLECHARSLOT)")
                   CHARSLOTS _ (\ALLOCBLOCK (ITIMES (ADD1 MAXCHARSLOTS)
                                                   CELLSPERCHARSLOT)
                                      PTRBLOCK.GCT))

(DATATYPE LINEDESCRIPTOR 
          (
           (* ;; 
       "Description of a single line of formatted text, either on the display or for a printed page.")

           YBOT                                              (* ; 
                                             "Y value for the bottom of the line (below the descent)")
           YBASE                                             (* ; 
                                                     "Yvalue for the base line the characters sit on")
           LEFTMARGIN                                        (* ; "Left margin, in screen points")
           RIGHTMARGIN                                       (* ; "Right margin, in screen points")
           LXLIM                                             (* ; "X value of right edge of LCHARLIM character on the line (may exceed right margin, if char is a space.). In natural stream units")
           LX1                                               (* ; 
                  "X value of the left edge of LCHAR1 from the left margin, in stream natural units.")
           LHEIGHT                                           (* ; 
                                                          "Total height of hte line, Ascent+Descent.")
           ASCENT                                            (* ; 
                                          "Ascent of the line above YBASE, adjusted for line leading")
           DESCENT                                           (* ; 
                                       "How far line descends below YBASE, adjusted for line leading")
           LTRUEDESCENT                                      (* ; 
                                       "The TRUE DESCENT for this line, unadjusted for line leading.")
           LTRUEASCENT                                       (* ; 
                               "The TRUE ASCENT for this line, unadjusted for pre-paragraph leading.")
           LCHAR1                                            (* ; 
                                                            "CH# of the first character on the line.")
           LCHARLIM                                          (* ; 
                                                             "CH# of the last character on the line")
           NIL                                               (* ; 
          "Was CHARTOP: CH# of the character which forced the line break (may be less than  CHARLIM)")
           NEXTLINE                                          (* ; "Next line chain pointer")
           (PREVLINE FULLXPOINTER)                           (* ; "Previous line chain pointer")
           LMARK                                             (* ; "One of SOLID, GREY, NIL.  Tells what kind of special-line marker should be put in the left margin for this paragraph.  (For hardcopy, can also be an indicator for special processing?)")
           LTEXTOBJ                                          (* ; "A cached TEXTOBJ that this line took its text from.  Used in hardcopy to disambiguate when chno's should be updated...")
           NIL                                               (* ; "Was CACHE: A cached THISLINE, for keeping hardcopy info around while we crunch with the line descriptors to make things fit.  Now:  THISLINE comes from TEXTOBJ")
           NIL                                               (* ; 
                      "Was LDOBJ: The object which lies behind this line of text, for updating, etc.")
           LFMTSPEC                                          (* ; 
                                             "The format spec for this line's paragraph (eventually)")
           (DIRTY FLAG)                                      (* ; 
                                            "T if this line has changed since it was last formatted.")
           (FORCED-END FLAG)                                 (* ; 
                                                             "T if this line ends with EOL or FORM.")
           (DELETED FLAG)                                    (* ; "T if this line has been completely deleted since it was last formatted or displayed.  (Used by deletion routines to detect garbage lines)")
           (LHASPROT FLAG)                                   (* ; 
                                                             "This line contains protected text.")
           (NIL FLAG)                                        (* ; "Was: LHASTABS.  But never fetched and this descriptions wasn't true: If this line has a tab in it, this is the line-relative ch# of the final tab.  This is to let us punt properly with tabs in a line.")
           (1STLN FLAG)                                      (* ; 
                                                         "This line is the first line in a paragraph")
           (LSTLN FLAG)                                      (* ; 
                                                             "This is the last line in a paragraph")
           )
          LCHARLIM _ 1000000 NEXTLINE _ NIL PREVLINE _ NIL DIRTY _ NIL YBOT _ 0 YBASE _ 0 LEFTMARGIN
          _ 0 DELETED _ NIL)

(DATATYPE LINECACHE (
                     (* ;; "Image cache for display lines.")

                     LCBITMAP                                (* ; 
                                         "The bitmap that will be used by this instance of the cache")
                     (LCNEXTCACHE FULLXPOINTER)              (* ; 
                                                   "The next cache in the chain, for screen updates.")
                     ))

(DATATYPE PENDINGTAB (
                      (* ;; "The data structure for a tab, within the line formatter, that we haven't finished dealing with yet, e.g. a centered tab where you need to wait for AFTER the centered text to do the formatting.")

                      PTRESOLVEDWIDTH

                      (* ;; "Width resolved for a prior tab.  This results from the resolution of an old RIGHT, CENTERED, or DECIMAL tab.")

                      PTOLDTAB                               (* ; "The pending tab")
                      PTTYPE                                 (* ; "Its tab type")
                      PTTABX                                 (* ; "Its nominal X position")
                      (PTCHARSLOT FULLXPOINTER)              (* ; "The CHARSLOT that may need to be updated later.  (RMK:  I don't know why this is a FULLXPOINTER--maybe an issue in the older THISLINE implementation?)")
                      PTOLDTX                                (* ; 
                                                         "The TX as of when the tab was encountered.")
                      ))
)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)

(/DECLAREDATATYPE 'PENDINGTAB '(POINTER POINTER POINTER POINTER FULLXPOINTER POINTER)
       '((PENDINGTAB 0 POINTER)
         (PENDINGTAB 2 POINTER)
         (PENDINGTAB 4 POINTER)
         (PENDINGTAB 6 POINTER)
         (PENDINGTAB 8 FULLXPOINTER)
         (PENDINGTAB 10 POINTER))
       '12)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS SPACEBREAK MACRO (NIL 
                                (* ;; "TX is the beginning of the first space of a run. Needed for SPACELEFT in DOBREAK. FIRSTINVISIBLEX is updated on the first space after one or more non-spaces. ")

                                (CL:WHEN INWORD
                                    (FORGETHYPHENBREAK)
                                    (SETQ FIRSTINVISIBLEX (ADD1 TX))
                                                             (* ; "The beginning of the space")
                                    (SETQ FIRSTINVISIBLESLOT CHARSLOT)
                                    (SETQ INWORD NIL)
                                    (SETQ INSPACES T))))

(PUTPROPS SAVEBREAK MACRO (NIL 
                               (* ;; "Values including the character just before a break")

                               (SETQ ASCENTB ASCENT)
                               (SETQ DESCENTB DESCENT)
                               (SETQ CHNOB CHNO)
                               (SETQ CHARSLOTB CHARSLOT)
                               (SETQ TXB TX)))

(PUTPROPS DOBREAK MACRO [(SPACERUN)

                         (* ;; 
                     "SPACERUN if we are backing up to a space run with unexpandable overhang spaces")

                         (SETQ ASCENT ASCENTB)
                         (SETQ DESCENT DESCENTB)
                         (SETQ TX TXB)
                         (SETQ CHNO CHNOB)
                         (SETQ CHARSLOT CHARSLOTB)
                         (COND
                            ((AND SPACERUN FIRSTINVISIBLESLOT)
                                                             (* ; "Clear/register the overhangs")
                             (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP (fetch (CHARSLOT CHAR)
                                                                              of FIRSTINVISIBLESLOT))
                              )
                             (SETQ SPACELEFT (IDIFFERENCE WIDTH FIRSTINVISIBLEX))
                             (SETQ OVERHANG (IDIFFERENCE TX FIRSTINVISIBLEX)))
                            (T (SETQ SPACELEFT (IDIFFERENCE WIDTH TX))
                               (SETQ OVERHANG 0])

(PUTPROPS FORCEBREAK MACRO (NIL (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))
                                                             (* ; "All spaces are natural")

                                (* ;; "If the EOL comes right after a word-character that was preceded by a space run, those earlier spaces don't count in our overhang.  INSPACES tracks that. ")

                                (add TX DX)
                                (SETQ OVERHANG (CL:IF INSPACES
                                                   (IDIFFERENCE TX FIRSTINVISIBLEX)
                                                   DX))
                                (SETQ SPACELEFT (IDIFFERENCE WIDTH (IDIFFERENCE TX OVERHANG)))
                                (SETQ LSTLN T)))

(PUTPROPS FORGETHYPHENBREAK MACRO (NIL (CL:WHEN PREVDHYPH    (* ; 
                                                             "Previous soft hyphen becomes invisible")
                                           (add TX (IMINUS (CHARW PREVDHYPH)))
                                           (FILLCHARSLOT PREVDHYPH NIL 1))
                                       (SETQ PREVDHYPH (SETQ PREVHYPH NIL))))

(PUTPROPS FORGETPREVIOUSBREAK MACRO (NIL (CL:WHEN PREVDHYPH  (* ; 
                                                             "Previous soft hyphen becomes invisible")
                                             (add TX (IMINUS (CHARW PREVDHYPH)))
                                             (FILLCHARSLOT PREVDHYPH NIL 1))
                                         (SETQ PREVDHYPH (SETQ PREVHYPH NIL))
                                                             (* ; "Forget hyphens")
                                         (SETQ FIRSTINVISIBLEX 0)
                                         (SETQ FIRSTINVISIBLESLOT NIL)))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS HCSCALE MACRO ((SCALE ITEM)
                         (FIXR (FTIMES SCALE ITEM))))

(PUTPROPS HCUNSCALE MACRO [OPENLAMBDA (SCALE ITEM)
                            (CL:IF (LISTP ITEM)
                                (for I in ITEM collect (FIXR (FQUOTIENT I SCALE)))
                                (FIXR (FQUOTIENT ITEM SCALE)))])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
)

(ADDTOVAR CHARACTERNAMES (EM-DASH "357,045")
                         (SOFT-HYPHEN "357,043")
                         (NONBREAKING-HYPHEN "357,042"))



(* ; "Formatting slots held by THISLINE")

(DECLARE%: EVAL@COMPILE

(BLOCKRECORD CHARSLOT (CHAR CHARW                            (* ; 
             "If CHAR is NIL, then (SMALLP CHARW) is an invisible ron, otherwise CHARW is CHARLOOKS.")
                            ))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS CHAR MACRO ((CSLOT)
                      (ffetch (CHARSLOT CHAR) of CSLOT)))

(PUTPROPS CHARW MACRO ((CSLOT)
                       (ffetch (CHARSLOT CHARW) of CSLOT)))

(PUTPROPS PREVCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT (IMINUS WORDSPERCHARSLOT))))

(PUTPROPS PREVCHARSLOT! MACRO ((CSLOT)

                               (* ;; "Backs over looks and invisibles to the last character slot")

                               (find CS _ (PREVCHARSLOT CSLOT) by (PREVCHARSLOT CS) while CS
                                  suchthat (CHAR CS))))

(PUTPROPS NEXTCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT WORDSPERCHARSLOT)))

(PUTPROPS FIRSTCHARSLOT MACRO ((TLINE)
                               (fetch (THISLINE CHARSLOTS) of TLINE)))

(PUTPROPS NTHCHARSLOT MACRO ((TLINE N)
                             (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                    (ITIMES N WORDSPERCHARSLOT))))

(PUTPROPS LASTCHARSLOT MACRO ((TLINE)
                              (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                     (TIMES (SUB1 MAXCHARSLOTS)
                                            WORDSPERCHARSLOT))))

(PUTPROPS FILLCHARSLOT MACRO ((CSLOT C W)
                              (freplace (CHARSLOT CHAR) of CSLOT with C)
                              (freplace (CHARSLOT CHARW) of CSLOT with W)))

(PUTPROPS BACKCHARS MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                           (SETQ CSLOTVAR (PREVCHARSLOT CSLOTVAR))
                           (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                           (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))))

(PUTPROPS PUSHCHAR MACRO ((CSLOTVAR C W)
                          (FILLCHARSLOT CSLOTVAR C W)
                          (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS POPCHAR MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                         (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                         (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))
                         (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS CHARSLOTP MACRO [OPENLAMBDA (X TL)

                            (* ;; "True if TL is a THISLINE and X is a pointer into its CHARSLOTS block.  A tool for consistency assertions.")

                            (CL:WHEN (TYPE? THISLINE TL)
                                [LET ((FIRSTSLOT (FIRSTCHARSLOT TL))
                                      (LASTSLOT (LASTCHARSLOT TL)))
                                     (AND [OR (IGREATERP (\HILOC X)
                                                     (\HILOC FIRSTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC FIRSTSLOT))
                                                   (IGEQ (\LOLOC X)
                                                         (\LOLOC FIRSTSLOT]
                                          (OR (ILESSP (\HILOC X)
                                                     (\HILOC LASTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC LASTSLOT))
                                                   (ILEQ (\LOLOC X)
                                                         (\LOLOC LASTSLOT])])
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ CELLSPERCHARSLOT 2)

(RPAQ WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))

(RPAQQ MAXCHARSLOTS 256)


(CONSTANTS (CELLSPERCHARSLOT 2)
       (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
       (MAXCHARSLOTS 256))
)



(* ;; 
"incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards."
)

(DECLARE%: EVAL@COMPILE 

(I.S.OPR 'incharslots NIL '[SUBST (GETDUMMYVAR)
                                  '$$STARTSLOT
                                  '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                      declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                      first (SETQ I.V. (COND
                                                          ((TYPE? THISLINE $$STARTSLOT)
                                                           (FIRSTCHARSLOT $$STARTSLOT))
                                                          (T $$STARTSLOT)))
                                            (SETQ $$CHARSLOTLIMIT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                ) of THISLINE))
                                      by (NEXTCHARSLOT I.V.) until (EQ I.V. $$CHARSLOTLIMIT)
                                      eachtime (SETQ CHAR (fetch (CHARSLOT CHAR) of I.V.))
                                            (SETQ CHARW (fetch (CHARSLOT CHARW) of I.V.]
       T)

(I.S.OPR 'backcharslots NIL '[SUBST (GETDUMMYVAR)
                                    '$$STARTSLOT
                                    '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                        declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                        first (SETQ I.V. (COND
                                                            ((TYPE? THISLINE $$STARTSLOT)
                                                             (PREVCHARSLOT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                         )
                                                                              of THISLINE)))
                                                            (T $$STARTSLOT)))
                                              (SETQ $$CHARSLOTLIMIT (FIRSTCHARSLOT THISLINE))
                                        by (PREVCHARSLOT I.V.) eachtime (SETQ CHAR
                                                                         (fetch (CHARSLOT CHAR)
                                                                            of I.V.))
                                                                     (SETQ CHARW (fetch (CHARSLOT
                                                                                         CHARW)
                                                                                    of I.V.))
                                        repeatuntil (EQ I.V. $$CHARSLOTLIMIT]
       T)

[I.S.OPR 'inlines NIL '(first (SETQ I.V. (OR BODY (GO $$OUT)))
                          by (OR (fetch (LINEDESCRIPTOR NEXTLINE) of I.V.)
                                 (GO $$OUT]
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)
(DEFINEQ

(\FORMATLINE
  [LAMBDA (TEXTOBJ CH#1 LINE REGION IMAGESTREAM)             (* ; "Edited 10-Mar-2023 10:55 by rmk")
                                                             (* ; "Edited 23-Oct-2022 09:11 by rmk")
    (DECLARE (SPECVARS IMAGESTREAM))

    (* ;; 
 "Format the next line of text starting at CH#1.  Return the LINEDESCRIPTOR;  reusing LINE if given.")

    (* ;; "The SPECVARS are reset under the BIN, by the LOOKSUPDATEFN.")

    (* ;; "")

    (* ;; "The objective of this body of code is to find")

    (* ;; "   LCHAR1:  The CHNO of the first visible character/object of this line.  LCHAR1=0 for empty/dummy line.")

    (* ;; "   LCHARLIM: The CHNO of the last character in the line-vector, including final EOL or last of run of spaces that overflows.")

    (* ;; "    LXLIM:   The X coordinate of the right edge of character/object LCHARLIM")

    (* ;; "   PREVSP:  The slot position in THISLINE of the right most scalable space.")

    (* ;; "   SPACELEFT:  How much unoccupied space is to be allocated according to justified, right, center alignments.")

    (* ;; "   OVERHANG:  How far beyond the right margin will trailing spaces/EOL occupy")

    (* ;; "  THISLINE:  The CHARSLOT vector that contains the actual characters and widths, together with their looks, as abstracted from the piece sequences of the underlying text.")

    (* ;; " ")

    (* ;; "At the end, \FORMATLINE.JUSTIFYmodifies LINE and THISLINE to deal with the vagaries of justification. The overhanging right-margin spaces don't get fattened even though justifying might fatten earlier spaces on the line.")

    (* ;; "")

    (* ;; "If a (visible) word crosses the margin |, then the line ends at the space just before the beginning of that word.  For x==yz==ab|cd, LCHARLIM goes to the space before a, LXLIM is its right edge. The justifier will leave the spaces between z and a alone, but might fatten the spaces between x and y based on the SPACELEFT between z and margin |.  The spaces after z OVERHANG. An EOL or FORM force a line-end and also overhang with along with any immediately preceding spaces--they are essentially treated as line-breaking spaces.")

    (* ;; "     abc123#45|6 => abc[123]#$|  (456 on next line--leading white space only after EOL)")

    (BTVALIDATE '\FORMATLINE 'START TEXTOBJ)
    (CL:UNLESS LINE

        (* ;; "Not needed until the end, but then we might not get the starting values for WRIGHT and WBOTTOM, if those change from piece to piece--check this.")

        [SETQ LINE (create LINEDESCRIPTOR
                          YBOT _ (SUB1 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ])
    (AND NIL (SETQ CH#1 (IMAX CH#1 1)))
    (PROG ((TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
           (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (OFFSET 0)
           (ASCENT 0)
           (DESCENT 0)
           (ASCENTB 0)
           (DESCENTB 0)
           (ASCENTC 0)
           (DESCENTC 0)
           LINETYPE DISPLAYSTREAM WIDTH LEFTEDGE SCALE FMTSPEC RIGHTMARGIN TABSPEC KERN SPACELEFT 
           OVERHANG FIRSTINVISIBLEX FIRSTINVISIBLESLOT PC CHARSLOT PREVSP 1STLN PROTECTED CHNOB 
           FORCED-END LSTLN CHNO LX1 TX TXB FONT CHARSLOTB TABPENDING PREVHYPH PREVDHYPH 
           START-OF-PIECE)
          (DECLARE (SPECVARS LINETYPE CHARSLOT CHNO OFFSET ASCENTC DESCENTC FONT IMAGESTREAM 
                          START-OF-PIECE KERN))

     (* ;; "CHNO = Current character # in the text")

     (* ;; "CHARSLOT = Pointer to the next available slot in THISLINE's CHARS.")

     (* ;; "DX = width of current char/object")

     (* ;; "TX = Right end of current text")

     (* ;; "PREVSP = CHARPOS of the last space of the most recent space-run")

     (* ;; 
     "ASCENT, DESCENT = The ascent and descent values of the line at the current character position")

     (* ;; "ASCENTC, DESCENTC = The ascent and descent from the last CLOOKS (including OFFSET)")

     (* ;; 
     "ASCENTB, DESCENTB, CHNOB, TXB, CHARSLOTB = The values at the most recent potential break-point")

     (* ;; "LX1 = theoffset from the true left margin of the first character, in native units, accounting for the first-line indentation.")

     (* ;; "")

          (SETQ LINETYPE (if IMAGESTREAM
                             then 'TRUEHARDCOPY
                           else (SETQ DISPLAYSTREAM (WINDOWPROP (CAR (ffetch (TEXTOBJ \WINDOW)
                                                                        of TEXTOBJ))
                                                           'DSP))
                                (SETQ IMAGESTREAM DISPLAYSTREAM)
                                'TRUEDISPLAY))               (* ; 
                                                   "DISPLAYSTREAM needed for HARDCOPYDISPLAY objects")
          (if (REGIONP REGION)
              then (SETQ LEFTEDGE (ffetch (REGION LEFT) of REGION)) 
                                                             (* ; 
                                                     "Presumably hardcopy in different page regions.")
                   (SETQ WIDTH (ffetch (REGION WIDTH) of REGION))
            else (SETQ LEFTEDGE 8)                           (* ; "A little more display margin")
                 (SETQ WIDTH (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)))

     (* ;; "")

          (SETQ PC (\CHTOPC CH#1 TEXTOBJ T))
          (CL:UNLESS PC
              (RETURN (\FORMATLINE.EMPTY TEXTOBJ CH#1 LINE)))

     (* ;; "")

     (* ;; "We have a visible starting piece.  ")

          (CL:WHEN (AND (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC))
                        (SETQ PC (\NEXT.VISIBLE.PIECE PC)))
              (SETQ CH#1 (\PCTOCH PC))                       (* ; 
                                                     "Unusual, simpler than keeping track on the fly")
              (SETQ START-OF-PIECE CH#1))
          (SETQ CHNO CH#1)
          (SETQ IMAGESTREAM (\FORMATLINE.SETUP TEXTOBJ PC LINE IMAGESTREAM))
          (SETQ FMTSPEC (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE))

     (* ;; "Display stream could have switched for hardcopy font widths.")

          (CL:WHEN (AND (EQ LINETYPE 'TRUEDISPLAY)
                        (ffetch (FMTSPEC FMTHARDCOPY) of FMTSPEC))
              (SETQ LINETYPE 'HARDCOPYDISPLAY))
          (SETQ SCALE (ffetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC))

     (* ;; "This line starts a paragraph if it starts the document or it is at the beginning of a piece just after a last-paragraph piece. This assumes that only visible pieces matter; otherwise, use PREVPIECE.")

          [SETQ 1STLN (OR (IEQP CH#1 1)
                          (AND (IEQP CH#1 START-OF-PIECE)
                               (OR (NOT (\PREV.VISIBLE.PIECE PC))
                                   (PPARALAST (\PREV.VISIBLE.PIECE PC]

     (* ;; "Account for first-line indentation from the true left margin (LEFTMAR), in natural units")

          (SETQ LX1 (CL:IF 1STLN
                        (ffetch 1STLEFTMAR of FMTSPEC)
                        (ffetch LEFTMAR of FMTSPEC)))
          (SETQ RIGHTMARGIN (if (ZEROP (ffetch RIGHTMAR of FMTSPEC))
                                then 
                                     (* ;; "RIGHTMAR = 0 => follow the window/region's width")

                                     WIDTH
                              else (ffetch RIGHTMAR of FMTSPEC)))
          (SETQ WIDTH (IDIFFERENCE RIGHTMARGIN LX1))
          (SETQ TABSPEC (ffetch (FMTSPEC TABSPEC) of FMTSPEC))
          (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)            (* ; "Scale points to hardcopy")
              (SETQ LX1 (HCSCALE SCALE LX1))
              (SETQ WIDTH (HCSCALE SCALE WIDTH))
              (SETQ TABSPEC (\FORMATLINE.SCALETABS TABSPEC SCALE)))

     (* ;; "")

     (* ;; "The unchanging paragraph looks have now been established. Set up starting piece for BINNING characters")

     (* ;; "The LOOKSUPDATEFN will initialize the character looks of the starting piece PC. It is also called at piece boundaries to reset the character-looks variables when BIN (=\TEXTBIN) moves from piece to piece.")

          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with (FUNCTION \FORMATLINE.UPDATELOOKS))
          (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with NIL)
          (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
          (\INSTALL.PIECE TSTREAM PC (- CH#1 START-OF-PIECE))

     (* ;; "")

     (* ;; "Note:  the character looks of the first piece establish the initial FONT, ASCENTC, DESCENTC in anticipation of  the first as yet unseen character, and these are reset when the PLOOKS of each piece change.  These character ASCENTC and DESCENTC values apply only to actual characters, not to image objects, which have their own intrinsic values.  The character values and image values together determine the ASCENT and DESCENT for the line.  But importantly: the initial character-looks or the looks at each piece-transition don't affect the line values until at least one character with those looks has been seen. That's why the line values are computed for each BIN, using character or object values as appropriate..")

     (* ;; "")

     (* ;; "TEXTLEN anticipates the EOL error.  Wouldn't need it if we reset the ENDOFSTREAMOP.")

     (* ;; 
     " INWORD=T if we haven't just seen a space, INSPACES=T if we are in the middle of a space run.")

          (SETQ TX 0)
          (SETQ FIRSTINVISIBLEX TX)
          (bind CH DX BOX INSPACES (INWORD _ T)
                (LASTCHARSLOT _ (LASTCHARSLOT THISLINE))
                (TEXTLEN _ (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)) for old CHNO by 1
             while (ILEQ CHNO TEXTLEN) while (SETQ CH (BIN TSTREAM))
             do

             (* ;; "Get CH's X width and maintain line ascent and descent.")

             [SETQ DX (COND
                         [(SMALLP CH)                        (* ; "CH is a character, ")
                          (SELCHARQ CH
                               ((EOL LF CR FORM)             (* ; 
                                                          "A pseudo character: fake width, no ascent")
                                    
                                    (* ;; 
   " Force an end to the line. BIN shouldn't produce CR or LF. Should FORM do morein display mode?  ")

                                 (* ;; "If the EOL is the only character on the line, we want to use the current font's ascent/descent.  But if only preceded by objects, use the objects values.")

                                    (SETQ DX (\FGETCHARWIDTH FONT (CHARCODE EOL)))
                                    (FILLCHARSLOT CHARSLOT (CL:IF (EQ CH (CHARCODE FORM))
                                                               (CHARCODE FORM)
                                                               (CHARCODE EOL))
                                           DX)
                                    (SETQ FORCED-END CH)     (* ; "Remember whether EOL or FORM")
                                    (FORCEBREAK)
                                    (RETURN))
                               NIL)
                          (SETQ ASCENT (IMAX ASCENT (IDIFFERENCE ASCENTC OFFSET)))
                          (SETQ DESCENT (IMAX DESCENT (IDIFFERENCE DESCENTC OFFSET)))
                                                             (* ; "ASCENTC may have changed")
                          (COND
                             ((AND (IGEQ CH 192)
                                   (ILEQ CH 207))            (* ; 
                                                       "This is an NS accent character.  Space it 0.")
                              0)
                             (T                              (* ; 
                                                             "Regular character.  Get it's width.")
                                (\FGETCHARWIDTH FONT CH]
                         (T                                  (* ; "CH is an object, get its size.")

                            (* ;; "If this isn't TRUEHARDCOPY, we want to do the imageobject in the displaystream with displaystream coordinates, because we don't know what internal size computations the imageobject might make based on its displaystream and fonts.  But we do have to scale is width to be compatible with other HARDCOPYDISPLAY measurements.")

                            (SETQ BOX (APPLY* (IMAGEOBJPROP CH 'IMAGEBOXFN)
                                             CH
                                             (CL:IF (EQ LINETYPE 'TRUEHARDCOPY)
                                                 IMAGESTREAM
                                                 DISPLAYSTREAM)
                                             TX WIDTH))
                            (SETQ ASCENT (IMAX ASCENT (IDIFFERENCE (IDIFFERENCE (fetch (IMAGEBOX
                                                                                        YSIZE)
                                                                                   of BOX)
                                                                          (fetch (IMAGEBOX YDESC)
                                                                             of BOX))
                                                             OFFSET)))
                            (SETQ DESCENT (IMAX DESCENT (IDIFFERENCE (fetch (IMAGEBOX YDESC)
                                                                        of BOX)
                                                               OFFSET)))
                            (IMAGEOBJPROP CH 'BOUNDBOX BOX)
                            (SETQ DX (IPLUS (fetch (IMAGEBOX XSIZE) of BOX)
                                            (fetch (IMAGEBOX XKERN) of BOX)))
                            (CL:IF (EQ LINETYPE 'HARDCOPYDISPLAY)
                                (HCSCALE SCALE DX)
                                DX)]
             (CL:WHEN KERN                                   (* ; "Unlikely for display")
                 (add DX KERN))
             [SELCHARQ CH
                  (SPACE 
                         (* ;; "White space and EOL can overhang the right margin, but no visible character can. The only white-space leading a line must follow an [EOL]")

                         (* ;; 
            "    123abc456xy|z  =>  123abc|[456]$xyz  Line break in front of x, 456 overhangs margin")

                         (SPACEBREAK)
                         (add TX DX)
                         (SAVEBREAK)

                         (* ;; "CHAR will be the slot of the previous space, not this space character, CHARW is the natural width of this space. PREVSP is the new chain-header.")

                         (PUSHCHAR CHARSLOT (PROG1 PREVSP (SETQ PREVSP CHARSLOT))
                                DX))
                  (TAB 
                       (* ;; "Try to be reasonable with tabs.  This will create trouble when doing fast-case insert/delete, but Pah! for now.")

                       (* ;; "Remove all prior candidate break points and expandable spsaces")

                       (FORGETHYPHENBREAK)
                       (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))

                       (* ;; "Now for this tab:")

                       (FILLCHARSLOT CHARSLOT CH 0)          (* ; 
                                                       "Start with 0 width, then set up the next tab")
                       (SETQ TABPENDING (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE CHARSLOT LX1 TX 
                                               TABPENDING))  (* ; 
                                                             "Proper width is already in CHARSLOT")
                       (add TX (CL:IF (FIXP TABPENDING)
                                   (PROG1 TABPENDING (SETQ TABPENDING NIL))
                                   (fetch (PENDINGTAB PTRESOLVEDWIDTH) of TABPENDING)))
                       (SAVEBREAK)
                       (SETQ CHARSLOT (NEXTCHARSLOT CHARSLOT)))
                  (PROGN

                   (* ;; "Not an EOL, space, or tab character.    ")

                   (SETQ INWORD T)                           (* ; "Space run has ended")
                   (SETQ INSPACES NIL)
                   (add TX DX)
                   (CL:WHEN (IGREATERP TX WIDTH)             (* ; "Overflow")
                       (CL:WHEN FIRSTINVISIBLESLOT           (* ; "Back to previous space run")
                           (DOBREAK T)
                           (RETURN))
                       (CL:WHEN (OR PREVHYPH PREVDHYPH TABPENDING)

                           (* ;; 
           "A good break-point not followed by spaces. NOTE: Right-tab maybe should go on next line?")

                           (DOBREAK)
                           (RETURN))
                       (if (IGREATERP DX WIDTH)
                           then 
                                (* ;; "This character will never fit (e.g. a large image object). Move it to next line, by itself, if this line isn't empty.  Otherwise, dump it here by itself.")

                                (if (IGREATERP CHNO CH#1)
                                    then 

                                 (* ;; "Move the offender to the next line, by itself.  For this line it essentially acts like an EOL wrt breaking and justifying, except that it doesn't get tacked on to the end.  There was no good earlier break, otherwise we would have done it.  ")

                                         (add TX (IMINUS DX))
                                         (add CHNO -1)       (* ; "back up to preceding character")
                                         (SETQ CHARSLOT (PREVCHARSLOT! CHARSLOT))
                                         (SETQ CH (CHAR CHARSLOT))
                                         (SETQ DX (CHARW CHARSLOT)) 

                                      (* ;; "ASCENT/DESCENT for the previous CLOOKS. BUT: if the previous character is an object, it has to back out its box parameters")

                                         (SETQ ASCENT ASCENTC)
                                         (SETQ DESCENT DESCENTC)
                                  else 
                                       (* ;; "Dump it here")

                                       (FILLCHARSLOT CHARSLOT CH DX))
                                (SETQ OVERHANG 0)
                                (SETQ SPACELEFT 0)
                         elseif (IGREATERP CHNO CH#1)
                           then 
                                (* ;; 
      "We've seen at least one real character, line is not empty, but no good candidate break point.")

                                (* ;; "If the overflow CH cannot appear as the first of the next line. or the previous character cannot appear at the end of this line, look back for an acceptable point to break.  We haven't yet pushed (CH, DX).")

                                (* ;; "If we run back to the beginning without finding a good break, we just take the original overflowed line. (Or, we could just chop at the end, and push the residue to the next line?")

                                (* ;; "TOO BAD WE DON'T HAVE A HEURISTIC HYPHENATOR")

                                (add TX (IMINUS DX))         (* ; 
                                                       "We start from the state before the overflow ")
                                (for CS PCS (X _ TX) backcharslots (PREVCHARSLOT! CHARSLOT)
                                   as CN from (SUB1 CHNO)
                                   do [if CHAR
                                          then (CL:UNLESS (OR (MEMB CHAR TEDIT.DONT.BREAK.CHARS)
                                                              (AND (SETQ PCS (PREVCHARSLOT! CS))
                                                                   (MEMB (CHAR PCS)
                                                                         TEDIT.DONT.LAST.CHARS)))
                                                   (SETQ CHNO CN)
                                                             (* ; 
                                                             "The offender goes to the next line")
                                                   (SETQ CHARSLOT CS)
                                                   (SETQ TX X)
                                                   (RETURN))
                                               (add CN -1)
                                               (add X CHARW)
                                        else (add CN (IMINUS (OR (SMALLP CHARW)
                                                                 0]
                                   finally 

                                         (* ;; "Didn't find one, the offender protrudes on this line")

                                         (FILLCHARSLOT CHARSLOT CH DX))
                         else 
                              (* ;; "Don't break: can't split before the first thing on the line!")

                              (PUSHCHAR CHARSLOT CH DX))
                       (RETURN))

                   (* ;; "")

                   (* ;; 
                   "Not past the rightmargin yet. Save the character and width, then maybe adjust.")

                   (SELCHARQ CH
                        (%.                                  (* ; 
                                                      "Check for decimal tabs, immediately after TAB")
                            (PUSHCHAR CHARSLOT CH DX)
                            (CL:WHEN (AND TABPENDING (EQ (fetch PTTYPE of TABPENDING)
                                                         'DECIMAL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                                (add (fetch (PENDINGTAB PTTABX) of TABPENDING)
                                     DX)                     (* ; 
               "Adjust the tab stop's X value so that the LEFT edge of the decimal point goes there.")
                                (SETQ TABPENDING (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE CHARSLOT LX1
                                                        TX TABPENDING T))
                                                             (* ; 
                                                    "Tab over to the LEFT side of the decimal point.")
                                (add TX (CL:IF (FIXP TABPENDING)
                                            (PROG1 TABPENDING (SETQ TABPENDING NIL))
                                            (fetch (PENDINGTAB PTRESOLVEDWIDTH) of TABPENDING)))
                                (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))
                                                             (* ; 
                                        "Spaces before a tab don't take part in later justification.")
                                (SAVEBREAK)))
                        ((- EM-DASH SOFT-HYPHEN)             (* ; 
                                                             "Hyphen, M-dash, discretionary hyphen")
                             (FORGETPREVIOUSBREAK)
                             (SETQ PREVHYPH CHARSLOT)
                             (CL:WHEN (EQ CH (CHARCODE SOFT-HYPHEN))
                                 (SETQ PREVDHYPH CHARSLOT)   (* ; 
                                                          "Discretionary hyphen may become invisible")
                                 (SETQ CH (CHARCODE))        (* ; 
                                                             "Otherwise, it shows as a real hyphen")
                                 (SETQ DX (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                             (SAVEBREAK)                     (* ; 
                                                             "Save the hyphen slot, then fill it")
                             (PUSHCHAR CHARSLOT CH DX))
                        (NONBREAKING-HYPHEN 
                                            (* ;; 
                            "Switch the character code and width in case font doesn't have a glyph??")

                             (PUSHCHAR CHARSLOT (CHARCODE -)
                                    (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                        (PUSHCHAR CHARSLOT CH DX] 

             (* ;; "BOUNDS CHECKING!")

             (CL:WHEN (EQ CHARSLOT LASTCHARSLOT)

                 (* ;; 
        "If too long, we let it roll over to the next line.  Should we put something in the margin??")

                 (TEDIT.PROMPTPRINT TEXTOBJ "Line too long to format." T)
                 (RETURN)) finally 

                                 (* ;; 
         "Ran out of TEXTLEN (and paragraph). Back up and force a break. Are ASCENT/DESCENT correct?")

                                 (SETQ CHARSLOT (PREVCHARSLOT! CHARSLOT))
                                 (add CHNO -1)
                                 (SETQ DX 0)                 (* ; "TX is already correct")
                                 (FORCEBREAK))

     (* ;; "End of character loop.  ")

          (freplace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with NIL)

     (* ;; "Fix up last tab?")

          (CL:WHEN TABPENDING
              (SETQ PREVSP (\FORMATLINE.PURGE.SPACES PREVSP))(* ; "Ignore spaces before tabs")
              (add TX (\FORMATLINE.TABS TEXTOBJ TABSPEC SCALE (FETCH (PENDINGTAB PTCHARSLOT)
                                                                 OF TABPENDING)
                             LX1
                             (IDIFFERENCE TX OVERHANG)
                             TABPENDING T)))

     (* ;; "")

     (* ;; 
     "All the line information is now in our variables.  Migrate to the LINE and THISLINE fields. ")

          (freplace (LINEDESCRIPTOR LCHAR1) of LINE with CH#1)
          (freplace (LINEDESCRIPTOR LCHARLIM) of LINE with CHNO)
          (freplace (LINEDESCRIPTOR LX1) of LINE with LX1)   (* ; 
                                                            "Still maybe scaled for hardcopy display")
          (freplace (LINEDESCRIPTOR LXLIM) of LINE with (IPLUS LX1 TX))
          (freplace (LINEDESCRIPTOR 1STLN) of LINE with 1STLN)
          (freplace (LINEDESCRIPTOR LSTLN) of LINE with LSTLN)

     (* ;; "First line of a paragraph.  Special paragraph types get marked in the display-margin.")

          (freplace (LINEDESCRIPTOR LMARK) of LINE
             with (CL:WHEN [AND 1STLN (OR (EQ (fetch FMTPARATYPE of FMTSPEC)
                                              'PAGEHEADING)
                                          (fetch FMTNEWPAGEBEFORE of FMTSPEC)
                                          (fetch FMTNEWPAGEAFTER of FMTSPEC)
                                          [AND (fetch FMTSPECIALX of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALX of FMTSPEC]
                                          (AND (fetch FMTSPECIALY of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALY of FMTSPEC]
                         'GREY))
          (freplace (LINEDESCRIPTOR FORCED-END) of LINE with FORCED-END)
          (freplace (LINEDESCRIPTOR DIRTY) of LINE with NIL)
          (freplace (LINEDESCRIPTOR LHASPROT) of LINE with PROTECTED)
          (freplace (LINEDESCRIPTOR LEFTMARGIN) of LINE with (fetch (FMTSPEC LEFTMAR) of FMTSPEC))
          (freplace (LINEDESCRIPTOR RIGHTMARGIN) of LINE with RIGHTMARGIN)
          (freplace (LINEDESCRIPTOR LTRUEASCENT) of LINE with ASCENT)
          (freplace (LINEDESCRIPTOR LTRUEDESCENT) of LINE with DESCENT)
          (freplace (LINEDESCRIPTOR LHEIGHT) of LINE
             with (CL:IF (ZEROP (IPLUS ASCENT DESCENT))
                      (FONTPROP (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                         (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ)))
                                    DEFAULTFONT)
                             'HEIGHT)
                      (IPLUS ASCENT DESCENT)))

     (* ;; "")

          (freplace (LINEDESCRIPTOR LFMTSPEC) of LINE with FMTSPEC)
          (freplace (THISLINE DESC) of THISLINE with LINE)
          (\FORMATLINE.ALIGN TEXTOBJ LINE FMTSPEC THISLINE PREVSP SPACELEFT OVERHANG LINETYPE)

     (* ;; "Finally translate to the left edge, perhsps a specialx if true hardcopy.")

          (CL:WHEN [AND (EQ LINETYPE 'TRUEHARDCOPY)
                        (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC)
                        (NOT (ZEROP (fetch (FMTSPEC FMTSPECIALX) of FMTSPEC]

              (* ;; "Maybe SETQ instead of add ??")

              (add LEFTEDGE (ffetch (FMTSPEC FMTSPECIALX) of FMTSPEC)))
          (add (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
               LEFTEDGE)
          (add (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE)
               LEFTEDGE)
          (add (ffetch (LINEDESCRIPTOR LX1) of LINE)
               LEFTEDGE)
          (add (ffetch (LINEDESCRIPTOR LXLIM) of LINE)
               LEFTEDGE)
          (RETURN LINE])

(\FORMATLINE.SETUP
  [LAMBDA (TEXTOBJ PC LINE IMAGESTREAM)                      (* ; "Edited  8-Mar-2023 22:15 by rmk")
                                                             (* ; "Edited  7-Mar-2023 16:52 by rmk")
                                                             (* ; "Edited  6-Mar-2023 00:25 by rmk")
                                                             (* ; "Edited  2-Mar-2023 12:06 by rmk")

    (* ;; "The paragraph looks of a line are the same for every piece of every line in a paragraph, only the character looks can change from piece to piece.  We retrieve the para looks from the starting piece, or the stream's default.   ")

    (* ;; "The global variable *TEDIT-CACHED-FMTSPEC* is a heuristic optimization")

    (* ;; "In hardcopy-display mode, the verticals (lineleading etc.) are in screen points, only the horizontals are upscaled according to the points-to-hardcopy scalefactor installed in the retrieved FMTSPEC.")

    (* ;; "See comments in TEDIT-LOOKSCOMS about the style-cache variables.  Probably not completely or correctly coordinated with this code.")

    (* ;; "The global variable *TEDIT-CACHED-FMTSPEC* offers a heuristic optimization to speed up construction of the FMTSPEC for successive lines in the same paragraph (or maybe even in a sequence of same-format paragraphs. ")

    (LET [(FMTSPEC (OR (AND PC (PPARALOOKS PC))
                       (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ]
         (SETQ FMTSPEC (\TEDIT.APPLY.PARASTYLES FMTSPEC PC TEXTOBJ))
         (if (NOT (DISPLAYSTREAMP IMAGESTREAM))
             then (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC FMTSPEC IMAGESTREAM))
           elseif (fetch (FMTSPEC FMTHARDCOPY) of FMTSPEC)
             then 
                  (* ;; "Coerce the image stream and FMTSPEC for chracter-width scaling. ")

                  [SETQ IMAGESTREAM (OR (fetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ)
                                        (replace (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ
                                           with (OPENIMAGESTREAM '{NODIRCORE} 'POSTSCRIPT]
                  (SETQ FMTSPEC (create FMTSPEC using FMTSPEC FMTHARDCOPYSCALE _ (DSPSCALE NIL 
                                                                                        IMAGESTREAM))
                   )
           elseif (NULL (fetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC))
             then                                            (* ; "Should be done at create")
                  (replace (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC with 1))
         (CL:UNLESS (OR (EQ FMTSPEC *TEDIT-CACHED-FMTSPEC*)
                        (NOT (fetch (FMTSPEC FMTCHARSTYLES) of FMTSPEC)))

             (* ;; "The cache of styles for the current paragraph is invalid; flush it, and note the new paragraph to cache for.")

             (SETQ *TEDIT-CURRENTPARA-CACHE* NIL)
             (SETQ *TEDIT-CACHED-FMTSPEC* FMTSPEC))
         (freplace (LINEDESCRIPTOR LFMTSPEC) of LINE with FMTSPEC)
         IMAGESTREAM])

(\FORMATLINE.ALIGN
  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE PREVSP SPACELEFT OVERHANG LINETYPE)
                                                             (* ; "Edited  8-Mar-2023 12:45 by rmk")

    (* ;; "Do the formatting work for justified, centered, etc.  lines.  We calculate how much space between LX0 and right margin is not occupied by the natural widths of the characters cached in THISLINE.  For this calculation we back out spaces at the end of the line.  They are present for later display and selection, but are ignored for purposes of right, centered, and justified alignment.")

    (* ;; "")

    (* ;; "In hardcopy-display mode, LX1, LXLIM, SPACELEFT, and OVERHANG are all in scaled units, otherwise in natural stream units.  SPACELEFT+LXLIM-OVERHANG should be the right margin.")

    (* ;; "")

    (* ;; "The display-alignment is controlled by LX0 (offset from LEFTMARGIN) and LXLIM.  At entry, LXLIM is the natural width of the line-characters. LXLIM may embrace the extra spaces, but they are out in the right margin or beyond the window, invisible unless selected")

    (* ;; "SPACELEFT is what it takes to push the last visible character out to the right margin.  This is done by expanding spaces.  OVERHANG is what gets added to LXLIM because of white space after the last visible.  The OVERHANG white space is not expanded.")

    (* ;; "")

    (* ;; "NOTE:  In hardcopy-display mode, the horizontal positions (margins and character widths) are in hardcopy units.  At the end we scale them back to screen points.  The vertical parameters (line-leading etc.) have not been up-scaled and don't need to be down-scaled.")

    (LET ((LINELEAD (fetch LINELEAD of FMTSPEC))
          (SCALE (ffetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC)))

         (* ;; "Vertical stuff first.  ")

         (freplace (LINEDESCRIPTOR DESCENT) of LINE with (fetch (LINEDESCRIPTOR LTRUEDESCENT)
                                                            of LINE))
         (freplace (LINEDESCRIPTOR ASCENT) of LINE with (fetch (LINEDESCRIPTOR LTRUEASCENT)
                                                           of LINE))
                                                             (* ; 
                                                    "Save the true ascent value for display purposes")
         (CL:WHEN LINELEAD
             (add (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                  LINELEAD)
             (add (ffetch (LINEDESCRIPTOR DESCENT) of LINE)
                  LINELEAD))
         (CL:WHEN (AND (ffetch (LINEDESCRIPTOR 1STLN) of LINE)
                       (ffetch LEADBEFORE of FMTSPEC))       (* ; "Set paragraph pre-leading")
             (add (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                  (fetch LEADBEFORE of FMTSPEC))
             (add (ffetch (LINEDESCRIPTOR ASCENT) of LINE)
                  (ffetch LEADBEFORE of FMTSPEC)))
         (CL:WHEN (AND (ffetch (LINEDESCRIPTOR LSTLN) of LINE)
                       (ffetch LEADAFTER of FMTSPEC))        (* ; "Set paragraph post-leading")
             (add (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                  (ffetch LEADAFTER of FMTSPEC))
             (add (ffetch (LINEDESCRIPTOR DESCENT) of LINE)
                  (ffetch LEADAFTER of FMTSPEC)))

         (* ;; "")

         (* ;; "Horizontal alignment--distribute SPACELEFT according to QUAD.   ")

         (freplace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
         (CL:WHEN (EQ 'JUSTIFIED (fetch QUAD of FMTSPEC))
                (\FORMATLINE.JUSTIFY LINE THISLINE PREVSP SPACELEFT LINETYPE))
         (\FORMATLINE.PURGE.SPACES PREVSP)

         (* ;; "")

         (* ;; "Done with spaces, expanded or not.  Down scale if hard-copy display mode")

         (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)
             (change (ffetch (LINEDESCRIPTOR LX1) of LINE)
                    (HCUNSCALE SCALE DATUM))
             (change (ffetch (LINEDESCRIPTOR LXLIM) of LINE)
                    (HCUNSCALE SCALE DATUM))
             (SETQ SPACELEFT (HCUNSCALE SCALE SPACELEFT))
             (SETQ OVERHANG (HCUNSCALE SCALE OVERHANG))

             (* ;; "Scale the character widths to points, propagating rounding error along the way. LOST starts at .5 pt so that rounding doesn't clip the last character")

             (for CHARSLOT REDUCED (LOST _ 0.5) incharslots THISLINE when CHAR
                do (SETQ REDUCED (FPLUS LOST (FQUOTIENT CHARW SCALE))) 
                                                             (* ; 
                                                         "Include the previously lost point-fraction")
                   [SETQ LOST (FDIFFERENCE REDUCED (SETQ REDUCED (FIX REDUCED]
                   (replace (CHARSLOT CHARW) of CHARSLOT with REDUCED)))

         (* ;; "")

         (SELECTQ (ffetch (FMTSPEC QUAD) of FMTSPEC)
             (RIGHT                                          (* ; "Move over to the right margin")
                    (add (ffetch (LINEDESCRIPTOR LX1) of LINE)
                         SPACELEFT)
                    (add (ffetch (LINEDESCRIPTOR LXLIM) of LINE)
                         SPACELEFT))
             (CENTERED                                       (* ; "Split the difference ")
                       (add (ffetch (LINEDESCRIPTOR LX1) of LINE)
                            (FOLDLO SPACELEFT 2))
                       (add (fetch (LINEDESCRIPTOR LXLIM) of LINE)
                            (FOLDLO SPACELEFT 2)))
             NIL])

(\FORMATLINE.JUSTIFY
  [LAMBDA (LINE THISLINE PREVSP SPACELEFT LINETYPE)          (* ; "Edited  7-Mar-2023 18:01 by rmk")
                                                             (* ; "Edited  2-Mar-2023 22:45 by rmk")
                                                             (* ; "Edited 22-Oct-2022 00:06 by rmk")
                                                             (* ; "Edited 29-Mar-94 12:36 by jds")

    (* ;; "The spaces in this line are to be expanded to eat up SPACELEFT so that the last visible character will align at the right margin.  SPACELELEFT may be in hardcopy-display scaled units.")

    (CL:WHEN (AND PREVSP (IGREATERP SPACELEFT 0))
        (LET (NATURALWIDTHS COMMONWIDTH)
             [if (EQ LINETYPE 'TRUEHARDCOPY)
                 then 
                      (* ;; "Original code removed overhanging spaces, so that LXLIM and the last charslot of THISLINE are consistent, and SPACELEFT is backed off.  But now, SPACELEFT only measures out to the margin, so doesn't need to be further adjusted (OVERHANG deals with that).  So, if the hardcopy stream doesn't mind printing extra spaces, we don't have to pull things back.  Here we just have to measure the sum of the natural widths, to do the space factor.")

                      [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP) by (CHAR SPSLOT) while SPSLOT
                                             sum (PROG1 (CHARW SPSLOT)
                                                     (CL:UNLESS (CHAR SPSLOT)
                                                             (* ; "Some early spaces may not expand")
                                                         (replace (THISLINE TLFIRSTSPACE)
                                                            of THISLINE with SPSLOT)))]
               else 
                    (* ;; "Typically all the spaces on the line have the same natural width and we can avoid floating point below.")

                    (* ;; "NB we operate in 32 x value form, for rounding ease and accuracy on screen-point display streams.  .")

                    [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP)
                                             CHARW FIRSTWIDTH (NSPACES _ 0)
                                             (ALLSAME _ T) by (CHAR SPSLOT)
                                           first (SETQ FIRSTWIDTH (CHARW SPSLOT)) while SPSLOT
                                           sum (SETQ CHARW (CHARW SPSLOT))
                                               (add NSPACES 1)
                                               (CL:UNLESS (IEQP CHARW FIRSTWIDTH)
                                                      (SETQ ALLSAME NIL))
                                               CHARW
                                           finally (CL:WHEN ALLSAME
                                                       (SETQ COMMONWIDTH
                                                        (IPLUS (UNFOLD FIRSTWIDTH 32)
                                                               (IQUOTIENT (UNFOLD SPACELEFT 32)
                                                                      NSPACES))))]
                    (if COMMONWIDTH
                        then 
                             (* ;; "Fast loop for the more common case where all the spaces on a line are of the same width. Multiply by 32 to keep rounding precision. Avoids floating point allocation.")

                             (for (SPSLOT _ PREVSP)
                                  EXPANDED
                                  (LOST _ 0) by (CHAR SPSLOT) while SPSLOT
                                do (SETQ EXPANDED (IPLUS LOST COMMONWIDTH))
                                   (replace (CHARSLOT CHARW) of SPSLOT with (FOLDLO EXPANDED 32))
                                   (SETQ LOST (IMOD EXPANDED 32)))
                      else 
                           (* ;; "The slow loop is for spaces of difference sizes. It allocates 3 floating point numbers per space.  ")

                           (for (SPSLOT _ PREVSP)
                                EXPANDED NEWW (LOST _ 0.0)
                                (MULTIPLIER _ (FPLUS 1.0 (FQUOTIENT SPACELEFT NATURALWIDTHS)))
                              by (CHAR SPSLOT) while SPSLOT do 

                                 (* ;; "Spaces are in different fonts with different widths. What we lose in rounding at one space we add back in the next, until we finally get resynchronized.  The effect is that a later loss may ripple to a few earlier spaces.")

                                                               (SETQ EXPANDED
                                                                (FPLUS LOST (FTIMES (CHARW SPSLOT)
                                                                                   MULTIPLIER)))
                                                               (SETQ NEWW (FIXR EXPANDED))
                                                               (freplace (CHARSLOT CHARW)
                                                                  of SPSLOT with NEWW)
                                                               (SETQ LOST (FDIFFERENCE EXPANDED NEWW]

             (* ;; "The \DISPLAYLINE for displaystreams does its own (Maiko) BLTCHAR, so the TLSPACEFACTOR  isn't actually used for display, but hardcopy streams make use of it.")

             (add (ffetch (LINEDESCRIPTOR LXLIM) of LINE)
                  SPACELEFT)
             (freplace (THISLINE TLSPACEFACTOR) of THISLINE with (FQUOTIENT (IPLUS NATURALWIDTHS 
                                                                                   SPACELEFT)
                                                                        NATURALWIDTHS))))])

(\FORMATLINE.TABS
  [LAMBDA (TEXTOBJ TABSPEC SCALE CHARSLOT LX1 TX PRIORTAB CLEANINGUP)
                                                             (* ; "Edited  9-Mar-2023 23:25 by rmk")
                                                             (* ; "Edited  5-Mar-2023 22:54 by rmk")
                                                             (* ; "Edited  4-Mar-2023 18:28 by rmk")
                                                             (* ; "Do the formatting work for a tab.")

    (* ;; "PRIORTAB is the outstanding tab, if any, that has to be resolved.  This will be a centered or flush right tab.  ")

    (* ;; "Specific tabs are relative to the true leftmargin; in that coordinate system the current position is LX1+TX (in properly scaled units. The TX entries in the prior tab are also in the scaled margin coordinate system.  TABSPEC is also properly scaled.")

    (* ;; "")

    (* ;; "If CLEANINGUP is non-NIL, then we're at the end of the line, and only need to resolve the outstanding tab.")

    (* ;; "This assumes that every thing except the constants is already hardcopy-scaled")

    (* ;; "")

    (* ;; "The return provides the number of (scaled) width-units that must be added to the TX in \FORMATLINE..  This includes resolving (and updating THISLINE) for the prior tab's now-known width, and adding the width for this tab if it can be resolved.  If it can't be resolved, the returned PENDINGTAB includes the prior width, so that can be discharged into \FORMATLINE's TX.")

    (* ;; "")

    (* ;; "GRAIN is the granularity of the tab spacing; anything within GRAIN will slop over to the next tab.  This is to finesse rounding problems when going among various devices.")

    (* ;; "")

    (add TX LX1)                                             (* ; "Margin relative")
    (PROG (NEXTTAB NEXTTABTYPE NEXTTABX DFLTTABX GRAIN (PRIORTABWIDTH 0)
                 (THISTABWIDTH 0))
          (CL:WHEN PRIORTAB

              (* ;; "If there is a prior tab to resolve, do that first--it affects the perceived current X value, which affects later tabs")

              (* ;; "TX - OLDTX = W, the width of the segment after the prior tab. The target X (right tab)  is TABX - W ")

              [SETQ PRIORTABWIDTH (IMAX (ITIMES SCALE 3)
                                        (IDIFFERENCE
                                         (IDIFFERENCE (fetch (PENDINGTAB PTTABX) of PRIORTAB)
                                                (SELECTQ (fetch (PENDINGTAB PTTYPE) of PRIORTAB)
                                                    ((CENTERED DOTTEDCENTERED) 
                                                             (* ; "Centered around the tab X")
                                                         (FOLDLO (IDIFFERENCE TX (fetch (PENDINGTAB
                                                                                         PTOLDTX)
                                                                                    of PRIORTAB))
                                                                2))
                                                    ((RIGHT DOTTEDRIGHT DECIMAL DOTTEDDECIMAL) 
                                                             (* ; "Snug up against the tab X")
                                                         (IDIFFERENCE TX (fetch (PENDINGTAB PTOLDTX)
                                                                            of PRIORTAB)))
                                                    (SHOULDNT)))
                                         (fetch (PENDINGTAB PTOLDTX) of PRIORTAB]
              (replace (CHARSLOT CHARW) of (fetch (PENDINGTAB PTCHARSLOT) of PRIORTAB) with 
                                                                                        PRIORTABWIDTH
                     )
              (add TX PRIORTABWIDTH))                        (* ; "Done with the past")
          (CL:WHEN CLEANINGUP                                (* ; "Cleaning up at end of line.")
              (RETURN PRIORTABWIDTH))                        (* ; 
                                            "Default Tab width, if there aren't any real tabs to use")
          (SETQ NEXTTAB (find TAB in (CDR TABSPEC) suchthat (IGREATERP (fetch TABX of TAB)
                                                                   TX)))
                                                             (* ; "The next tab on this line, if any")
          (SETQ NEXTTABTYPE (OR (AND NEXTTAB (fetch TABKIND of NEXTTAB))
                                'LEFT))                      (* ; 
                                    "The type of the next tab  is LEFT if we use the default spacing")
          [SETQ NEXTTABX (COND
                            (NEXTTAB                         (* ; 
                                                    "There is a real tab to go to; use its location.")
                                   (fetch TABX of NEXTTAB))
                            (T (SETQ DFLTTABX (OR (FIXP (CAR TABSPEC))
                                                  DEFAULTTAB))
                               (SETQ GRAIN (FOLDLO SCALE 2))

                               (* ;; "No real tab; use the next multiple of the default spacing.")

                               (ITIMES DFLTTABX (ADD1 (IQUOTIENT (IPLUS GRAIN TX)
                                                             DFLTTABX]
                                                             (* ; "The next tab's X value")
          (CL:WHEN (FMEMB NEXTTABTYPE '(DOTTEDLEFT DOTTEDCENTERED DOTTEDRIGHT DOTTEDDECIMAL))

              (* ;; "Change a dotted-leader tab to Meta,TAB, so the line displayers can recognize that they need to do special output that can't be precomputed here.  By the same token, we could replace the resolved tab with a widened space, since we know that space-expansion is suppressed when a tab is seen. ")

              (replace (CHARSLOT CHAR) of CHARSLOT with (CHARCODE Meta,TAB)))
          (RETURN (if (FMEMB NEXTTABTYPE '(LEFT DOTTEDLEFT))
                      then 
                           (* ;; 
   "Prior and LEFT tabs are both resolved.  At least 1 point for display-selection?  1 isn't scaled?")

                           (SETQ THISTABWIDTH (IMAX 1 (IDIFFERENCE NEXTTABX TX)))
                           (replace (CHARSLOT CHARW) of CHARSLOT with THISTABWIDTH)
                           (IPLUS PRIORTABWIDTH THISTABWIDTH)
                    else (replace (CHARSLOT CHARW) of CHARSLOT with 0) 
                                                             (* ; "All others:  wait for this width")

                         (* ;; "PTOLDTX and PTTABX in absolute coordinates for future comparisons (on the same line with same LX1).")

                         (create PENDINGTAB
                                PTRESOLVEDWIDTH _ (IPLUS PRIORTABWIDTH THISTABWIDTH)
                                PTTYPE _ NEXTTABTYPE
                                PTTABX _ NEXTTABX
                                PTCHARSLOT _ CHARSLOT
                                PTOLDTX _ TX])

(\FORMATLINE.SCALETABS
  [LAMBDA (TABSPEC SCALE)                                    (* ; "Edited  7-Mar-2023 21:06 by rmk")
                                                             (* ; "Edited  5-Mar-2023 20:39 by rmk")

    (* ;; "Scales tab stops to hardcopy units (possibly hardcopy display)")

    (CL:WHEN (type? FMTSPEC TABSPEC)
        (SETQ TABSPEC (ffetch (FMTSPEC TABSPEC) of TABSPEC)))
    (CL:UNLESS (CAR TABSPEC)
        (SETQ TABSPEC (CONS DEFAULTTAB (CDR TABSPEC))))
    (if (EQ SCALE 1)
        then TABSPEC
      else (CONS (HCSCALE SCALE (CAR TABSPEC))
                 (for TAB in (CDR TABSPEC) collect (create TAB using TAB TABX _
                                                                     (HCSCALE SCALE
                                                                            (fetch (TAB TABX)
                                                                               of TAB])

(\FORMATLINE.PURGE.SPACES
  [LAMBDA (PREVSP UNTILSP)                                   (* ; "Edited 10-Mar-2023 12:28 by rmk")
                                                             (* jds " 9-NOV-83 17:12")

    (* ;; "Walks PREVSP back through the chain until it reaches UNTILSP, either NIL or a back up point.  Each of the slots it passes over is reverted to a space, return is the slot of early expandable spaces, if any.")

    (bind OPREVSP until (EQ PREVSP UNTILSP) do (SETQ OPREVSP PREVSP)
                                               (SETQ PREVSP (CHAR OPREVSP))
                                               (CL:WHEN (SMALLP PREVSP)
                                                   (HELP 'PURGE))
                                               (replace (CHARSLOT CHAR) of OPREVSP
                                                  with (CHARCODE SPACE)))
    PREVSP])

(\FORMATLINE.EMPTY
  [LAMBDA (TEXTOBJ CH#1 LINE)                                (* ; "Edited  7-Mar-2023 23:11 by rmk")
                                                             (* ; "Edited  5-Mar-2023 22:57 by rmk")
                                                             (* ; "Edited  4-Mar-2023 21:40 by rmk")

    (* ;; "CH#1 is presumably beyond the end.   This returns an empty line descriptor that is set up correctly wrt leading and font.  This is used by \FILLWINDOW to create the dummy line at end of document when you hit an EOL there.  (For safety, \FORMATLINE also calls this if CHE1 doesn't pick out a real piece.)")
                                                             (* ; ".")

    (* ;; "NOTE: this follows the original in not distinguishing hardcopy-display mode. Presumably empty is empty.")

    (* ;; "Original code asked for the piece at TEXTLEN (last piece?) to get its looks, but those looks would be the TEXTOBJ default looks anyway. ")

    (CL:UNLESS LINE
        [SETQ LINE (create LINEDESCRIPTOR
                          RIGHTMARGIN _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                          YBOT _ (SUB1 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ])
    (LET (CHARSLOT FONT ASC DESC LM FMTSPEC (THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ)))
         (\FORMATLINE.SETUP TEXTOBJ NIL LINE (WINDOWPROP (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                                                    'DSP))
         (SETQ FMTSPEC (fetch (LINEDESCRIPTOR LFMTSPEC) of LINE))
         (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
         (replace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
         (freplace (THISLINE DESC) of THISLINE with LINE)

         (* ;; "Get looks from the TSTREAM, so that \DISPLAYLINE works.  ")

         (FILLCHARSLOT CHARSLOT NIL (OR (fetch (TEXTSTREAM CURRENTLOOKS) of (fetch (TEXTOBJ 
                                                                                          STREAMHINT)
                                                                               of TEXTOBJ))
                                        (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                        (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)))

         (* ;; "Not sure what might break if even an emptyTHISLINE doesn't start with charlooks.  ")

         (* ;; 
        " Font preferences: the caret looks, else the default for this text, else the system default")

         (SETQ FONT (CL:IF (CHARW CHARSLOT)
                        (fetch CLFONT of (CHARW CHARSLOT))
                        DEFAULTFONT))
         (SETQ ASC (FONTPROP FONT 'ASCENT))
         (SETQ DESC (FONTPROP FONT 'DESCENT))
         (SETQ LM (IPLUS 8 (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                         (fetch 1STLEFTMAR of FMTSPEC)))
         [with LINEDESCRIPTOR LINE (SETQ LCHAR1 CH#1)
               (SETQ LCHARLIM CH#1)
               (SETQ 1STLN T)
               (SETQ LSTLN T)
               (SETQ LMARK NIL)
               (SETQ LX1 LM)
               (SETQ LXLIM LM)
               (SETQ FORCED-END CH#1)
               (SETQ DIRTY NIL)
               (SETQ LHASPROT NIL)
               (SETQ LFMTSPEC FMTSPEC)
               (SETQ LEFTMARGIN LM)
               (SETQ RIGHTMARGIN (CL:IF (ZEROP (fetch RIGHTMAR of FMTSPEC))
                                     (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                            8)
                                     (fetch RIGHTMAR of FMTSPEC)))
               (SETQ LTRUEASCENT ASC)
               (SETQ LTRUEDESCENT DESC)
               (SETQ LHEIGHT (CL:IF (ZEROP (IPLUS ASC DESC))
                                 (FONTPROP (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                                    (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS
                                                                                   ) of TEXTOBJ)))
                                               DEFAULTFONT)
                                        'HEIGHT)
                                 (IPLUS ASC DESC))]

         (* ;; "Just to initialize the rest of the fields--no intended transformations.")

         (\FORMATLINE.ALIGN TEXTOBJ LINE FMTSPEC THISLINE NIL 0 0)
         LINE])

(\FORMATLINE.UPDATELOOKS
  [LAMBDA (TSTREAM PC)                                       (* ; "Edited  7-Mar-2023 20:54 by rmk")
                                                             (* ; "Edited 30-May-91 21:47 by jds")

(* ;;; "Called from \INSTALL.PIECE under \FORMATLINE only when the new piece has different looks than the previous piece. This updates the formatting fields such as ASCENTC, DESCENTC, etc.  This assumes that the \INSTALL.PIECE caller has passed over any invisible pieces, and that TSTREAM is set up consistently with looks that match PC")

    (* ;; "RMK: Storing the  looks in theTEXTSTREAM here seems to be an attempt to avoid calls to the \TEDIT.APPLY.STYLES function in the transition from piece to piece.  Presumably, the looks of each piece may be incomplete, and missing fields are filled in from the current (sequence of?) styles.  If the style is changed dynamically, then (also presumably) all of the currently displayed pieces should be upgraded.  But that doesn't appear to happen.")

    (* ;; "A simpler implementation, whether dynamic or not, would be to expand the looks when the piece is created or the style changes, so that each piece is always references its completed looks.  But the piece also needs to keep track of its partial looks, for restyling and for saving.")

    (* ;; "Style sheets are undocumented, I suspect that this was never really thought through.")

    (DECLARE (USEDFREE LINETYPE CHARSLOT CHNO PROTECTED OFFSET ASCENTC DESCENTC FONT IMAGESTREAM KERN
                    ))
    (CL:UNLESS PC                                            (* ; 
                                                          "Ran off the end ? Skips the ENDOFSTREAMOP")
        (RETFROM (FUNCTION \TEXTBIN)
               NIL))
    (LET (PLOOKS INVISIBLERUN SCALE CLOFFSET)

         (* ;; "")

         (* ;; "We have to adjust the CHNO to pass over invisible pieces, and to record the number of characters we passed over in THISLINE's character vector.  This maintains the correspondence between the indexing of actual characters in the vector and characters positions in the stream.  This information isn't need for display, but TEDIT.SCAN.LINE requires that mapping.")

         (* ;; "Invisible runs are coded in a character slot, like other non-character entries (looks, objects) by putting a NIL in the CHAR field of a slot and putting the non-character information in the CHARWIDTH field.  Thus, an invisible run is represented as a pair (NIL,runlength).")

         (SETQ INVISIBLERUN (for old PC inpieces PC while (OR (ZEROP (PLEN PC))
                                                              (fetch (CHARLOOKS CLINVISIBLE)
                                                                 of (PLOOKS PC)))
                               sum (PLEN PC)))
         (if (EQ 0 INVISIBLERUN)
             then 
                  (* ;; "If the looks are the same as current looks, we don't need to change anything.  APPLY STYLES AT PIECE CREATION??")

                  (SETQ PLOOKS (PLOOKS PC))
                  (CL:UNLESS (EQ PLOOKS (ffetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))
                      (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with PLOOKS)

                      (* ;; "")

                      (SETQ OFFSET (OR (ffetch (CHARLOOKS CLOFFSET) of PLOOKS)
                                       0))
                      (SETQ FONT (fetch (CHARLOOKS CLFONT) of PLOOKS))
                                                             (* ; 
                                                             "CLFONT is a display font or a class")
                      [if (EQ LINETYPE 'TRUEHARDCOPY)
                          then (SETQ FONT (FONTCOPY FONT 'DEVICE IMAGESTREAM)) 
                                                             (* ; "Hardcopy widths and verticals")
                               (SETQ ASCENTC (ffetch \SFAscent of FONT))
                               (SETQ DESCENTC (ffetch \SFDescent of FONT))
                               (CL:UNLESS (EQ OFFSET 0)
                                   (SETQ OFFSET (HCSCALE (DSPSCALE NIL IMAGESTREAM)
                                                       OFFSET)))
                        else (CL:WHEN (type? FONTCLASS FONT) (* ; "Display widths and verticals")
                                 (SETQ FONT (FONTCOPY FONT 'DEVICE 'DISPLAY)))
                             (SETQ ASCENTC (ffetch \SFAscent of FONT))
                             (SETQ DESCENTC (ffetch \SFDescent of FONT))
                             (CL:WHEN (EQ LINETYPE 'HARDCOPYDISPLAY)
                                                             (* ; "Switch widths to hardcopy")
                                 (SETQ FONT (FONTCOPY FONT 'DEVICE IMAGESTREAM)))]

                      (* ;; "")

                      (SETQ KERN (LISTGET (ffetch (CHARLOOKS CLUSERINFO) of PLOOKS)
                                        'KERN))

                      (* ;; "Apparently, KERN's are given in display points, which seems odd.  So here we scale up. Is there just a single kern value? Very strange.")

                      (CL:WHEN KERN
                          (SETQ KERN (HCSCALE (DSPSCALE NIL IMAGESTREAM)
                                            KERN)))
                      (STREAMPROP TSTREAM 'KERN KERN)
                      (CL:WHEN (ffetch (CHARLOOKS CLPROTECTED) of PLOOKS)
                                                             (* ; 
                                                         "Mark the line as containing protected text")
                          (SETQ PROTECTED T))
                      (PUSHCHAR CHARSLOT NIL PLOOKS))
           else (PUSHCHAR CHARSLOT NIL INVISIBLERUN)
                (add CHNO INVISIBLERUN)
                (\INSTALL.PIECE PC 0))
         PC])

(\CLEARTHISLINE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:09 by rmk")

    (* ;; "This sets it up for a consistency checker to determine that something has gone wrong.  Only called in an assertion.")

    (create THISLINE smashing THISLINE DESC _ 'NODESC TLSPACEFACTOR _ 'NOSPACEFACTOR TLFIRSTSPACE _
                           'NOTLFIRSTSPACE NEXTAVAILABLECHARSLOT _ (FIRSTCHARSLOT THISLINE))
    (for CHARSLOT _ (FIRSTCHARSLOT THISLINE)
         (LASTCHARSLOT _ (LASTCHARSLOT THISLINE)) until (EQ CHARSLOT LASTCHARSLOT)
       do (PUSHCHAR CHARSLOT 'BADCHAR 'BADCHARW))
    THISLINE])

(\TLVALIDATE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:16 by rmk")

    (* ;; "Check validity of THISLINE, either just before or anytime after \FORMATLINE.JUSTIFY")

    [with THISLINE THISLINE (CL:WHEN (EQ DESC 'NODESC)
                                   (HELP "INVALID THISLINE" DESC))
          (CL:WHEN (EQ TLSPACEFACTOR 'NOSPACEFACTOR)
                 (HELP "INVALID THISLINE" TLSPACEFACTOR))
          (CL:WHEN (EQ TLFIRSTSPACE 'NOTLFIRSTSPACE)
                 (HELP "INVALID THISLINE" TLFIRSTSPACE))
          (CL:UNLESS (CHARSLOTP NEXTAVAILABLECHARSLOT THISLINE)
              (HELP "INVALID THISLINE" 'NEXTAVAILABLE))]
    (for CHARSLOT incharslots THISLINE do (if CHAR
                                              then (CL:UNLESS (OR (SMALLP CHAR)
                                                                  (CHARSLOTP CHAR THISLINE))

                                                       (* ;; 
                                                      "CHARSLOTP if spaces haven't been instantiated")

                                                       (HELP "INVALID THISLINE" 'BADCHAR))
                                                   (CL:UNLESS (SMALLP CHARW)
                                                       (HELP "INVALID THISLINE" 'BADCHARW))
                                            elseif (OR (SMALLP CHARW)
                                                       (type? CHARLOOKS CHARW))
                                            else (HELP "INVALID THISLINE" 'BADCHARW])
)

(RPAQ? *TEDIT-CACHED-FMTSPEC* NIL)



(* ; "Heuristic for \FORMATLINE")

(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS *TEDIT-CACHED-FMTSPEC*)
)
(DEFINEQ

(\DISPLAYLINE
  [LAMBDA (TEXTOBJ LINE WINDOW)                              (* ; "Edited  9-Mar-2023 14:06 by rmk")
                                                             (* ; "Edited  7-Mar-2023 23:11 by rmk")

    (* ;; "Display the line of text LINE in the edit window where it belongs.")

    (* ;; "Validate the incoming arguments so ffetch can be used consistently for all their field extractions.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (\DTEST LINE 'LINEDESCRIPTOR)
    (LET ((WINDOWDS (WINDOWPROP (OR WINDOW (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
                           'DSP))
          (THISLINE (\DTEST (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)
                           'THISLINE))
          (OLDCACHE (fetch (LINECACHE LCBITMAP) of (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)))
          (DS (ffetch (TEXTOBJ DISPLAYCACHEDS) of TEXTOBJ))
          CACHE XOFFSET CLIPLEFT CLIPRIGHT DISPLAYDATA DDPILOTBBT CURY LHEIGHT)
         [SETQ LHEIGHT (COND
                          ((ffetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                                             (* ; 
                                    "So if theres a base-to-base measure, we clear everything right.")
                           (IMAX (IDIFFERENCE (ffetch (LINEDESCRIPTOR YBOT)
                                                 of (ffetch (LINEDESCRIPTOR PREVLINE) of LINE))
                                        (ffetch (LINEDESCRIPTOR YBOT) of LINE))
                                 (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)))
                          (T (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE]
         (SETQ CACHE (\TEDIT.LINECACHE (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)
                            (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE)
                            LHEIGHT))
         (CL:UNLESS (EQ CACHE OLDCACHE)                      (* ; 
                 "We changed the bitmaps because this line was bigger--update the displaystream, too")
             (DSPDESTINATION CACHE DS)
             (DSPCLIPPINGREGION (create REGION
                                       LEFT _ 0
                                       BOTTOM _ 0
                                       WIDTH _ (fetch BITMAPWIDTH of CACHE)
                                       HEIGHT _ (fetch BITMAPHEIGHT of CACHE))
                    DS)
             (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE))
         (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE)
                                                             (* ; "Clear the line cache")
         (CL:WHEN (AND (NOT (ZEROP (fetch (LINEDESCRIPTOR LCHAR1) of LINE)))
                       (ILEQ (ffetch (LINEDESCRIPTOR LCHAR1) of LINE)
                             (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                       (IGEQ (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                             (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

             (* ;; "Only display the line if it contains text (CHAR1 > 0), appears before the end of the text, and is on-screen.")

             (CL:UNLESS (EQ (fetch (THISLINE DESC) of THISLINE)
                            LINE)                            (* ; 
                                                            "No image cache -- re-format and display")
                 (\FORMATLINE TEXTOBJ (ffetch (LINEDESCRIPTOR LCHAR1) of LINE)
                        LINE))
             (MOVETO (ffetch (LINEDESCRIPTOR LX1) of LINE)
                    (ffetch (LINEDESCRIPTOR DESCENT) of LINE)
                    DS)
             (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DS))
                                                             (* ; 
                                                    "IMAGEDATA of the display stream, not textstream")
             (SETQ DDPILOTBBT (ffetch DDPILOTBBT of DISPLAYDATA))
             (SETQ XOFFSET (fetch DDXOFFSET of DISPLAYDATA))

             (* ;; "The X position of the left edge of the window, since \TEDIT.BLTCHAR works on the screen bitmap itself.")

             (SETQ CLIPLEFT (fetch DDClippingLeft of DISPLAYDATA))
                                                             (* ; 
                       "The left and right edges of the clipping region for the text display window.")
             (SETQ CLIPRIGHT (fetch DDClippingRight of DISPLAYDATA))

             (* ;; "We know that the line's first CLOOKS comes before the first CHAR")

             (for CHARSLOT incharslots THISLINE bind CLOOKS LOOKSTARTX
                                                     (TX _ (IPLUS XOFFSET (ffetch (LINEDESCRIPTOR
                                                                                   LX1) of LINE)))
                                                     (TERMSA _ (ffetch (TEXTOBJ TXTTERMSA)
                                                                  of TEXTOBJ))
                do 
                   (* ;; 
              "Display the line character by character.  CHAR and CHARW are bound to CHARSLOT values")

                   (CL:WHEN (EQ CHAR (CHARCODE EOL))         (* ; 
                              "\FORMATLINE used space-width for EOL and FORM. Display them that way.")
                       (SETQ CHAR (CHARCODE SPACE)))
                   (SELCHARQ CHAR
                        ((TAB Meta,TAB) 
                             (CL:WHEN (OR (EQ CHAR (CHARCODE Meta,TAB))
                                          (fetch CLLEADER of CLOOKS)
                                          (EQ (fetch CLUSERINFO of CLOOKS)
                                              'DOTTEDLEADER))

                                 (* ;; "Not just white space, have to fill in with dots.")

                                 (\DISPLAYLINE.TABS CHARW DS TX TERMSA LINE CLOOKS DISPLAYDATA 
                                        DDPILOTBBT CLIPRIGHT TEXTOBJ))
                             (add TX CHARW))
                        (NIL                                 (* ; 
    "LOOKS or SMALLP-invisibles. Line-start looks are guaranteed to come before any character/object")
                             [if (type? CHARLOOKS CHARW)
                                 then (replace DDXPOSITION of DISPLAYDATA with (IDIFFERENCE TX 
                                                                                      XOFFSET)) 
                                                             (* ; 
                                              "Make the displaystream reflect our current X position")
                                      (CL:WHEN CLOOKS        (* ; 
                                              "Underline/overline/strike the just-finished looks run")
                                          (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                 (ffetch (LINEDESCRIPTOR DESCENT) of LINE)))
                                      (SETQ CLOOKS CHARW)
                                      (DSPFONT (fetch CLFONT of CLOOKS)
                                             DS)
                                      (CL:UNLESS (EQ 0 (fetch CLOFFSET of CLOOKS))
                                                             (* ; "Account for super/subscripting")
                                          (RELMOVETO 0 (fetch CLOFFSET of CLOOKS)
                                                 DS))
                                      (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET)) 
                                                             (* ; 
                                        "LOOKSTARTX: Starting X position for the current-looks text.")
                               elseif (SMALLP CHARW)
                               else (SHOULDNT "UNRECOGNIZED CHARW") 

                                    (* ;; 
                           "Discretionary hyphens are invisible (CHARW=1), this should never happen.")

                                 (* ;; "Original comment: A character we've suppressed as part of line formatting (e.g., a discretionary hyphen we didn't use to break the line).  Show it as a thin black line.")

                                    (AND NIL (BLTSHADE BLACKSHADE DS TX 0 1 100 'PAINT])
                        (PROGN (if (IMAGEOBJP CHAR)
                                   then 
                                        (* ;; "Go to the base line, left edge of the image region.")

                                        (SETQ CURY (DSPYPOSITION NIL DS))
                                        (MOVETO (IDIFFERENCE TX XOFFSET)
                                               CURY DS)
                                        (APPLY* (IMAGEOBJPROP CHAR 'DISPLAYFN)
                                               CHAR DS 'DISPLAY (ffetch (TEXTOBJ STREAMHINT)
                                                                   of TEXTOBJ))
                                        (DSPFONT (fetch CLFONT of CLOOKS)
                                               DS)           (* ; 
                                         "Restore the character font, move to just after the object.")
                                        (MOVETO (IDIFFERENCE TX XOFFSET)
                                               CURY DS)
                                 elseif TERMSA
                                   then                      (* ; "Using special instrns from TERMSA")
                                        (\DSPPRINTCHAR DS CHAR)
                                 else                        (* ; "Native charcodes")
                                      (MI-TEDIT.BLTCHAR CHAR DS TX DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                               (add TX CHARW))) finally (replace DDXPOSITION of DISPLAYDATA
                                                           with (IDIFFERENCE TX XOFFSET)) 
                                                             (* ; 
                                        "Make any necessary looks mods to the last run of characters")
                                                      (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                             (ffetch (LINEDESCRIPTOR DESCENT)
                                                                of LINE))))
         (BITBLT CACHE 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                LHEIGHT
                'INPUT
                'REPLACE)                                    (* ; 
                          "Paint the cached image on the screen (this lessens flicker during update)")
         (CL:WHEN (fetch (FMTSPEC FMTREVISED) of (fetch (LINEDESCRIPTOR LFMTSPEC) of LINE))
                                                             (* ; 
                                                       "This paragraph has been revised, so mark it.")
             (\TEDIT.MARK.REVISION TEXTOBJ (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE)
                    WINDOWDS LINE))
         (SELECTQ (ffetch (LINEDESCRIPTOR LMARK) of LINE)
             (GREY                                           (* ; 
                "This line has some property that isn't visible to the user.  Tell him to be careful")
                   (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                          6 6 'TEXTURE 'PAINT 42405))
             (SOLID (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                           6 6 'TEXTURE 'PAINT BLACKSHADE))
             (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                    6 6 'TEXTURE 'REPLACE WHITESHADE])

(\DISPLAYLINE.TABS
  [LAMBDA (CW DS TX TERMSA LINE CLOOKS DISPLAYDATA DDPILOTBBT CLIPRIGHT TEXTOBJ)
                                                             (* ; "Edited  4-Mar-2023 22:17 by rmk")
                                                             (* ; "Edited  1-Oct-2022 11:35 by rmk")
                                                             (* ; "Edited 24-Sep-2022 21:19 by rmk")

    (* ;; "Fills in tab-space CW with dotted leaders.  LINE is only needed to get the FMTSPEC.  TEXTOBJ only needed to get hardcopy-display stream.  LTEXTOBJ seems to be set in hardcopy functions but not in basic setup.  Maybe because FMTSPEC's are cached?")

    (bind TTX DOTWIDTH (FMTSPEC _ (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE))
       first 
             (* ;; "The dots on successive lines may not align so well, in hardcopy display mode.  But that's not a mode that looks good anyway.  The TERMSA probably screws it anyway.")

             [SETQ DOTWIDTH (CL:IF (fetch (FMTSPEC FMTHARDCOPY) of FMTSPEC)
                                [HCUNSCALE (fetch (FMTSPEC FMTHARDCOPYSCALE) of FMTSPEC)
                                       (CHARWIDTH (CHARCODE %.)
                                              (FONTCOPY (fetch CLFONT of CLOOKS)
                                                     'DEVICE
                                                     (ffetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ]
                                (CHARWIDTH (CHARCODE %.)
                                       (fetch CLFONT of CLOOKS)))]
             [SETQ TTX (IPLUS TX DOTWIDTH (IDIFFERENCE DOTWIDTH (IREMAINDER TX DOTWIDTH]
       while (ILEQ TTX (IPLUS TX CW)) do (if TERMSA
                                             then            (* ; "Using special instrns from TERMSA")
                                                  (\DSPPRINTCHAR DS (CHARCODE %.))
                                           else              (* ; "Native charcodes")
                                                (MI-TEDIT.BLTCHAR (CHARCODE %.)
                                                       DS
                                                       (IDIFFERENCE TTX DOTWIDTH)
                                                       DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                                         (add TTX DOTWIDTH])

(\TEDIT.LINECACHE
  [LAMBDA (CACHE WIDTH HEIGHT)                               (* jds "21-Apr-84 00:52")

         (* Given a candidate line cache, return the bitmap, making sure it's at least 
         WIDTH by HEIGHT big.)

    (PROG ((BITMAP (fetch LCBITMAP of CACHE))
           CW CH)
          (SETQ CW (fetch BITMAPWIDTH of BITMAP))
          (SETQ CH (fetch BITMAPHEIGHT of BITMAP))
          (COND
             ((AND (IGEQ CW WIDTH)
                   (IGEQ CH HEIGHT))
              (RETURN BITMAP))
             (T (RETURN (replace LCBITMAP of CACHE with (BITMAPCREATE (IMAX CW WIDTH)
                                                               (IMAX CH HEIGHT])

(\TEDIT.CREATE.LINECACHE
  [LAMBDA (%#CACHES)                                         (* jds "21-Apr-84 00:58")
                                                             (* Create a linked-together set of 
                                                             LINECACHEs, for saving line images.)
    (PROG [(CACHES (for I from 1 to %#CACHES collect (create LINECACHE
                                                            LCBITMAP _ (BITMAPCREATE 100 15]
          [for CACHE on CACHES do                            (* Link the caches together.)
                                  (replace LCNEXTCACHE of (CAR CACHE) with (OR (CADR CACHE)
                                                                               (CAR CACHES]
          (RETURN CACHES])

(\TEDIT.BLTCHAR
  [LAMBDA (CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                                             (* jds " 9-Jan-86 17:14")

         (* Version of BLTCHAR peculiar to TEdit --
         relies on \DISPLAYLINE to make sure things keep working right.)

         (* puts a character on a guaranteed display stream.
         Much of the information needed by the BitBlt microcode is prestored by the 
         routines that change it. This is kept in the BitBltTable.)
                                                             (* knows about the representation of 
                                                             display stream image data)
                                                             (* MUST NOT POINT AT A WINDOW'S 
                                                             DISPLAYSTREAM!!!)

         (* ASSUMES THAT WE NEVER WANT TO PRINT TO THE LEFT OF ORIGIN 0 ON THE LINE CACHE 
         BITMAP, OR THAT IF WE DO, ALL BETS ARE OFF)

    (DECLARE (LOCALVARS . T))
    (PROG (NEWX LEFT RIGHT IMAGEWIDTH (CHAR8CODE (\CHAR8CODE CHARCODE)))
          [COND
             ((NEQ (ffetch DDCHARSET of DISPLAYDATA)
                   (\CHARSET CHARCODE))
              (\CHANGECHARSET.DISPLAY DISPLAYDATA (\CHARSET CHARCODE]
          (SETQ IMAGEWIDTH (\GETBASE (fetch DDCHARIMAGEWIDTHS of DISPLAYDATA)
                                  (\CHAR8CODE CHARCODE)))
          (SETQ NEWX (IPLUS CURX IMAGEWIDTH))
          (SETQ LEFT (IMAX 0 CURX))
          (SETQ RIGHT (IMIN CLIPRIGHT NEWX))
          (COND
             ((ILESSP LEFT RIGHT)                            (* Only print anything if there is a 
                                                             place to put it)
              (UNINTERRUPTABLY
                  (freplace PBTDESTBIT of DDPILOTBBT with LEFT)
                                                             (* Set up the bitblt-table source left)
                  (freplace PBTWIDTH of DDPILOTBBT with (IMIN IMAGEWIDTH (IDIFFERENCE RIGHT LEFT)))
                  (freplace PBTSOURCEBIT of DDPILOTBBT with (\GETBASE (fetch DDOFFSETSCACHE
                                                                         of DISPLAYDATA)
                                                                   (\CHAR8CODE CHARCODE)))
                  (\PILOTBITBLT DDPILOTBBT 0))
              T])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS MI-TEDIT.BLTCHAR MACRO [(CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                  (COND
                                     ((EQ 'MAIKO (MACHINETYPE))
                                      (SUBRCALL TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA
                                             DDPILOTBBT CLIPRIGHT))
                                     (T (\TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA 
                                               DDPILOTBBT CLIPRIGHT])
)
)
(DEFINEQ

(TEDIT.DELETELINE
  [LAMBDA (LINE TEXTOBJ WINDOW)                              (* ; "Edited 30-May-91 15:58 by jds")

         (* Remove a complete text line descriptor from the edit window, then move lower 
         lines up over it.)

    (PROG ((PREV (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
           (NEXT (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))) (* Fix up the line-descriptor chain to 
                                                             dis-include line)
          (COND
             (PREV (replace (LINEDESCRIPTOR NEXTLINE) of PREV with NEXT)))
          (COND
             (NEXT (replace (LINEDESCRIPTOR PREVLINE) of NEXT with PREV)))
          (\TEDIT.CLOSEUPLINES TEXTOBJ PREV NEXT NIL WINDOW) (* And fix up the screen to cover the 
                                                             blank space.)
      ])

(TEDIT.INSERT.DISPLAYTEXT
  [LAMBDA (TEXTOBJ CH CHWIDTH LINE XPOINT DS SEL)            (* ; "Edited 13-Aug-2022 23:37 by rmk")
                                                             (* ; "Edited 30-May-91 16:56 by jds")
                                                             (* This function does the actual 
                                                             displaying of typed-in text on the 
                                                             edit window.)
                                                             (* (PROG ((LOOKS (\TEDIT.APPLY.STYLES
                                                             (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                                             (fetch (TEXTOBJ INSERTPC) of TEXTOBJ) 
                                                             TEXTOBJ)) (TERMSA (fetch
                                                             (TEXTOBJ TXTTERMSA) of TEXTOBJ)) DY 
                                                             FONT) (DSPFONT (SETQ FONT
                                                             (fetch CLFONT of LOOKS)) DS)
                                                             (* Change the font) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE))
                                                             (* The font this character is in is 
                                                             taller than the existing line.
                                                             Adjust the LINEDESCRIPTOR's ascent.)
                                                             (\TEDIT.ADJUST.LINES TEXTOBJ LINE DS
                                                             (fetch (LINEDESCRIPTOR YBOT) of
                                                             (fetch (LINEDESCRIPTOR PREVLINE) of 
                                                             LINE)) (IDIFFERENCE (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)))) (* Move other text 
                                                             to allow for the new height)
                                                             (add (fetch (LINEDESCRIPTOR ASCENT) of 
                                                             LINE) (IDIFFERENCE (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)))
                                                             (replace (LINEDESCRIPTOR LTRUEASCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT))))) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE))
                                                             (* If the caret's font will change the 
                                                             line's descent, adjust lower lines 
                                                             downward) (\TEDIT.ADJUST.LINES TEXTOBJ
                                                             (fetch (LINEDESCRIPTOR NEXTLINE) of 
                                                             LINE) DS (fetch (LINEDESCRIPTOR YBOT) 
                                                             of LINE) (IDIFFERENCE
                                                             (fetch (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE) (FONTPROP (fetch CLFONT of 
                                                             LOOKS) (QUOTE DESCENT))))
                                                             (add (fetch (LINEDESCRIPTOR DESCENT) 
                                                             of LINE) (IDIFFERENCE
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE)))
                                                             (* Fix the line's leading-adjusted 
                                                             descent to account for this change)
                                                             (replace (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT))) (* Also the 
                                                             unadjusted descent) (replace
                                                             (LINEDESCRIPTOR YBOT) of LINE with
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             YBASE) of LINE) (fetch
                                                             (LINEDESCRIPTOR DESCENT) of LINE)))
                                                             (* And note our new location.)))
                                                             (BITBLT DS XPOINT (fetch
                                                             (LINEDESCRIPTOR YBOT) of LINE) DS
                                                             (IPLUS XPOINT CHWIDTH)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             RIGHTMARGIN) of LINE) XPOINT)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE INPUT) (QUOTE REPLACE))
                                                             (* Move the old text over)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             CHWIDTH (fetch (LINEDESCRIPTOR LHEIGHT)
    of LINE) (QUOTE TEXTURE) (QUOTE REPLACE) WHITESHADE) (* Blank out the area we're going to write 
                                                             into) (MOVETO XPOINT
                                                             (IPLUS (fetch (LINEDESCRIPTOR YBASE) 
                                                             of LINE) (OR (fetch CLOFFSET of LOOKS) 
                                                             0)) DS) (* Set the display stream 
                                                             position) (COND (TERMSA
                                                             (* Special terminal table for 
                                                             controlling character display.
                                                             Use it.) (RESETLST (RESETSAVE 
                                                             \PRIMTERMSA TERMSA) (replace
                                                             (TEXTSTREAM REALFILE) of
                                                             (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
    with DS) (COND ((STRINGP CH) (for CHAR instring CH do (SELCHARQ CHAR (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CHAR))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS 
                                                             XPOINT (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CH))))))
                                                             (T (* No special handling;
                                                             just use native character codes)
                                                             (COND ((STRINGP CH) (for CHAR instring 
                                                             CH do (SELCHARQ CHAR
                                                             (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CHAR DS))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (* Blank out the CR's width.)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CH DS))))))
                                                             (BITBLT NIL 0 0 DS (fetch
                                                             (LINEDESCRIPTOR LXLIM) of LINE)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (* Clear after EOL) (TEDIT.MODIFYLOOKS 
                                                             LINE XPOINT DS LOOKS
                                                             (fetch (LINEDESCRIPTOR YBASE) of LINE))
                                                             (* Do underlining, strike-out, etc.)))
    (HELP])

(TEDIT.INSERT.UPDATESCREEN
  [LAMBDA (CH# NCHARSADDED TEXTOBJ SEL DONTSCROLL INCREMENTAL)
                                                             (* ; "Edited  1-Mar-2023 20:16 by rmk")
                                                             (* ; "Edited 25-Feb-2023 10:44 by rmk")
                                                             (* ; "Edited 21-Feb-2023 23:28 by rmk")
                                                             (* ; "Edited  9-Nov-2022 08:47 by rmk")
                                                             (* ; "Edited  4-Nov-2022 17:54 by rmk")
                                                             (* ; "Edited 12-Aug-2022 18:04 by rmk")
                                                             (* ; "Edited 30-May-91 16:06 by jds")

    (* ;; "Update the edit window after an insertion of NCHARSADDED at CH#. We first move the selection to a LEFT selection just after the insertion, assuming that the insertion started at the selections CH#.  The caller has decoded the ending point of the insertion according to the selection's original POINT LEFT/RIGHT.")

    (PROG ((WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
           SELINE)
          (replace (SELECTION CH#) of SEL with (IPLUS NCHARSADDED CH#))
                                                             (* ; 
                                                             "SELs are valid even without a window.")
          (replace (SELECTION CHLIM) of SEL with (fetch (SELECTION CH#) of SEL))

     (* ;; 
     "We don't care about one-past because point (DCH=0) selections are still treated specially.")

          (replace (SELECTION POINT) of SEL with 'LEFT)
          (replace (SELECTION DCH) of SEL with 0)
          (replace (SELECTION SELKIND) of SEL with 'CHAR)

     (* ;; "Selection is now good. Bail out if we're doing incremental updates without type-in waiting, screen isn't being updated, or no window to update.")

          (CL:UNLESS (OR (AND INCREMENTAL (\SYSBUFP))
                         (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)
                         WINDOW)
                 (RETURN))
          (TEDIT.UPDATE.SCREEN TEXTOBJ T (fetch (SELECTION CH#) of SEL))
          (\FIXSEL SEL TEXTOBJ)
          (\SHOWSEL SEL NIL T)
          (\COPYSEL SEL TEDIT.SELECTION)

     (* ;; "\FIXSEL may have changed point to RIGHT, if we are at the end of something.")

          (for PANE (POINT _ (fetch (SELECTION POINT) of SEL)) inside WINDOW as L1
             inside (fetch (SELECTION L1) of SEL) as LN inside (fetch (SELECTION LN) of SEL)
             do (CL:UNLESS (OR DONTSCROLL (NEQ PANE (fetch (TEXTOBJ SELWINDOW) of TEXTOBJ)))
                    (SETQ SELINE (SELECTQ POINT
                                     (LEFT L1)
                                     (RIGHT LN)
                                     NIL))
                    (CL:WHEN [OR (NULL SELINE)
                                 (ILEQ (CL:IF SELINE
                                           (fetch (LINEDESCRIPTOR YBOT) of SELINE)
                                           0)
                                       (fetch (REGION BOTTOM) of (DSPCLIPPINGREGION NIL PANE]

                        (* ;; 
           "The caret is not in the selection window.  Need to scroll it up so the caret is visible.")

                        (while (OR (ILESSP (CL:IF SELINE
                                               (fetch (LINEDESCRIPTOR YBOT) of SELINE)
                                               (fetch (SELECTION Y0) of SEL))
                                          (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                   (AND (IGEQ (fetch (SELECTION Y0) of SEL)
                                              (fetch (TEXTOBJ WTOP) of TEXTOBJ))
                                        (NULL SELINE)))
                           do 
                              (* ;; "The caret just went off-screen.  Move it up some.")

                              (replace (TEXTOBJ EDITOPACTIVE) of TEXTOBJ with NIL)
                              (SCROLLW PANE 0 (LLSH (CL:IF SELINE
                                                        (fetch (LINEDESCRIPTOR LHEIGHT) of SELINE)
                                                        12)
                                                    1)))))
                (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ PANE))
          (\COPYSEL SEL TEDIT.SELECTION])

(TEDIT.UPDATE.SCREEN
  [LAMBDA (TEXTOBJ INCREMENTAL? NEXTCARETCH#)                (* ; "Edited 25-Feb-2023 10:45 by rmk")
                                                             (* ; "Edited 24-Feb-2023 00:16 by rmk")
                                                             (* ; "Edited 22-Feb-2023 13:18 by rmk")
                                                             (* ; "Edited 15-Feb-2023 22:26 by rmk")
                                                             (* ; "Edited  5-Oct-2022 21:30 by rmk")

    (* ;; "Update the screen, as needed to fix up 'dirty' lines in the different panes.")

    (SETQ TEXTOBJ (TEXTOBJ TEXTOBJ))
    (CL:UNLESS (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)
        (for PANE NLINE inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
           when (SETQ NLINE (\TEDIT.FIXCHANGEDPART TEXTOBJ PANE INCREMENTAL? NEXTCARETCH#))
           do 
              (* ;; "The last unmodified line in PANE")

              (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of NLINE)
                     NLINE TEXTOBJ PANE NEXTCARETCH#)))])

(\BACKFORMAT
  [LAMBDA (LINES TEXTOBJ WHEIGHT)                            (* ; "Edited 15-Feb-2023 23:52 by rmk")
                                                             (* ; "Edited  6-Feb-2023 21:48 by rmk")
                                                             (* ; "Edited 17-Sep-2022 22:20 by rmk")
                                                             (* ; "Edited  8-Sep-2022 16:41 by rmk")
                                                             (* ; "Edited 30-May-91 15:58 by jds")

    (* ;; "Move back to the next preceding EOL (to guarantee a line break), then format lines to reach where we are now.")

    (* ;; "LINES is the dummy first line for this window in TEXTOBJ")

    (* ;; "Returns a pointer to the last of the back-formatted lines (i.e., the one that comes latest in the document), or to LINES if no lines are formatted")

    (PROG ((LINE1 (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
           CH1 CHNO LINE)
          (SETQ CH1 (CL:IF LINE1
                        (fetch (LINEDESCRIPTOR LCHAR1) of LINE1)
                        (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          (CL:WHEN (ILEQ CH1 1)                              (* ; 
                                                 "No more lines to format--at the front of the file.")
              (RETURN LINES))

     (* ;; "More to do.  Back up until we find a preceding EOL")

          [SETQ CHNO (find I (TSTREAM _ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                        from (IDIFFERENCE CH1 2) to 2 by -1 first (\TEXTSETFILEPTR TSTREAM
                                                                         (IDIFFERENCE CH1 2)) 
                                                             (* ; 
                                                      "Because fileptrs are one back from characters")
                        suchthat (EQ (CHARCODE EOL)
                                     (\BACKBIN TSTREAM]
          (SETQ CHNO (ADD1 (OR CHNO 0)))                     (* ; 
                                                   "But never further than the front of the document")
          [while (ILEQ CHNO (SUB1 CH1)) do                   (* ; 
                           "Now move forward, formatting lines until we catch up with where we were.")
                                           (SETQ LINE (\FORMATLINE TEXTOBJ CHNO)) 
                                                             (* ; "Format the next line")
                                           (replace (LINEDESCRIPTOR YBOT) of LINE with WHEIGHT) 
                                                             (* ; 
                                                             "Make sure it thinks it's off-window")
                                           (replace (LINEDESCRIPTOR YBASE) of LINE with WHEIGHT)
                                           (replace (LINEDESCRIPTOR PREVLINE) of LINE with LINES) 
                                                             (* ; "Hook it onto the end of the chain")
                                           (replace (LINEDESCRIPTOR NEXTLINE) of LINES with LINE)
                                           (SETQ LINES LINE) (* ; 
                                                             "And find the start of the next line")
                                           (SETQ CHNO (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM)
                                                               of LINE]
          (replace (LINEDESCRIPTOR NEXTLINE) of LINE with LINE1)
                                                             (* ; 
                    "Now, with the final line we formatted, hook the rest of the line chain onto it.")
          (CL:WHEN LINE1
              (replace (LINEDESCRIPTOR PREVLINE) of LINE1 with LINE))
          (RETURN LINE])

(\FILLWINDOW
  [LAMBDA (YBOT PREVLINE TEXTOBJ WINDOW NEXTCARETCH#)        (* ; "Edited 11-Mar-2023 22:42 by rmk")
                                                             (* ; "Edited  9-Mar-2023 23:12 by rmk")
                                                             (* ; "Edited  4-Mar-2023 21:47 by rmk")
                                                             (* ; "Edited  2-Mar-2023 17:36 by rmk")
                                                             (* ; "Edited 26-Feb-2023 22:39 by rmk")
                                                             (* ; "Edited  9-Sep-2022 21:22 by rmk")
                                                             (* ; "Edited  6-Sep-2022 11:12 by rmk")

    (* ;; "Fill out TEXTOBJ's window, starting with the line after PREVLINE, whose ybottom is YBOT")

    (PROG (LINE OFLOWFN LASTYBOT (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                (WHEIGHT (WINDOWPROP WINDOW 'HEIGHT))
                (WBOTTOM (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

     (* ;; "")

     (* ;; "Find the first on-screen line after PREVLINE, if any.  If none, start with PREVLINE, maybe the dummy.")

          (SETQ LINE (find L inlines (fetch (LINEDESCRIPTOR NEXTLINE) of PREVLINE)
                        suchthat (ILESSP (fetch (LINEDESCRIPTOR YBOT) of L)
                                        WHEIGHT)))

     (* ;; "")

     (* ;; "Display all the existing lines that fit in the window.")

          (CL:WHEN LINE
              (SETQ PREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of LINE)))
          (do (if LINE
                  then (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT LINE PREVLINE))
                       (if (IGEQ YBOT WBOTTOM)
                           then (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT) 
                                                             (* ; "This line fits in the window")
                                (replace (LINEDESCRIPTOR YBASE) of LINE
                                   with (IPLUS YBOT (fetch (LINEDESCRIPTOR DESCENT) of LINE)))
                                (\DISPLAYLINE TEXTOBJ LINE WINDOW)
                                (SETQ PREVLINE LINE)
                                (SETQ LINE (ffetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                         else 
                              (* ;; "LINE doesn't fit in the window.  Keep any lines below it (to avoid reformatting if window is reshaped or scrolled) but mark them as not fitting. But why bother, and who cares what their YBOT is?")

                              (for L inlines LINE do (replace (LINEDESCRIPTOR YBOT) of L
                                                        with (SUB1 WBOTTOM)))
                              (RETURN))
                elseif (ILEQ (fetch (LINEDESCRIPTOR LCHARLIM) of PREVLINE)
                             TEXTLEN)
                  then 
                       (* ;; "Ran out of formatted lines, but didn't run out of window or text.  Format a new line, link it in, and go around to display")

                       [SETQ LINE (\FORMATLINE TEXTOBJ (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM)
                                                                of PREVLINE]
                       (\TEDIT.INSERTLINE LINE PREVLINE T)
                else (RETURN)))
          (CL:WHEN (AND (IEQP (fetch (LINEDESCRIPTOR LCHARLIM) of PREVLINE)
                              TEXTLEN)
                        (fetch (LINEDESCRIPTOR FORCED-END) of PREVLINE))
                                                             (* ; 
                                        "Dummy after final line end.  If not IEQP, adds duplicates. ")
              (SETQ PREVLINE (\TEDIT.ADD.TRAILING.LINE TEXTOBJ PREVLINE))
              (\DISPLAYLINE TEXTOBJ PREVLINE WINDOW))
          (SETQ LASTYBOT (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))

     (* ;; "")

     (* ;; "According to the manual, the user overflow function is called whenever a line falls out of the window, but it isn't told anything else. The use-case mentioned is coordination with the REGION property wherein TEDIT is running in part of a window.  But how does the userfn know where it is?")

          (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                        (APPLY* OFLOWFN WINDOW TEXTOBJ))     (* ; 
                                                   "User overflow fn might handle the space overflow")
              (RETURN))

     (* ;; "")

     (* ;; "User function didn't cleared to the window bottom, so we blank out any space below LASTYBOT, the bottom of the last fitting line (PREVLINE).")

          (CL:WHEN (IGEQ LASTYBOT WBOTTOM)
              (BITBLT NIL 0 0 WINDOW 0 WBOTTOM (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                     (IDIFFERENCE LASTYBOT WBOTTOM)
                     'TEXTURE
                     'REPLACE WHITESHADE))])

(\FIXDLINES
  [LAMBDA (SEL CH#1 CH#LIM TEXTOBJ)                          (* ; "Edited 21-Feb-2023 14:58 by rmk")
                                                             (* ; "Edited 16-Feb-2023 00:13 by rmk")
                                                             (* ; "Edited  7-Feb-2023 21:48 by rmk")
                                                             (* ; "Edited 10-Nov-2022 22:37 by rmk")
                                                             (* ; "Edited 23-Oct-2022 14:37 by rmk")
                                                             (* ; "Edited 19-Sep-2022 21:55 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; 
    "Fix up the list LINES of line descriptors, given that characters CH#1 thru CH#LIM were deleted.")

    (* ;; "Change LCHAR1 and LCHARLIM entries in each descriptor, and remove any descriptors for lines which disappeared entirely.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)
        (for LINES (NCHARSDELETED _ (IDIFFERENCE CH#LIM CH#1))
             (CH#1L _ (SUB1 CH#1)) inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
           inside (fetch (TEXTOBJ LINES) of TEXTOBJ)
           do [for LINE LCHAR1 LCHARLIM PL NL (NLINES _ LINES) inlines (fetch (LINEDESCRIPTOR 
                                                                                     NEXTLINE)
                                                                          of LINES)
                 do (SETQ LCHAR1 (ffetch (LINEDESCRIPTOR LCHAR1) of LINE))
                    (SETQ LCHARLIM (ffetch (LINEDESCRIPTOR LCHARLIM) of LINE))
                    (COND
                       ((ILEQ LCHARLIM CH#1)                 (* ; "Somewhere before. Just before?")
                        (CL:UNLESS (AND (SETQ NL (ffetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                        (ILESSP (ffetch (LINEDESCRIPTOR LCHAR1) of NL)
                                               CH#1))

                            (* ;; "Change could have affected LINE's break decision.")

                            (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                            (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)))
                       ((IGEQ LCHAR1 CH#LIM)                 (* ; 
           "This line contains none of the deleted text but is after it.  Update LCHAR1 and LCHARLIM")
                        (freplace (LINEDESCRIPTOR LCHAR1) of LINE with (IMAX 1 (IDIFFERENCE LCHAR1 
                                                                                      NCHARSDELETED))
                               )
                        (add (ffetch (LINEDESCRIPTOR LCHARLIM) of LINE)
                             (IMINUS NCHARSDELETED)))
                       ((OR (ILESSP LCHAR1 CH#1)
                            (IGEQ LCHARLIM CH#LIM))          (* ; 
       "This line contains some of the deleted text, mark it as dirty and update LCHAR1 and LCHARLIM")
                        (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                        (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)
                        (freplace (LINEDESCRIPTOR LCHAR1) of LINE with (IMAX 1 (IMIN LCHAR1 CH#1)))
                        (freplace (LINEDESCRIPTOR LCHARLIM) of LINE
                           with (CL:IF (IGEQ LCHARLIM CH#LIM)
                                    (IDIFFERENCE LCHARLIM (IMIN NCHARSDELETED (IDIFFERENCE CH#LIM 
                                                                                     LCHAR1)))
                                    CH#1L)))
                       (T                                    (* ; 
                                            "This line is totally within the deleted text, remove it")
                          (SETQ NL (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                          (SETQ PL (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
                          (CL:WHEN PL
                              (replace (LINEDESCRIPTOR NEXTLINE) of PL with NL))
                          (CL:WHEN NL
                              (replace (LINEDESCRIPTOR PREVLINE) of NL with PL))
                          (CL:WHEN (EQ NLINES LINE)
                                 (SETQ NLINES NL))
                          (replace (LINEDESCRIPTOR DELETED) of LINE with T)
                                                             (* ; 
                                      "Mark this line deleted, so DELETETEXTCHARS know to ignore it.")

                          (* ;; 
                  "This may well force a reformatting of the next line.  Mark it dirty just in case.")

                          (CL:WHEN NL
                              (replace (LINEDESCRIPTOR DIRTY) of NL with T))]
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM NCHARSDELETED)
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM NCHARSDELETED)
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM NCHARSDELETED)
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ DELETESEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM NCHARSDELETED)))])

(\FIXILINES
  [LAMBDA (TEXTOBJ SEL CH#1 NCHARSADDED OTEXTLEN)            (* ; "Edited  1-Mar-2023 20:25 by rmk")
                                                             (* ; "Edited 22-Feb-2023 07:42 by rmk")
                                                             (* ; "Edited 10-Nov-2022 22:41 by rmk")
                                                             (* ; "Edited  5-Oct-2022 21:56 by rmk")
                                                             (* ; "Edited 30-May-91 16:07 by jds")

    (* ;; "Fix the list LINES of line descriptors for each pane to account for NCHARSADDED characters inserted before CH#1, and mark them dirty.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)

        (* ;; "We are allowed to change the document.  HOW COULD WE BE HERE OTHERWISE??")

        (for LINES inside (ffetch (TEXTOBJ LINES) of TEXTOBJ) as L1 in (fetch (SELECTION L1)
                                                                          of SEL)
           do 
              (* ;; 
  "LINES is a list of per-pane starting lines, L1 is the start of their pane-selected copied subset.")

              (for LINE inlines (find L inlines (CL:IF (IGEQ (fetch (LINEDESCRIPTOR LCHAR1)
                                                                of LINES)
                                                             1)
                                                    LINES
                                                    (ffetch (LINEDESCRIPTOR NEXTLINE) of LINES))
                                   suchthat 

                                         (* ;; 
           "Find the first line that includes or follows the insertion, skpping the dummy first line")

                                         (OR (IGEQ (ffetch (LINEDESCRIPTOR LCHARLIM) of L)
                                                   CH#1)
                                             (IGEQ (ffetch (LINEDESCRIPTOR LCHARLIM) of L)
                                                   OTEXTLEN)))
                 first (CL:WHEN (fetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                                             (* ; 
                                                       "To be sure, also redisplay the previous line")
                           (replace (LINEDESCRIPTOR DIRTY) of (fetch (LINEDESCRIPTOR PREVLINE)
                                                                 of LINE) with T))
                 do 
                    (* ;; 
     "Only the character limits of LINE and all later lines need to be translated (and redisplayed).")

                    (add (ffetch (LINEDESCRIPTOR LCHAR1) of LINE)
                         NCHARSADDED)
                    (add (ffetch (LINEDESCRIPTOR LCHARLIM) of LINE)
                         NCHARSADDED)
                    (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)))
        (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)

        (* ;; "Lines are now good, translate the selections.")

        (CL:WHEN NIL                                         (* ; "I think \FIXSEL did this one")
            (\TEDIT.FIXINSSEL SEL TEXTOBJ CH#1 NCHARSADDED))
        (\TEDIT.FIXINSSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
               TEXTOBJ CH#1 NCHARSADDED)
        (\TEDIT.FIXINSSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
               TEXTOBJ CH#1 NCHARSADDED))])

(\SHOWTEXT
  [LAMBDA (TEXTOBJ WINDOW)

    (* ;; "Edited 11-Mar-2023 22:44 by rmk")

    (* ;; "Edited  7-Mar-2023 23:11 by rmk")

    (* ;; "Edited 25-Feb-2023 10:33 by rmk")

    (* ;; "Edited 22-Feb-2023 20:50 by rmk")

    (* ;; "Edited  6-Sep-2022 11:06 by rmk")

    (* ;; "Edited 12-Jan-2022 18:56 by rmk: I took out the WAITINGCURSOR, the resetsave wasn't working for some reason, and it really isn't necessary for modern machines.")

    (* ;; "Edited 12-Jun-90 19:22 by mitani")

    (* ;; "Fill the editor window with text, starting from the top of the file.")

    (CL:WHEN (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)            (* ; 
                                                           "If there is no edit window, just return.")
        (LET (WREG FIRSTLINE)
             (SETQ WINDOW (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
                                                             (* ; 
                                                             "Clear the region within the window")
             (DSPFILL (DSPCLIPPINGREGION NIL WINDOW)
                    WHITESHADE
                    'REPLACE WINDOW)
             (PROGN 
                    (* ;; "RMK: For reasons unknown, the original cursor was not restored when the PROGN was a RESETLST and this exited.  But there is presumably no need for this waiting indicator in modern times.  This only fills lines visible within a window, and machines are really fast.  So we don't bother to switch to the hourglass cursor")

                    (AND NIL (RESETSAVE (CURSOR WAITINGCURSOR)))

                    (* ;; 
              "Initialize with a dummy empty first line with LCHAR1 and LCHARLIM=0 at the window top")

                    (SETQ FIRSTLINE
                     (create LINEDESCRIPTOR
                            YBOT _ (WINDOWPROP WINDOW 'HEIGHT)
                            LCHAR1 _ 0
                            LCHARLIM _ 0
                            RIGHTMARGIN _ (SUB1 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
                            NEXTLINE _ NIL
                            LHEIGHT _ 0
                            LX1 _ 0
                            LXLIM _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                            FORCED-END _ T
                            ASCENT _ 0
                            DESCENT _ 0
                            LTRUEASCENT _ 0
                            LFMTSPEC _ TEDIT.DEFAULT.FMTSPEC))
                    (replace (TEXTWINDOW WLINES) of WINDOW with FIRSTLINE)
                    (\FILLWINDOW (WINDOWPROP WINDOW 'HEIGHT)
                           FIRSTLINE TEXTOBJ WINDOW)
                    (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ WINDOW)
                    FIRSTLINE)))])

(\TEDIT.ADJUST.LINES
  [LAMBDA (TEXTOBJ FIRSTLINE WINDOW LINETOP DY)              (* ; "Edited 24-Feb-2023 00:17 by rmk")
                                                             (* ; "Edited 22-Feb-2023 11:54 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Move all lines from FIRSTLINE (inclusive) on up or down.  Fill in a line or drop one off, accordingly.  Positive DY means move UP.")

    (* ;; "LINETOP is the top of the region to be moved as the adjustment is made.  It corresponds to the TOP of FIRSTLINE.")

    (* ;; "But only if the lines total height has changed and the line is on the screen")

    (CL:UNLESS (OR (ZEROP DY)
                   (ILESSP LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                   (NULL FIRSTLINE))
        [LET (OFLOW OFLOWFN OYBOT PREVLINE)

             (* ;; 
        "Adjust the Y locations of the lines that are affected by the change (i.e., those below it).")

             (for LL inlines FIRSTLINE while (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LL)
                                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                do (SETQ OYBOT (fetch (LINEDESCRIPTOR YBOT) of LL))
                   (CL:WHEN (ILESSP (replace (LINEDESCRIPTOR YBOT) of LL with (IPLUS OYBOT DY))
                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                     "This line moved below the bottom of the screen")
                       (BITBLT NIL 0 0 WINDOW 0 OYBOT (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                              (fetch (LINEDESCRIPTOR LHEIGHT) of LL)
                              'TEXTURE
                              'REPLACE WHITESHADE)           (* ; 
                                                             "So clear the space it used to occupy.")
                       (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                     (SETQ OFLOW T)
                                     (APPLY* OFLOWFN WINDOW TEXTOBJ))
                                                             (* ; 
                            "We walked off the bottom, and the user gave us an OFLOWFN to handle it.")
                           (RETURN NIL)))
                   (add (fetch (LINEDESCRIPTOR YBASE) of LL)
                        DY)                                  (* ; 
                                   "Adjust the baseline of the line, as well as its physical bottom.")
                   (replace (LINEDESCRIPTOR YBOT) of LL with (IDIFFERENCE (fetch (LINEDESCRIPTOR
                                                                                  YBASE) of LL)
                                                                    (fetch (LINEDESCRIPTOR DESCENT)
                                                                       of LL))) 
                                                             (* ; 
                                "This looks redundant, but the line's descent may have changed, too.")
                                                             (* ; 
                        "Prior line needed it if we later try to fill out the window with more text.")
                   (SETQ PREVLINE LL))

             (* ;; "User's OFLOWFN handled the overflow, nothing more to do.")

             (COND
                (OFLOW)
                ((IGREATERP DY 0)                            (* ; 
                                                            "The line is shorter;  move the rest up.")
                 (BITBLT WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                        WINDOW 0 (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                        (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                        LINETOP
                        'INPUT
                        'REPLACE)                            (* ; "Move the text up")
                 (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                        (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                        DY
                        'TEXTURE
                        'REPLACE WHITESHADE)

                 (* ;; "Now clear the bottom part of the window, which got vacated by the adjustment")

                 (CL:WHEN (AND PREVLINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                              (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                                             (* ; 
                                "If there is space left on the screen, try to fill it with new text.")
                     (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                            PREVLINE TEXTOBJ WINDOW)))
                (T                                           (* ; 
                                                           "The line is taller;  move the rest down.")
                   (BITBLT WINDOW 0 (IPLUS (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                           (IMINUS DY))
                          WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                          (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                          (IDIFFERENCE LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                          'INPUT
                          'REPLACE)                          (* ; "Move the text down")
                                                             (* ; 
                                                           "Now clear the region we moved it out of.")
                   (BITBLT NIL 0 0 WINDOW 0 (IPLUS LINETOP DY)
                          (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                          (IMINUS DY)
                          'TEXTURE
                          'REPLACE WHITESHADE])])

(\TEDIT.CLEAR.SCREEN.BELOW.LINE
  [LAMBDA (TEXTOBJ WINDOW YBOT WIDTH)                        (* ; "Edited 22-Feb-2023 13:58 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Clears the edit window to white, clearing only the space below YBOT's line.")

    (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
           (OR WIDTH (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
           (IDIFFERENCE YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
           'TEXTURE
           'REPLACE WHITESHADE])

(\TEDIT.CLOSEUPLINES
  [LAMBDA (TEXTOBJ PREVLINE NEXTLINE DONTFILLFLG WINDOW)     (* ; "Edited 15-Feb-2023 23:53 by rmk")
                                                             (* ; "Edited  6-Feb-2023 21:49 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Given a gap between PREVLINE and NEXTLINE, move NEXTLINE et seq up to coverthe gap, and adjust the YBOTs.  If DONTFILLFLG is T then we're not filling the screen")
                                                             (* ; 
                                                          "NEXTLINE = NIL => remove all lower lines.")
    (COND
       (PREVLINE                                             (* ; 
                                                         "PREVLINE = NIL => DON'T close up anything.")
              (PROG [DY (WWIDTH (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                       (fetch (TEXTOBJ WLEFT) of TEXTOBJ)))
                        (LOWESTY (COND
                                    (PREVLINE (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                    (T (ADD1 (fetch (TEXTOBJ WTOP) of TEXTOBJ]
                    [COND
                       (NEXTLINE                             (* ; 
                                        "If the gap isn't at the end, move whatever else up over it.")
                              [SETQ DY (IDIFFERENCE LOWESTY (IPLUS (fetch (LINEDESCRIPTOR YBOT)
                                                                      of NEXTLINE)
                                                                   (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of NEXTLINE]
                              (AND (ILEQ DY 0)
                                   (RETURN))                 (* ; 
                                                "If there's no gap, don't bother with anything else.")
                              (BITBLT WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                     WINDOW
                                     (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                     WWIDTH
                                     (IPLUS (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of NEXTLINE)
                                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                            (fetch (LINEDESCRIPTOR LHEIGHT) of NEXTLINE))
                                     'INPUT
                                     'REPLACE)               (* ; "Move the remaining lines upward.")
                              (bind (LINE _ NEXTLINE)
                                    (NYBOT _ LOWESTY) while LINE
                                 do                          (* ; 
                               "Scan the remaining lines, fixing up the vertical spacing information")
                                    (SETQ NYBOT (IDIFFERENCE NYBOT (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of LINE)))
                                    (COND
                                       ((IGEQ NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                        (SETQ LOWESTY NYBOT)))
                                    [COND
                                       [(ILESSP (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                               (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                 "Line is off screen.  Display it at the right spot.")
                                        (AND DONTFILLFLG (RETURN))
                                                             (* ; 
                                                   "If we're not filling the screen, then stop here.")
                                        (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                        (replace (LINEDESCRIPTOR YBASE) of LINE
                                           with (IPLUS NYBOT (fetch (LINEDESCRIPTOR DESCENT)
                                                                of LINE)))
                                        (\DISPLAYLINE TEXTOBJ LINE WINDOW)
                                        (COND
                                           ((fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                             (* ; 
                                                 "There's a next line after the current one.  Use it")
                                            )
                                           ((IGEQ (fetch (LINEDESCRIPTOR LCHARLIM) of LINE)
                                                  (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                               "We're at the end of the text;  don't bother trying to add more lines")
                                            )
                                           (T                (* ; 
                                                            "There's more;  try adding another line.")
                                              [replace (LINEDESCRIPTOR NEXTLINE) of LINE
                                                 with (\FORMATLINE TEXTOBJ (ADD1 (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         LCHARLIM)
                                                                                    of LINE]
                                              (replace (LINEDESCRIPTOR PREVLINE)
                                                 of (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                 with LINE]
                                       (T                    (* ; 
                                                           "Line is visible;  just update YBOT/YBASE")
                                          (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                          (replace (LINEDESCRIPTOR YBASE) of LINE
                                             with (IPLUS (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                         (fetch (LINEDESCRIPTOR DESCENT) of LINE]
                                    (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                 until (ILESSP NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
                    (BITBLT NIL 0 0 WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                           (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                           WWIDTH
                           (IDIFFERENCE LOWESTY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                           'TEXTURE
                           'REPLACE WHITESHADE)              (* ; 
                                   "Clear the part of the screen below the lowest line now displayed")
                    (RETURN T])

(\TEDIT.FIXCHANGEDLINE
  [LAMBDA (TEXTOBJ PREVYBOT LINES WINDOW LCHARLIM NEXTCARETCH#)
                                                             (* ; "Edited 25-Feb-2023 10:38 by rmk")
                                                             (* ; "Edited 22-Feb-2023 21:01 by rmk")
                                                             (* ; "Edited 15-Feb-2023 23:23 by rmk")
                                                             (* ; "Edited  6-Feb-2023 21:49 by rmk")
                                                             (* ; "Edited  5-Oct-2022 23:05 by rmk")
                                                             (* ; "Edited 30-Jul-2022 21:15 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")

    (* ;; "Reformats and redisplays a single line, if need be.  Returns the changed line.  Called only from \TEDIT.FIXCHNAGEDPART")

    (* ;; "LCHARLIM is actually one more than the LCHARLIM of the previous line, so can be compared to LCHAR1 of next.")

    (CL:WHEN (ILESSP LCHARLIM 1)
        (HELP "FIXCHANGE-LCHARLIM 0")                        (* ; "Dummy line?")
        (SETQ LCHARLIM (SUB1 (fetch (LINEDESCRIPTOR LCHAR1) of LINES))))

    (* ;; 
    "Only act if this line has changed there is a gap or overlap between this line and the prior one")

    (CL:WHEN [OR (fetch (LINEDESCRIPTOR DIRTY) of LINES)
                 (NOT (IEQP LCHARLIM (fetch (LINEDESCRIPTOR LCHAR1) of LINES]
        (PROG ((YBOT PREVYBOT)
               (OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES))
               DY OFLOWFN NEWLINE)
              (SETQ NEWLINE (\FORMATLINE TEXTOBJ LCHARLIM))  (* ; "Create the fresh line")
              (COND
                 ((AND (ILESSP LCHARLIM (fetch (LINEDESCRIPTOR LCHAR1) of LINES))
                       (IEQP (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM) of NEWLINE))
                             (fetch (LINEDESCRIPTOR LCHAR1) of LINES)))
                                                             (* ; 
                                   "If this is a space-filling line, just move the other lines down.")
                  (\TEDIT.INSERTLINE NEWLINE LINES))
                 (T                                          (* ; 
                                                             "Otherwise, write over existing lines")
                    (\TEDIT.COPY.LINEDESCRIPTOR NEWLINE LINES)
                                                             (* ; "Move it into place in the chain")
                    (replace (THISLINE DESC) of (fetch (TEXTOBJ THISLINE) of TEXTOBJ) with LINES)
                                                             (* ; 
                     "And pretend that LINES is the line we just formatted--since it effectively IS.")
                                                             (* ; 
                                                             "And copy it back over the original")
                    (SETQ NEWLINE LINES)))
              (COND
                 ((IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINES)
                        (fetch (REGION PTOP) of (DSPCLIPPINGREGION NIL WINDOW)))
                                                             (* ; 
                                     "Do nothing until we see a change to a line which is on-screen.")
                                                             (* ; 
                               "Except to make sure that the fresh line also thinks it is off screen")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with (fetch (LINEDESCRIPTOR YBOT)
                                                                    of LINES)))
                 ((AND (IGEQ (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT NEWLINE (fetch (LINEDESCRIPTOR
                                                                                      PREVLINE)
                                                                                 of NEWLINE)))
                             (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                       (NEQ LINES NEWLINE))                  (* ; 
                          "If there's space left on the screen for this line, (and it is a new line)")
                  (\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of NEWLINE)
                         WINDOW
                         (fetch (LINEDESCRIPTOR YBOT) of (fetch (LINEDESCRIPTOR PREVLINE)
                                                            of NEWLINE))
                         (IMINUS (fetch (LINEDESCRIPTOR LHEIGHT) of NEWLINE)))
                                                             (* ; 
                                                          "Move the existing lines down to fit it in")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of NEWLINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                      DESCENT)
                                                                                 of NEWLINE)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ NEWLINE WINDOW))
                 ((IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
          "If there's space left on the screen for this line, and we're overlaying an existing line.")
                  [\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                         WINDOW
                         (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES)
                                (IMINUS OLHEIGHT))
                         (COND
                            ((fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC) of LINES))
                             (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of LINES)
                                    YBOT))
                            (T (IDIFFERENCE OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES]
                                                             (* ; 
                             "Adjust for the possible difference in heights between old and new line")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of LINES with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINES)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ LINES WINDOW))
                 ((AND NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR LCHAR1) of LINES)
                                          NEXTCARETCH#))     (* ; 
                        "This line is off-screen, but is needed for finding the caret's new location")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                  (replace (LINEDESCRIPTOR YBASE) of LINES with YBOT))
                 (T                                          (* ; 
                        "We have walked off the bottom of the screen.  Chop off the lines from here.")
                    (SETQ LINES NEWLINE)
                    (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                  (APPLY* OFLOWFN WINDOW TEXTOBJ))
                           (RETURN))
                    [replace (LINEDESCRIPTOR YBOT) of LINES with (replace (LINEDESCRIPTOR YBASE)
                                                                    of LINES
                                                                    with (SUB1 (fetch (TEXTOBJ 
                                                                                             WBOTTOM)
                                                                                  of TEXTOBJ]
                                                             (* ; 
                                                             "Mark this line as being off-screen")
                    (CL:WHEN (IGREATERP (fetch (LINEDESCRIPTOR LCHARLIM) of LINES)
                                    NEXTCARETCH#)
                        (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL))
                                                             (* ; 
   "Chop off any lines below it, to preserve changes that may propogate off the bottom of the window")
                    (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW (fetch (LINEDESCRIPTOR YBOT)
                                                                      of (fetch (LINEDESCRIPTOR
                                                                                 PREVLINE)
                                                                            of LINES)))
                                                             (* ; 
                                            "And clear the space below the bottom line on the screen")
                    (RETURN)))

         (* ;; "So that if we inserted a line, we start by moving up to the pre-existing line")

              (SETQ LINES NEWLINE)))
    LINES])

(\TEDIT.FIXCHANGEDPART
  [LAMBDA (TEXTOBJ WINDOW INCREMENTAL? NEXTCARETCH#)         (* ; "Edited 22-Feb-2023 20:59 by rmk")
                                                             (* ; "Edited 15-Feb-2023 23:23 by rmk")
                                                             (* ; "Edited  7-Feb-2023 16:31 by rmk")
                                                             (* ; "Edited  5-Oct-2022 23:05 by rmk")
                                                             (* ; "Edited 30-May-91 16:07 by jds")
    (CL:UNLESS NEXTCARETCH#
        (SETQ NEXTCARETCH# (fetch (SELECTION CH#) of (fetch (TEXTOBJ SEL) of TEXTOBJ))))

    (* ;; "Reformat lines as needed after a change.  Return the last line changed, or NIL if there's no need for a \FILLWINDOW.")

    (PROG ((LINES (fetch (LINEDESCRIPTOR NEXTLINE) of (fetch (TEXTWINDOW WLINES) of WINDOW)))
           (REGION (DSPCLIPPINGREGION NIL WINDOW))
           (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
           (CLEARBOTTOM T)
           YBOT PREVLINE DY)
          (SETQ YBOT (fetch (REGION PTOP) of REGION))
          [SETQ LINES (for L inlines LINES eachtime (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT)
                                                                  of L))
                                                 (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM
                                                                        YBOT L (fetch (LINEDESCRIPTOR
                                                                                       PREVLINE)
                                                                                  of L))
                                                                 YBOT))
                                                 (CL:WHEN (ILESSP 0 DY)

                                                     (* ;; 
                           "There used to be another line above this one.  Move this up to cover it.")

                                                     (* ;; 
      "This HAS to fill the window, or we may wind up with missing lines at the bottom of the screen")

                                                     (\TEDIT.CLOSEUPLINES TEXTOBJ (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                          PREVLINE)
                                                                                     of L)
                                                            L NIL (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ
                                                                                    ))))
                         do 
                            (* ;; "Find the first visible DIRTY line.")

                            (CL:WHEN (AND (ILESSP YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                          (IGREATERP (fetch (LINEDESCRIPTOR LCHAR1) of L)
                                                 NEXTCARETCH#))
                                                             (* ; 
                                                            "We've run off the bottom of the screen.")
                                (replace (LINEDESCRIPTOR NEXTLINE) of (fetch (LINEDESCRIPTOR PREVLINE
                                                                                    ) of L)
                                   with NIL)                 (* ; 
                                 "There may be unfixed changes there, so chop off any further lines.")
                                (RETURN NIL))
                            (CL:WHEN (fetch (LINEDESCRIPTOR DIRTY) of L)
                                   (RETURN L))
                            (CL:UNLESS [OR [IEQP (fetch (LINEDESCRIPTOR LCHAR1) of L)
                                                 (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM)
                                                          of (fetch (LINEDESCRIPTOR PREVLINE)
                                                                of L]
                                           (ZEROP (fetch (LINEDESCRIPTOR LCHARLIM)
                                                     of (fetch (LINEDESCRIPTOR PREVLINE) of L]

                                (* ;; "This line doesn't match up with the previous line;  we should start updating here.  But don't worry about the dummy first line")

                                (RETURN L))]
          (CL:WHEN (AND LINES (ILEQ (fetch (LINEDESCRIPTOR LCHAR1) of LINES)
                                    0))                      (* ; "Skip over the dummy first line .")
              (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)))
          (CL:UNLESS LINES                                   (* ; 
                                                "No changed lines -- clear below last line on screen")
              (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW YBOT (fetch (REGION WIDTH) of REGION))
              (RETURN (COND
                         ([OR (ZEROP TEXTLEN)
                              (NOT (fetch (LINEDESCRIPTOR NEXTLINE) of (fetch (TEXTWINDOW WLINES)
                                                                          of WINDOW]

                          (* ;; "Force \FILLWINDOW to create an empty final line.")

                          (fetch (TEXTWINDOW WLINES) of WINDOW))
                         (T (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
                                                             (* ; "No changes, nothing more to do. ")
                            NIL))))
          (SETQ PREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of LINES))
          (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                                             (* ; 
                                                            "Y bottom of the first line to reformat.")

     (* ;; "Start formatting at LCHARLIM+1: presumably the LCHAR1 of next line")

          (for old LINES (LCHARLIM _ (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM) of PREVLINE)))
             inlines LINES while (OR (IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                     (ILEQ LCHARLIM NEXTCARETCH#))
             do 
                (* ;; "Start cleaning at the first dirty line, stop if we're both past the place the caret will be AND off the bottom of the screen.")

                (CL:WHEN [ILESSP 0 (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM YBOT LINES
                                                                (fetch (LINEDESCRIPTOR PREVLINE)
                                                                   of LINES))
                                                   (fetch (LINEDESCRIPTOR YBOT) of LINES]

                    (* ;; "There used to be another line above this one.  Move this up to cover it.")

                    (\TEDIT.CLOSEUPLINES TEXTOBJ PREVLINE LINES NIL (OR WINDOW (\TEDIT.PRIMARYW
                                                                                TEXTOBJ))))
                [COND
                   ((IGREATERP LCHARLIM (IMIN (IMAX 1 (fetch (LINEDESCRIPTOR LCHARLIM) of LINES))
                                              TEXTLEN))

                    (* ;; "This line has been rendered superfluous -- Delete it.")

                    (TEDIT.DELETELINE LINES TEXTOBJ WINDOW))
                   (T 
                      (* ;; "Try updating the line.  If the updater returns NIL, it ran off the bottom of the screen, and we should give up.")

                      (COND
                         ((SETQ LINES (\TEDIT.FIXCHANGEDLINE TEXTOBJ YBOT LINES WINDOW LCHARLIM 
                                             NEXTCARETCH#))

                          (* ;; 
             "We're still on screen;  update the character and Y-position counters for the next loop")

                          (SETQ LCHARLIM (ADD1 (fetch (LINEDESCRIPTOR LCHARLIM) of LINES)))
                          (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of LINES)))
                         (T 
                            (* ;; 
   "Ran off the bottom of the window;  the bottom has already been cleared, so avoid doing it again.")

                            (SETQ CLEARBOTTOM NIL)
                            (RETURN]
                (COND
                   ((IGEQ LCHARLIM TEXTLEN)

                    (* ;; "We've run out of text, we won't be needing any remaining lines and there is no more screen updating.")

                    (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL)
                    (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL))
                   ((AND INCREMENTAL? (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                         (IGREATERP LCHARLIM NEXTCARETCH#)
                         (\SYSBUFP))

                    (* ;; 
                  "This is an incremental update, and he hit a key.  Stop updating and listen to him")

                    (* ;; 
                    "HOWEVER, NEVER STOP ON THE LAST LINE -- IF THERE ARE NEW LINES TO ADD, ADD ONE.")

                    (SETQ PREVLINE NIL)
                    (SETQ CLEARBOTTOM NIL)
                    (RETURN))) 

                (* ;; "Remember the last line we really formatted.")

                (SETQ PREVLINE LINES))
          (CL:WHEN CLEARBOTTOM

              (* ;; 
     "There had been lines yet to be formatted, so there may be garbage below the end of the screen.")

              (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW YBOT))
          (RETURN PREVLINE])

(\TEDIT.INSERTLINE
  [LAMBDA (NEWLINE OLDLINE AFTER)                            (* ; "Edited 26-Feb-2023 22:36 by rmk")
                                                             (* ; "Edited 24-Feb-2023 23:12 by rmk")
                                                             (* ; "Edited 23-Feb-2023 22:41 by rmk")
                                                             (* ; "Edited 30-May-91 16:05 by jds")

    (* ;; 
    "Inserts NEWLINE in the line-descriptor chain either AFTER OLDLINE or before it (AFTER=NIL)")

    (LET (LINE)
         (if AFTER
             then (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of OLDLINE))
                  (CL:WHEN LINE
                      (replace (LINEDESCRIPTOR PREVLINE) of LINE with NEWLINE))
                  (replace (LINEDESCRIPTOR NEXTLINE) of NEWLINE with LINE)
                  (replace (LINEDESCRIPTOR PREVLINE) of NEWLINE with OLDLINE)
                  (replace (LINEDESCRIPTOR NEXTLINE) of OLDLINE with NEWLINE)
           else (SETQ LINE (fetch (LINEDESCRIPTOR PREVLINE) of OLDLINE))
                (CL:WHEN LINE
                    (replace (LINEDESCRIPTOR NEXTLINE) of LINE with NEWLINE))
                (replace (LINEDESCRIPTOR PREVLINE) of NEWLINE with LINE)
                (replace (LINEDESCRIPTOR NEXTLINE) of NEWLINE with OLDLINE)
                (replace (LINEDESCRIPTOR PREVLINE) of OLDLINE with NEWLINE])

(\TEDIT.ADD.TRAILING.LINE
  [LAMBDA (TEXTOBJ LASTLINE)                                 (* ; "Edited 25-Feb-2023 09:23 by rmk")

    (* ;; "Fabricates a final line to ensure a little white space in the window after the true last line of the text.  \FORMATLINE may be overkill--maybe we really want to construct exactly what we want.  But \FORMATLINE does get the LHEIGHT and ASCENT.")

    (LET [(LINE (\FORMATLINE TEXTOBJ (ADD1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ]
         (\TEDIT.INSERTLINE LINE LASTLINE T)                 (* ; "")
         (replace (LINEDESCRIPTOR YBOT) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                     of LASTLINE)
                                                            (fetch (LINEDESCRIPTOR LHEIGHT)
                                                               of LINE)))
         (replace (LINEDESCRIPTOR YBASE) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                      of LASTLINE)
                                                             (fetch (LINEDESCRIPTOR ASCENT)
                                                                of LINE)))
         LINE])

(\TEDIT.LINE.LIST
  [LAMBDA (TEXTOBJ WINDOW)                                   (* ; "Edited 18-Feb-2023 21:19 by rmk")
                                                            (* ; "Edited 12-Jun-90 19:23 by mitani")
    (find LINES inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as WW inside (fetch (TEXTOBJ \WINDOW)
                                                                          of TEXTOBJ)
       suchthat (EQ WW WINDOW])

(\TEDIT.MARK.LINES.DIRTY
  [LAMBDA (TEXTOBJ FIRSTCHAR LASTCHAR)                       (* ; "Edited 23-Feb-2023 18:22 by rmk")
                                                             (* ; "Edited 21-Feb-2023 23:46 by rmk")
                                                             (* ; "Edited 16-Feb-2023 00:06 by rmk")
                                                             (* ; "Edited 19-Oct-2022 11:13 by rmk")
                                                             (* ; "Edited 30-May-91 16:05 by jds")

    (* ;; "Mark as dirty the lines that intersect the range FIRSTCHAR to LASTCHAR  inclusive, and assert that all panes need to be updated.")

    (SETQ FIRSTCHAR (IMIN FIRSTCHAR (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
    [SETQ LASTCHAR (CL:IF (EQ LASTCHAR -1)
                       (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)
                       (IMIN LASTCHAR (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))]
    (for PANE inside (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ)
       do (for LINES inlines (find L inlines (fetch (TEXTWINDOW WLINES) of PANE)
                                suchthat 

                                      (* ;; "The first line ending after FIRSTCHAR")

                                      (IGEQ (fetch (LINEDESCRIPTOR LCHARLIM) of L)
                                            FIRSTCHAR))
             do (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)
                (for LINE inlines LINES while (ILEQ (fetch (LINEDESCRIPTOR LCHAR1) of LINE)
                                                    LASTCHAR) do 
                                                                 (* ;; 
                                                          "All the lines that beginX before LASTCHAR")

                                                                 (freplace (LINEDESCRIPTOR DIRTY)
                                                                    of LINE with T])

(\TEDIT.NEXT.LINE.BOTTOM
  [LAMBDA (CURYBOT LINE PREVLINE)                            (* ; "Edited 24-Sep-87 10:00 by jds")

(* ;;; "Given a current Y-bottom for PREVLINE, and a LINE to follow it, compute the new line's YBOT value.  Takes into account Base-to-base leading, as well as paragraph leadings.")

    (PROG (NEWYBOT PARALEADING PARALOOKS BASETOBASE)
          [COND
             [[SETQ BASETOBASE (fetch (FMTSPEC FMTBASETOBASE) of (SETQ PARALOOKS (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         LFMTSPEC)
                                                                                    of LINE]

              (* ;; "If base-to-base spacing is specified, we have to do this in two parts: First, compute the proper spacing between the lines;  then add in any paragraph leading.")

              [SETQ NEWYBOT (IDIFFERENCE (IPLUS CURYBOT (fetch (LINEDESCRIPTOR DESCENT) of PREVLINE))
                                   (IPLUS BASETOBASE (fetch (LINEDESCRIPTOR DESCENT) of LINE]
              (COND
                 ((fetch (LINEDESCRIPTOR 1STLN) of LINE)     (* ; 
                          "This is the first line of a new paragraph.  Add in any paragraph leading.")
                  [SETQ PARALEADING (IPLUS (fetch (FMTSPEC LEADBEFORE) of PARALOOKS)
                                           (fetch (FMTSPEC LEADAFTER) of (fetch (LINEDESCRIPTOR
                                                                                 LFMTSPEC)
                                                                            of PREVLINE]

                  (* ;; "The inter-paragraph space is the sum of the previous para's post-leading and this para's pre-leading.")

                  (SETQ NEWYBOT (IDIFFERENCE NEWYBOT PARALEADING]
             (T 
                (* ;; "If there's no base-to-base spacing, then paragraph leading was taken into account in the line formatter, and is already part of LHEIGHT.")

                (SETQ NEWYBOT (IDIFFERENCE CURYBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
          (RETURN NEWYBOT])

(\TEDIT.COPY.LINEDESCRIPTOR
  [LAMBDA (FROMLINE TOLINE)                                  (* ; "Edited  7-Mar-2023 23:12 by rmk")
                                                             (* ; "Edited  5-Mar-2023 23:39 by rmk")
                                                             (* ; "Edited  2-Mar-2023 17:35 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")

    (* ;; 
  "Copy the contents of one line descriptor into another -- except for chaining and Y-location info.")

    (freplace (LINEDESCRIPTOR LEFTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR LEFTMARGIN)
                                                            of FROMLINE))
    (freplace (LINEDESCRIPTOR RIGHTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR LXLIM) of TOLINE with (ffetch (LINEDESCRIPTOR LXLIM) of FROMLINE))
    (freplace (LINEDESCRIPTOR LX1) of TOLINE with (ffetch (LINEDESCRIPTOR LX1) of FROMLINE))
    (freplace (LINEDESCRIPTOR LHEIGHT) of TOLINE with (ffetch (LINEDESCRIPTOR LHEIGHT) of FROMLINE))
    (freplace (LINEDESCRIPTOR LCHAR1) of TOLINE with (ffetch (LINEDESCRIPTOR LCHAR1) of FROMLINE))
    (freplace (LINEDESCRIPTOR LCHARLIM) of TOLINE with (ffetch (LINEDESCRIPTOR LCHARLIM) of FROMLINE)
           )
    (AND NIL (freplace (LINEDESCRIPTOR DIRTY) of TOLINE with NIL))
    (freplace (LINEDESCRIPTOR FORCED-END) of TOLINE with (ffetch (LINEDESCRIPTOR FORCED-END)
                                                            of FROMLINE))
    (freplace (LINEDESCRIPTOR LHASPROT) of TOLINE with (ffetch (LINEDESCRIPTOR LHASPROT) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LFMTSPEC) of TOLINE with (ffetch (LINEDESCRIPTOR LFMTSPEC) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LTRUEDESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEDESCENT)
                                                              of FROMLINE))
    (freplace (LINEDESCRIPTOR LTRUEASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEASCENT)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR ASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR ASCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR DESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR DESCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR LMARK) of TOLINE with (ffetch (LINEDESCRIPTOR LMARK) of FROMLINE))
    (freplace (LINEDESCRIPTOR 1STLN) of TOLINE with (ffetch (LINEDESCRIPTOR 1STLN) of FROMLINE))
    (freplace (LINEDESCRIPTOR LSTLN) of TOLINE with (ffetch (LINEDESCRIPTOR LSTLN) of FROMLINE])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (27796 95518 (\FORMATLINE 27806 . 58331) (\FORMATLINE.SETUP 58333 . 61490) (
\FORMATLINE.ALIGN 61492 . 67386) (\FORMATLINE.JUSTIFY 67388 . 73322) (\FORMATLINE.TABS 73324 . 80692) 
(\FORMATLINE.SCALETABS 80694 . 81691) (\FORMATLINE.PURGE.SPACES 81693 . 82624) (\FORMATLINE.EMPTY 
82626 . 87169) (\FORMATLINE.UPDATELOOKS 87171 . 93220) (\CLEARTHISLINE 93222 . 93891) (\TLVALIDATE 
93893 . 95516)) (95675 114518 (\DISPLAYLINE 95685 . 107981) (\DISPLAYLINE.TABS 107983 . 110425) (
\TEDIT.LINECACHE 110427 . 111155) (\TEDIT.CREATE.LINECACHE 111157 . 111993) (\TEDIT.BLTCHAR 111995 . 
114516)) (115133 205589 (TEDIT.DELETELINE 115143 . 116065) (TEDIT.INSERT.DISPLAYTEXT 116067 . 132211) 
(TEDIT.INSERT.UPDATESCREEN 132213 . 136977) (TEDIT.UPDATE.SCREEN 136979 . 138148) (\BACKFORMAT 138150
 . 142216) (\FILLWINDOW 142218 . 147412) (\FIXDLINES 147414 . 153115) (\FIXILINES 153117 . 156770) (
\SHOWTEXT 156772 . 159585) (\TEDIT.ADJUST.LINES 159587 . 165850) (\TEDIT.CLEAR.SCREEN.BELOW.LINE 
165852 . 166466) (\TEDIT.CLOSEUPLINES 166468 . 174281) (\TEDIT.FIXCHANGEDLINE 174283 . 184562) (
\TEDIT.FIXCHANGEDPART 184564 . 194703) (\TEDIT.INSERTLINE 194705 . 196264) (\TEDIT.ADD.TRAILING.LINE 
196266 . 197597) (\TEDIT.LINE.LIST 197599 . 198088) (\TEDIT.MARK.LINES.DIRTY 198090 . 200205) (
\TEDIT.NEXT.LINE.BOTTOM 200207 . 202504) (\TEDIT.COPY.LINEDESCRIPTOR 202506 . 205587)))))
STOP
