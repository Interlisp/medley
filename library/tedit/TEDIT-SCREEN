(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED " 7-Nov-2022 12:47:12" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;225 200881 

      :CHANGES-TO (FNS \FORMATLINE \CLEARTHISLINE \TLVALIDATE)
                  (VARS TEDIT-SCREENCOMS)

      :PREVIOUS-DATE " 6-Nov-2022 20:14:51" {WMEDLEY}<library>tedit>TEDIT-SCREEN.;219)


(PRETTYCOMPRINT TEDIT-SCREENCOMS)

(RPAQQ TEDIT-SCREENCOMS
       ([DECLARE%: EVAL@COMPILE DONTCOPY
               (EXPORT (RECORDS THISLINE LINEDESCRIPTOR LINECACHE PENDINGTAB)
                      (MACROS SAVEBREAK DOBREAK FORGETHYPHENBREAK HCSCALE HCUNSCALE)
                      (GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
                      (ADDVARS (CHARACTERNAMES (EM-DASH "357,045")
                                      (SOFT-HYPHEN "357,043")
                                      (NONBREAKING-HYPHEN "357,042")))
                      (COMS                                  (* ; "Formatting slots held by THISLINE")
                            (RECORDS CHARSLOT)
                            (MACROS CHAR CHARW PREVCHARSLOT PREVCHARSLOT! NEXTCHARSLOT FIRSTCHARSLOT
                                   NTHCHARSLOT LASTCHARSLOT FILLCHARSLOT BACKCHARS PUSHCHAR POPCHAR 
                                   CHARSLOTP)
                            (CONSTANTS (CELLSPERCHARSLOT 2)
                                   (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
                                   (MAXCHARSLOTS 256))
                            
                            (* ;; "incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards.")

                            (I.S.OPRS incharslots backcharslots inlines]
        (INITRECORDS THISLINE LINEDESCRIPTOR LINECACHE)
        (FNS \FORMATLINE \FORMATLINE.JUSTIFY \FORMATLINE.TABS \FORMATLINE.PURGE.SPACES 
             \FORMATLINE.NEWNSCHARS \TEDIT.LOOKS.UPDATE \CLEARTHISLINE \TLVALIDATE)
        (FNS \DISPLAYLINE \DISPLAYLINE.TABS \TEDIT.LINECACHE \TEDIT.CREATE.LINECACHE \TEDIT.BLTCHAR)
        (DECLARE%: EVAL@COMPILE DONTCOPY 

               (* ;; "Machine independent version of \TEDIT.BLTCHAR")

               (MACROS MI-TEDIT.BLTCHAR))
        (FNS TEDIT.CR.UPDATESCREEN TEDIT.DELETELINE TEDIT.INSERT.DISPLAYTEXT 
             TEDIT.INSERT.UPDATESCREEN TEDIT.UPDATE.SCREEN \BACKFORMAT \FILLWINDOW \FIXDLINES 
             \FIXILINES \SHOWTEXT \TEDIT.ADJUST.LINES \TEDIT.CLEAR.SCREEN.BELOW.LINE 
             \TEDIT.CLOSEUPLINES \TEDIT.FIXCHANGEDLINE \TEDIT.FIXCHANGEDPART \TEDIT.INSERTLINE 
             \TEDIT.LINE.LIST \TEDIT.MARK.LINES.DIRTY \TEDIT.NEXT.LINE.BOTTOM 
             \TEDIT.COPY.LINEDESCRIPTOR)))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE THISLINE (
                    (* ;; 
        "Cache for line-related character location info, for selection and line-display code to use.")

                    (DESC FULLXPOINTER)                      (* ; 
                                                    "Line descriptor for the line this describes now")
                    TLSPACEFACTOR                            (* ; 
                                                   "The SPACEFACTOR to be used in printing this line")
                    TLFIRSTSPACE                             (* ; "The first space to which SPACEFACTOR is to apply.  This is used sothat spaces to the left of a TAB have their default width.")
                    CHARSLOTS                                (* ; "Pointer block holdomg char/width slots MAXCHARSLOTS (with an extra slot so that there is always storage behind NEXTAVAILABLECHARSLOT")
                    NEXTAVAILABLECHARSLOT)                   (* ; 
                                  "The last used CHARSLOT is at (PREVCHARSLOT NEXTAVAILABLECHARSLOT)")
                   CHARSLOTS _ (\ALLOCBLOCK (ITIMES (ADD1 MAXCHARSLOTS)
                                                   CELLSPERCHARSLOT)
                                      PTRBLOCK.GCT))

(DATATYPE LINEDESCRIPTOR 
          (
           (* ;; 
       "Description of a single line of formatted text, either on the display or for a printed page.")

           YBOT                                              (* ; 
                                             "Y value for the bottom of the line (below the descent)")
           YBASE                                             (* ; 
                                                     "Yvalue for the base line the characters sit on")
           LEFTMARGIN                                        (* ; "Left margin, in screen points")
           RIGHTMARGIN                                       (* ; "Right margin, in screen points")
           LXLIM                                             (* ; "X value of right edge of rightmost character on the line (may exceed right margin, if char is a space.)")
           NIL                                               (* ; "Was SPACELEFT: Space left on the line, ignoring trailing blanks & CRs. But equivalent to RIGHTMARGIN - LXLIM.")
           LHEIGHT                                           (* ; 
                                                          "Total height of hte line, Ascent+Descent.")
           ASCENT                                            (* ; "Ascent of the line above YBASE")
           DESCENT                                           (* ; "How far line descends below YBASE")
           LTRUEDESCENT                                      (* ; 
                                       "The TRUE DESCENT for this line, unadjusted for line leading.")
           LTRUEASCENT                                       (* ; 
                               "The TRUE ASCENT for this line, unadjusted for pre-paragraph leading.")
           CHAR1                                             (* ; 
                                                            "CH# of the first character on the line.")
           CHARLIM                                           (* ; 
                                                             "CH# of the last character on the line")
           CHARTOP                                           (* ; 
                              "CH# of the character which forced the line break (may exceed CHARLIM)")
           NEXTLINE                                          (* ; "Next line chain pointer")
           (PREVLINE FULLXPOINTER)                           (* ; "Previous line chain pointer")
           LMARK                                             (* ; "One of SOLID, GREY, NIL.  Tells what kind of special-line marker should be put in the left margin for this paragraph.  (For hardcopy, can also be an indicator for special processing?)")
           LTEXTOBJ                                          (* ; "A cached TEXTOBJ that this line took its text from.  Used in hardcopy to disambiguate when chno's should be updated...")
           NIL                                               (* ; "Was CACHE: A cached THISLINE, for keeping hardcopy info around while we crunch with the line descriptors to make things fit.  Now:  THISLINE comes from TEXTOBJ")
           NIL                                               (* ; 
                      "Was LDOBJ: The object which lies behind this line of text, for updating, etc.")
           LFMTSPEC                                          (* ; 
                                             "The format spec for this line's paragraph (eventually)")
           (DIRTY FLAG)                                      (* ; 
                                            "T if this line has changed since it was last formatted.")
           (CR\END FLAG)                                     (* ; "T if this line ends with a CR.")
           (DELETED FLAG)                                    (* ; "T if this line has been completely deleted since it was last formatted or displayed.  (Used by deletion routines to detect garbage lines)")
           (LHASPROT FLAG)                                   (* ; 
                                                             "This line contains protected text.")
           (NIL FLAG)                                        (* ; "Was: LHASTABS.  But never fetched and this descriptions wasn't true: If this line has a tab in it, this is the line-relative ch# of the final tab.  This is to let us punt properly with tabs in a line.")
           (1STLN FLAG)                                      (* ; 
                                                         "This line is the first line in a paragraph")
           (LSTLN FLAG)                                      (* ; 
                                                             "This is the last line in a paragraph")
           )
          CHARLIM _ 1000000 NEXTLINE _ NIL PREVLINE _ NIL DIRTY _ NIL YBOT _ 0 YBASE _ 0 LEFTMARGIN _
          0 DELETED _ NIL)

(DATATYPE LINECACHE (
                     (* ;; "Image cache for display lines.")

                     LCBITMAP                                (* ; 
                                         "The bitmap that will be used by this instance of the cache")
                     (LCNEXTCACHE FULLXPOINTER)              (* ; 
                                                   "The next cache in the chain, for screen updates.")
                     ))

(DATATYPE PENDINGTAB (
                      (* ;; "The data structure for a tab, within the line formatter, that we haven't finished dealing with yet, e.g. a centered tab where you need to wait for AFTER the centered text to do the formatting.")

                      PTNEWTX

                      (* ;; "An updated TX, being passed back to the line formatter.  This results from the resolution of an old RIGHT, CENTERED, or DECIMAL tab, which changed the width of a prior tab.")

                      PTOLDTAB                               (* ; "The pending tab")
                      PTTYPE                                 (* ; "Its tab type")
                      PTTABX                                 (* ; "Its nominal X position")
                      (PTCHARSLOT FULLXPOINTER)              (* ; "The CHARSLOT that may need to be updated later.  (RMK:  I don't know why this is a FULLXPOINTER--maybe an issue in the older THISLINE implementation?)")
                      PTOLDTX                                (* ; 
                                                         "The TX as of when the tab was encountered.")
                      ))
)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)

(/DECLAREDATATYPE 'PENDINGTAB '(POINTER POINTER POINTER POINTER FULLXPOINTER POINTER)
       '((PENDINGTAB 0 POINTER)
         (PENDINGTAB 2 POINTER)
         (PENDINGTAB 4 POINTER)
         (PENDINGTAB 6 POINTER)
         (PENDINGTAB 8 FULLXPOINTER)
         (PENDINGTAB 10 POINTER))
       '12)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS SAVEBREAK MACRO ((CN CS)
                           (SETQ ASCENTB ASCENT)
                           (SETQ DESCENTB DESCENT)
                           (SETQ CHNOB CN)
                           (SETQ CHARSLOTB CS)
                           (SETQ TXB TX)))

(PUTPROPS DOBREAK MACRO (NIL (SETQ ASCENT ASCENTB)
                             (SETQ DESCENT DESCENTB)
                             (SETQ TX TXB)
                             (SETQ CHARTOP CHNOB)
                             (SETQ CHARSLOT CHARSLOTB)))

(PUTPROPS FORGETHYPHENBREAK MACRO (NIL (CL:WHEN PREVDHYPH    (* ; 
                                                             "Previous soft hyphen becomes invisible")
                                           (add TX (IMINUS (CHARW PREVDHYPH)))
                                           (FILLCHARSLOT PREVDHYPH NIL 1))
                                       (SETQ PREVDHYPH (SETQ PREVHYPH NIL))))

(PUTPROPS HCSCALE MACRO ((SCALE ITEM)
                         (FIXR (FTIMES SCALE ITEM))))

(PUTPROPS HCUNSCALE MACRO ((SCALE ITEM)
                           (FIXR (FQUOTIENT ITEM SCALE))))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
)

(ADDTOVAR CHARACTERNAMES (EM-DASH "357,045")
                         (SOFT-HYPHEN "357,043")
                         (NONBREAKING-HYPHEN "357,042"))



(* ; "Formatting slots held by THISLINE")

(DECLARE%: EVAL@COMPILE

(BLOCKRECORD CHARSLOT (CHAR CHARW))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS CHAR MACRO ((CSLOT)
                      (ffetch (CHARSLOT CHAR) of CSLOT)))

(PUTPROPS CHARW MACRO ((CSLOT)
                       (ffetch (CHARSLOT CHARW) of CSLOT)))

(PUTPROPS PREVCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT (IMINUS WORDSPERCHARSLOT))))

(PUTPROPS PREVCHARSLOT! MACRO ((CSLOT)

                               (* ;; "Backs over looks and invisibles to the last character slot")

                               (find CS _ (PREVCHARSLOT CSLOT) by (PREVCHARSLOT CS) while CS
                                  suchthat (CHAR CS))))

(PUTPROPS NEXTCHARSLOT MACRO ((CSLOT)
                              (\ADDBASE CSLOT WORDSPERCHARSLOT)))

(PUTPROPS FIRSTCHARSLOT MACRO ((TLINE)
                               (fetch (THISLINE CHARSLOTS) of TLINE)))

(PUTPROPS NTHCHARSLOT MACRO ((TLINE N)
                             (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                    (ITIMES N WORDSPERCHARSLOT))))

(PUTPROPS LASTCHARSLOT MACRO ((TLINE)
                              (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE)
                                     (TIMES (SUB1 MAXCHARSLOTS)
                                            WORDSPERCHARSLOT))))

(PUTPROPS FILLCHARSLOT MACRO ((CSLOT C W)
                              (freplace (CHARSLOT CHAR) of CSLOT with C)
                              (freplace (CHARSLOT CHARW) of CSLOT with W)))

(PUTPROPS BACKCHARS MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                           (SETQ CSLOTVAR (PREVCHARSLOT CSLOTVAR))
                           (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                           (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))))

(PUTPROPS PUSHCHAR MACRO ((CSLOTVAR C W)
                          (FILLCHARSLOT CSLOTVAR C W)
                          (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS POPCHAR MACRO ((CSLOTVAR CHARVAR WIDTHVAR)
                         (SETQ CHARVAR (fetch (CHARSLOT CHAR) of CSLOTVAR))
                         (SETQ WIDTHVAR (fetch (CHARSLOT CHARW) of CSLOTVAR))
                         (SETQ CSLOTVAR (NEXTCHARSLOT CSLOTVAR))))

(PUTPROPS CHARSLOTP MACRO [OPENLAMBDA (X TL)

                            (* ;; "True if TL is a THISLINE and X is a pointer into its CHARSLOTS block.  A tool for consistency assertions.")

                            (CL:WHEN (TYPE? THISLINE TL)
                                [LET ((FIRSTSLOT (FIRSTCHARSLOT TL))
                                      (LASTSLOT (LASTCHARSLOT TL)))
                                     (AND [OR (IGREATERP (\HILOC X)
                                                     (\HILOC FIRSTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC FIRSTSLOT))
                                                   (IGEQ (\LOLOC X)
                                                         (\LOLOC FIRSTSLOT]
                                          (OR (ILESSP (\HILOC X)
                                                     (\HILOC LASTSLOT))
                                              (AND (EQ (\HILOC X)
                                                       (\HILOC LASTSLOT))
                                                   (ILEQ (\LOLOC X)
                                                         (\LOLOC LASTSLOT])])
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ CELLSPERCHARSLOT 2)

(RPAQ WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))

(RPAQQ MAXCHARSLOTS 256)


(CONSTANTS (CELLSPERCHARSLOT 2)
       (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
       (MAXCHARSLOTS 256))
)



(* ;; 
"incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards."
)

(DECLARE%: EVAL@COMPILE 

(I.S.OPR 'incharslots NIL '[SUBST (GETDUMMYVAR)
                                  '$$STARTSLOT
                                  '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                      declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                      first (SETQ I.V. (COND
                                                          ((TYPE? THISLINE $$STARTSLOT)
                                                           (FIRSTCHARSLOT $$STARTSLOT))
                                                          (T $$STARTSLOT)))
                                            (SETQ $$CHARSLOTLIMIT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                ) of THISLINE))
                                      by (NEXTCHARSLOT I.V.) until (EQ I.V. $$CHARSLOTLIMIT)
                                      eachtime (SETQ CHAR (fetch (CHARSLOT CHAR) of I.V.))
                                            (SETQ CHARW (fetch (CHARSLOT CHARW) of I.V.]
       T)

(I.S.OPR 'backcharslots NIL '[SUBST (GETDUMMYVAR)
                                    '$$STARTSLOT
                                    '(bind $$STARTSLOT _ BODY CHAR CHARW $$CHARSLOTLIMIT
                                        declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT)
                                        first (SETQ I.V. (COND
                                                            ((TYPE? THISLINE $$STARTSLOT)
                                                             (PREVCHARSLOT (fetch (THISLINE 
                                                                                NEXTAVAILABLECHARSLOT
                                                                                         )
                                                                              of THISLINE)))
                                                            (T $$STARTSLOT)))
                                              (SETQ $$CHARSLOTLIMIT (FIRSTCHARSLOT THISLINE))
                                        by (PREVCHARSLOT I.V.) eachtime (SETQ CHAR
                                                                         (fetch (CHARSLOT CHAR)
                                                                            of I.V.))
                                                                     (SETQ CHARW (fetch (CHARSLOT
                                                                                         CHARW)
                                                                                    of I.V.))
                                        repeatuntil (EQ I.V. $$CHARSLOTLIMIT]
       T)

[I.S.OPR 'inlines NIL '(first (SETQ I.V. (OR BODY (GO $$OUT)))
                          by (OR (fetch (LINEDESCRIPTOR NEXTLINE) of I.V.)
                                 (GO $$OUT]
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'THISLINE '(FULLXPOINTER POINTER POINTER POINTER POINTER)
       '((THISLINE 0 FULLXPOINTER)
         (THISLINE 2 POINTER)
         (THISLINE 4 POINTER)
         (THISLINE 6 POINTER)
         (THISLINE 8 POINTER))
       '10)

(/DECLAREDATATYPE 'LINEDESCRIPTOR
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER POINTER POINTER POINTER 
               FLAG FLAG FLAG FLAG FLAG FLAG FLAG)
       '((LINEDESCRIPTOR 0 POINTER)
         (LINEDESCRIPTOR 2 POINTER)
         (LINEDESCRIPTOR 4 POINTER)
         (LINEDESCRIPTOR 6 POINTER)
         (LINEDESCRIPTOR 8 POINTER)
         (LINEDESCRIPTOR 10 POINTER)
         (LINEDESCRIPTOR 12 POINTER)
         (LINEDESCRIPTOR 14 POINTER)
         (LINEDESCRIPTOR 16 POINTER)
         (LINEDESCRIPTOR 18 POINTER)
         (LINEDESCRIPTOR 20 POINTER)
         (LINEDESCRIPTOR 22 POINTER)
         (LINEDESCRIPTOR 24 POINTER)
         (LINEDESCRIPTOR 26 POINTER)
         (LINEDESCRIPTOR 28 POINTER)
         (LINEDESCRIPTOR 30 FULLXPOINTER)
         (LINEDESCRIPTOR 32 POINTER)
         (LINEDESCRIPTOR 34 POINTER)
         (LINEDESCRIPTOR 36 POINTER)
         (LINEDESCRIPTOR 38 POINTER)
         (LINEDESCRIPTOR 40 POINTER)
         (LINEDESCRIPTOR 40 (FLAGBITS . 0))
         (LINEDESCRIPTOR 40 (FLAGBITS . 16))
         (LINEDESCRIPTOR 40 (FLAGBITS . 32))
         (LINEDESCRIPTOR 40 (FLAGBITS . 48))
         (LINEDESCRIPTOR 38 (FLAGBITS . 0))
         (LINEDESCRIPTOR 38 (FLAGBITS . 16))
         (LINEDESCRIPTOR 38 (FLAGBITS . 32)))
       '42)

(/DECLAREDATATYPE 'LINECACHE '(POINTER FULLXPOINTER)
       '((LINECACHE 0 POINTER)
         (LINECACHE 2 FULLXPOINTER))
       '4)
(DEFINEQ

(\FORMATLINE
  [LAMBDA (TEXTOBJ FMTSPEC CH#1 LINE)                        (* ; "Edited  7-Nov-2022 12:47 by rmk")
                                                             (* ; "Edited 29-Oct-2022 19:45 by rmk")
                                                             (* ; "Edited 23-Oct-2022 09:11 by rmk")

    (* ;; "Given a starting place, format the next line of text.  Return the LINEDESCRIPTOR;  reusing LINE if it's given.")

    (* ;; "If CH#1 is past end of document, \FORMATLINE returns an empty line descriptor that is set up correctly wrt leading and font.  This is used by \FILLWINDOW to create the dummy line at end of document when you hit an EOL there. The SPECVARS may be reset under the BIN, by the LOOKSUPDATEFN.")

    (* ;; "")

    (* ;; "The objective of this body of code is to find")

    (* ;; "   CHAR1:  The CHNO of the first visible character/object of this line")

    (* ;; "   CHARTOP:  The CHNO of the last character on this line.  CHARTOP+1 is the CHNO of the first character of the next line.")

    (* ;; "   LXLIM:   The X coordinate of the right edge of character/object CHARTOP")

    (* ;; "   PREVSP:  The slot position in THISLINE of the right most scalable space.")

    (* ;; "  THISLINE:  The CHARSLOT vector that contains the actual characters and widths, together with their looks, as abstracted from the piece sequences of the underlying text.")

    (* ;; "")

    (* ;; "CHARTOP is the rightmost of a run of spaces or a hyphen such that there is no space or hyphen breakpoint before the subsequent characters overflow the right margin.")

    (* ;; " ")
                                                             (* ; "")

    (* ;; "At the end, \FORMATLINE.JUSTIFYmodifies LINE and THISLINE to deal with the vagaries of justification.")

    (BTVALIDATE '\FORMATLINE 'START TEXTOBJ)
    (CL:UNLESS LINE                                          (* ; "Not needed until the end, but then we might not get the starting values for WRIGHT and WBOTTOM, if those change from piece to piece--check this.")
        [SETQ LINE (create LINEDESCRIPTOR
                          RIGHTMARGIN _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                          YBOT _ (SUB1 (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ])
    (SETQ CH#1 (IMAX CH#1 1))
    (PROG ((TSTREAM (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
           (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (DS (WINDOWPROP (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                      'DSP))
           (ASCENT 0)
           (DESCENT 0)
           (ASCENTB 0)
           (DESCENTB 0)
           (DEFAULTTAB 36)
           (LEFTEDGE 8)
           (SCALE 1)
           (DEVICE 'DISPLAY)
           ORIGFMTSPEC PC CHARSLOT PREVSP 1STLN LEFTMARGIN PROTECTED CHNOB CHARTOP CR\END LSTLN CHNO
           TX TXB WIDTH FONT CHARSLOTB TABPENDING TABSPEC PREVHYPH PREVDHYPH *TEDIT-CACHED-FMTSPEC* 
           START-OF-PIECE)
          (DECLARE (SPECVARS CHARSLOT CHNO ASCENT DESCENT FONT DEVICE START-OF-PIECE))

     (* ;; "Variables (TLEN = Current character count on the line")

     (* ;; "CHNO = Current character # in the text")

     (* ;; "CHARSLOT = Pointer to the next available slot in THISLINE's CHARS.")

     (* ;; "DX = width of current char/object")

     (* ;; "TX = Right end of current text")

     (* ;; "PREVSP = CHARPOS of the last space of the most recent space-run")

     (* ;; "ASCENT, DESCENT = The ascent and descent values at the current character position")

     (* ;; 
     "ASCENTB, DESCENTB, CHNOB, TXB, CHARSLOTB = The values at the most recent potential break-point")

     (* ;; "Maybe *TEDIT-CACHED-FMTSPEC* is supposed to be free, held over between calls?  If so, INITVARS in TEDIT-SCREEN")

          (SETQ CHARSLOT (FIRSTCHARSLOT THISLINE))
          (SETQ PC (\CHTOPC CH#1 TEXTOBJ T))
          (CL:WHEN (AND PC (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC))
                        (SETQ PC (\NEXT.VISIBLE.PIECE PC)))
              (SETQ CH#1 (\PCTOCH PC))                       (* ; 
                                                     "Unusual, simpler than keeping track on the fly")
              (SETQ START-OF-PIECE CH#1))                    (* ; "Ready to go")
          (SETQ CHNO CH#1)
          [COND
             [PC                                             (* ; "We have a visible piece")

              (* ;; "The paragraph looks of a line are the same for every piece of every line in a paragraph, only the character looks can change from piece to piece.  If FMTSPEC is not provided, we extract it from the starting piece, or the stream's default.")

              (CL:UNLESS FMTSPEC
                  (SETQ FMTSPEC (OR (PPARALOOKS PC)
                                    (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ))))
              (SETQ FMTSPEC (\TEDIT.APPLY.PARASTYLES FMTSPEC PC TSTREAM))
              (SETQ ORIGFMTSPEC FMTSPEC)                     (* ; 
                                                   "Saved for justify, in case hardcopy-display mode")
              (CL:UNLESS (EQ FMTSPEC *TEDIT-CACHED-FMTSPEC*)

                  (* ;; "The cache of styles for the current paragraph is invalid; flush it, and note the new paragraph to cache for.")

                  (SETQ *TEDIT-CURRENTPARA-CACHE* NIL)
                  (SETQ *TEDIT-CACHED-FMTSPEC* FMTSPEC))
              (CL:WHEN (fetch FMTHARDCOPY of FMTSPEC)        (* ; 
                                                           "Set up for an ugly hardcopy-display line")
                  [SETQ DEVICE (OR (fetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ)
                                   (replace (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ
                                      with (OPENIMAGESTREAM '{NODIRCORE} 'POSTSCRIPT]
                  (SETQ SCALE (DSPSCALE NIL DEVICE))
                  (SETQ FMTSPEC (\TEDIT.HCPYFMTSPEC FMTSPEC DEVICE))
                  (SETQ DEFAULTTAB (HCSCALE SCALE DEFAULTTAB))
                  (SETQ LEFTEDGE (HCSCALE SCALE LEFTEDGE)))

              (* ;; "This line starts a paragraph if it starts the document or it is at the beginning of a piece just after a last-paragraph piece. This assumes that only visible pieces matter; otherwise, use PREVPIECE.")

              (SETQ TABSPEC (fetch TABSPEC of FMTSPEC))
              [SETQ 1STLN (OR (IEQP CH#1 1)
                              (AND (IEQP CH#1 START-OF-PIECE)
                                   (OR (NOT (\PREV.VISIBLE.PIECE PC))
                                       (PPARALAST (\PREV.VISIBLE.PIECE PC]
              [SETQ LEFTMARGIN (IPLUS LEFTEDGE (HCSCALE SCALE (fetch (TEXTOBJ WLEFT) of TEXTOBJ))
                                      (CL:IF 1STLN
                                          (fetch 1STLEFTMAR of FMTSPEC)
                                          (fetch LEFTMAR of FMTSPEC))]
              [SETQ WIDTH (if (ZEROP (fetch RIGHTMAR of FMTSPEC))
                              then                           (* ; 
                                                         "RIGHTMAR = 0 => follow the window's width.")
                                   (HCSCALE SCALE (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                                         LEFTEDGE))
                            else (IPLUS LEFTEDGE (fetch RIGHTMAR of FMTSPEC]

              (* ;; "The unchanging paragraph looks have now been established ")

              (* ;; 
          "Set up the LOOKSUPDATEFN to initialize with the character looks of the starting piece PC.")

              (replace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with (FUNCTION \TEDIT.LOOKS.UPDATE))

              (* ;; " LOOKSUPDATEFN is called at piece boundaries, sets up looks variables, returns NIL from BIN (= \TEXTBIN) if the stream runs out of characters.")

              (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with NIL)
              (\INSTALL.PIECE TSTREAM PC (- CH#1 START-OF-PIECE))
                                                             (* ; "Set up starting piece for BIN")
              (SETQ TX LEFTMARGIN)

              (* ;; 
              "TEXTLEN anticipates the EOL error.  Wouldn't need it if we reset the ENDOFSTREAMOP.")

              (* ;; 
              "INSPACES=T if continuing in a space-run, INWORD=T if continuing in a non-space run.")

              (bind CH BOX DX INSPACES INWORD (LASTCHARSLOT _ (LASTCHARSLOT THISLINE))
                    (TEXTLEN _ (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)) for old CHNO by 1
                 while (ILEQ CHNO TEXTLEN) while (SETQ CH (BIN TSTREAM))
                 do

                 (* ;; "Get CH's X width.")

                 [SETQ DX (COND
                             [(SMALLP CH)                    (* ; "CH is really a character")
                              (COND
                                 ((AND (IGEQ CH 192)
                                       (ILEQ CH 207))        (* ; 
                                                       "This is an NS accent character.  Space it 0.")
                                  0)
                                 (T                          (* ; 
                                                             "Regular character.  Get it's width.")
                                    (\FGETCHARWIDTH FONT CH]
                             (T                              (* ; "CH is an object, get its size.")
                                (SETQ BOX (APPLY* (IMAGEOBJPROP CH 'IMAGEBOXFN)
                                                 CH DS TX WIDTH))
                                (CL:WHEN (IEQP CHNO CH#1)

                                 (* ;; "Ignore the line-start-font height parameters if the object is first on the line.  It may be the only thing on the line and its height may be smaller than the font height (e.g. an HRULE).")

                                    (SETQ ASCENT (SETQ DESCENT 0)))
                                [SETQ ASCENT (IMAX ASCENT (IDIFFERENCE (fetch YSIZE of BOX)
                                                                 (fetch YDESC of BOX]
                                (SETQ DESCENT (IMAX DESCENT (fetch YDESC of BOX)))
                                (IMAGEOBJPROP CH 'BOUNDBOX BOX)
                                (fetch XSIZE of BOX]
                 [SELCHARQ CH
                      (SPACE (CL:UNLESS INSPACES             (* ; "First of a space run.  ")
                                 (FORGETHYPHENBREAK)

                                 (* ;; "We don't do the overflow test as long as we are in a space run, since space runs can protrude into the right margin. We continue to advance TX and CHNO, and we record the space charslots for future expansion.")

                                 (SETQ INWORD NIL)
                                 (SETQ INSPACES T))

                             (* ;; "CHAR is the slot of the previous space, not this space character, CHARW is the natural width of this space. PREVSP is the new chain-header.")

                             (PUSHCHAR CHARSLOT (PROG1 PREVSP (SETQ PREVSP CHARSLOT))
                                    DX)
                             (add TX DX))
                      ((EOL CR LF FORM)                      (* ; 
                                                    " Force an end to the line. Should FORM do more.")
                           [SETQ DX (IMAX DX (\FGETCHARWIDTH FONT (CHARCODE SPACE]
                                                             (* ; 
                                                            "Maximum insures something to point at??")
                           (add TX DX)
                           (FILLCHARSLOT CHARSLOT (CHARCODE EOL)
                                  DX)
                           (SETQ CR\END DX)
                           (SETQ LSTLN T)
                           (RETURN))
                      (TAB 
                           (* ;; "Try to be reasonable with tabs.  This will create trouble when doing fast-case insert/delete, but Pah! for now.")

                           (* ;; "Remove all prior candidate break points")

                           (FORGETHYPHENBREAK)
                           (\FORMATLINE.PURGE.SPACES PREVSP) (* ; 
                                             "Pre-tab spaces don't take part in later justification.")
                           (SETQ PREVSP NIL)
                           (SETQ INSPACES NIL)

                           (* ;; "Now for this tab:")

                           (FILLCHARSLOT CHARSLOT CH 0)      (* ; 
                                                       "Start with 0 width, then set up the next tab")
                           (SETQ TABPENDING (\FORMATLINE.TABS TEXTOBJ TABSPEC CHARSLOT TX DEFAULTTAB
                                                   LEFTEDGE TABPENDING SCALE))
                           [COND
                              ((FIXP TABPENDING)             (* ; 
                                                             "The new TX, adjusted for prior tabs")
                               (SETQ TX TABPENDING)
                               (SETQ TABPENDING NIL))
                              (TABPENDING                    (* ; "PENDINGTAB has the new TX")
                                     (SETQ TX (fetch PTNEWTX of TABPENDING]
                           (SETQ DX (CHARW CHARSLOT))        (* ; "Just-computed tab width ")
                           (add TX DX)
                           (SAVEBREAK CHNO CHARSLOT)
                           (SETQ CHARSLOT (NEXTCHARSLOT CHARSLOT)))
                      (PROGN

                       (* ;; "Not a space-formatting character.  If this ends a space run (INSPACES=T), then the last character was the end of the run.  It goes on the current line (if we have over flowed), the first word character goes on the next line.  ")

                       (CL:UNLESS INWORD                     (* ; "Remember the start of a word")
                           (CL:WHEN INSPACES                 (* ; 
                                            "The immediately last character was a space ending at TX")
                               (SAVEBREAK (SUB1 CHNO)
                                      PREVSP)
                               (SETQ INSPACES NIL))
                           (SETQ INWORD T))
                       (add TX DX)
                       (CL:WHEN (IGREATERP TX WIDTH)

                           (* ;; "Be careful here: CHARSLOT already points to the next (and pobably) last CHARSLOT.  So probaby best to fill before the return, not push.")

                           (if (OR (AND PREVSP (EQ CHARSLOTB PREVSP))
                                   PREVHYPH PREVDHYPH TABPENDING)
                               then                          (* ; 
                                                      "NOTE: Right-tab maybe should go on next line?")
                                    (DOBREAK)
                             elseif (IGREATERP DX WIDTH)
                               then 

                                 (* ;; "This character will never fit (e.g. a large image object).  No point in going to the next line, just continue and hope for a later break point.")

                                    (FILLCHARSLOT CHARSLOT CH DX)
                             elseif (IGREATERP CHNO CH#1)
                               then

                               (* ;; 
      "We've seen at least one real character, line is not empty, but no good candidate break point.")

                               (* ;; "If the overflow CH cannot appear as the first of the next line. or the previous character cannot appear at the end of this line, look back for an acceptable point to break.  We haven't yet pushed (CH, DX).")

                               (* ;; "If we run back to the beginning without finding a good break, we just take the original overflowed line. (Or, we could just chop at the end, and push the residue to the next line?")

                               (* ;; "TOO BAD WE DON'T HAVE A HEURISTIC HYPHENATOR")

                               (add TX (IMINUS DX))          (* ; 
                                                       "We start from the state before the overflow ")
                               (for CS PCS (X _ TX) backcharslots (PREVCHARSLOT CHARSLOT)
                                  as CN from (SUB1 CHNO)
                                  do [if CHAR
                                         then (CL:UNLESS (OR (MEMB CHAR TEDIT.DONT.BREAK.CHARS)
                                                             (AND (SETQ PCS (PREVCHARSLOT! CS))
                                                                  (MEMB (CHAR PCS)
                                                                        TEDIT.DONT.LAST.CHARS)))
                                                  (SETQ CHNO CN)
                                                             (* ; 
                                                             "The offender goes to the next line")
                                                  (SETQ CHARSLOT CS)
                                                  (SETQ TX X)
                                                  (RETURN))
                                              (add CN -1)
                                              (add X CHARW)
                                       else (add CN (IMINUS (OR (SMALLP CHARW)
                                                                0] finally 

                                                                         (* ;; 
                                               "Didn't find one, the offender protrudes on this line")

                                                                         (FILLCHARSLOT CHARSLOT CH DX
                                                                                ))
                             else 
                                  (* ;; 
                                  "Don't break: can't split before the first thing on the line!")

                                  (FILLCHARSLOT CHARSLOT CH DX))
                           (RETURN))

                       (* ;; "")

                       (* ;; 
                     "Not past the rightmargin yet. Save the character and width, then maybe adjust.")

                       (* ;; "In the sequence %"xx yyzz%", TXB is the width at the last break point.   If z is the overflow (TX tested above), we want to go back to TXB.")

                       (SELCHARQ CH
                            (%.                              (* ; 
                                                      "Check for decimal tabs, immediately after TAB")
                                (PUSHCHAR CHARSLOT CH DX)
                                (CL:WHEN (AND TABPENDING (EQ (fetch PTTYPE of TABPENDING)
                                                             'DECIMAL))
                                                             (* ; 
                             "Figure out which tab stop to use, and what we need to do to get there.")
                                    (add (fetch (PENDINGTAB PTTABX) of TABPENDING)
                                         DX)                 (* ; 
               "Adjust the tab stop's X value so that the LEFT edge of the decimal point goes there.")
                                    (SETQ TABPENDING
                                     (\FORMATLINE.TABS TEXTOBJ TABSPEC CHARSLOT TX DEFAULTTAB 
                                            LEFTMARGIN TABPENDING SCALE T))
                                                             (* ; 
                                                    "Tab over to the LEFT side of the decimal point.")
                                    [COND
                                       ((FIXP TABPENDING)    (* ; 
                            "If it returns a number, that is the new TX, adjusted for any prior tabs")
                                        (SETQ TX TABPENDING)
                                        (SETQ TABPENDING NIL))
                                       (TABPENDING           (* ; 
                                                   "Otherwise, look in the PENDINGTAB for the new TX")
                                              (SETQ TX (fetch PTNEWTX of TABPENDING]
                                    (\FORMATLINE.PURGE.SPACES PREVSP)
                                                             (* ; 
                                        "Spaces before a tab don't take part in later justification.")
                                    (SETQ PREVSP NIL)
                                    (SAVEBREAK CHNO CHARSLOT)))
                            ((- EM-DASH)                     (* ; "Hyphen, M-dash")
                                 (FORGETHYPHENBREAK)
                                 (SETQ PREVHYPH CHARSLOT)
                                 (SETQ INSPACES NIL)
                                 (SAVEBREAK CHNO CHARSLOT)   (* ; 
                                                             "Save the hyphen slot, then fill it")
                                 (PUSHCHAR CHARSLOT CH DX))
                            (NONBREAKING-HYPHEN 
                                                (* ;; 
                            "Switch the character code and width in case font doesn't have a glyph??")

                                 (PUSHCHAR CHARSLOT (CHARCODE -)
                                        (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                            (SOFT-HYPHEN                     (* ; 
                                                          "Discretionary hyphen may become invisible")
                                         (SETQ INSPACES NIL)
                                         (SETQ PREVDHYPH CHARSLOT)
                                         (SETQ PREVHYPH NIL)
                                         (SAVEBREAK CHNO CHARSLOT)
                                                             (* ; 
                                                "If this is the break, it will show as a real hyphen")
                                         (PUSHCHAR CHARSLOT (CHARCODE -)
                                                (\FGETCHARWIDTH FONT (CHARCODE "-"))))
                            (PUSHCHAR CHARSLOT CH DX] 

                 (* ;; "BOUNDS CHECKING!")

                 (CL:WHEN (EQ CHARSLOT LASTCHARSLOT)

                     (* ;; 
        "If too long, we let it roll over to the next line.  Should we put something in the margin??")

                     (TEDIT.PROMPTPRINT TEXTOBJ "Line too long to format." T)
                     (RETURN)) finally (SETQ CHARSLOT (PREVCHARSLOT CHARSLOT)) 
                                                             (* ; "Ran off the end of the text")
                                     (add CHNO -1))

              (* ;; "End of character loop.  Fix up last tab?")

              (CL:WHEN TABPENDING
                  (\FORMATLINE.PURGE.SPACES PREVSP)          (* ; "Ignore spaces before tabs")
                  (SETQ PREVSP NIL)
                  (SETQ TX (\FORMATLINE.TABS TEXTOBJ TABSPEC (FETCH (PENDINGTAB PTCHARSLOT)
                                                                OF TABPENDING)
                                  (IDIFFERENCE TX (OR CR\END 0))
                                  DEFAULTTAB LEFTEDGE TABPENDING 0 T)))]
             (T 
                (* ;; "No starting  PC: empty or beyond the end. Get looks from the TSTREAM, so that \DISPLAYLINE works.  Original code asked for the piece at TEXTLEN (last piece?) to get its looks, but those looks would be the TEXTOBJ default looks anyway.")

                (* ;; "NOTE: this follows the original in not distinguishing hardcopy-display mode. Presumably empty is empty.")

                (PUSHCHAR CHARSLOT NIL (fetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))

                (* ;; 
         "Font preferences: the caret looks, else the default for this text, else the system default")

                (SETQ CHNO CH#1)
                (SETQ FONT (OR (AND (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)))
                               (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                    (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)))
                               DEFAULTFONT))
                (SETQ ASCENT (FONTPROP FONT 'ASCENT))
                (SETQ DESCENT (FONTPROP FONT 'DESCENT))
                (SETQ FMTSPEC (OR FMTSPEC (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ)))
                (SETQ ORIGFMTSPEC FMTSPEC)
                (SETQ 1STLN T)
                (SETQ LEFTMARGIN (IPLUS LEFTEDGE (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                        (fetch 1STLEFTMAR of FMTSPEC)))
                (SETQ TX LEFTMARGIN)
                (SETQ WIDTH (CL:IF (ZEROP (fetch RIGHTMAR of FMTSPEC))
                                (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                       8)
                                (fetch RIGHTMAR of FMTSPEC))]

     (* ;; "")

     (* ;; 
     "All the line information is now in our variables.  Migrate to the LINE and THISLINE fields. ")

          (CL:UNLESS CHARTOP (SETQ CHARTOP CHNO))
          (freplace (LINEDESCRIPTOR CHAR1) of LINE with CH#1)
          (freplace (LINEDESCRIPTOR CHARLIM) of LINE with CHARTOP)
                                                             (* ; "LET JUSTIFIER FIGURE THIS OUT?")
          (freplace (LINEDESCRIPTOR CHARTOP) of LINE with CHARTOP)
          (freplace (LINEDESCRIPTOR 1STLN) of LINE with 1STLN)

     (* ;; "First line of a paragraph.  Special paragraph types get marked in the margin.")

          (freplace (LINEDESCRIPTOR LMARK) of LINE
             with (CL:WHEN [AND 1STLN (OR (EQ (fetch FMTPARATYPE of FMTSPEC)
                                              'PAGEHEADING)
                                          (fetch FMTNEWPAGEBEFORE of FMTSPEC)
                                          (fetch FMTNEWPAGEAFTER of FMTSPEC)
                                          [AND (fetch FMTSPECIALX of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALX of FMTSPEC]
                                          (AND (fetch FMTSPECIALY of FMTSPEC)
                                               (NOT (ZEROP (fetch FMTSPECIALY of FMTSPEC]
                         'GREY))
          (freplace (LINEDESCRIPTOR LSTLN) of LINE with LSTLN)
          (freplace (LINEDESCRIPTOR CR\END) of LINE with CR\END)
          (freplace (LINEDESCRIPTOR DIRTY) of LINE with NIL)
          (freplace (LINEDESCRIPTOR LHASPROT) of LINE with PROTECTED)
          (freplace (LINEDESCRIPTOR LEFTMARGIN) of LINE with LEFTMARGIN)
          (freplace (LINEDESCRIPTOR RIGHTMARGIN) of LINE with WIDTH)
                                                             (* ; "SHOULD THIS HAVE LEFTEDGE ADDED?")
          (freplace (LINEDESCRIPTOR LHEIGHT) of LINE
             with (CL:IF (ZEROP (IPLUS ASCENT DESCENT))
                      (FONTPROP (OR (AND (fetch (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ)
                                         (fetch CLFONT of (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ)))
                                    DEFAULTFONT)
                             'HEIGHT)
                      (IPLUS ASCENT DESCENT)))
          (freplace (LINEDESCRIPTOR ASCENT) of LINE with ASCENT)
          (freplace (LINEDESCRIPTOR DESCENT) of LINE with DESCENT)
          (freplace (LINEDESCRIPTOR LXLIM) of LINE with TX)
          (freplace (LINEDESCRIPTOR LFMTSPEC) of LINE with FMTSPEC)

     (* ;; "LINE is complete")

     (* ;; "")

          (freplace (THISLINE DESC) of THISLINE with LINE)
          (freplace (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE with (NEXTCHARSLOT CHARSLOT))
          (freplace (TEXTSTREAM LOOKSUPDATEFN) of TSTREAM with NIL)
          (\FORMATLINE.JUSTIFY TEXTOBJ LINE ORIGFMTSPEC THISLINE PREVSP)
          (RETURN LINE])

(\FORMATLINE.JUSTIFY
  [LAMBDA (TEXTOBJ LINE FMTSPEC THISLINE PREVSP)             (* ; "Edited 24-Oct-2022 23:40 by rmk")
                                                             (* ; "Edited 23-Oct-2022 23:28 by rmk")
                                                             (* ; "Edited 22-Oct-2022 00:06 by rmk")
                                                             (* ; "Edited 29-Mar-94 12:36 by jds")

    (* ;; "Do the formatting work for justified, centered, etc.  lines.  We begin by calculating how much space between the left margin and right margin is not occupied by the natural widths of the characters cached in THISLINE.  For this calculation we exclude spaces at the end of the line.  They are present for later display and selection, but are ignored for purposes of right, centered, and justified alignment.")

    (* ;; "The display-alignment is controlled by LEFTMARGIN and LXLIM.  At entry, LXLIM is the natural width of the line-characters.")

    (PROG ((QUAD (fetch QUAD of FMTSPEC))
           SPACELEFT NATURALWIDTHS COMMONWIDTH LINELEAD)
          (replace (LINEDESCRIPTOR LTRUEDESCENT) of LINE with (fetch (LINEDESCRIPTOR DESCENT)
                                                                 of LINE))
          (replace (LINEDESCRIPTOR LTRUEASCENT) of LINE with (fetch (LINEDESCRIPTOR ASCENT)
                                                                of LINE))
                                                             (* ; 
                                                    "Save the true ascent value for display purposes")
          (CL:WHEN (SETQ LINELEAD (fetch LINELEAD of FMTSPEC))
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   LINELEAD)
              (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                   LINELEAD))
          (CL:WHEN (AND (fetch (LINEDESCRIPTOR 1STLN) of LINE)
                        (fetch LEADBEFORE of FMTSPEC))       (* ; "Set paragraph pre-leading")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC))
              (add (fetch (LINEDESCRIPTOR ASCENT) of LINE)
                   (fetch LEADBEFORE of FMTSPEC)))
          (CL:WHEN (AND (fetch (LINEDESCRIPTOR LSTLN) of LINE)
                        (fetch LEADAFTER of FMTSPEC))        (* ; "Set paragraph post-leading")
              (add (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)
                   (fetch LEADAFTER of FMTSPEC))
              (add (fetch (LINEDESCRIPTOR DESCENT) of LINE)
                   (fetch LEADAFTER of FMTSPEC)))

     (* ;; "")

     (* ;; "Now for the horizontal alignment.  To start, assume that all spaces have their natural width, and then calculate the SPACELEFT not counting trailing spaces that may need to be distributed.")

          (CL:WHEN (EQ PREVSP (PREVCHARSLOT! (fetch (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE)))

              (* ;; "At least one trailing space, back up PREVSP and LXLIM.  Use PREVCHARSLOT! to be sure that any invisibles or looks don't interfere with a contiguous space-run.  (May never happen, but...)")

              (bind OPREVSP (LXLIM _ (ffetch (LINEDESCRIPTOR LXLIM) of LINE)) while PREVSP
                 do (SETQ OPREVSP PREVSP)
                    (SETQ PREVSP (CHAR OPREVSP))             (* ; 
                                                             "Back up to the next previous space")
                    (freplace (CHARSLOT CHAR) of OPREVSP with (CHARCODE SPACE))
                    (add LXLIM (IMINUS (CHARW OPREVSP))) repeatwhile (EQ PREVSP (PREVCHARSLOT! 
                                                                                       OPREVSP))
                 finally (freplace (LINEDESCRIPTOR LXLIM) of LINE with LXLIM)))
          [SETQ SPACELEFT (IMAX 0 (IDIFFERENCE (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE)
                                         (ffetch (LINEDESCRIPTOR LXLIM) of LINE]
          (replace (THISLINE TLSPACEFACTOR) of THISLINE with 1)
          (SELECTQ QUAD
              (LEFT                                          (* ; 
                                                             "Just purge spaces below, no stretching")
                    (RETURN))
              (RIGHT                                         (* ; 
                                                             "Move the right margin over, then purge")
                     (add (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                          SPACELEFT)
                     (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                                     of LINE))
                     (RETURN))
              (CENTERED                                      (* ; 
                                                             "Split the difference : 32 x value form")
                        (add (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                             (FOLDLO SPACELEFT 2))
                        (add (fetch (LINEDESCRIPTOR LXLIM) of LINE)
                             (FOLDLO SPACELEFT 2))
                        (RETURN))
              (JUSTIFIED (CL:UNLESS PREVSP                   (* ; "No spaces to stretch")
                             (RETURN))
                         (CL:WHEN (OR (fetch (LINEDESCRIPTOR CR\END) of LINE)
                                      (IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                            (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                                                             (* ; 
                                                          "Don't stretch last line in the paragraph.")
                             (RETURN))

                         (* ;; 
              "Apportion the extra space evenly among spaces, pushing LXLIM out to the right margin.")

                         (replace (LINEDESCRIPTOR LXLIM) of LINE with (fetch (LINEDESCRIPTOR 
                                                                                    RIGHTMARGIN)
                                                                         of LINE))

                         (* ;; 
      "If all the spaces on the line have the same natural width, we can avoid floating point below.")

                         (* ;; "NB we operate in 32 x value form, for rounding ease and accuracy.")

                         [SETQ NATURALWIDTHS (for (SPSLOT _ PREVSP)
                                                  W FIRSTWIDTH (NSPACES _ 0)
                                                  (ALLSAME _ T) by (CHAR SPSLOT)
                                                first (SETQ FIRSTWIDTH (CHARW SPSLOT)) while SPSLOT
                                                sum (add NSPACES 1)
                                                    (SETQ W (CHARW SPSLOT))
                                                    (CL:UNLESS (EQ W FIRSTWIDTH)
                                                           (SETQ ALLSAME NIL))
                                                    W
                                                finally (CL:WHEN ALLSAME
                                                            (SETQ COMMONWIDTH
                                                             (IPLUS (UNFOLD FIRSTWIDTH 32)
                                                                    (IQUOTIENT (UNFOLD SPACELEFT 32)
                                                                           NSPACES))))]
                         [if COMMONWIDTH
                             then 

                                 (* ;; "Fast loop for the more common case where all the spaces on a line are of the same width. Multiply by 32 to keep rounding precision. Avoids floating point allocation.")

                                  (for (SPSLOT _ PREVSP)
                                       EXPANDED
                                       (LOST _ 0) by (CHAR SPSLOT) while SPSLOT
                                     do (SETQ EXPANDED (IPLUS LOST COMMONWIDTH))
                                        (replace (CHARSLOT CHARW) of SPSLOT with (FOLDLO EXPANDED 32)
                                               )
                                        (SETQ LOST (IMOD EXPANDED 32)))
                           else 
                                (* ;; "The slow loop is for spaces of difference sizes. It allocates 3 floating point numbers per space.  ")

                                (for (SPSLOT _ PREVSP)
                                     EXPANDED NEWW (LOST _ 0.0)
                                     (MULTIPLIER _ (FPLUS 1.0 (FQUOTIENT SPACELEFT NATURALWIDTHS)))
                                   by (CHAR SPSLOT) while SPSLOT
                                   do 

                                 (* ;; "Spaces are in different fonts with different widths. What we lose in rounding at one space we add back in the next, until we finally get resynchronized.  The effect is that a later loss may ripple to a few earlier spaces.")

                                      (SETQ EXPANDED (FPLUS LOST (FTIMES (CHARW SPSLOT)
                                                                        MULTIPLIER)))
                                      (SETQ NEWW (FIXR EXPANDED))
                                      (freplace (CHARSLOT CHARW) of SPSLOT with NEWW)
                                      (SETQ LOST (FDIFFERENCE EXPANDED NEWW]

                         (* ;; "The \DISPLAYLINE for displaystreams does its own (Maiko) BLTCHAR, so the TLSPACEFACTOR actually isn't used.  But...")

                         (replace (THISLINE TLSPACEFACTOR) of THISLINE with (FQUOTIENT (IPLUS 
                                                                                        NATURALWIDTHS
                                                                                              
                                                                                            SPACELEFT
                                                                                              )
                                                                                   NATURALWIDTHS))
                         (RETURN))
              NIL))

    (* ;; 
  "Change all the spaces--chained for justification--back into regular spaces, for the display code.")

    (\FORMATLINE.PURGE.SPACES PREVSP])

(\FORMATLINE.TABS
  [LAMBDA (TEXTOBJ TABSPEC CHARSLOT TX DFLTTABX LEFTMARGIN PRIORTAB SCALE CLEANINGUP)
                                                             (* ; "Edited 29-Oct-2022 15:52 by rmk")
                                                             (* ; "Edited 22-Oct-2022 23:55 by rmk")
                                                             (* ; "Edited  9-Oct-2022 09:32 by rmk")
                                                             (* ; "Edited 29-Sep-2022 12:23 by rmk")
                                                             (* ; "Edited 26-Sep-2022 00:20 by rmk")
                                                             (* ; "Edited 13-Nov-90 01:09 by jds")
                                                             (* ; "Do the formatting work for a tab.")

    (* ;; "PRIORTAB is the outstanding tab, if any, that has to be resolved.  This will be a centered or flush right tab.  its format is a PENDINGTAB")

    (* ;; "If CLEANINGUP is non-NIL, then we're at the end of the line, and only need to resolve the outstanding tab.")

    (* ;; "GRAIN is the granularity of the tab spacing; anything within GRAIN will slop over to the next tab.  This is to finesse rounding problems when going among various devices.")

    (PROG (NEXTTAB NEXTTABTYPE NEXTTABX DEFAULTTAB TABWIDTH (GRAIN (FOLDLO SCALE 2)))
          (CL:WHEN PRIORTAB

              (* ;; "If there is a prior tab to resolve, do that first--it affects the perceived current X value, which affects later tabs")

              [SETQ TABWIDTH (IMAX 3 (IDIFFERENCE (IDIFFERENCE (fetch PTTABX of PRIORTAB)
                                                         (SELECTQ (fetch PTTYPE of PRIORTAB)
                                                             ((CENTERED DOTTEDCENTERED) 
                                                             (* ; "Centered around the tab X")
                                                                  (FOLDLO (IDIFFERENCE TX
                                                                                 (fetch PTOLDTX
                                                                                    of PRIORTAB))
                                                                         2))
                                                             ((RIGHT DOTTEDRIGHT DECIMAL 
                                                                     DOTTEDDECIMAL) 
                                                             (* ; "Snug up against the tab X")
                                                                  (IDIFFERENCE TX
                                                                         (fetch PTOLDTX of PRIORTAB)))
                                                             (SHOULDNT)))
                                            (fetch PTOLDTX of PRIORTAB]
              (replace (CHARSLOT CHARW) of (fetch (PENDINGTAB PTCHARSLOT) of PRIORTAB) with TABWIDTH)
              (add TX TABWIDTH))
          (CL:WHEN CLEANINGUP                                (* ; 
                               "We're cleaning up at end of line, so this shouldn't have any effect.")
              (RETURN TX))
          (SETQ DEFAULTTAB (OR (CAR TABSPEC)
                               DFLTTABX))                    (* ; 
                                            "Default Tab width, if there aren't any real tabs to use")
          [SETQ NEXTTAB (find TAB in (CDR TABSPEC) suchthat (IGREATERP (fetch TABX of TAB)
                                                                   (IDIFFERENCE TX LEFTMARGIN]
                                                             (* ; "The next tab on this line, if any")
          (SETQ NEXTTABTYPE (OR (AND NEXTTAB (fetch TABKIND of NEXTTAB))
                                'LEFT))                      (* ; 
                                     "The type of the next tab (LEFT, if we use the default spacing)")
          [SETQ NEXTTABX (IPLUS LEFTMARGIN (COND
                                              (NEXTTAB       (* ; 
                                                    "There is a real tab to go to; use its location.")
                                                     (fetch TABX of NEXTTAB))
                                              (T             (* ; 
                                         "No real tab; use the next multiple of the default spacing.")
                                                 (ITIMES DEFAULTTAB
                                                        (ADD1 (IQUOTIENT (IPLUS GRAIN
                                                                                (IDIFFERENCE TX 
                                                                                       LEFTMARGIN))
                                                                     DEFAULTTAB]
                                                             (* ; "The next tab's X value")
          (CL:WHEN (FMEMB NEXTTABTYPE '(DOTTEDLEFT DOTTEDCENTERED DOTTEDRIGHT DOTTEDDECIMAL))

              (* ;; "Change a dotted-leader tab to Meta,TAB, so the line displayer knows.")

              (replace (CHARSLOT CHAR) of CHARSLOT with (CHARCODE Meta,TAB)))
          (RETURN (if (FMEMB NEXTTABTYPE '(LEFT DOTTEDLEFT))
                      then                                   (* ; "Flush LEFT TAB.")
                           (replace (CHARSLOT CHARW) of CHARSLOT with (IMAX 1 (IDIFFERENCE NEXTTABX 
                                                                                     TX)))
                           TX
                    else (replace (CHARSLOT CHARW) of CHARSLOT with 0) 
                                                             (* ; "All others")
                         (create PENDINGTAB
                                PTNEWTX _ TX
                                PTTYPE _ NEXTTABTYPE
                                PTTABX _ NEXTTABX
                                PTCHARSLOT _ CHARSLOT
                                PTOLDTX _ TX])

(\FORMATLINE.PURGE.SPACES
  [LAMBDA (PREVSP)                                           (* ; "Edited 28-Sep-2022 15:13 by rmk")
                                                             (* ; "Edited 26-Sep-2022 17:17 by rmk")
                                                             (* ; "Edited 18-Sep-2022 09:41 by rmk")
                                                             (* jds " 9-NOV-83 17:12")

    (* ;; "Replace the locations of all the spaces that are temporarily in the character stack with the space character")

    (bind OPREVSP while PREVSP do (SETQ OPREVSP PREVSP)
                                  (SETQ PREVSP (CHAR OPREVSP))
                                  (replace (CHARSLOT CHAR) of OPREVSP with (CHARCODE SPACE])

(\FORMATLINE.NEWNSCHARS
  [LAMBDA (CH TEXTOBJ)                                       (* ; "Edited  1-Aug-2022 20:09 by rmk")
    (CL:WHEN (AND (EQ CH (CHARCODE NSCHARSETSHIFT))
                  (NOT (ffetch (TEXTOBJ TXTNONSCHARS) of TEXTOBJ)))

        (* ;; "Character-set change character.  This suggests undetected NS characters.")

        (HELP "PIECES SHOULD NOT CONTAIN NSCHARS")
        (\TEDIT.NSCHAR.RUN CHNO TEXTOBJ TEXTSTREAM)          (* ; 
                                                    "Leaves us ready to BIN again at the same place.")

        (* ;; "Back up the cache pointers and counters so that when we go to the top of the loop we're where we are now.")

        (SETQ CHLIST (\ADDBASE CHLIST -2))
        (SETQ WLIST (\ADDBASE WLIST -2))
        (add CHNO -1)
        (add TLEN -1)

        (* ;; "Because moving to NS characters changes the TEXTLEN for the shorter.")

        (SETQ TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
        T)])

(\TEDIT.LOOKS.UPDATE
  [LAMBDA (TSTREAM PC)                                       (* ; "Edited 24-Oct-2022 23:29 by rmk")
                                                             (* ; "Edited 30-May-91 21:47 by jds")

(* ;;; "Called from \INSTALL.PIECE under \FORMATLINE only when the new piece has different looks than the previous piece. This updates the line formatting fields such as ASCENT, DESCENT, etc.  This assumes that the \INSTALL.PIECE caller has passed over any invisible pieces, and that TSTREAM is set up consistently with looks that match PC")

    (* ;; "RMK: Storing the  looks in theTEXTSTREAM here seems to be an attempt to avoid calls to the \TEDIT.APPLY.STYLES function in the transition from piece to piece.  Presumably, the looks of each piece may be incomplete, and missing fields are filled in from the current (sequence of?) styles.  If the style is changed dynamically, then (also presumably) all of the currently displayed pieces should be upgraded.  But that doesn't appear to happen.")

    (* ;; "A simpler implementation, whether dynamic or not, would be to expand the looks when the piece is created or the style changes, so that each piece is always references its completed looks.  But the piece also needs to keep track of its partial looks, for restyling and for saving.")

    (* ;; "Style sheets are undocumented, I suspect that this was never really thought through.")

    (DECLARE (USEDFREE CHARSLOT CHNO PROTECTED ASCENT DESCENT FONT DEVICE))
    (CL:UNLESS PC                                            (* ; 
                                                          "Ran off the end ? Skips the ENDOFSTREAMOP")
        (RETFROM (FUNCTION \TEXTBIN)
               NIL))
    (LET (PLOOKS INVISIBLERUN)

         (* ;; "")

         (* ;; "We have to adjust the CHNO to pass over invisible pieces, and to record the number of characters we passed over in THISLINE's character vector.  This maintains the correspondence between the indexing of actual characters in the vector and characters positions in the stream.  This information isn't need for display, but TEDIT.SCAN.LINE requires that mapping.")

         (* ;; "Invisible runs are coded in a character slot, like other non-character entries (looks, objects) by putting a NIL in the CHAR field of a slot and putting the non-character information in the CHARWIDTH field.  Thus, an invisible run is represented as a pair (NIL,runlength).")

         (SETQ INVISIBLERUN (for old PC by (NEXTPIECE PC) while PC
                               while (OR (ZEROP (PLEN PC))
                                         (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PC)))
                               sum (PLEN PC)))
         (if (EQ 0 INVISIBLERUN)
             then 
                  (* ;; "If the looks are the same as current looks, we don't need to change anything.  APPLY STYLES AT PIECE CREATION??")

                  (SETQ PLOOKS (PLOOKS PC))
                  (CL:UNLESS (EQ PLOOKS (ffetch (TEXTSTREAM CURRENTLOOKS) of TSTREAM))
                      (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with PLOOKS)
                      (SETQ FONT (fetch (CHARLOOKS CLFONT) of PLOOKS))
                      (CL:WHEN (type? FONTCLASS FONT)
                          (SETQ FONT (FONTCOPY FONT 'DEVICE 'DISPLAY)))

                      (* ;; "Ascent and descent are in display units, even if hardcopy-displaymode")

                      [SETQ ASCENT (IMAX ASCENT (IPLUS (fetch \SFAscent of FONT)
                                                       (OR (ffetch (CHARLOOKS CLOFFSET) of PLOOKS)
                                                           0]
                      [SETQ DESCENT (IMAX DESCENT (IDIFFERENCE (fetch \SFDescent of FONT)
                                                         (OR (ffetch (CHARLOOKS CLOFFSET)
                                                                of PLOOKS)
                                                             0]
                      (CL:UNLESS (EQ DEVICE 'DISPLAY)        (* ; "Maybe hardcopy-display mode")
                          (SETQ FONT (FONTCOPY FONT 'DEVICE DEVICE)))
                      (CL:WHEN (ffetch (CHARLOOKS CLPROTECTED) of PLOOKS)
                                                             (* ; 
                                                         "Mark the line as containing protected text")
                          (SETQ PROTECTED T))
                      (PUSHCHAR CHARSLOT NIL PLOOKS))
           else (PUSHCHAR CHARSLOT NIL INVISIBLERUN)
                (add CHNO INVISIBLERUN)
                (\INSTALL.PIECE PC 0))
         PC])

(\CLEARTHISLINE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:09 by rmk")

    (* ;; "This sets it up for a consistency checker to determine that something has gone wrong.  Only called in an assertion.")

    (create THISLINE smashing THISLINE DESC _ 'NODESC TLSPACEFACTOR _ 'NOSPACEFACTOR TLFIRSTSPACE _
                           'NOTLFIRSTSPACE NEXTAVAILABLECHARSLOT _ (FIRSTCHARSLOT THISLINE))
    (for CHARSLOT _ (FIRSTCHARSLOT THISLINE)
         (LASTCHARSLOT _ (LASTCHARSLOT THISLINE)) until (EQ CHARSLOT LASTCHARSLOT)
       do (PUSHCHAR CHARSLOT 'BADCHAR 'BADCHARW))
    THISLINE])

(\TLVALIDATE
  [LAMBDA (THISLINE)                                         (* ; "Edited  7-Nov-2022 10:16 by rmk")

    (* ;; "Check validity of THISLINE, either just before or anytime after \FORMATLINE.JUSTIFY")

    [with THISLINE THISLINE (CL:WHEN (EQ DESC 'NODESC)
                                   (HELP "INVALID THISLINE" DESC))
          (CL:WHEN (EQ TLSPACEFACTOR 'NOSPACEFACTOR)
                 (HELP "INVALID THISLINE" TLSPACEFACTOR))
          (CL:WHEN (EQ TLFIRSTSPACE 'NOTLFIRSTSPACE)
                 (HELP "INVALID THISLINE" TLFIRSTSPACE))
          (CL:UNLESS (CHARSLOTP NEXTAVAILABLECHARSLOT THISLINE)
              (HELP "INVALID THISLINE" 'NEXTAVAILABLE))]
    (for CHARSLOT incharslots THISLINE do (if CHAR
                                              then (CL:UNLESS (OR (SMALLP CHAR)
                                                                  (CHARSLOTP CHAR THISLINE))

                                                       (* ;; 
                                                      "CHARSLOTP if spaces haven't been instantiated")

                                                       (HELP "INVALID THISLINE" 'BADCHAR))
                                                   (CL:UNLESS (SMALLP CHARW)
                                                       (HELP "INVALID THISLINE" 'BADCHARW))
                                            elseif (OR (SMALLP CHARW)
                                                       (type? CHARLOOKS CHARW))
                                            else (HELP "INVALID THISLINE" 'BADCHARW])
)
(DEFINEQ

(\DISPLAYLINE
  [LAMBDA (TEXTOBJ LINE WINDOW)                              (* ; "Edited 20-Oct-2022 13:12 by rmk")
                                                             (* ; "Edited  1-Oct-2022 23:21 by rmk")
                                                             (* ; "Edited 29-Sep-2022 15:31 by rmk")
                                                             (* ; "Edited 25-Sep-2022 16:02 by rmk")

    (* ;; "Display the line of text LINE in the edit window where it belongs.")

    (* ;; "Validate the incoming arguments so ffetch can be used consistently for all their field extractions.")

    (\DTEST TEXTOBJ 'TEXTOBJ)
    (\DTEST LINE 'LINEDESCRIPTOR)
    (LET ((WINDOWDS (WINDOWPROP (OR WINDOW (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
                           'DSP))
          (THISLINE (\DTEST (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)
                           'THISLINE))
          (OLDCACHE (fetch (LINECACHE LCBITMAP) of (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)))
          (DS (ffetch (TEXTOBJ DISPLAYCACHEDS) of TEXTOBJ))
          (HCPYDS (ffetch (TEXTOBJ DISPLAYHCPYDS) of TEXTOBJ))
          (HARDCOPYMODE (fetch (FMTSPEC FMTHARDCOPY) of (ffetch (LINEDESCRIPTOR LFMTSPEC)
                                                           of LINE)))
          CACHE XOFFSET CLIPLEFT CLIPRIGHT DISPLAYDATA DDPILOTBBT DDWIDTHCACHE DDOFFSETCACHE CURY 
          LHEIGHT SCALE)
         [SETQ LHEIGHT (COND
                          ((ffetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                                             (* ; 
                                    "So if theres a base-to-base measure, we clear everything right.")
                           (IMAX (IDIFFERENCE (ffetch (LINEDESCRIPTOR YBOT)
                                                 of (ffetch (LINEDESCRIPTOR PREVLINE) of LINE))
                                        (ffetch (LINEDESCRIPTOR YBOT) of LINE))
                                 (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE)))
                          (T (ffetch (LINEDESCRIPTOR LHEIGHT) of LINE]
         (SETQ SCALE (CL:IF HARDCOPYMODE
                         (DSPSCALE NIL HCPYDS)
                         1))
         (SETQ CACHE (\TEDIT.LINECACHE (ffetch (TEXTOBJ DISPLAYCACHE) of TEXTOBJ)
                            (CL:IF HARDCOPYMODE
                                (HCUNSCALE SCALE (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE))
                                (ffetch (LINEDESCRIPTOR RIGHTMARGIN) of LINE))
                            LHEIGHT))
         (CL:UNLESS (EQ CACHE OLDCACHE)                      (* ; 
                 "We changed the bitmaps because this line was bigger--update the displaystream, too")
             (DSPDESTINATION CACHE DS)
             (DSPCLIPPINGREGION (create REGION
                                       LEFT _ 0
                                       BOTTOM _ 0
                                       WIDTH _ (fetch BITMAPWIDTH of CACHE)
                                       HEIGHT _ (fetch BITMAPHEIGHT of CACHE))
                    DS)
             (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE))
         (BITBLT NIL 0 0 CACHE 0 0 NIL NIL 'TEXTURE 'REPLACE WHITESHADE)
                                                             (* ; "Clear the line cache")
         (CL:WHEN (AND (NOT (ZEROP (fetch (LINEDESCRIPTOR CHAR1) of LINE)))
                       (ILEQ (ffetch (LINEDESCRIPTOR CHAR1) of LINE)
                             (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                       (IGEQ (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                             (ffetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

             (* ;; "Only display the line if it contains text (CHAR1 > 0), appears before the end of the text, and is on-screen.")

             (CL:UNLESS (EQ (fetch (THISLINE DESC) of THISLINE)
                            LINE)                            (* ; 
                                                            "No image cache -- re-format and display")
                 (\FORMATLINE TEXTOBJ NIL (ffetch (LINEDESCRIPTOR CHAR1) of LINE)
                        LINE))
             (MOVETO (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)
                    (ffetch (LINEDESCRIPTOR DESCENT) of LINE)
                    DS)
             (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DS))
             (SETQ DDPILOTBBT (ffetch DDPILOTBBT of DISPLAYDATA))
             (SETQ XOFFSET (fetch DDXOFFSET of DISPLAYDATA))

             (* ;; "The X position of the left edge of the window, since \TEDIT.BLTCHAR works on the screen bitmap itself.")

             (SETQ CLIPLEFT (fetch DDClippingLeft of DISPLAYDATA))
                                                             (* ; 
                       "The left and right edges of the clipping region for the text display window.")
             (SETQ CLIPRIGHT (fetch DDClippingRight of DISPLAYDATA))
             (SETQ DDWIDTHCACHE (ffetch DDWIDTHSCACHE of DISPLAYDATA))
                                                             (* ; "Cache the character-image widths")
             (SETQ DDOFFSETCACHE (ffetch DDOFFSETSCACHE of DISPLAYDATA))
                                                             (* ; 
                                                            "And the offset-into-strike-bitmap array")

             (* ;; "We know that the line's first CLOOKS comes before the first CHAR")

             (for CHARSLOT incharslots THISLINE bind CLOOKS LOOKSTARTX
                                                     (TX _ (IPLUS XOFFSET (ffetch (LINEDESCRIPTOR
                                                                                   LEFTMARGIN)
                                                                             of LINE)))
                                                     (TERMSA _ (ffetch (TEXTOBJ TXTTERMSA)
                                                                  of TEXTOBJ))
                do 
                   (* ;; 
              "Display the line character by character.  CHAR and CHARW are bound to CHARSLOT values")

                   (SELCHARQ CHAR
                        ((TAB Meta,TAB) 
                             (CL:WHEN (OR (EQ CHAR (CHARCODE Meta,TAB))
                                          (fetch CLLEADER of CLOOKS)
                                          (EQ (fetch CLUSERINFO of CLOOKS)
                                              'DOTTEDLEADER))
                                 (\DISPLAYLINE.TABS CHARW (CHARWIDTH (CHARCODE %.)
                                                                 (CL:IF HARDCOPYMODE
                                                                     (FONTCOPY (fetch CLFONT
                                                                                  of CLOOKS)
                                                                            'DEVICE HCPYDS)
                                                                     (fetch CLFONT of CLOOKS)))
                                        DS TX SCALE TERMSA HARDCOPYMODE DISPLAYDATA DDPILOTBBT 
                                        CLIPRIGHT))
                             (add TX CHARW))
                        ((EOL LF CR) 
                             NIL)
                        (NIL                                 (* ; 
    "LOOKS or SMALLP-invisibles. Line-start looks are guaranteed to come before any character/object")
                             [if (type? CHARLOOKS CHARW)
                                 then (replace DDXPOSITION of DISPLAYDATA with (IDIFFERENCE TX 
                                                                                      XOFFSET)) 
                                                             (* ; 
                                              "Make the displaystream reflect our current X position")
                                      (CL:WHEN CLOOKS        (* ; 
                                              "Underline/overline/strike the just-finished looks run")
                                          (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                 (ffetch (LINEDESCRIPTOR DESCENT) of LINE)))
                                      (SETQ CLOOKS CHARW)
                                      (DSPFONT (fetch CLFONT of CLOOKS)
                                             DS)
                                      (CL:UNLESS (EQ 0 (fetch CLOFFSET of CLOOKS))
                                                             (* ; "Account for super/subscripting")
                                          (RELMOVETO 0 (HCSCALE SCALE (fetch CLOFFSET of CLOOKS))
                                                 DS))
                                      (SETQ LOOKSTARTX (IDIFFERENCE TX XOFFSET)) 
                                                             (* ; 
                                        "LOOKSTARTX: Starting X position for the current-looks text.")
                               elseif (SMALLP CHARW)
                               else (HELP "UNRECOGNIZED CHARW" CHARW) 

                                    (* ;; 
                           "Discretionary hyphens are invisible (CHARW=1), this should never happen.")

                                 (* ;; "Original comment: A character we've suppressed as part of line formatting (e.g., a discretionary hyphen we didn't use to break the line).  Show it as a thin black line.")

                                    (AND NIL (BLTSHADE BLACKSHADE DS TX 0 1 100 'PAINT])
                        (PROGN (if (IMAGEOBJP CHAR)
                                   then 
                                        (* ;; "Go to the base line, left edge of the image region.")

                                        (SETQ CURY (DSPYPOSITION NIL DS))
                                        (MOVETO (IDIFFERENCE (HCUNSCALE SCALE TX)
                                                       XOFFSET)
                                               CURY DS)
                                        (APPLY* (IMAGEOBJPROP CHAR 'DISPLAYFN)
                                               CHAR DS 'DISPLAY (ffetch (TEXTOBJ STREAMHINT)
                                                                   of TEXTOBJ))
                                        (DSPFONT (fetch CLFONT of CLOOKS)
                                               DS)           (* ; 
                                         "Restore the character font, move to just after the object.")

                                        (* ;; "RMK: Shouldn't CHARW be added to TX??")

                                        (MOVETO (IDIFFERENCE (HCUNSCALE SCALE TX)
                                                       XOFFSET)
                                               CURY DS)
                                 elseif HARDCOPYMODE
                                   then (MI-TEDIT.BLTCHAR CHAR DS (HCUNSCALE SCALE TX)
                                               DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                 elseif TERMSA
                                   then                      (* ; "Using special instrns from TERMSA")
                                        (\DSPPRINTCHAR DS CHAR)
                                 else                        (* ; "Native charcodes")
                                      (MI-TEDIT.BLTCHAR CHAR DS TX DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                               (add TX CHARW))) finally (replace DDXPOSITION of DISPLAYDATA
                                                           with (IDIFFERENCE (HCUNSCALE SCALE TX)
                                                                       XOFFSET)) 
                                                             (* ; 
                                        "Make any necessary looks mods to the last run of characters")
                                                      (TEDIT.MODIFYLOOKS LINE LOOKSTARTX DS CLOOKS
                                                             (ffetch (LINEDESCRIPTOR DESCENT)
                                                                of LINE))))
         (BITBLT CACHE 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBOT) of LINE)
                (ffetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                LHEIGHT
                'INPUT
                'REPLACE)                                    (* ; 
                          "Paint the cached image on the screen (this lessens flicker during update)")
         (CL:WHEN (fetch (FMTSPEC FMTREVISED) of (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE))
                                                             (* ; 
                                                       "This paragraph has been revised, so mark it.")
             (\TEDIT.MARK.REVISION TEXTOBJ (ffetch (LINEDESCRIPTOR LFMTSPEC) of LINE)
                    WINDOWDS LINE))
         (SELECTQ (ffetch (LINEDESCRIPTOR LMARK) of LINE)
             (GREY                                           (* ; 
                "This line has some property that isn't visible to the user.  Tell him to be careful")
                   (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                          6 6 'TEXTURE 'PAINT 42405))
             (SOLID (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                           6 6 'TEXTURE 'PAINT BLACKSHADE))
             (BITBLT NIL 0 0 WINDOWDS 0 (ffetch (LINEDESCRIPTOR YBASE) of LINE)
                    6 6 'TEXTURE 'REPLACE WHITESHADE])

(\DISPLAYLINE.TABS
  [LAMBDA (CW DOTWIDTH DS TX SCALE TERMSA HARDCOPYMODE DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                                             (* ; "Edited  1-Oct-2022 11:35 by rmk")
                                                             (* ; "Edited 24-Sep-2022 21:19 by rmk")
    (bind [TTX _ (IPLUS TX DOTWIDTH (IDIFFERENCE DOTWIDTH (IREMAINDER TX DOTWIDTH]
       while (ILEQ TTX (IPLUS TX CW)) do (if HARDCOPYMODE
                                             then (MI-TEDIT.BLTCHAR (CHARCODE %.)
                                                         DS
                                                         (HCUNSCALE SCALE (IDIFFERENCE TTX DOTWIDTH))
                                                         DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                           elseif TERMSA
                                             then            (* ; "Using special instrns from TERMSA")
                                                  (\DSPPRINTCHAR DS (CHARCODE %.))
                                           else              (* ; "Native charcodes")
                                                (MI-TEDIT.BLTCHAR (CHARCODE %.)
                                                       DS
                                                       (IDIFFERENCE TTX DOTWIDTH)
                                                       DISPLAYDATA DDPILOTBBT CLIPRIGHT))
                                         (add TTX DOTWIDTH])

(\TEDIT.LINECACHE
  [LAMBDA (CACHE WIDTH HEIGHT)                               (* jds "21-Apr-84 00:52")

         (* Given a candidate line cache, return the bitmap, making sure it's at least 
         WIDTH by HEIGHT big.)

    (PROG ((BITMAP (fetch LCBITMAP of CACHE))
           CW CH)
          (SETQ CW (fetch BITMAPWIDTH of BITMAP))
          (SETQ CH (fetch BITMAPHEIGHT of BITMAP))
          (COND
             ((AND (IGEQ CW WIDTH)
                   (IGEQ CH HEIGHT))
              (RETURN BITMAP))
             (T (RETURN (replace LCBITMAP of CACHE with (BITMAPCREATE (IMAX CW WIDTH)
                                                               (IMAX CH HEIGHT])

(\TEDIT.CREATE.LINECACHE
  [LAMBDA (%#CACHES)                                         (* jds "21-Apr-84 00:58")
                                                             (* Create a linked-together set of 
                                                             LINECACHEs, for saving line images.)
    (PROG [(CACHES (for I from 1 to %#CACHES collect (create LINECACHE
                                                            LCBITMAP _ (BITMAPCREATE 100 15]
          [for CACHE on CACHES do                            (* Link the caches together.)
                                  (replace LCNEXTCACHE of (CAR CACHE) with (OR (CADR CACHE)
                                                                               (CAR CACHES]
          (RETURN CACHES])

(\TEDIT.BLTCHAR
  [LAMBDA (CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                                             (* jds " 9-Jan-86 17:14")

         (* Version of BLTCHAR peculiar to TEdit --
         relies on \DISPLAYLINE to make sure things keep working right.)

         (* puts a character on a guaranteed display stream.
         Much of the information needed by the BitBlt microcode is prestored by the 
         routines that change it. This is kept in the BitBltTable.)
                                                             (* knows about the representation of 
                                                             display stream image data)
                                                             (* MUST NOT POINT AT A WINDOW'S 
                                                             DISPLAYSTREAM!!!)

         (* ASSUMES THAT WE NEVER WANT TO PRINT TO THE LEFT OF ORIGIN 0 ON THE LINE CACHE 
         BITMAP, OR THAT IF WE DO, ALL BETS ARE OFF)

    (DECLARE (LOCALVARS . T))
    (PROG (NEWX LEFT RIGHT IMAGEWIDTH (CHAR8CODE (\CHAR8CODE CHARCODE)))
          [COND
             ((NEQ (ffetch DDCHARSET of DISPLAYDATA)
                   (\CHARSET CHARCODE))
              (\CHANGECHARSET.DISPLAY DISPLAYDATA (\CHARSET CHARCODE]
          (SETQ IMAGEWIDTH (\GETBASE (fetch DDCHARIMAGEWIDTHS of DISPLAYDATA)
                                  (\CHAR8CODE CHARCODE)))
          (SETQ NEWX (IPLUS CURX IMAGEWIDTH))
          (SETQ LEFT (IMAX 0 CURX))
          (SETQ RIGHT (IMIN CLIPRIGHT NEWX))
          (COND
             ((ILESSP LEFT RIGHT)                            (* Only print anything if there is a 
                                                             place to put it)
              (UNINTERRUPTABLY
                  (freplace PBTDESTBIT of DDPILOTBBT with LEFT)
                                                             (* Set up the bitblt-table source left)
                  (freplace PBTWIDTH of DDPILOTBBT with (IMIN IMAGEWIDTH (IDIFFERENCE RIGHT LEFT)))
                  (freplace PBTSOURCEBIT of DDPILOTBBT with (\GETBASE (fetch DDOFFSETSCACHE
                                                                         of DISPLAYDATA)
                                                                   (\CHAR8CODE CHARCODE)))
                  (\PILOTBITBLT DDPILOTBBT 0))
              T])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS MI-TEDIT.BLTCHAR MACRO [(CHARCODE DISPLAYSTREAM CURX DISPLAYDATA DDPILOTBBT CLIPRIGHT)
                                  (COND
                                     ((EQ 'MAIKO (MACHINETYPE))
                                      (SUBRCALL TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA
                                             DDPILOTBBT CLIPRIGHT))
                                     (T (\TEDIT.BLTCHAR CHARCODE DISPLAYSTREAM CURX DISPLAYDATA 
                                               DDPILOTBBT CLIPRIGHT])
)
)
(DEFINEQ

(TEDIT.CR.UPDATESCREEN
  [LAMBDA (CH# XPOINT TEXTOBJ SEL LINE BLANKSEEN CRSEEN DS CHWIDTH DONTSCROLL)
                                                             (* ; "Edited 23-Feb-88 11:12 by jds")

    (* ;; "Update the edit window image after a CR is typed.  Move any text after the CR to a new line, and push or pull text as needed.")

    (* ;; "(PROG ((WINDOW (fetch \WINDOW of TEXTOBJ)) (PREVLINE (fetch PREVLINE of LINE))) (COND ((AND (NOT (fetch CR\END of PREVLINE)) (ILEQ (IDIFFERENCE XPOINT (fetch LEFTMARGIN of LINE)) (IDIFFERENCE (fetch RIGHTMARGIN of PREVLINE) (fetch LXLIM of PREVLINE)))) (* This CR should push the start of the line back upward.) (replace DIRTY of PREVLINE with T) (replace TXTNEEDSUPDATE of TEXTOBJ with T))) (TEDIT.UPDATE.SCREEN TEXTOBJ PREVLINE T) (\FIXSEL SEL TEXTOBJ) (\SHOWSEL SEL NIL T) (COND (DONTSCROLL (* SO DO NOTHING)) ((OR (NOT (fetch NEXTLINE of LINE)) (ILEQ (fetch YBOT of (fetch NEXTLINE of LINE)) (fetch BOTTOM of (DSPCLIPPINGREGION NIL WINDOW)))) (* This pushed the caret off-screen.  Move it up.) (replace EDITOPACTIVE of TEXTOBJ with NIL) (SCROLLW WINDOW 0 (LLSH (fetch LHEIGHT of (COND ((fetch NEXTLINE of LINE)) (LINE))) 1)))))")

    (HELP])

(TEDIT.DELETELINE
  [LAMBDA (LINE TEXTOBJ WINDOW)                              (* ; "Edited 30-May-91 15:58 by jds")

         (* Remove a complete text line descriptor from the edit window, then move lower 
         lines up over it.)

    (PROG ((PREV (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
           (NEXT (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))) (* Fix up the line-descriptor chain to 
                                                             dis-include line)
          (COND
             (PREV (replace (LINEDESCRIPTOR NEXTLINE) of PREV with NEXT)))
          (COND
             (NEXT (replace (LINEDESCRIPTOR PREVLINE) of NEXT with PREV)))
          (\TEDIT.CLOSEUPLINES TEXTOBJ PREV NEXT NIL WINDOW) (* And fix up the screen to cover the 
                                                             blank space.)
      ])

(TEDIT.INSERT.DISPLAYTEXT
  [LAMBDA (TEXTOBJ CH CHWIDTH LINE XPOINT DS SEL)            (* ; "Edited 13-Aug-2022 23:37 by rmk")
                                                             (* ; "Edited 30-May-91 16:56 by jds")
                                                             (* This function does the actual 
                                                             displaying of typed-in text on the 
                                                             edit window.)
                                                             (* (PROG ((LOOKS (\TEDIT.APPLY.STYLES
                                                             (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                                             (fetch (TEXTOBJ INSERTPC) of TEXTOBJ) 
                                                             TEXTOBJ)) (TERMSA (fetch
                                                             (TEXTOBJ TXTTERMSA) of TEXTOBJ)) DY 
                                                             FONT) (DSPFONT (SETQ FONT
                                                             (fetch CLFONT of LOOKS)) DS)
                                                             (* Change the font) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE))
                                                             (* The font this character is in is 
                                                             taller than the existing line.
                                                             Adjust the LINEDESCRIPTOR's ascent.)
                                                             (\TEDIT.ADJUST.LINES TEXTOBJ LINE DS
                                                             (fetch (LINEDESCRIPTOR YBOT) of
                                                             (fetch (LINEDESCRIPTOR PREVLINE) of 
                                                             LINE)) (IDIFFERENCE (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)))) (* Move other text 
                                                             to allow for the new height)
                                                             (add (fetch (LINEDESCRIPTOR ASCENT) of 
                                                             LINE) (IDIFFERENCE (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEASCENT) of LINE)))
                                                             (replace (LINEDESCRIPTOR LTRUEASCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE ASCENT))))) (COND
                                                             ((IGREATERP (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE))
                                                             (* If the caret's font will change the 
                                                             line's descent, adjust lower lines 
                                                             downward) (\TEDIT.ADJUST.LINES TEXTOBJ
                                                             (fetch (LINEDESCRIPTOR NEXTLINE) of 
                                                             LINE) DS (fetch (LINEDESCRIPTOR YBOT) 
                                                             of LINE) (IDIFFERENCE
                                                             (fetch (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE) (FONTPROP (fetch CLFONT of 
                                                             LOOKS) (QUOTE DESCENT))))
                                                             (add (fetch (LINEDESCRIPTOR DESCENT) 
                                                             of LINE) (IDIFFERENCE
                                                             (FONTPROP (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT)) (fetch
                                                             (LINEDESCRIPTOR LTRUEDESCENT) of LINE)))
                                                             (* Fix the line's leading-adjusted 
                                                             descent to account for this change)
                                                             (replace (LINEDESCRIPTOR LTRUEDESCENT) 
                                                             of LINE with (FONTPROP
                                                             (fetch CLFONT of LOOKS)
                                                             (QUOTE DESCENT))) (* Also the 
                                                             unadjusted descent) (replace
                                                             (LINEDESCRIPTOR YBOT) of LINE with
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             YBASE) of LINE) (fetch
                                                             (LINEDESCRIPTOR DESCENT) of LINE)))
                                                             (* And note our new location.)))
                                                             (BITBLT DS XPOINT (fetch
                                                             (LINEDESCRIPTOR YBOT) of LINE) DS
                                                             (IPLUS XPOINT CHWIDTH)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IDIFFERENCE (fetch (LINEDESCRIPTOR 
                                                             RIGHTMARGIN) of LINE) XPOINT)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE INPUT) (QUOTE REPLACE))
                                                             (* Move the old text over)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             CHWIDTH (fetch (LINEDESCRIPTOR LHEIGHT)
    of LINE) (QUOTE TEXTURE) (QUOTE REPLACE) WHITESHADE) (* Blank out the area we're going to write 
                                                             into) (MOVETO XPOINT
                                                             (IPLUS (fetch (LINEDESCRIPTOR YBASE) 
                                                             of LINE) (OR (fetch CLOFFSET of LOOKS) 
                                                             0)) DS) (* Set the display stream 
                                                             position) (COND (TERMSA
                                                             (* Special terminal table for 
                                                             controlling character display.
                                                             Use it.) (RESETLST (RESETSAVE 
                                                             \PRIMTERMSA TERMSA) (replace
                                                             (TEXTSTREAM REALFILE) of
                                                             (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
    with DS) (COND ((STRINGP CH) (for CHAR instring CH do (SELCHARQ CHAR (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CHAR))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS 
                                                             XPOINT (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS XPOINT
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (\DSPPRINTCHAR (fetch
                                                             (TEXTOBJ STREAMHINT) of TEXTOBJ) CH))))))
                                                             (T (* No special handling;
                                                             just use native character codes)
                                                             (COND ((STRINGP CH) (for CHAR instring 
                                                             CH do (SELCHARQ CHAR
                                                             (TAB (* Put down white)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) 36 (fetch (LINEDESCRIPTOR 
                                                             LHEIGHT) of LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (IMAX 6 (CHARWIDTH CHAR FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CHAR DS))))
                                                             (T (SELCHARQ CH (TAB
                                                             (* Put down white) (BITBLT NIL 0 0 DS
                                                             (DSPXPOSITION NIL DS)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE) 
                                                             36 (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (RELMOVETO 36 0 DS))
                                                             (CR (* Blank out the CR's width.)
                                                             (BITBLT NIL 0 0 DS (DSPXPOSITION NIL 
                                                             DS) (fetch (LINEDESCRIPTOR YBOT) of 
                                                             LINE) (IMAX 6 (CHARWIDTH CH FONT))
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE))
                                                             (BLTCHAR CH DS))))))
                                                             (BITBLT NIL 0 0 DS (fetch
                                                             (LINEDESCRIPTOR LXLIM) of LINE)
                                                             (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                             (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                                             (fetch (LINEDESCRIPTOR LHEIGHT) of 
                                                             LINE) (QUOTE TEXTURE)
                                                             (QUOTE REPLACE) WHITESHADE)
                                                             (* Clear after EOL) (TEDIT.MODIFYLOOKS 
                                                             LINE XPOINT DS LOOKS
                                                             (fetch (LINEDESCRIPTOR YBASE) of LINE))
                                                             (* Do underlining, strike-out, etc.)))
    (HELP])

(TEDIT.INSERT.UPDATESCREEN
  [LAMBDA (CH CH# CHARS TEXTOBJ SEL OTEXTLEN BLANKSEEN CRSEEN DONTSCROLL INCREMENTAL)
                                                             (* ; "Edited  4-Nov-2022 17:54 by rmk")
                                                             (* ; "Edited 12-Aug-2022 18:04 by rmk")
                                                             (* ; "Edited 30-May-91 16:06 by jds")
                                                             (* ; 
                                                          "Update the edit window after an insertion")
    (PROG ((THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ))
           (WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
           SELINE)
          (replace (SELECTION CH#) of SEL with (IPLUS CHARS CH#))
                                                             (* ; 
                                    "These must be here, since SELs are valid even without a window.")
          (replace (SELECTION CHLIM) of SEL with (fetch (SELECTION CH#) of SEL))
          (replace (SELECTION POINT) of SEL with 'LEFT)
          (replace (SELECTION DCH) of SEL with 0)
          (replace (SELECTION SELKIND) of SEL with 'CHAR)
          (COND
             ((AND INCREMENTAL (\SYSBUFP))

              (* ;; "We're doing incremental updates, and there's type-in waiting.  Bail out, now that we have fixed up the selection.")

              (RETURN))
             ((fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)    (* ; 
                                            "Don't update the screen if updates are being inhibited.")
              (RETURN))
             ((NOT WINDOW)                                   (* ; 
                                              "If this textobj has no window to update, don't bother")
              (RETURN))
             ((OR T (LISTP WINDOW)
                  (TEXTPROP TEXTOBJ 'SLOWUPDATE))            (* ; 
                                                     "FOR NOW, ALWAYS UPDATE THE SCREEN THE HARD WAY")
              (TEDIT.UPDATE.SCREEN TEXTOBJ NIL T (fetch (SELECTION CH#) of SEL))
              (\FIXSEL SEL TEXTOBJ)
              (\SHOWSEL SEL NIL T)))
          (\COPYSEL SEL TEDIT.SELECTION)
          (for PANE (POINT _ (fetch (SELECTION POINT) of SEL)) inside WINDOW as L1
             inside (fetch (SELECTION L1) of SEL) as LN inside (fetch (SELECTION LN) of SEL)
             do (SETQ SELINE (SELECTQ POINT
                                 (LEFT L1)
                                 (RIGHT LN)
                                 NIL))
                (COND
                   (DONTSCROLL 

                          (* ;; "If scrolling is suppressed, don't bother with the next check:")

                          (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ PANE))
                   [(EQ PANE (fetch (TEXTOBJ SELWINDOW) of TEXTOBJ))
                    (COND
                       ([OR (NULL SELINE)
                            (ILEQ (CL:IF SELINE
                                      (fetch (LINEDESCRIPTOR YBOT) of SELINE)
                                      0)
                                  (fetch (REGION BOTTOM) of (DSPCLIPPINGREGION NIL PANE]

                        (* ;; 
    "The caret is off-window in the selection window.  Need to scroll it up so the caret is visible.")

                        (while (OR [COND
                                      (SELINE (ILESSP (fetch (LINEDESCRIPTOR YBOT) of SELINE)
                                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                      (T (ILESSP (fetch (SELECTION Y0) of SEL)
                                                (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
                                   (AND (IGEQ (fetch (SELECTION Y0) of SEL)
                                              (fetch (TEXTOBJ WTOP) of TEXTOBJ))
                                        (NULL SELINE)))
                           do 
                              (* ;; "The caret just went off-screen.  Move it up some.")

                              (replace (TEXTOBJ EDITOPACTIVE) of TEXTOBJ with NIL)
                              (SCROLLW PANE 0 (LLSH (CL:IF SELINE
                                                        (fetch (LINEDESCRIPTOR LHEIGHT) of SELINE)
                                                        12)
                                                    1]
                   (T (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ PANE)))
                (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ PANE))
          (\COPYSEL SEL TEDIT.SELECTION])

(TEDIT.UPDATE.SCREEN
  [LAMBDA (TEXTOBJ STARTINGLINE INCREMENTAL? NEXTCARETCH#)   (* ; "Edited  5-Oct-2022 21:30 by rmk")
                                                             (* ; "Edited 30-May-91 15:58 by jds")
                                                             (* Update the screen, as needed to fix 
                                                             up "dirty" lines.)
    (SETQ TEXTOBJ (TEXTOBJ TEXTOBJ))
    (CL:UNLESS (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)

        (* ;; "Only update the screen if we aren't suppressing updating.")

        (bind NLINE for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINE
           inside (OR STARTINGLINE (fetch (TEXTOBJ LINES) of TEXTOBJ))
           do (SETQ NLINE (\TEDIT.FIXCHANGEDPART TEXTOBJ LINE WW INCREMENTAL? NEXTCARETCH#))
              (CL:WHEN NLINE

                  (* ;; "The last line in the edit window")

                  (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of NLINE)
                         NLINE TEXTOBJ NIL WW NEXTCARETCH#))))])

(\BACKFORMAT
  [LAMBDA (LINES TEXTOBJ WHEIGHT)                            (* ; "Edited 17-Sep-2022 22:20 by rmk")
                                                             (* ; "Edited  8-Sep-2022 16:41 by rmk")
                                                             (* ; "Edited 30-May-91 15:58 by jds")

    (* ;; "Move back to the next preceding EOL (to guarantee a line break), then format lines to reach where we are now.")

    (* ;; "LINES is the dummy first line for this window in TEXTOBJ")

    (* ;; "Returns a pointer to the last of the back-formatted lines (i.e., the one that comes latest in the document), or to LINES if no lines are formatted")

    (PROG ((LINE1 (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
           CH1 CHNO LINE)
          (SETQ CH1 (CL:IF LINE1
                        (fetch (LINEDESCRIPTOR CHAR1) of LINE1)
                        (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          (CL:WHEN (ILEQ CH1 1)                              (* ; 
                                                 "No more lines to format--at the front of the file.")
              (RETURN LINES))

     (* ;; "More to do.  Back up until we find a preceding EOL")

          [SETQ CHNO (find I (TSTREAM _ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                        from (IDIFFERENCE CH1 2) to 2 by -1 first (\TEXTSETFILEPTR TSTREAM
                                                                         (IDIFFERENCE CH1 2)) 
                                                             (* ; 
                                                      "Because fileptrs are one back from characters")
                        suchthat (EQ (CHARCODE EOL)
                                     (\BACKBIN TSTREAM]
          (SETQ CHNO (ADD1 (OR CHNO 0)))                     (* ; 
                                                   "But never further than the front of the document")
          [while (ILEQ CHNO (SUB1 CH1)) do                   (* ; 
                           "Now move forward, formatting lines until we catch up with where we were.")
                                           (SETQ LINE (\FORMATLINE TEXTOBJ NIL CHNO)) 
                                                             (* ; "Format the next line")
                                           (replace (LINEDESCRIPTOR YBOT) of LINE with WHEIGHT) 
                                                             (* ; 
                                                             "Make sure it thinks it's off-window")
                                           (replace (LINEDESCRIPTOR YBASE) of LINE with WHEIGHT)
                                           (replace (LINEDESCRIPTOR PREVLINE) of LINE with LINES) 
                                                             (* ; "Hook it onto the end of the chain")
                                           (replace (LINEDESCRIPTOR NEXTLINE) of LINES with LINE)
                                           (SETQ LINES LINE) (* ; 
                                                             "And find the start of the next line")
                                           (SETQ CHNO (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                               of LINE]
          (replace (LINEDESCRIPTOR NEXTLINE) of LINE with LINE1)
                                                             (* ; 
                    "Now, with the final line we formatted, hook the rest of the line chain onto it.")
          (CL:WHEN LINE1
              (replace (LINEDESCRIPTOR PREVLINE) of LINE1 with LINE))
          (RETURN LINE])

(\FILLWINDOW
  [LAMBDA (YBOT CURLINE TEXTOBJ DONTFILLFLG WINDOW NEXTCARETCH#)
                                                             (* ; "Edited  9-Sep-2022 21:22 by rmk")
                                                             (* ; "Edited  6-Sep-2022 11:12 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")

    (* ;; "Fill out TEXTOBJ's window, starting with the line after CURLINE, whose ybottom is YBOT")

    (* ;; "Return T if any lines are moved up.")

    (* ;; "DONTFILLFLG => Don't bother printing any new lines at the bottom of the screen.")

    (* ;; "NEXTCARETCH# => always format to at least this CH#, to assure that we know where the caret will next be.")

    (CL:UNLESS WINDOW
        (SETQ WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)))
    (LET ((LINE (fetch (LINEDESCRIPTOR NEXTLINE) of CURLINE))
          (CHARLIM (fetch (LINEDESCRIPTOR CHARLIM) of CURLINE))
          (PREVLINE CURLINE)
          (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
          (LINES\DELETED NIL)
          (WHEIGHT (WINDOWPROP WINDOW 'HEIGHT))
          NEXTLINE OFLOWFN)
         (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
         (while (AND LINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                WHEIGHT)) do                 (* ; 
                                     "Do not start with a line which is above the top of the screen.")
                                             (SETQ PREVLINE LINE)
                                             (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHARLIM)
                                                              of LINE))
                                             (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
         [repeatwhile (ILESSP CHARLIM TEXTLEN)
            do                                               (* ; 
                                                       "Walk thru the lines below the starting line.")
               [COND
                  ((AND LINE (IGEQ (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT LINE PREVLINE))
                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                                             (* ; 
                                  "If there is a line to display, and space to display it, go ahead.")
                   (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                   (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINE)))
                   (\DISPLAYLINE TEXTOBJ LINE WINDOW))
                  [(AND LINE NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                                NEXTCARETCH#))
                                                             (* ; 
                        "There's a line, and it's earlier than the next caret location.  Keep going.")
                   (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                   (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINE]
                  (LINE                                      (* ; 
                                                             "There is a line, but it won't fit.")
                        [SETQ YBOT (COND
                                      ((fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                  of LINE))
                                       (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                      (T (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
                                                             (* ; 
    "This existing line won't fit.  Punt out of this, setting YBOT so the screen gets cleared right.")
                        (CL:WHEN (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                                             (* ; 
                            "Try calling any user-supplied overflow fn, to handle the space overflow")
                            (CL:WHEN (APPLY* OFLOWFN WINDOW TEXTOBJ)
                                (RETFROM '\FILLWINDOW NIL)))
                        (RETURN))
                  (DONTFILLFLG                               (* ; 
                                      "We are instructed NOT to try filling the screen, so punt out.")
                         (RETURN))
                  ((OR (ILESSP CHARLIM TEXTLEN)
                       (AND (IEQP CHARLIM TEXTLEN)
                            (fetch (LINEDESCRIPTOR CR\END) of CURLINE))
                       (ZEROP TEXTLEN))

                   (* ;; "No existing lines to display, but there's text left (or the doc is empty and we need a dummy first line)")

                   (SETQ LINE (\FORMATLINE TEXTOBJ NIL (ADD1 CHARLIM)))
                                                             (* ; "Format the next line")
                   (replace (LINEDESCRIPTOR PREVLINE) of LINE with PREVLINE)
                                                             (* ; 
                                                         "Hook it into the chain of line descriptors")
                   (replace (LINEDESCRIPTOR NEXTLINE) of LINE with (SETQ NEXTLINE (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                          NEXTLINE)
                                                                                     of PREVLINE)))
                   (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with LINE)
                   (CL:WHEN NEXTLINE
                       (replace (LINEDESCRIPTOR PREVLINE) of NEXTLINE with LINE))
                   [SETQ YBOT (COND
                                 [(fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                             of LINE))
                                  (IDIFFERENCE (IPLUS YBOT (fetch (LINEDESCRIPTOR DESCENT)
                                                              of PREVLINE))
                                         (IPLUS (fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR 
                                                                                      LFMTSPEC)
                                                                           of LINE))
                                                (fetch (LINEDESCRIPTOR DESCENT) of LINE]
                                 (T (IDIFFERENCE YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
                   (COND
                      ((IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                             "If there's room, display the new line")
                       (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                       (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                        DESCENT)
                                                                                   of LINE)))
                       (\DISPLAYLINE TEXTOBJ LINE WINDOW))
                      [(AND NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                               NEXTCARETCH#))(* ; 
           "This line is needed to find the next caret location, even tho it won't fit on the screen")
                       (replace (LINEDESCRIPTOR YBOT) of LINE with YBOT)
                       (replace (LINEDESCRIPTOR YBASE) of LINE with (IPLUS YBOT (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                        DESCENT)
                                                                                   of LINE]
                      (T                                     (* ; 
                                                        "Otherwise, we've overflown the window again")
                         (SETQ YBOT (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE)))
                         (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                       (APPLY* OFLOWFN WINDOW TEXTOBJ))
                             (RETFROM '\FILLWINDOW NIL))
                         (RETURN]
               (COND
                  (LINE                                      (* ; 
                                                 "Move forward to the next line in the chain, if any")
                        (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHARLIM) of LINE))
                        (SETQ PREVLINE LINE)
                        (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
                  (T                                         (* ; 
                                               "Otherwise, note that we ran off the end of the file.")
                     (SETQ CHARLIM (ADD1 TEXTLEN]
         (while LINE do                                      (* ; 
          "If there are any existing lines which didn't fit, set their YBOTs to 0 so they don't show")
                        (CL:WHEN (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                       TEXTLEN)
                            (replace (LINEDESCRIPTOR YBOT) of LINE with (SUB1 (fetch (TEXTOBJ WBOTTOM
                                                                                            )
                                                                                 of TEXTOBJ))))
                        (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)))
         (CL:WHEN (IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                  "If there is space left at the bottom of the window, blank it out.")
             (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                    (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                    (IDIFFERENCE YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                    'TEXTURE
                    'REPLACE WHITESHADE))
         (CL:WHEN (AND PREVLINE (fetch (LINEDESCRIPTOR CR\END) of PREVLINE)
                       (OR (ILESSP (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                  WHEIGHT)
                           (ILEQ (fetch (LINEDESCRIPTOR CHARTOP) of PREVLINE)
                                 0))
                       (IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)
                             TEXTLEN))                       (* ; 
                                          "If the last line ends in a CR, put a dummy line below it.")
             [SETQ LINE (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with (\FORMATLINE TEXTOBJ NIL
                                                                                   (ADD1 TEXTLEN]
             (replace (LINEDESCRIPTOR PREVLINE) of LINE with PREVLINE)
             (replace (LINEDESCRIPTOR YBOT) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                         of PREVLINE)
                                                                (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                   of LINE)))
             (replace (LINEDESCRIPTOR YBASE) of LINE with (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT)
                                                                          of PREVLINE)
                                                                 (fetch (LINEDESCRIPTOR ASCENT)
                                                                    of LINE)))
             (replace (LINEDESCRIPTOR CHARLIM) of LINE with (ADD1 TEXTLEN))
             (SETQ PREVLINE LINE))
         (CL:WHEN (AND (IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)
                             TEXTLEN)
                       (NOT (fetch (LINEDESCRIPTOR CR\END) of PREVLINE)))
                                                             (* ; 
                                    "This line lies at end of text, so chop off any following lines.")
             (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with NIL))
         LINES\DELETED])

(\FIXDLINES
  [LAMBDA (SEL CH#1 CH#LIM TEXTOBJ)                          (* ; "Edited 23-Oct-2022 14:37 by rmk")
                                                             (* ; "Edited 19-Sep-2022 21:55 by rmk")
                                                             (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; 
    "Fix up the list LINES of line descriptors, given that characters CH#1 thru CH#LIM were deleted.")

    (* ;; "Change CHAR1 and CHARLIM entries in each descriptor, and remove any descriptors for lines which disappeared entirely.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)

        (* ;; "Only do this if we're allowed to change the document.")

        (* ;; "RMK:  ORIGINAL HAD LINES AS AN (IGNORED) ARGUMENT (AND ALWAYS = THE LINES OF TEXTOBJ)")

        (for WW LINES (DCH _ (IDIFFERENCE CH#LIM CH#1))
             (CH#1L _ (SUB1 CH#1)) inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
           do (SETQ LINES (WINDOWPROP WW 'LINES))
              [for (LINE _ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
                   CHAR1 CHARLIM CHARTOP PL NL (NLINES _ LINES) by (ffetch (LINEDESCRIPTOR NEXTLINE)
                                                                      of LINE) while LINE
                 do (SETQ CHAR1 (ffetch (LINEDESCRIPTOR CHAR1) of LINE))
                    (SETQ CHARLIM (ffetch (LINEDESCRIPTOR CHARLIM) of LINE))
                    (SETQ CHARTOP (ffetch (LINEDESCRIPTOR CHARTOP) of LINE))
                    (COND
                       ((ILEQ CHARLIM CH#1)                  (* ; "Somewhere before. Just before?")
                        (CL:UNLESS (AND (SETQ NL (ffetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                        (ILESSP (ffetch (LINEDESCRIPTOR CHARTOP) of NL)
                                               CH#1))

                            (* ;; "Change could have affected LINE's break decision.")

                            (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                            (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)))
                       ((IGEQ CHAR1 CH#LIM)                  (* ; 
    "This line contains none of the deleted text but is after it.  Update CHAR1, CHARLIM and CHARTOP")
                        (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IMAX 1 (IDIFFERENCE CHAR1 DCH)
                                                                            ))
                        (add (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                             (IMINUS DCH))
                        (add (ffetch (LINEDESCRIPTOR CHARLIM) of LINE)
                             (IMINUS DCH)))
                       ((OR (ILESSP CHAR1 CH#1)
                            (IGEQ CHARLIM CH#LIM))           (* ; "This line contains some of the deleted text, mark it as dirty and update CHAR1, CHARLIM, and CHARTOP")
                        (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                        (freplace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)
                        (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IMAX 1 (IMIN CHAR1 CH#1)))
                        (freplace (LINEDESCRIPTOR CHARLIM) of LINE
                           with (CL:IF (IGEQ CHARLIM CH#LIM)
                                    (IDIFFERENCE CHARLIM (IMIN DCH (IDIFFERENCE CH#LIM CHAR1)))
                                    CH#1L))
                        (change (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                               (CL:IF (IGEQ CHARTOP CH#LIM)
                                   (IDIFFERENCE CHARTOP (IMIN DCH (IDIFFERENCE CH#LIM CHAR1)))
                                   CH#1L)))
                       (T                                    (* ; 
                                            "This line is totally within the deleted text, remove it")
                          (SETQ NL (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                          (SETQ PL (fetch (LINEDESCRIPTOR PREVLINE) of LINE))
                          (CL:WHEN PL
                              (replace (LINEDESCRIPTOR NEXTLINE) of PL with NL))
                          (CL:WHEN NL
                              (replace (LINEDESCRIPTOR PREVLINE) of NL with PL))
                          (CL:WHEN (EQ NLINES LINE)
                                 (SETQ NLINES NL))
                          (replace (LINEDESCRIPTOR DELETED) of LINE with T)
                                                             (* ; 
                                      "Mark this line deleted, so DELETETEXTCHARS know to ignore it.")

                          (* ;; 
                  "This may well force a reformatting of the next line.  Mark it dirty just in case.")

                          (CL:WHEN NL
                              (replace (LINEDESCRIPTOR DIRTY) of NL with T))]
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM DCH)                (* ; 
                                                             "Fix up the selections in this textobj")
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM DCH)
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM DCH)
              (\TEDIT.FIXDELSEL (fetch (TEXTOBJ DELETESEL) of TEXTOBJ)
                     TEXTOBJ CH#1 CH#LIM DCH)))])

(\FIXILINES
  [LAMBDA (TEXTOBJ SEL CH#1 DCH OTEXTLEN)                    (* ; "Edited  5-Oct-2022 21:56 by rmk")
                                                             (* ; "Edited 30-May-91 16:07 by jds")

    (* ;; "Fix the list LINES of line descriptors to account for DCH characters inserted before CH#1")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)

        (* ;; "Only make this change if you're allowed to change the document.")

        (LET (LINES CH# CHLIM CHAR1 CHARLIM)
             (SETQ CH#1 (IMAX CH#1 1))                       (* ; 
                                                         "Make sure we're inserting in a legit spot.")
             [for WW inside (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINES
                inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as L1 in (fetch (SELECTION L1) of SEL)
                do 
                   (* ;; "For each pane in the editing window, examine the pane's list of lines")

                   (for [LINE _ (COND
                                   ((IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINES)
                                          0)                 (* ; 
                                                           "Make sure to skip the initial dummy line")
                                    LINES)
                                   (T (ffetch (LINEDESCRIPTOR NEXTLINE) of LINES]
                      by (ffetch (LINEDESCRIPTOR NEXTLINE) of LINE) while LINE
                      do (\DTEST LINE 'LINEDESCRIPTOR)
                         (COND
                            ((IGREATERP (SETQ CHAR1 (ffetch (LINEDESCRIPTOR CHAR1) of LINE))
                                    CH#1)                    (* ; 
                                     "This line starts after the insertion point.  Update it's CHAR1")
                             (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IPLUS CHAR1 DCH)))
                            ((AND (IEQP CH#1 CHAR1)
                                  (NEQ LINE L1))             (* ; 
                   "The insertion is at the end of the PRIOR line--so go ahead and update this CHAR1")
                             (freplace (LINEDESCRIPTOR CHAR1) of LINE with (IPLUS CHAR1 DCH))
                             (CL:WHEN (ffetch (LINEDESCRIPTOR PREVLINE) of LINE)
                                 (freplace (LINEDESCRIPTOR DIRTY) of (ffetch (LINEDESCRIPTOR PREVLINE
                                                                                    ) of LINE)
                                    with T))
                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T))
                            ((IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                   CH#1)                     (* ; 
                                                  "This line spans the insert point.  Mark it DIRTY.")
                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T))
                            ((AND (IGEQ (SETQ CHARLIM (ffetch (LINEDESCRIPTOR CHARLIM) of LINE))
                                        OTEXTLEN)
                                  (NOT (ffetch (LINEDESCRIPTOR CR\END) of LINE)))

                             (* ;; "This line is the last in the file, and its CHAR1 is <= the insert point, and it doesn't end in a CR.  Therefore, move the line's end upward to accomodate the insertion.")

                             (freplace (LINEDESCRIPTOR DIRTY) of LINE with T)
                             (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T)))
                         (CL:WHEN [OR (IGEQ (SETQ CHARLIM (ffetch (LINEDESCRIPTOR CHARLIM)
                                                             of LINE))
                                            CH#1)
                                      (AND (IGEQ CHARLIM OTEXTLEN)
                                           (NOT (ffetch (LINEDESCRIPTOR CR\END) of LINE]
                             (freplace (LINEDESCRIPTOR CHARLIM) of LINE with (IPLUS CHARLIM DCH))
                             (CL:WHEN (IGEQ (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                            CH#1)
                                 (add (ffetch (LINEDESCRIPTOR CHARTOP) of LINE)
                                      DCH)))]
             (\TEDIT.FIXINSSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                    TEXTOBJ CH#1 DCH)
             (\TEDIT.FIXINSSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                    TEXTOBJ CH#1 DCH)
             (\TEDIT.FIXINSSEL SEL TEXTOBJ CH#1 DCH)))])

(\SHOWTEXT
  [LAMBDA (TEXTOBJ WINDOW)

    (* ;; "Edited  5-Nov-2022 11:44 by rmk")

    (* ;; "Edited 20-Oct-2022 21:26 by rmk")

    (* ;; "Edited  6-Sep-2022 11:06 by rmk")

    (* ;; "Edited 12-Jan-2022 18:56 by rmk: I took out the WAITINGCURSOR, the resetsave wasn't working for some reason, and it really isn't necessary for modern machines.")

    (* ;; "Edited 12-Jun-90 19:22 by mitani")

    (* ;; "Fill the editor window with text, starting from the top of the file.")

    (CL:WHEN (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)            (* ; 
                                                           "If there is no edit window, just return.")
        (LET (WREG LINES)
             (SETQ WINDOW (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
             (DSPFILL (PROG1 (DSPCLIPPINGREGION NIL WINDOW)  (* ; "For region within a window:")
                             )
                    WHITESHADE
                    'REPLACE WINDOW)                         (* ; "Clear the window.")
             (RESETLST

                 (* ;; "RMK: For reasons unknown, the original cursor is not restored when this exits.  But there is presumably no need for this waiting indicator in modern times.  This only fills lines visible within a window, and machines are really fast.")

                 (* ;; "Display the hourglass cursor as we work")

                 (AND NIL (RESETSAVE (CURSOR WAITINGCURSOR)))

                 (* ;; "Make sure we have the anchor pseudo-line")

                 (SETQ LINES
                  (create LINEDESCRIPTOR
                         YBOT _ (WINDOWPROP WINDOW 'HEIGHT)
                         CHAR1 _ 0
                         CHARLIM _ 0
                         RIGHTMARGIN _ (SUB1 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
                         NEXTLINE _ NIL
                         CHARTOP _ -1
                         LHEIGHT _ 0
                         LXLIM _ (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                         CR\END _ T
                         ASCENT _ 0
                         DESCENT _ 0
                         LTRUEASCENT _ 0
                         LFMTSPEC _ TEDIT.DEFAULT.FMTSPEC))
                 (replace (TEXTWINDOW WLINES) of WINDOW with LINES)
                                                             (* ; "Fill the window as usual")
                 (\FILLWINDOW (WINDOWPROP WINDOW 'HEIGHT)
                        LINES TEXTOBJ NIL WINDOW)
                 (\TEDIT.SET.WINDOW.EXTENT TEXTOBJ WINDOW)
                 LINES)))])

(\TEDIT.ADJUST.LINES
  [LAMBDA (TEXTOBJ FIRSTLINE WINDOW LINETOP DY)              (* ; "Edited 30-May-91 15:59 by jds")

         (* Move all lines from FIRSTLINE (inclusive) on up or down.
         Fill in a line or drop one off, accordingly.
         Positive DY means move UP.)

         (* LINETOP is the top of the region to be moved as the adjustment is made.
         It corresponds to the TOP of FIRSTLINE.)

    (PROG ((OFLOW NIL)
           OFLOWFN OYBOT PREVLINE)
          [COND
             ((ZEROP DY)                                     (* This line's total height HAS NOT 
                                                             CHANGED. Don't make any adjustments.)
              )
             ((ILESSP LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* This line is off the screen.
                                                             Don't bother adjusting it.)
              )
             (FIRSTLINE 

         (* This line's total height changed -- must move the rest of the window, and 
         adjust YBOT/BASEs.)

                    (bind (LL _ FIRSTLINE) while (AND LL (IGEQ (fetch (LINEDESCRIPTOR YBOT)
                                                                  of LL)
                                                               (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                       do 

         (* Loop thru the line descriptors that are affected by the change
         (i.e., those below it)%, and adjust their Y locations.)

                          (SETQ OYBOT (fetch (LINEDESCRIPTOR YBOT) of LL))
                          [COND
                             ((ILESSP (replace (LINEDESCRIPTOR YBOT) of LL with (IPLUS OYBOT DY))
                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* This line moved below the bottom of 
                                                             the screen)
                              (BITBLT NIL 0 0 WINDOW 0 OYBOT (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                     (fetch (LINEDESCRIPTOR LHEIGHT) of LL)
                                     'TEXTURE
                                     'REPLACE WHITESHADE)    (* So clear the space it used to 
                                                             occupy.)
                              (COND
                                 ((AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                       (SETQ OFLOW T)
                                       (APPLY* OFLOWFN WINDOW TEXTOBJ)
                                       (RETURN NIL))

         (* We walked off the bottom, and the user gave us an OFLOWFN to handle it.
         Give it a try.)

                                  ]
                          (add (fetch (LINEDESCRIPTOR YBASE) of LL)
                               DY)                           (* Adjust the baseline of the line, as 
                                                             well as its physical bottom.)
                          (replace (LINEDESCRIPTOR YBOT) of LL with (IDIFFERENCE (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         YBASE)
                                                                                    of LL)
                                                                           (fetch (LINEDESCRIPTOR
                                                                                   DESCENT)
                                                                              of LL))) 
                                                             (* I realize this looks redundant, but 
                                                             the line's descent may have changed, 
                                                             too.)
                          (SETQ PREVLINE LL) 

         (* Remember the prior line, since we'll need it if we later try to fill out the 
         window with more text.)

                          (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)) 
                                                             (* Move to the next line.))
                    (AND OFLOW (RETURN NIL))

         (* If there was an overflow, and it got handled by the user's OFLOWFN, don't 
         bother trying anything further.)

                    (COND
                       [(IGREATERP DY 0)                     (* The line is shorter;
                                                             move the rest up.)
                        (BITBLT WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                               WINDOW 0 (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                               (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                               LINETOP
                               'INPUT
                               'REPLACE)                     (* Move the text up)
                        (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                               (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                               DY
                               'TEXTURE
                               'REPLACE WHITESHADE)          (* Now clear the bottom part of the 
                                                             window, which got vacated by the 
                                                             adjustment)
                        (COND
                           ((AND PREVLINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                                (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))

         (* If there is space left on the screen, try to fill it with new text.)

                            (\FILLWINDOW (fetch (LINEDESCRIPTOR YBOT) of PREVLINE)
                                   PREVLINE TEXTOBJ NIL WINDOW]
                       (T                                    (* The line is taller;
                                                             move the rest down.)
                          (BITBLT WINDOW 0 (IPLUS (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                                  (IMINUS DY))
                                 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                 (IDIFFERENCE LINETOP (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                 'INPUT
                                 'REPLACE)                   (* Move the text down)
                          (BITBLT NIL 0 0 WINDOW 0 (IPLUS LINETOP DY)
                                 (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                 (IMINUS DY)
                                 'TEXTURE
                                 'REPLACE WHITESHADE)        (* Now clear the region we moved it 
                                                             out of.)
                          ]
          (RETURN T])

(\TEDIT.CLEAR.SCREEN.BELOW.LINE
  [LAMBDA (TEXTOBJ WINDOW LINE)                              (* ; "Edited 30-May-91 15:59 by jds")
                                                             (* Clears the edit window to white, 
                                                             clearing only the sapce below the line 
                                                             given.)
    (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
           (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
           (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of LINE)
                  (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
           'TEXTURE
           'REPLACE WHITESHADE])

(\TEDIT.CLOSEUPLINES
  [LAMBDA (TEXTOBJ PREVLINE NEXTLINE DONTFILLFLG WINDOW)     (* ; "Edited 30-May-91 15:59 by jds")

    (* ;; "Given a gap between PREVLINE and NEXTLINE, move NEXTLINE et seq up to coverthe gap, and adjust the YBOTs.  If DONTFILLFLG is T then we're not filling the screen")
                                                             (* ; 
                                                          "NEXTLINE = NIL => remove all lower lines.")
    (COND
       (PREVLINE                                             (* ; 
                                                         "PREVLINE = NIL => DON'T close up anything.")
              (PROG [DY (WWIDTH (IDIFFERENCE (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                                       (fetch (TEXTOBJ WLEFT) of TEXTOBJ)))
                        (LOWESTY (COND
                                    (PREVLINE (fetch (LINEDESCRIPTOR YBOT) of PREVLINE))
                                    (T (ADD1 (fetch (TEXTOBJ WTOP) of TEXTOBJ]
                    [COND
                       (NEXTLINE                             (* ; 
                                        "If the gap isn't at the end, move whatever else up over it.")
                              [SETQ DY (IDIFFERENCE LOWESTY (IPLUS (fetch (LINEDESCRIPTOR YBOT)
                                                                      of NEXTLINE)
                                                                   (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of NEXTLINE]
                              (AND (ILEQ DY 0)
                                   (RETURN))                 (* ; 
                                                "If there's no gap, don't bother with anything else.")
                              (BITBLT WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                                     WINDOW
                                     (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                                     (IPLUS DY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                     WWIDTH
                                     (IPLUS (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of NEXTLINE)
                                                   (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                            (fetch (LINEDESCRIPTOR LHEIGHT) of NEXTLINE))
                                     'INPUT
                                     'REPLACE)               (* ; "Move the remaining lines upward.")
                              (bind (LINE _ NEXTLINE)
                                    (NYBOT _ LOWESTY) while LINE
                                 do                          (* ; 
                               "Scan the remaining lines, fixing up the vertical spacing information")
                                    (SETQ NYBOT (IDIFFERENCE NYBOT (fetch (LINEDESCRIPTOR LHEIGHT)
                                                                      of LINE)))
                                    (COND
                                       ((IGEQ NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                        (SETQ LOWESTY NYBOT)))
                                    [COND
                                       [(ILESSP (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                               (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
                                                 "Line is off screen.  Display it at the right spot.")
                                        (AND DONTFILLFLG (RETURN))
                                                             (* ; 
                                                   "If we're not filling the screen, then stop here.")
                                        (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                        (replace (LINEDESCRIPTOR YBASE) of LINE
                                           with (IPLUS NYBOT (fetch (LINEDESCRIPTOR DESCENT)
                                                                of LINE)))
                                        (\DISPLAYLINE TEXTOBJ LINE WINDOW)
                                        (COND
                                           ((fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                             (* ; 
                                                 "There's a next line after the current one.  Use it")
                                            )
                                           ((IGEQ (fetch (LINEDESCRIPTOR CHARLIM) of LINE)
                                                  (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                               "We're at the end of the text;  don't bother trying to add more lines")
                                            )
                                           (T                (* ; 
                                                            "There's more;  try adding another line.")
                                              [replace (LINEDESCRIPTOR NEXTLINE) of LINE
                                                 with (\FORMATLINE TEXTOBJ NIL
                                                             (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                                      of LINE]
                                              (replace (LINEDESCRIPTOR PREVLINE)
                                                 of (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                                 with LINE]
                                       (T                    (* ; 
                                                           "Line is visible;  just update YBOT/YBASE")
                                          (replace (LINEDESCRIPTOR YBOT) of LINE with NYBOT)
                                          (replace (LINEDESCRIPTOR YBASE) of LINE
                                             with (IPLUS (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                                         (fetch (LINEDESCRIPTOR DESCENT) of LINE]
                                    (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                 until (ILESSP NYBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ]
                    (BITBLT NIL 0 0 WINDOW (fetch (TEXTOBJ WLEFT) of TEXTOBJ)
                           (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                           WWIDTH
                           (IDIFFERENCE LOWESTY (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                           'TEXTURE
                           'REPLACE WHITESHADE)              (* ; 
                                   "Clear the part of the screen below the lowest line now displayed")
                    (RETURN T])

(\TEDIT.FIXCHANGEDLINE
  [LAMBDA (TEXTOBJ PREVYBOT LINES WINDOW TEXTLEN THISLINE WHEIGHT CHARLIM NEXTCARETCH# PREVDESCENT)
                                                             (* ; "Edited  5-Oct-2022 23:05 by rmk")
                                                             (* ; "Edited 30-Jul-2022 21:15 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")
                                                             (* ; 
                                      "Reformat a single line, if need be.  Returns the changed line")
    (PROG ((YBOT PREVYBOT)
           (FORMATDONE NIL)
           LIMITCHANGED WASDIRTY OCHLIM OLHEIGHT (PREVLINE NIL)
           (FOUND NIL)
           DY OFLOWFN NEWLINE)
          (CL:WHEN (IEQP CHARLIM 1)
              (SETQ CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES)))
          (CL:WHEN [OR (fetch (LINEDESCRIPTOR DIRTY) of LINES)
                       (NOT (IEQP CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES]

              (* ;; "Only act if this line has changed, or if there is a gap or overlap between this line and the prior one")

              (SETQ OCHLIM (fetch (LINEDESCRIPTOR CHARLIM) of LINES))
                                                             (* ; 
                                                    "This line's old CHLIM, for seeing if it changes")
              (SETQ OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES))
                                                             (* ; 
                                                  "This line's old height, for seeing if it changes.")
              (SETQ NEWLINE (\FORMATLINE TEXTOBJ NIL CHARLIM))
                                                             (* ; "Create the fresh line")
              (COND
                 ((AND (ILESSP CHARLIM (fetch (LINEDESCRIPTOR CHAR1) of LINES))
                       (IEQP (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of NEWLINE))
                             (fetch (LINEDESCRIPTOR CHAR1) of LINES)))
                                                             (* ; 
                                   "If this is a space-filling line, just move the other lines down.")
                  (\TEDIT.INSERTLINE NEWLINE LINES))
                 (T                                          (* ; 
                                                             "Otherwise, write over existing lines")
                    (\TEDIT.COPY.LINEDESCRIPTOR NEWLINE LINES)
                                                             (* ; "Move it into place in the chain")
                    (replace (THISLINE DESC) of THISLINE with LINES)
                                                             (* ; 
                     "And pretend that LINES is the line we just formatted--since it effectively IS.")
                                                             (* ; 
                                                             "And copy it back over the original")
                    (SETQ NEWLINE LINES)))
              (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of NEWLINE)))

              (* ;; "Find the end of the new line (this MUST be before this COND, because LINES is set to NIL inside it.)")

              (COND
                 ((IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINES)
                        WHEIGHT)                             (* ; 
                                     "Do nothing until we see a change to a line which is on-screen.")
                                                             (* ; 
                               "Except to make sure that the fresh line also thinks it is off screen")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with (fetch (LINEDESCRIPTOR YBOT)
                                                                    of LINES)))
                 ((AND (IGEQ (SETQ YBOT (\TEDIT.NEXT.LINE.BOTTOM YBOT NEWLINE (fetch (LINEDESCRIPTOR
                                                                                      PREVLINE)
                                                                                 of NEWLINE)))
                             (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                       (NEQ LINES NEWLINE))                  (* ; 
                          "If there's space left on the screen for this line, (and it is a new line)")
                  (\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of NEWLINE)
                         WINDOW
                         (fetch (LINEDESCRIPTOR YBOT) of (fetch (LINEDESCRIPTOR PREVLINE)
                                                            of NEWLINE))
                         (IMINUS (fetch (LINEDESCRIPTOR LHEIGHT) of NEWLINE)))
                                                             (* ; 
                                                          "Move the existing lines down to fit it in")
                  (replace (LINEDESCRIPTOR YBOT) of NEWLINE with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of NEWLINE with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                      DESCENT)
                                                                                 of NEWLINE)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ NEWLINE WINDOW))
                 ((IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                                             (* ; 
          "If there's space left on the screen for this line, and we're overlaying an existing line.")
                  [\TEDIT.ADJUST.LINES TEXTOBJ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                         WINDOW
                         (IPLUS YBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES)
                                (IMINUS OLHEIGHT))
                         (COND
                            ((fetch FMTBASETOBASE of (fetch (LINEDESCRIPTOR LFMTSPEC) of LINES))
                             (IDIFFERENCE (fetch (LINEDESCRIPTOR YBOT) of LINES)
                                    YBOT))
                            (T (IDIFFERENCE OLHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LINES]
                                                             (* ; 
                             "Adjust for the possible difference in heights between old and new line")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                                                             (* ; "Display it where we are now")
                  (replace (LINEDESCRIPTOR YBASE) of LINES with (IPLUS YBOT (fetch (LINEDESCRIPTOR
                                                                                    DESCENT)
                                                                               of LINES)))
                                                             (* ; 
                                                             "Base line for the characters to sit on")
                  (\DISPLAYLINE TEXTOBJ LINES WINDOW))
                 ((AND NEXTCARETCH# (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                          NEXTCARETCH#))     (* ; 
                        "This line is off-screen, but is needed for finding the caret's new location")
                  (replace (LINEDESCRIPTOR YBOT) of LINES with YBOT)
                  (replace (LINEDESCRIPTOR YBASE) of LINES with YBOT))
                 (T                                          (* ; 
                        "We have walked off the bottom of the screen.  Chop off the lines from here.")
                    (SETQ LINES NEWLINE)
                    (CL:WHEN (AND (SETQ OFLOWFN (TEXTPROP TEXTOBJ 'OVERFLOWFN))
                                  (APPLY* OFLOWFN WINDOW TEXTOBJ))
                        (RETFROM (FUNCTION \TEDIT.FIXCHANGEDLINE)))
                    [replace (LINEDESCRIPTOR YBOT) of LINES with (replace (LINEDESCRIPTOR YBASE)
                                                                    of LINES
                                                                    with (SUB1 (fetch (TEXTOBJ 
                                                                                             WBOTTOM)
                                                                                  of TEXTOBJ]
                                                             (* ; 
                                                             "Mark this line as being off-screen")
                    (CL:WHEN (IGREATERP (fetch (LINEDESCRIPTOR CHARLIM) of LINES)
                                    NEXTCARETCH#)
                        (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL))
                                                             (* ; 
   "Chop off any lines below it, to preserve changes that may propogate off the bottom of the window")
                    (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW (fetch (LINEDESCRIPTOR PREVLINE)
                                                                      of LINES))
                                                             (* ; 
                                            "And clear the space below the bottom line on the screen")
                    (RETURN)))
              (SETQ LINES NEWLINE)                           (* ; 
                      "So that if we inserted a line, we start by moving up to the pre-existing line")
              )
          (RETURN LINES])

(\TEDIT.FIXCHANGEDPART
  [LAMBDA (TEXTOBJ STARTINGLINE WINDOW INCREMENTAL? NEXTCARETCH#)
                                                             (* ; "Edited  5-Oct-2022 23:05 by rmk")
                                                             (* ; "Edited 30-May-91 16:07 by jds")

    (* ;; "Reformat lines as needed after a change.  Return the last line changed, or NIL if there's no need for a \FILLWINDOW.")

    (PROG* ((THISW (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ)))
            [LINES (fetch (LINEDESCRIPTOR NEXTLINE) of (WINDOWPROP THISW 'LINES]
            (REGION (DSPCLIPPINGREGION NIL THISW))
            (YBOT (fetch (REGION PTOP) of REGION))
            (FORMATDONE NIL)
            LIMITCHANGED WASDIRTY CHARLIM OCHLIM OLHEIGHT (PREVLINE NIL)
            (TPREVLINE NIL)
            (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
            (THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ))
            (WHEIGHT (fetch (REGION PTOP) of REGION))
            (WBOTTOM (fetch (REGION BOTTOM) of REGION))
            (CLEARBOTTOM T)
            [NEXTCARETCH# (OR NEXTCARETCH# (fetch (SELECTION CH#) of (fetch (TEXTOBJ SEL)
                                                                        of TEXTOBJ]
            DY OFLOWFN NEWLINE TYBOT)
           (CL:WHEN LINES
               (SETQ TPREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of LINES)))
           [while LINES do                                   (* ; 
                                                    "Find the first line descriptor of a DIRTY line.")
                           (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of LINES))
                           (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM YBOT LINES
                                                        (fetch (LINEDESCRIPTOR PREVLINE) of LINES))
                                           YBOT))
                           (CL:WHEN (ILESSP 0 DY)            (* ; 
                           "There used to be another line above this one.  Move this up to cover it.")

                               (* ;; 
      "This HAS to fill the window, or we may wind up with missing lines at the bottom of the screen")

                               (\TEDIT.CLOSEUPLINES TEXTOBJ (fetch (LINEDESCRIPTOR PREVLINE)
                                                               of LINES)
                                      LINES NIL (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ))))
                           (COND
                              ((AND (ILESSP YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                    (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                           NEXTCARETCH#))    (* ; 
                                                            "We've run off the bottom of the screen.")
                               (replace (LINEDESCRIPTOR NEXTLINE) of TPREVLINE with NIL)
                                                             (* ; 
                                 "There may be unfixed changes there, so chop off any further lines.")
                               (SETQ LINES NIL))
                              ((fetch (LINEDESCRIPTOR DIRTY) of LINES)
                               (RETURN))
                              ([AND [NOT (IEQP (fetch (LINEDESCRIPTOR CHAR1) of LINES)
                                               (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of TPREVLINE]
                                    (NOT (ZEROP (fetch (LINEDESCRIPTOR CHARLIM) of TPREVLINE]

                               (* ;; "This line doesn't match up with the previous line;  we should start updating here.  But don't worry about the dummy first line")

                               (RETURN))
                              (T (SETQ TPREVLINE LINES)
                                 (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES]
           (CL:WHEN (AND LINES (ILESSP (fetch (LINEDESCRIPTOR CHARTOP) of LINES)
                                      0))                    (* ; 
                       "If we hit on the dummy first line, skip over it -- never try to reformat it.")
               (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)))
           (CL:UNLESS LINES                                  (* ; 
                                          "No changed lines found -- clear below last line on screen")
               (BITBLT NIL 0 0 WINDOW 0 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)
                      (fetch (REGION WIDTH) of (DSPCLIPPINGREGION NIL WINDOW))
                      (IDIFFERENCE YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                      'TEXTURE
                      'REPLACE WHITESHADE)
               (COND
                  [[OR (ZEROP TEXTLEN)
                       (NOT (fetch (LINEDESCRIPTOR NEXTLINE) of (WINDOWPROP (OR WINDOW (
                                                                                      \TEDIT.PRIMARYW
                                                                                        TEXTOBJ))
                                                                       'LINES]

                   (* ;; "If there is no text, or no image, force a call to \FILLWINDOW, to provide a dummy empty line descriptor for the guy to type at.")

                   (RETURN (WINDOWPROP WINDOW 'LINES]
                  (T                                         (* ; 
                                               "We found no changes;  return a NIL last-line-changed")
                     (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
                                                             (* ; 
                        "Reset the 'needs-update' flag so we don't come back looking for work again.")
                     (RETURN NIL))))
           [SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of (SETQ PREVLINE (fetch (LINEDESCRIPTOR PREVLINE)
                                                                        of LINES]
                                                             (* ; 
                                                            "Y bottom of the first line to reformat.")
           (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of PREVLINE)))
                                                             (* ; "char to start formatting with")
           (while (AND LINES (OR (IGEQ YBOT (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ))
                                 (ILEQ CHARLIM NEXTCARETCH#)))
              do 
                 (* ;; "Run thru lines, cleaning them up.  Start with the first dirty line, and only stop if we're both past the place the caret will be AND off the bottom of the screen.")

                 (CL:WHEN [ILESSP 0 (SETQ DY (IDIFFERENCE (\TEDIT.NEXT.LINE.BOTTOM
                                                           YBOT LINES (fetch (LINEDESCRIPTOR PREVLINE
                                                                                    ) of LINES))
                                                    (fetch (LINEDESCRIPTOR YBOT) of LINES]
                                                             (* ; 
                           "There used to be another line above this one.  Move this up to cover it.")
                     (\TEDIT.CLOSEUPLINES TEXTOBJ (fetch (LINEDESCRIPTOR PREVLINE) of LINES)
                            LINES NIL (OR WINDOW (\TEDIT.PRIMARYW TEXTOBJ))))
                 [COND
                    ((IGREATERP CHARLIM (IMIN (IMAX 1 (fetch (LINEDESCRIPTOR CHARLIM) of LINES))
                                              TEXTLEN))      (* ; 
                                              "This line has been rendered superfluous -- Delete it.")
                     (TEDIT.DELETELINE LINES TEXTOBJ WINDOW))
                    (T 
                       (* ;; "Try updating the line.  If the updater returns NIL, it ran off the bottom of the screen, and we should give up.")

                       (COND
                          ((SETQ LINES (\TEDIT.FIXCHANGEDLINE TEXTOBJ YBOT LINES WINDOW TEXTLEN 
                                              THISLINE WHEIGHT CHARLIM NEXTCARETCH#
                                              (fetch (LINEDESCRIPTOR DESCENT) of PREVLINE)))
                                                             (* ; 
             "We're still on screen;  update the character and Y-position counters for the next loop")
                           (SETQ CHARLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINES)))
                           (SETQ YBOT (fetch (LINEDESCRIPTOR YBOT) of LINES)))
                          (T                                 (* ; 
    "Ran off the bottom of the window;  the bottom has already been cleared, so avoid doing it here.")
                             (SETQ CLEARBOTTOM NIL)
                             (RETURN]
                 (COND
                    ((IGEQ CHARLIM TEXTLEN)                  (* ; 
 "If we've run out of text, chop off any remaining line descriptors, since we won't be needing them.")
                     (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL)
                     (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with NIL)
                                                             (* ; 
                                                 "And there's no more screen updating to do, either.")
                     )
                    ((AND INCREMENTAL? (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)
                          (IGREATERP CHARLIM NEXTCARETCH#)
                          (\SYSBUFP))                        (* ; 
                  "This is an incremental update, and he hit a key.  Stop updating and listen to him")
                                                             (* ; 
                    "HOWEVER, NEVER STOP ON THE LAST LINE -- IF THERE ARE NEW LINES TO ADD, ADD ONE.")
                     (SETQ PREVLINE NIL)
                     (SETQ CLEARBOTTOM NIL)
                     (RETURN)))
                 (SETQ PREVLINE LINES)                       (* ; 
                                                        "Remember the last line we really formatted.")
                 (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES)) 
                                                             (* ; "Move to the next line"))
           (CL:WHEN CLEARBOTTOM                              (* ; 
     "There had been lines yet to be formatted, so there may be garbage below the end of the screen.")
               (\TEDIT.CLEAR.SCREEN.BELOW.LINE TEXTOBJ WINDOW PREVLINE))
           (RETURN PREVLINE])

(\TEDIT.INSERTLINE
  [LAMBDA (NEWLINE BEFORELINE)                               (* ; "Edited 30-May-91 16:05 by jds")
                                                             (* Inserts NEWLINE in front of 
                                                             BEFORELINE in the line-descriptor 
                                                             chain)
    (PROG ((PREVLINE (fetch (LINEDESCRIPTOR PREVLINE) of BEFORELINE)))
          (replace (LINEDESCRIPTOR PREVLINE) of NEWLINE with PREVLINE)
          (replace (LINEDESCRIPTOR NEXTLINE) of NEWLINE with BEFORELINE)
          (replace (LINEDESCRIPTOR PREVLINE) of BEFORELINE with NEWLINE)
          (AND PREVLINE (replace (LINEDESCRIPTOR NEXTLINE) of PREVLINE with NEWLINE])

(\TEDIT.LINE.LIST
  [LAMBDA (TEXTOBJ WINDOW)                                  (* ; "Edited 12-Jun-90 19:23 by mitani")
    (for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINES inside (fetch (TEXTOBJ LINES)
                                                                           of TEXTOBJ)
       when (EQ WW WINDOW) do (RETURN LINES])

(\TEDIT.MARK.LINES.DIRTY
  [LAMBDA (TEXTOBJ CH1 CHLIM)                                (* ; "Edited 19-Oct-2022 11:13 by rmk")
                                                             (* ; "Edited 30-May-91 16:05 by jds")

    (* ;; "Mark dirty the lines that intersect the range CH1 to CHLIM  inclusive")

    (bind (CH# _ (IMIN CH1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          (CHLIM# _ (COND
                       ((IEQP CHLIM -1)
                        (ADD1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                       (T CHLIM))) for WW inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
       do (bind (LL _ (WINDOWPROP WW 'LINES)) while LL
             do                                              (* ; "Mark changed lines as DIRTY.")
                (COND
                   ((AND (ILEQ (fetch (LINEDESCRIPTOR CHAR1) of LL)
                               CHLIM#)
                         (IGEQ (fetch (LINEDESCRIPTOR CHARTOP) of LL)
                               CH#))

                    (* ;; "The dirty range overlaps with this line -- it is between the 1st char on the line, and the last char examined when deciding where to break the line.")

                    (replace (LINEDESCRIPTOR DIRTY) of LL with T)))
                (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)))
       finally (replace (TEXTOBJ TXTNEEDSUPDATE) of TEXTOBJ with T])

(\TEDIT.NEXT.LINE.BOTTOM
  [LAMBDA (CURYBOT LINE PREVLINE)                            (* ; "Edited 24-Sep-87 10:00 by jds")

(* ;;; "Given a current Y-bottom for PREVLINE, and a LINE to follow it, compute the new line's YBOT value.  Takes into account Base-to-base leading, as well as paragraph leadings.")

    (PROG (NEWYBOT PARALEADING PARALOOKS BASETOBASE)
          [COND
             [[SETQ BASETOBASE (fetch (FMTSPEC FMTBASETOBASE) of (SETQ PARALOOKS (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                         LFMTSPEC)
                                                                                    of LINE]

              (* ;; "If base-to-base spacing is specified, we have to do this in two parts: First, compute the proper spacing between the lines;  then add in any paragraph leading.")

              [SETQ NEWYBOT (IDIFFERENCE (IPLUS CURYBOT (fetch (LINEDESCRIPTOR DESCENT) of PREVLINE))
                                   (IPLUS BASETOBASE (fetch (LINEDESCRIPTOR DESCENT) of LINE]
              (COND
                 ((fetch (LINEDESCRIPTOR 1STLN) of LINE)     (* ; 
                          "This is the first line of a new paragraph.  Add in any paragraph leading.")
                  [SETQ PARALEADING (IPLUS (fetch (FMTSPEC LEADBEFORE) of PARALOOKS)
                                           (fetch (FMTSPEC LEADAFTER) of (fetch (LINEDESCRIPTOR
                                                                                 LFMTSPEC)
                                                                            of PREVLINE]

                  (* ;; "The inter-paragraph space is the sum of the previous para's post-leading and this para's pre-leading.")

                  (SETQ NEWYBOT (IDIFFERENCE NEWYBOT PARALEADING]
             (T 
                (* ;; "If there's no base-to-base spacing, then paragraph leading was taken into account in the line formatter, and is already part of LHEIGHT.")

                (SETQ NEWYBOT (IDIFFERENCE CURYBOT (fetch (LINEDESCRIPTOR LHEIGHT) of LINE]
          (RETURN NEWYBOT])

(\TEDIT.COPY.LINEDESCRIPTOR
  [LAMBDA (FROMLINE TOLINE)                                  (* ; "Edited 19-Oct-2022 09:08 by rmk")
                                                             (* ; "Edited 29-Sep-2022 21:42 by rmk")
                                                             (* ; "Edited 30-May-91 16:57 by jds")

    (* ;; 
  "Copy the contents of one line descriptor into another -- except for chaining and Y-location info.")

    (freplace (LINEDESCRIPTOR LEFTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR LEFTMARGIN)
                                                            of FROMLINE))
    (freplace (LINEDESCRIPTOR RIGHTMARGIN) of TOLINE with (ffetch (LINEDESCRIPTOR RIGHTMARGIN)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR LXLIM) of TOLINE with (ffetch (LINEDESCRIPTOR LXLIM) of FROMLINE))
    (freplace (LINEDESCRIPTOR LHEIGHT) of TOLINE with (ffetch (LINEDESCRIPTOR LHEIGHT) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHAR1) of TOLINE with (ffetch (LINEDESCRIPTOR CHAR1) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHARLIM) of TOLINE with (ffetch (LINEDESCRIPTOR CHARLIM) of FROMLINE))
    (freplace (LINEDESCRIPTOR CHARTOP) of TOLINE with (ffetch (LINEDESCRIPTOR CHARTOP) of FROMLINE))
    (freplace (LINEDESCRIPTOR DIRTY) of TOLINE with NIL)
    (freplace (LINEDESCRIPTOR CR\END) of TOLINE with (ffetch (LINEDESCRIPTOR CR\END) of FROMLINE))
    (freplace (LINEDESCRIPTOR LHASPROT) of TOLINE with (ffetch (LINEDESCRIPTOR LHASPROT) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LFMTSPEC) of TOLINE with (ffetch (LINEDESCRIPTOR LFMTSPEC) of FROMLINE)
           )
    (freplace (LINEDESCRIPTOR LTRUEDESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEDESCENT)
                                                              of FROMLINE))
    (freplace (LINEDESCRIPTOR LTRUEASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR LTRUEASCENT)
                                                             of FROMLINE))
    (freplace (LINEDESCRIPTOR ASCENT) of TOLINE with (ffetch (LINEDESCRIPTOR ASCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR DESCENT) of TOLINE with (ffetch (LINEDESCRIPTOR DESCENT) of FROMLINE))
    (freplace (LINEDESCRIPTOR LMARK) of TOLINE with (ffetch (LINEDESCRIPTOR LMARK) of FROMLINE))
    (freplace (LINEDESCRIPTOR 1STLN) of TOLINE with (ffetch (LINEDESCRIPTOR 1STLN) of FROMLINE))
    (freplace (LINEDESCRIPTOR LSTLN) of TOLINE with (ffetch (LINEDESCRIPTOR LSTLN) of FROMLINE])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (23827 79679 (\FORMATLINE 23837 . 53341) (\FORMATLINE.JUSTIFY 53343 . 64408) (
\FORMATLINE.TABS 64410 . 70707) (\FORMATLINE.PURGE.SPACES 70709 . 71520) (\FORMATLINE.NEWNSCHARS 71522
 . 72553) (\TEDIT.LOOKS.UPDATE 72555 . 77381) (\CLEARTHISLINE 77383 . 78052) (\TLVALIDATE 78054 . 
79677)) (79680 99630 (\DISPLAYLINE 79690 . 93986) (\DISPLAYLINE.TABS 93988 . 95537) (\TEDIT.LINECACHE 
95539 . 96267) (\TEDIT.CREATE.LINECACHE 96269 . 97105) (\TEDIT.BLTCHAR 97107 . 99628)) (100245 200858 
(TEDIT.CR.UPDATESCREEN 100255 . 101474) (TEDIT.DELETELINE 101476 . 102398) (TEDIT.INSERT.DISPLAYTEXT 
102400 . 118544) (TEDIT.INSERT.UPDATESCREEN 118546 . 123446) (TEDIT.UPDATE.SCREEN 123448 . 124591) (
\BACKFORMAT 124593 . 128443) (\FILLWINDOW 128445 . 142151) (\FIXDLINES 142153 . 147990) (\FIXILINES 
147992 . 153098) (\SHOWTEXT 153100 . 155709) (\TEDIT.ADJUST.LINES 155711 . 163289) (
\TEDIT.CLEAR.SCREEN.BELOW.LINE 163291 . 164029) (\TEDIT.CLOSEUPLINES 164031 . 171498) (
\TEDIT.FIXCHANGEDLINE 171500 . 181822) (\TEDIT.FIXCHANGEDPART 181824 . 192932) (\TEDIT.INSERTLINE 
192934 . 193762) (\TEDIT.LINE.LIST 193764 . 194162) (\TEDIT.MARK.LINES.DIRTY 194164 . 195669) (
\TEDIT.NEXT.LINE.BOTTOM 195671 . 197968) (\TEDIT.COPY.LINEDESCRIPTOR 197970 . 200856)))))
STOP
