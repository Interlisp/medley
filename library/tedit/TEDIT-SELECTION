(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "26-Oct-2022 22:02:06" 
{DSK}<users>kaplan>local>medley3.5>working-medley>library>tedit>TEDIT-SELECTION.;100 135535 

      :CHANGES-TO (FNS TEDIT.SELECT.LINE.SCANNER)

      :PREVIOUS-DATE "26-Oct-2022 20:41:48" 
{DSK}<users>kaplan>local>medley3.5>working-medley>library>tedit>TEDIT-SELECTION.;99)


(PRETTYCOMPRINT TEDIT-SELECTIONCOMS)

(RPAQQ TEDIT-SELECTIONCOMS
       ([DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \FIXSEL.HCUNSCALE \SHOWSEL.HCUNSCALE)
               (EXPORT (RECORDS SELECTION)
                      (CONSTANTS (COPYSELSHADE 30583)
                             (COPYLOOKSSELSHADE 30583)
                             (EDITMOVESHADE -1)
                             (EDITGRAY 32800]
        (INITRECORDS SELECTION)
        (FNS TEDIT.SEL.AS.STRING TEDIT.SELECTED.PIECES \TEDIT.FIND.FIRST.LINE \TEDIT.FIND.LAST.LINE 
             \TEDIT.FIND.OVERLAPPING.LINE \TEDIT.FIND.PROTECTED.END \TEDIT.FIND.PROTECTED.START 
             \TEDIT.WORD.BOUND)
        (INITVARS (TEDIT.EXTEND.PENDING.DELETE T))
        (FNS \CREATE.TEDIT.SELECTION \CREATE.TEDIT.SHIFTEDSELECTION \CREATE.TEDIT.MOVESELECTION 
             \CREATE.TEDIT.DELETESELECTION)
                                                             (* ; 
                                                         "Added by yabu.fx, for LOADUP without DWIM.")
        (VARS (TEDIT.SELECTION (\CREATE.TEDIT.SELECTION))
                                                             (* ; 
                                                             "Original was %"(create SELECTION)%".")
              (TEDIT.SCRATCHSELECTION (\CREATE.TEDIT.SELECTION))
                                                             (* ; 
                                                             "Original was %"(create SELECTION)%".")
              (TEDIT.SHIFTEDSELECTION (\CREATE.TEDIT.SHIFTEDSELECTION))
                                                             (* ; 
                                                "Original was %"(create SELECTION HASCARET _ NIL)%".")
              (TEDIT.COPYLOOKSSELECTION (\CREATE.TEDIT.SHIFTEDSELECTION))
                                                             (* ; 
                                                "Original was %"(create SELECTION HASCARET _ NIL)%".")
              (TEDIT.MOVESELECTION (\CREATE.TEDIT.MOVESELECTION))
                                                             (* ; 
                              "Original was %"(CREATE SELECTION HASCARET _ NIL HOWHEIGHT _ 32767)%".")
              (TEDIT.DELETESELECTION (\CREATE.TEDIT.DELETESELECTION))
                                                             (* ; 
             "Original was %"(CREATE SELECTION HOW _ BLACKSHADE HASCARET _ NIL HOWHEIGHT _ 32767)%".")
                                                             (* ; 
                                                       "Changed by yabu.fx, for LOADUP without DWIM.")
              (TEDIT.SELPENDING NIL))
        (GLOBALVARS TEDIT.SELECTION TEDIT.SCRATCHSELECTION TEDIT.MOVESELECTION TEDIT.SHIFTEDSELECTION
               TEDIT.COPYLOOKSSELECTION TEDIT.DELETESELECTION TEDIT.SELPENDING 
               TEDIT.EXTEND.PENDING.DELETE)
        (COMS                                                (* ; "Selection manipulating code")
              (FNS TEDIT.EXTEND.SEL TEDIT.SELECT TEDIT.SCAN.LINE TEDIT.SELECT.LINE.SCANNER 
                   \TEDIT.SELECT.OBJECT)
              (FNS \FIXSEL \TEDIT.FIXDELSEL \TEDIT.FIXINSSEL \TEDIT.FIXSELS)
              (FNS TEDIT.RESET.EXTEND.PENDING.DELETE \TEDIT.SET.SEL.LOOKS)
              (FNS \SHOWSEL \SHOWSEL.HILIGHT \TEDIT.UPDATE.SHOWSEL \TEDIT.SHOWSELS 
                   \TEDIT.REFRESH.SHOWSEL)
              (FNS \COPYSEL \TEDIT.SEL.CHANGED?))
        (COMS 
              (* ;; "User entries to the selection code")

              (FNS TEDIT.GETPOINT TEDIT.GETSEL TEDIT.MAKESEL TEDIT.SCANSEL TEDIT.SET.SEL.LOOKS 
                   TEDIT.SETSEL TEDIT.SHOWSEL))))
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \FIXSEL.HCUNSCALE MACRO [(LINE FIELD)

                                   (* ;; 
                        "Scale selection X-limits down to points for lines in hardcopy-display mode.")

                                   (CL:WHEN (AND LINE (fetch (FMTSPEC FMTHARDCOPY)
                                                         of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                               of LINE)))
                                       (change (fetch (SELECTION FIELD) of SEL)
                                              (HCUNSCALE (fetch (FMTSPEC FMTHARDCOPYSCALE)
                                                            of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                  of LINE))
                                                     DATUM)))])

(PUTPROPS \SHOWSEL.HCUNSCALE MACRO ((LINE VAL)

                                    (* ;; "Scale line value for lines in hardcopy-display mode.")

                                    (CL:IF (AND LINE (fetch (FMTSPEC FMTHARDCOPY)
                                                        of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                              of LINE)))
                                        (HCUNSCALE (fetch (FMTSPEC FMTHARDCOPYSCALE)
                                                      of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                            of LINE))
                                               VAL)
                                        VAL)))
)

(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE SELECTION 
          (
           (* ;; "Description of a piece of selected text for TEdit.  Text has to be selected before it can be operated on by the user.")

           Y0                                                (* ; 
                                                             "Y value of topmost line of selection")
           X0                                                (* ; "X value of left edge of selection")
           DX                                                (* ; 
                                                       "Width of the selection, if it's on one line.")
           CH#                                               (* ; 
                                                             "CH# of the first selected character")
           XLIM                                              (* ; 
                                                   "X value of right edge of last selected character")
           CHLIM                                             (* ; 
                                                         "CH# of the last character in the selection")
           DCH                                               (* ; 
                                       "# of characters selected (can be zero, for point selection.)")
           L1                                                (* ; 
                              "-> line descriptor for the line where the first selected character is")
           LN                                                (* ; 
                            "-> line descriptor for the line which contains the end of the selection")
           YLIM                                              (* ; 
                                          "Y value of the bottom of the line that ends the selection")
           POINT                                             (* ; 
                                             "Which end should the caret appear at?  (LEFT or RIGHT)")
           (SET FLAG)                                        (* ; 
                                                           "T if this selection is real;  NIL if not")
           (SELTEXTOBJ FULLXPOINTER)                         (* ; 
                                                           "TEXTOBJ that describes the selected text")
           SELKIND                                           (* ; 
                                              "What kind of selection?  CHAR or WORD or LINE or PARA")
           HOW                                               (* ; 
                                                             "SHADE used to highlight this selection")
           HOWHEIGHT                                         (* ; 
                             "Height of the highlight (1 usually, full line for delete selection...)")
           (HASCARET FLAG)                                   (* ; 
                                                    "T if there should be a caret for this selection")
           SELOBJ                                            (* ; 
                                               "If this selection is inside an object, which object?")
           (ONFLG FLAG)                                      (* ; 
                                          "T if the selection is highlighted on the screen, else NIL")
           SELOBJINFO                                        (* ; 
                         "A Place for the selected object to put info about selection inside itself.")
           )
          SET _ NIL HOW _ BLACKSHADE HOWHEIGHT _ 1 HASCARET _ T Y0 _ 0 X0 _ 0 POINT _ 'LEFT L1 _
          (LIST NIL)
          LN _ (LIST NIL))
)

(/DECLAREDATATYPE 'SELECTION
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG
               FULLXPOINTER POINTER POINTER POINTER FLAG POINTER FLAG POINTER)
       '((SELECTION 0 POINTER)
         (SELECTION 2 POINTER)
         (SELECTION 4 POINTER)
         (SELECTION 6 POINTER)
         (SELECTION 8 POINTER)
         (SELECTION 10 POINTER)
         (SELECTION 12 POINTER)
         (SELECTION 14 POINTER)
         (SELECTION 16 POINTER)
         (SELECTION 18 POINTER)
         (SELECTION 20 POINTER)
         (SELECTION 20 (FLAGBITS . 0))
         (SELECTION 22 FULLXPOINTER)
         (SELECTION 24 POINTER)
         (SELECTION 26 POINTER)
         (SELECTION 28 POINTER)
         (SELECTION 28 (FLAGBITS . 0))
         (SELECTION 30 POINTER)
         (SELECTION 30 (FLAGBITS . 0))
         (SELECTION 32 POINTER))
       '34)
(DECLARE%: EVAL@COMPILE 

(RPAQQ COPYSELSHADE 30583)

(RPAQQ COPYLOOKSSELSHADE 30583)

(RPAQQ EDITMOVESHADE -1)

(RPAQQ EDITGRAY 32800)


(CONSTANTS (COPYSELSHADE 30583)
       (COPYLOOKSSELSHADE 30583)
       (EDITMOVESHADE -1)
       (EDITGRAY 32800))
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'SELECTION
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG
               FULLXPOINTER POINTER POINTER POINTER FLAG POINTER FLAG POINTER)
       '((SELECTION 0 POINTER)
         (SELECTION 2 POINTER)
         (SELECTION 4 POINTER)
         (SELECTION 6 POINTER)
         (SELECTION 8 POINTER)
         (SELECTION 10 POINTER)
         (SELECTION 12 POINTER)
         (SELECTION 14 POINTER)
         (SELECTION 16 POINTER)
         (SELECTION 18 POINTER)
         (SELECTION 20 POINTER)
         (SELECTION 20 (FLAGBITS . 0))
         (SELECTION 22 FULLXPOINTER)
         (SELECTION 24 POINTER)
         (SELECTION 26 POINTER)
         (SELECTION 28 POINTER)
         (SELECTION 28 (FLAGBITS . 0))
         (SELECTION 30 POINTER)
         (SELECTION 30 (FLAGBITS . 0))
         (SELECTION 32 POINTER))
       '34)
(DEFINEQ

(TEDIT.SEL.AS.STRING
  [LAMBDA (TSTREAM SEL)                                      (* ; "Edited  8-Sep-2022 23:35 by rmk")
                                                             (* ; "Edited 22-Apr-93 16:44 by jds")

    (* ;; "RMK:  WHAT IF THE STREAM CONTAINS AN OBJECT?")

    (* ;; 
    "Given a text stream, go to the TEXTOBJ, get the current selection, and return it as a string.")

    (CL:UNLESS SEL
        (SETQ SEL (fetch (TEXTOBJ SEL) of (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))))
    (SETQ TSTREAM (TEXTSTREAM TSTREAM))
    (LET (RESULT (LEN (fetch (SELECTION DCH) of SEL)))
         (COND
            ((ZEROP LEN)                                     (* ; 
                                              "There is no selection, or it's zero-width.  Return ''")
             (CONCAT ""))
            (T (SETQ RESULT (ALLOCSTRING LEN (CHARCODE SPACE)))
                                                             (* ; "The resulting string")
               (\TEXTSETFILEPTR TSTREAM (SUB1 (fetch (SELECTION CH#) of SEL)))
                                                             (* ; 
                                               "Starting point for the string is start of selection.")
               (for I from 1 to LEN do (RPLCHARCODE RESULT I (BIN TSTREAM)))
               RESULT])

(TEDIT.SELECTED.PIECES
  [LAMBDA (TEXTOBJ SEL PIECEMAPFN FNARG1 FNARG2)             (* ; "Edited 22-Oct-2022 15:12 by rmk")
                                                             (* ; "Edited  9-Oct-2022 12:12 by rmk")
                                                             (* ; "Edited  7-Sep-2022 23:04 by rmk")
                                                             (* ; "Edited  5-Sep-2022 14:41 by rmk")
                                                             (* ; "Edited 20-Apr-93 17:06 by jds")

    (* ;; "Create a list of pieces corresponding to the selection;  if FNARG, apply it to each piece, and use the result as the copy of the piece")

    (CL:UNLESS (ZEROP (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
        (for PC inpiecerange (\PIECERANGE SEL NIL TEXTOBJ)
           collect (CL:IF PIECEMAPFN (APPLY* PIECEMAPFN PC TEXTOBJ FNARG1 FNARG2))
                 PC))])

(\TEDIT.FIND.FIRST.LINE
  [LAMBDA (TEXTOBJ WHEIGHT CH# WINDOW)                       (* ; "Edited  8-Sep-2022 21:02 by rmk")
                                                             (* ; "Edited 30-May-91 23:02 by jds")
                                                             (* ; 
                      "Find the first line to be displayed, given that it must include character CH#")
    (PROG ((LINES (OR (AND WINDOW (WINDOWPROP WINDOW 'LINES))
                      (fetch (TEXTOBJ LINES) of TEXTOBJ)))
           (WWIDTH (fetch (TEXTOBJ WRIGHT) of TEXTOBJ))
           LINE CHNO)
          (CL:WHEN (ZEROP (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                                                            "If there's no text, force an empty line")
              (replace (LINEDESCRIPTOR NEXTLINE) of LINES with NIL)
              (RETURN LINES))
          (CL:WHEN (IGREATERP CH# (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                                                  "If there's no text on the screen, just return nil")
              (RETURN NIL))
          [if (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
              then 
                   (* ;; "For a para-formatted object, back up to the prior para bound.")

                   (SETQ CHNO (CAR (\TEDIT.PARABOUNDS TEXTOBJ CH#)))
            else 
                 (* ;; "Otherwise, move back thru the text until we find a for-sure line break")

                 [SETQ CHNO (find I (TSTREAM _ (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ))
                               from (SUB1 CH#) to 2 by -1 first (\TEXTSETFILEPTR TSTREAM (SUB1 CH#))
                                                                
                                                             (* ; 
                                                      "Because fileptrs are one back from characters")
                               suchthat (EQ (CHARCODE EOL)
                                            (\BACKBIN TSTREAM]
                 (SETQ CHNO (if (NULL CHNO)
                                then 
                                     (* ;; 
                     "If we didn't find a preceding EOL, move forward from the beginning of the file")

                                     1
                              elseif (IEQP CHNO CH#)
                                then 
                                     (* ;; 
                            "If we landed on an EOL first shot, let's try moving forward from there.")

                                     CH# T
                              else 
                                   (* ;; "Otherwise, skip the EOL we passed over")

                                   (ADD1 CHNO]
          [repeatwhile (ILEQ CHNO CH#) do 
                                          (* ;; "Starting from the known line break, move forward until we find the line which has the right CH# in it")

                                          (SETQ LINE (\FORMATLINE TEXTOBJ NIL CHNO))
                                          (replace (LINEDESCRIPTOR YBOT) of LINE with WHEIGHT)
                                          (replace (LINEDESCRIPTOR NEXTLINE) of LINES with LINE)
                                          (replace (LINEDESCRIPTOR PREVLINE) of LINE with LINES)
                                          (SETQ LINES LINE)
                                          (SETQ CHNO (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                              of LINE]
          (RETURN LINE])

(\TEDIT.FIND.LAST.LINE
  [LAMBDA (TEXTOBJ LINES)                                    (* ; "Edited 30-May-91 23:02 by jds")

         (* Among the line descriptors in LINES, find the last one on the screen;
         then return it.)

    (OR LINES (SETQ LINES (fetch (TEXTOBJ LINES) of TEXTOBJ)))
                                                             (* Make sure a list of line 
                                                             descriptors is specified.)
    (COND
       ((fetch (TEXTOBJ \WINDOW) of TEXTOBJ)                 (* If there's no window, return NIL.)
        (bind (OLINE _ LINES)
              (LINE _ LINES)
              (CURY _ (fetch (LINEDESCRIPTOR YBOT) of LINES))
           while (AND LINE (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINE)
                                 (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
           do                                                (* Find the lowest line above screen 
                                                             bottom, and put it in OLINE.)
              (SETQ OLINE LINE)
              (SETQ LINE (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)) finally (RETURN OLINE)))
       (T NIL])

(\TEDIT.FIND.OVERLAPPING.LINE
  [LAMBDA (LINES Y)                                          (* ; "Edited 30-May-91 22:57 by jds")
    (while LINES do (COND
                       ((ILEQ (fetch (LINEDESCRIPTOR YBOT) of LINES)
                              Y)
                        (RETURN LINES))
                       (T (SETQ LINES (fetch (LINEDESCRIPTOR NEXTLINE) of LINES])

(\TEDIT.FIND.PROTECTED.END
  [LAMBDA (TEXTOBJ CH# LIMITCH#)                             (* ; "Edited 23-Oct-2022 17:44 by rmk")
                                                             (* ; "Edited  5-Sep-2022 15:31 by rmk")
                                                             (* ; "Edited 22-Aug-2022 13:21 by rmk")
                                                             (* ; "Edited 18-Apr-93 23:49 by jds")

    (* ;; "Starting from a CH# in a selectable region, find the CH# of the last selectable character following that.  This is used to limit selections to unprotected text, and to prevent selection of the protected text between tow unprotected areas.")

    (* ;; "If LIMITCH# is given, the search will stop there.")

    (bind (OURLIMIT _ (IMIN (OR LIMITCH# (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                            (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
          START-OF-PIECE PC first (SETQ PC (\CHTOPC CH# TEXTOBJ T)) while PC
       do 
          (* ;; "Move forward thru the pieces of the document, looking for one that contains protected text.  If that comes before the end of the region we're interested in, tell the caller about the earlier end to selectable text.")

          [COND
             ((IGREATERP START-OF-PIECE OURLIMIT)            (* ; 
                         "We've passed the limit, so it's time to give up.  Just return the LIMITCH#")
              (RETURN OURLIMIT))
             ((fetch (CHARLOOKS CLPROTECTED) of (PLOOKS PC))

              (* ;; "We've found the beginning of a protected region -- i.e., the end of the selectable region.  Tell the caller about it.")

              (RETURN (SUB1 START-OF-PIECE]
          (add START-OF-PIECE (PLEN PC))
          (SETQ PC (NEXTPIECE PC)) finally (RETURN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ])

(\TEDIT.FIND.PROTECTED.START
  [LAMBDA (TEXTOBJ CH# LIMITCH#)                             (* ; "Edited 23-Oct-2022 16:20 by rmk")
                                                             (* ; "Edited  2-Sep-2022 15:26 by rmk")
                                                             (* ; "Edited 22-Aug-2022 13:20 by rmk")
                                                             (* ; "Edited 30-Apr-93 01:39 by jds")

    (* ;; "Starting from a CH# in a selectable region, find the CH# of the earliest contiguously-selectable character preceding that.  This is used to limit selections to unprotected text, and to prevent selection of the protected text between two unprotected areas.")

    (* ;; "Will stop looking when it passes LIMITCH#, or at the beginning of the document.")

    (bind (OURLIMIT _ (OR LIMITCH# 1))
          PC START-OF-PIECE declare (SPECVARS START-OF-PIECE)
       first 
             (* ;; 
             "RMK: Not sure about the double call.  NIL on the first one is the end of the text?")

             (SETQ PC (OR (\CHTOPC CH# TEXTOBJ T)
                          (\CHTOPC (SUB1 START-OF-PIECE)
                                 TEXTOBJ T))) while PC do [COND
                                                             ((ILEQ START-OF-PIECE OURLIMIT)
                                                             (* ; 
          "If he specified a LIMITCH#, and we have passed it, stop bothering and return the LIMITCH#")
                                                              (RETURN OURLIMIT))
                                                             ((fetch (CHARLOOKS CLPROTECTED)
                                                                 of (PLOOKS PC))

                                        (* ;; "We hit a PROTECTED piece of text.  This is the place to stop.  Return the CH# just AFTER the protected text we found.")

                                                              (RETURN (IPLUS START-OF-PIECE
                                                                             (PLEN PC]
                                                          (SETQ PC (PREVPIECE PC))
                                                          (add START-OF-PIECE (IMINUS (PLEN PC])

(\TEDIT.WORD.BOUND
  [LAMBDA (TEXTOBJ PREVCH CH)                                (* ; "Edited 27-Sep-2022 23:54 by rmk")
                                                             (* ; "Edited 25-Sep-2022 23:48 by rmk")
                                                             (* ; "Edited 30-May-91 23:02 by jds")
    (CL:WHEN (AND (FIXP PREVCH)
                  (FIXP CH))
        (LET [(READSA (fetch READSA of (OR (fetch (TEXTOBJ TXTWTBL) of TEXTOBJ)
                                           TEDIT.WORDBOUND.READTABLE]
             (NEQ (\SYNCODE READSA PREVCH)
                  (\SYNCODE READSA CH))))])
)

(RPAQ? TEDIT.EXTEND.PENDING.DELETE T)
(DEFINEQ

(\CREATE.TEDIT.SELECTION
  [LAMBDA NIL
    (create SELECTION])

(\CREATE.TEDIT.SHIFTEDSELECTION
  [LAMBDA NIL
    (create SELECTION
           HASCARET _ NIL])

(\CREATE.TEDIT.MOVESELECTION
  [LAMBDA NIL
    (CREATE SELECTION
           HASCARET _ NIL
           HOWHEIGHT _ 32767])

(\CREATE.TEDIT.DELETESELECTION
  [LAMBDA NIL
    (CREATE SELECTION
           HOW _ BLACKSHADE
           HASCARET _ NIL
           HOWHEIGHT _ 32767])
)



(* ; "Added by yabu.fx, for LOADUP without DWIM.")


(RPAQ TEDIT.SELECTION (\CREATE.TEDIT.SELECTION))

(RPAQ TEDIT.SCRATCHSELECTION (\CREATE.TEDIT.SELECTION))

(RPAQ TEDIT.SHIFTEDSELECTION (\CREATE.TEDIT.SHIFTEDSELECTION))

(RPAQ TEDIT.COPYLOOKSSELECTION (\CREATE.TEDIT.SHIFTEDSELECTION))

(RPAQ TEDIT.MOVESELECTION (\CREATE.TEDIT.MOVESELECTION))

(RPAQ TEDIT.DELETESELECTION (\CREATE.TEDIT.DELETESELECTION))

(RPAQQ TEDIT.SELPENDING NIL)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS TEDIT.SELECTION TEDIT.SCRATCHSELECTION TEDIT.MOVESELECTION TEDIT.SHIFTEDSELECTION 
       TEDIT.COPYLOOKSSELECTION TEDIT.DELETESELECTION TEDIT.SELPENDING TEDIT.EXTEND.PENDING.DELETE)
)



(* ; "Selection manipulating code")

(DEFINEQ

(TEDIT.EXTEND.SEL
  [LAMBDA (X Y OSEL TEXTOBJ SELOPERATION SELWINDOW NEWSEL)   (* ; "Edited 19-Apr-93 13:49 by jds")
                                                             (* ; 
    "Gather a new selected character, and extend OSEL to include it.  Return the extended selection.")
    (PROG ((NSEL (OR NEWSEL (TEDIT.SELECT X Y TEXTOBJ (SELECTQ (fetch (SELECTION SELKIND)
                                                                  of OSEL)
                                                          ((LINE PARA) 
                                                               'LINE)
                                                          ((WORD CHAR) 
                                                               'TEXT)
                                                          'TEXT)
                                   (OR (EQ (fetch (SELECTION SELKIND) of OSEL)
                                           'WORD)
                                       (EQ (fetch (SELECTION SELKIND) of OSEL)
                                           'PARA))
                                   SELOPERATION SELWINDOW T)))
           (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
           (NPOINT NIL)
           (SETOSELFLG NIL)
           (FIXUPNEEDED NIL))
          (COND
             ((ZEROP TEXTLEN)                                (* ; 
                                              "No sense in extending a selection if there's no text!")
              (RETURN NSEL)))
          (COND
             ((AND NSEL (fetch (SELECTION SET) of NSEL))     (* ; 
                                                "If there's no second selection, don't bother trying")
              (\TEDIT.SET.SEL.LOOKS NSEL SELOPERATION)

              (* ;; "Make the new selection be the same kind as the original, as to what it's for -- regular, copy-source, etc.")

              [SETQ NPOINT (COND
                              ((IGEQ (fetch (SELECTION CHLIM) of NSEL)
                                     (fetch (SELECTION CHLIM) of OSEL))
                                                             (* ; 
                               "The new selection ends to the right of the old one.  Move this edge.")
                               'RIGHT)
                              ((ILEQ (fetch (SELECTION CH#) of NSEL)
                                     (fetch (SELECTION CH#) of OSEL))
                                                             (* ; 
                             "If the new selection starts to left of old one, caret goes at the LEFT")
                               'LEFT)
                              ([IGREATERP (IABS (IDIFFERENCE (fetch (SELECTION CHLIM) of NSEL)
                                                       (fetch (SELECTION CHLIM) of OSEL)))
                                      (IABS (IDIFFERENCE (fetch (SELECTION CH#) of NSEL)
                                                   (fetch (SELECTION CH#) of OSEL]
                               (SETQ SETOSELFLG T)
                               'LEFT)
                              (T (SETQ SETOSELFLG T)
                                 'RIGHT]
              [SELECTQ NPOINT
                  (LEFT                                      (* ; 
                                                      "Caret's to the left.  Keep the same right end")
                        [replace (SELECTION CHLIM) of NSEL
                           with (IMAX (fetch (SELECTION CHLIM) of NSEL)
                                      (SELECTQ (fetch (SELECTION POINT) of OSEL)
                                          (LEFT (IPLUS (fetch (SELECTION CH#) of OSEL)
                                                       (fetch (SELECTION DCH) of OSEL)))
                                          (RIGHT (fetch (SELECTION CHLIM) of OSEL))
                                          (SHOULDNT]
                        (replace (SELECTION XLIM) of NSEL with (fetch (SELECTION XLIM) of OSEL))
                        (replace (SELECTION YLIM) of NSEL with (fetch (SELECTION YLIM) of OSEL))
                        (replace (SELECTION LN) of NSEL with (COPY (fetch (SELECTION LN) of OSEL)))
                        (COND
                           ((NEQ SELOPERATION 'COPY)         (* ; 
                       "The old sel is in a protected area.  Only let him extend to the start of it.")
                            [replace (SELECTION CH#) of NSEL
                               with (IMAX (fetch (SELECTION CH#) of NSEL)
                                          (\TEDIT.FIND.PROTECTED.START TEXTOBJ
                                                 (SUB1 (fetch (SELECTION CHLIM) of OSEL))
                                                 (fetch (SELECTION CH#) of NSEL]
                            (SETQ FIXUPNEEDED T)             (* ; 
        "Note that the L1/LN may be invalid as a result of this contraction.  Force a \FIXSEL later.")
                            )))
                  (RIGHT                                     (* ; 
                                                     "Point's to the right;  keep the same left end.")
                         [replace (SELECTION CH#) of NSEL
                            with (IMIN (fetch (SELECTION CH#) of NSEL)
                                       (SELECTQ (fetch (SELECTION POINT) of OSEL)
                                           (LEFT (fetch (SELECTION CH#) of OSEL))
                                           (RIGHT (IDIFFERENCE (fetch (SELECTION CHLIM) of OSEL)
                                                         (fetch (SELECTION DCH) of OSEL)))
                                           (SHOULDNT]
                         (replace (SELECTION X0) of NSEL with (fetch (SELECTION X0) of OSEL))
                         (replace (SELECTION Y0) of NSEL with (fetch (SELECTION Y0) of OSEL))
                         (replace (SELECTION L1) of NSEL with (COPY (fetch (SELECTION L1)
                                                                       of OSEL)))
                         (COND
                            ((NEQ SELOPERATION 'COPY)        (* ; 
                       "The old sel is in a protected area.  Only let him extend to the start of it.")
                             [replace (SELECTION CHLIM) of NSEL
                                with (IMIN (fetch (SELECTION CHLIM) of NSEL)
                                           (ADD1 (\TEDIT.FIND.PROTECTED.END
                                                  TEXTOBJ
                                                  (fetch (SELECTION CH#) of OSEL)
                                                  (ADD1 (\TEDIT.FIND.PROTECTED.END
                                                         TEXTOBJ
                                                         (fetch (SELECTION CH#) of OSEL)
                                                         (SUB1 (fetch (SELECTION CHLIM) of NSEL]
                             (replace (SELECTION CH#) of NSEL with (IMIN (fetch (SELECTION CHLIM)
                                                                            of NSEL)
                                                                         (fetch (SELECTION CH#)
                                                                            of NSEL)))
                             (SETQ FIXUPNEEDED T)            (* ; 
        "Note that the L1/LN may be invalid as a result of this contraction.  Force a \FIXSEL later.")
                             )))
                  (PROGN (replace (SELECTION CHLIM) of NSEL with (fetch (SELECTION CHLIM)
                                                                    of OSEL))
                         (replace (SELECTION XLIM) of NSEL with (fetch (SELECTION XLIM) of OSEL))
                         (replace (SELECTION YLIM) of NSEL with (fetch (SELECTION YLIM) of OSEL))
                         (replace (SELECTION LN) of NSEL with (COPY (fetch (SELECTION LN)
                                                                       of OSEL)))
                         (replace (SELECTION CH#) of NSEL with (fetch (SELECTION CH#) of OSEL))
                         (replace (SELECTION X0) of NSEL with (fetch (SELECTION X0) of OSEL))
                         (replace (SELECTION Y0) of NSEL with (fetch (SELECTION Y0) of OSEL))
                         (replace L1 of NSEL with (COPY (fetch L1 of OSEL)))
                         (SETQ NPOINT (fetch POINT of OSEL]
              (replace DCH of NSEL with (IDIFFERENCE (IMIN (ADD1 TEXTLEN)
                                                           (fetch CHLIM of NSEL))
                                               (fetch CH# of NSEL)))
                                                             (* ; 
                                       "The selection's length cannot exceed that of the whole text.")
              (replace CHLIM of NSEL with (IPLUS (fetch CH# of NSEL)
                                                 (fetch DCH of NSEL)))
                                                             (* ; 
                                                "This assures that the CHLIM corresponds to the DCH.")
              (replace POINT of NSEL with NPOINT)
              (replace (SELECTION DX) of NSEL with (IDIFFERENCE (fetch XLIM of NSEL)
                                                          (fetch X0 of NSEL)))
              (COND
                 ((NEQ (fetch SELOBJ of OSEL)
                       (fetch SELOBJ of NSEL))
                  (replace SELOBJ of NSEL with NIL)))
              (COND
                 (FIXUPNEEDED 

                        (* ;; "We're in a menu, and this selection got contracted because of a protection violation.  Fix up everything.")

                        (\FIXSEL NSEL TEXTOBJ)))
              (COND
                 (SETOSELFLG                                 (* ; 
                              "For whatever reason, it is wise to copy the new sel into the old one.")
                        (\COPYSEL NSEL OSEL))
                 (T                                          (* ; 
                            "Otherwise, set the POINT of the old sel to correspond to the new sel's.")
                                                             (* ; 
                                                             "(replace POINT of OSEL with NPOINT)")
                                                             (* ; 
                 "THIS WAS REMOVED, BECAUSE EXTENDING A POINT-SELECTION WOULD DIE WHEN THIS WAS DONE")
                    ))
              (RETURN NSEL))
             (T                                              (* ; 
                                               "No new selection was made;  just return the old one.")
                (RETURN OSEL])

(TEDIT.SELECT
  [LAMBDA (X Y TEXTOBJ REGION WORDSELFLG SELOPERATION WINDOW EXTENDING)
                                                             (* ; "Edited 24-Oct-2022 15:55 by rmk")
                                                             (* ; "Edited 21-Oct-2022 18:37 by rmk")
                                                             (* ; "Edited  4-Oct-2022 13:18 by rmk")
                                                             (* ; "Edited  1-Oct-2022 15:59 by rmk")
                                                             (* ; "Edited 30-May-91 23:07 by jds")

    (* ;; "Select the character word, line, or paragraph the mouse is pointing at.")

    (PROG ((SEL NIL)
           (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
           PREVLINE L1 LN)
          (SETQ SEL (TEDIT.SELECT.LINE.SCANNER X Y TEXTOBJ (\TEDIT.LINE.LIST TEXTOBJ WINDOW)
                           REGION WORDSELFLG SELOPERATION WINDOW EXTENDING))
          (COND
             ((AND (type? SELECTION SEL)
                   (fetch (SELECTION SET) of SEL))           (* ; 
                                                        "He pointed at something real;  return that.")
              (\TEDIT.SET.SEL.LOOKS SEL SELOPERATION)
              (CL:WHEN [AND (CAR (fetch (SELECTION L1) of SEL))
                            (fetch (FMTSPEC FMTHARDCOPY) of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                               of (CAR (fetch (SELECTION L1)
                                                                          of SEL]
                  (change (fetch (SELECTION X0) of SEL)
                         (HCUNSCALE [fetch (FMTSPEC FMTHARDCOPYSCALE)
                                       of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                             of (CAR (fetch (SELECTION L1) of SEL]
                                DATUM)))
              (CL:WHEN [AND (CAR (fetch (SELECTION LN) of SEL))
                            (fetch (FMTSPEC FMTHARDCOPY) of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                               of (CAR (fetch (SELECTION LN)
                                                                          of SEL]
                  (change (fetch (SELECTION XLIM) of SEL)
                         (HCUNSCALE [fetch (FMTSPEC FMTHARDCOPYSCALE)
                                       of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                             of (CAR (fetch (SELECTION LN) of SEL]
                                DATUM)))
              (replace (SELECTION DX) of SEL with (IDIFFERENCE (fetch (SELECTION XLIM) of SEL)
                                                         (fetch (SELECTION X0) of SEL)))
              (\FIXSEL SEL TEXTOBJ WINDOW T)
              (RETURN SEL))
             ((type? LINEDESCRIPTOR SEL)                     (* ; 
 "He pointed below the bottom of the text.  Select to the right of the last character on the screen.")
              (CL:WHEN (fetch (LINEDESCRIPTOR LHASPROT) of SEL)
                                                             (* ; 
                                                "The last line is protected.  Don't select anything.")
                  (RETURN))
              (SETQ PREVLINE SEL)
              (SETQ SEL (fetch (TEXTOBJ SCRATCHSEL) of TEXTOBJ))
              (replace (SELECTION SET) of SEL with T)
              (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)
              [replace (SELECTION CH#) of SEL with (IMAX 1 (ADD1 (IMIN TEXTLEN (fetch (LINEDESCRIPTOR
                                                                                       CHARLIM)
                                                                                  of PREVLINE]
              (replace (SELECTION CHLIM) of SEL with (fetch (SELECTION CH#) of SEL))
              (replace (SELECTION DCH) of SEL with 0)
              [replace (SELECTION POINT) of SEL with (COND
                                                        ((IGREATERP (fetch (SELECTION CH#)
                                                                       of SEL)
                                                                (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))

                                             (* ;; "Can't select to the right of a character past EOF, only to the left -- which is the right edge of the text.")

                                                         'LEFT)
                                                        (T 'RIGHT]
              (\TEDIT.SET.SEL.LOOKS SEL SELOPERATION)
              (\FIXSEL SEL TEXTOBJ)
              (RETURN SEL])

(TEDIT.SCAN.LINE
  [LAMBDA (TEXTOBJ LINE X Y WORDSELFLG SELOPERATION WINDOW EXTENDING)
                                                             (* ; "Edited 26-Oct-2022 20:36 by rmk")
                                                             (* ; "Edited 22-Oct-2022 22:45 by rmk")
                                                             (* ; "Edited 18-Oct-2022 21:59 by rmk")
                                                             (* ; "Edited 31-May-91 12:26 by jds")

    (* ;; "Given that LINE meets the mouse-Y criterion, find the selection picked out by the mouse X  coordinate.  This may run to the right if the mouse-position is protected.")

    (PROG (SEL CHARSLOT CLOOKS CHNO CHNOB TXB TX SELSLOT SELCHAR SELHERE PASTRIGHT
               (THISLINE (ffetch (TEXTOBJ THISLINE) of TEXTOBJ)))
          (CL:UNLESS (EQ LINE (fetch DESC of THISLINE))      (* ; 
                                                            "Make sure the cache describes this line")
              (SETQ LINE (\FORMATLINE TEXTOBJ NIL (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                LINE)))
          (CL:WHEN (fetch (FMTSPEC FMTHARDCOPY) of (fetch (LINEDESCRIPTOR LFMTSPEC) of LINE))

              (* ;; "Convert display X units to hardcopy scale")

              (SETQ X (HCSCALE (fetch (FMTSPEC FMTHARDCOPYSCALE) of (fetch (LINEDESCRIPTOR LFMTSPEC)
                                                                       of LINE))
                             X)))
          (SETQ TX (ffetch (LINEDESCRIPTOR LEFTMARGIN) of LINE))
          (SETQ X (IMAX X TX))                               (* ; 
                                                     "Move over if the click was in the left margin.")
          (SETQ CHNO (ffetch (LINEDESCRIPTOR CHAR1) of LINE))

     (* ;; "")

     (* ;; "Step 1:  Find the slot, character number, and ending TX for the character at the incoming mouse X position. We'll find the last character  if X is past the last character on the line.")

          (for old CHARSLOT CHARWB incharslots THISLINE do (CL:UNLESS CHAR
                                                               (CL:IF (SMALLP CHARW)
                                                                   (add CHNO CHARW)
                                                                   (SETQ CLOOKS CHARW))
                                                               (GO $$ITERATE))
                                                           (SETQ TXB TX) 
                                                             (* ; "TXB is the end of CHNO-1.")
                                                           (SETQ CHARWB CHARW)
                                                           (add TX CHARW)
                                                           (CL:WHEN (IGEQ TX X)
                                                             (* ; 
                                                       "TXB is the end of the character before CHNO.")
                                                               (RETURN))
                                                           (add CHNO 1)
             finally (SETQ PASTRIGHT T)                      (* ; 
                                                             "Back up to the last non-white-space ")
                   (SETQ TXB (IDIFFERENCE TX CHARWB))
                   (add CHNO -1)
                   (SETQ CHARSLOT (PREVCHARSLOT CHARSLOT))
                   (for old CHARSLOT backcharslots CHARSLOT
                      do (CL:UNLESS CHAR
                             (CL:IF (SMALLP CHARW)
                                 (add CHNO (IMINUS CHARW))
                                 (SETQ CLOOKS CHARW)))
                         (CL:UNLESS (FMEMB CHAR (CHARCODE (SPACE EOL)))
                             (SETQ X TX)
                             (RETURN))
                         (SETQ TX TXB)
                         (add TXB (IMINUS CHARW))
                         (add CHNO -1)))

     (* ;; "CHNO and CHARSLOT:  the character pointed to, CLOOKS the looks of that character")

     (* ;; "TXB the end of CHNO-1, TX the end of CHNO")

     (* ;; "If the click is past the end of the line, it has been moved back to the last character. ")

     (* ;; "")

     (* ;; "Step 2:  If the character at the mouse position is not selectable, try to find one that is.  At start, cursor X is somewhere in character CHNO (maybe at the start).  TX is the end of character CHNO.")

          [if (ffetch (CLSELHERE) of CLOOKS)
              then (SETQ SELHERE CHARSLOT)
            elseif (AND (fetch (CHARLOOKS CLPROTECTED) of CLOOKS)
                        (NEQ SELOPERATION 'COPY))
              then (if PASTRIGHT
                       then 
                            (* ;; "Mouse is off the end. If the last character is a protected (menu) item, look for someting in front of it. Original code looks for unprotected or selhere character, not an image object.")

                            (for old CHARSLOT backcharslots CHARSLOT
                               do (CL:UNLESS CHAR
                                      (CL:WHEN (SMALLP CHARW)
                                          (add CHNO (IMINUS CHARW))
                                          (GO $$ITERATE))
                                      (SETQ CLOOKS CHARW)
                                      (CL:WHEN (AND (ffetch (CHARLOOKS CLPROTECTED) of CLOOKS)
                                                    (NOT (ffetch (CHARLOOKS CLSELHERE) of CLOOKS)))
                                             (GO $$ITERATE))
                                      (SETQ CHARSLOT (NEXTCHARSLOT CHARSLOT))
                                                             (* ; "Following character is selectable")
                                      (add CHNO 1)
                                      (CL:WHEN (type? IMAGEOBJ (CHAR CHARSLOT))
                                                             (* ; "Don't back up to an image object.")
                                          (RETURN))
                                      (if (ffetch (CHARLOOKS CLSELHERE) of CLOOKS)
                                          then (SETQ SELHERE CHARSLOT)
                                               (add TX (CHARW CHARSLOT))
                                               (SETQ TXB TX)
                                        else (SETQ TXB TX)
                                             (add TX (CHARW CHARSLOT)))
                                      (SETQ PASTRIGHT NIL)
                                      (RETURN))
                                  (SETQ TX TXB)
                                  (add TXB (IMINUS CHARW))
                                  (add CHNO -1))
                     else 
                          (* ;; "Search forward for the next selectable slot/chno/TX.")

                          (for old CHARSLOT incharslots (NEXTCHARSLOT CHARSLOT)
                             do (CL:UNLESS CHAR              (* ; 
                                                             "(Guaranteed not NIL the first time)")
                                    (CL:IF (SMALLP CHARW)
                                        (add CHNO CHARW)
                                        (SETQ CLOOKS CHARW))
                                    (GO $$ITERATE))
                                (add CHNO 1)
                                (SETQ TXB TX)
                                (add TX CHARW)
                                (CL:WHEN (fetch (CHARLOOKS CLSELHERE) of CLOOKS)
                                    (SETQ SELHERE CHARSLOT)
                                    (RETURN))
                                (CL:UNLESS (fetch (CHARLOOKS CLPROTECTED) of CLOOKS)
                                    (SETQ TX (IPLUS TXB CHARW))
                                    (RETURN)) finally (SETQ PASTRIGHT T))) 
                                                             (* ; "Nothing selectable to the right")
                   (CL:WHEN PASTRIGHT
                       (RETURN 'DON'T))]
          (SETQ SELSLOT CHARSLOT)
          (SETQ SELCHAR (CHAR CHARSLOT))
          (SETQ CHNOB CHNO)

     (* ;; 
     " CHNO and SELSLOT define a selectable character/object SELCHAR that runs from TXB to TX.    ")

     (* ;; "")

     (* ;; "Step 3, if this is a WORDSELFLG selection.   ")

          (CL:WHEN WORDSELFLG                                (* ; 
                                                  "Back to the start of the word containing SELCHAR.")
              (CL:UNLESS (EQ SELSLOT (FIRSTCHARSLOT THISLINE))
                  (for old CHARSLOT (LASTCHAR _ SELCHAR) backcharslots (PREVCHARSLOT SELSLOT)
                     do (CL:UNLESS CHAR
                            (CL:IF (SMALLP CHARW)
                                (add CHNOB (IMINUS CHARW))
                                (SETQ CLOOKS CHARW))
                            (GO $$ITERATE))
                        (CL:WHEN (OR (type? IMAGEOBJ CHAR)
                                     (\TEDIT.WORD.BOUND TEXTOBJ CHAR LASTCHAR)
                                     (fetch (CHARLOOKS CLPROTECTED) of CLOOKS))
                                                             (* ; "Stop at a protection bounary")
                            (RETURN))
                        (SETQ LASTCHAR CHAR)
                        (ADD TXB (IMINUS CHARW))
                        (ADD CHNOB -1)))

              (* ;; "And search forward for the end of the word")

              (for CHARSLOT (PREVCHAR _ SELCHAR) incharslots (NEXTCHARSLOT SELSLOT)
                 do (CL:UNLESS CHAR
                        (CL:IF (SMALLP CHARW)
                            (add CHNO CHARW)
                            (SETQ CLOOKS CHARW))
                        (GO $$ITERATE))
                    (CL:WHEN (OR (type? IMAGEOBJ CHAR)
                                 (\TEDIT.WORD.BOUND TEXTOBJ PREVCHAR CHAR)
                                 (fetch (CHARLOOKS CLPROTECTED) of CLOOKS))

                        (* ;; "TX is now the end of the last character of the word, at CHNO.")

                        (* ;; "CHNO and TX should be OK if we run off the end.")

                        (RETURN))
                    (add TX CHARW)
                    (add CHNO 1)
                    (SETQ PREVCHAR CHAR)))

     (* ;; "The selection runs from TXB to TX and from CHNOB to CHNO.  In the character case, CHNOB=CHNO and TX-TB is the selection width (DX).")

     (* ;; "If the selected piece is SELHERE (presumably in a menu), the selection is specialized in various ways..")

          (SETQ SEL (fetch (TEXTOBJ SCRATCHSEL) of TEXTOBJ))
          [with SELECTION SEL (SETQ SELTEXTOBJ TEXTOBJ)
                (SETQ SET T)
                (SETQ SELKIND (CL:IF WORDSELFLG
                                  'WORD
                                  'CHAR))
                (SETQ X0 (CL:IF SELHERE
                             TX
                             TXB))
                (SETQ XLIM TX)
                (SETQ DX (IDIFFERENCE TX TXB))
                (SETQ Y0 (fetch (LINEDESCRIPTOR YBOT) of LINE))
                (SETQ YLIM (fetch (LINEDESCRIPTOR YBOT) of LINE))
                (SETQ CH# CHNOB)
                (SETQ CHLIM (ADD1 CHNO))
                (SETQ DCH (CL:IF SELHERE
                              0
                              (IDIFFERENCE (ADD1 CHNO)
                                     CHNOB)))
                (SETQ POINT (if [OR SELHERE (AND (IGEQ (IDIFFERENCE TX TXB)
                                                       3)
                                                 (IGEQ X (FOLDLO (IPLUS TX TXB)
                                                                2))
                                                 (OR T (NOT (AND PASTRIGHT (ffetch (LINEDESCRIPTOR
                                                                                    CR\END)
                                                                              of LINE]
                                then 

                                 (* ;; "To the right of an otherwise-protected insertion, past the middle of a selection that is wide enough to discriminate, and not at the  end of an EOL-terminated line.")

                                     'RIGHT
                              else 'LEFT]
          (CL:WHEN (type? IMAGEOBJ SELCHAR)
              (\TEDIT.SELECT.OBJECT TEXTOBJ SEL SELCHAR LINE X Y TXB WINDOW SELOPERATION
                     (COND
                        (EXTENDING 'RIGHT)
                        (WORDSELFLG 'MIDDLE)
                        (T 'LEFT))
                     EXTENDING))
          (for L1 on (fetch (SELECTION L1) of SEL) as LN on (fetch (SELECTION LN) of SEL)
             as PANE inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) when (EQ PANE WINDOW)
             do (RPLACA L1 LINE)
                (RPLACA LN LINE))
          (RETURN SEL])

(TEDIT.SELECT.LINE.SCANNER
  [LAMBDA (X Y TEXTOBJ LINES REGION WORDSELFLG SELOPERATION WINDOW EXTENDING)
                                                             (* ; "Edited 26-Oct-2022 22:01 by rmk")
                                                             (* ; "Edited 31-May-91 12:26 by jds")
                                                             (* ; 
                                                       "Find the text line the mouse is pointing at.")
    (for (LINE _ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
         SEL PREVLINE PARABOUNDS PARASTART PARAEND PL1 PLN (TEXTLEN _ (fetch (TEXTOBJ TEXTLEN)
                                                                         of TEXTOBJ))
         (WREG _ (DSPCLIPPINGREGION NIL WINDOW)) by (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
       while LINE while (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LINE)
                              (fetch BOTTOM of WREG))
       do

       (* ;; "Search thru the list of (real) displayed lines, looking for the first one whose bottom is below the mouse.  That's the line we're pointing at.")

       (COND
          ((ILEQ (fetch (LINEDESCRIPTOR YBOT) of LINE)
                 Y)                                          (* ; "Found it.")
           (SELECTQ REGION
               ((TEXT WINDOW)                                (* ; 
                         "We're in the regular text area, so scan accross looking for the character.")
                    (SETQ SEL (TEDIT.SCAN.LINE TEXTOBJ LINE X Y WORDSELFLG SELOPERATION WINDOW 
                                     EXTENDING)))
               (LINE                                         (* ; 
                                                    "He is selecting an entire line, or a paragraph.")
                     (SETQ SEL (fetch (TEXTOBJ SCRATCHSEL) of TEXTOBJ))
                     (for TL1 on (fetch (SELECTION L1) of SEL) as TLN
                        on (fetch (SELECTION LN) of SEL) as PANE inside (fetch (TEXTOBJ \WINDOW)
                                                                           of TEXTOBJ)
                        when (EQ PANE WINDOW) do (SETQ PL1 TL1)
                                                 (SETQ PLN TLN)
                                                 (RETURN))
                     (CL:WHEN (AND (fetch (LINEDESCRIPTOR LHASPROT) of LINE)
                                   (NEQ SELOPERATION 'COPY)) (* ; 
                                       "In a TEDIT menu, you can't select a whole paragraph or line.")
                         (replace (SELECTION SET) of SEL with NIL)
                         (RETURN SEL))                       (* ; "The scratch selection")
                     (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)
                                                             (* ; 
                                               "Make sure he knows what document the selection's in.")
                     (replace (SELECTION SET) of SEL with T) (* ; "Mark it valid.")
                     (replace (SELECTION SELOBJ) of SEL with NIL)
                                                             (* ; "Not selecting an object just yet")
                     [COND
                        [WORDSELFLG                          (* ; "Select a paragraph.")
                         (replace (SELECTION SELKIND) of SEL with 'PARA)
                                                             (* ; 
                         "SEARCH FORWARD FROM THE CURRENT LINE TO A LINE WITH A CR OR CHARLIM=EOTEXT")
                         (CL:WHEN (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)

                             (* ;; "If this is a para-formatted document, use the paragraph bounds.  Otherwise, delimit a para by the surrounding CRs.")

                             (SETQ PARABOUNDS (\TEDIT.PARABOUNDS TEXTOBJ (fetch (LINEDESCRIPTOR
                                                                                 CHAR1) of LINE)))
                             (SETQ PARASTART (\TEDIT.FIND.PROTECTED.START TEXTOBJ (fetch (
                                                                                       LINEDESCRIPTOR
                                                                                          CHAR1)
                                                                                     of LINE)
                                                    (CAR PARABOUNDS)))
                             (SETQ PARAEND (\TEDIT.FIND.PROTECTED.END TEXTOBJ (fetch (LINEDESCRIPTOR
                                                                                      CHAR1)
                                                                                 of LINE)
                                                  (CDR PARABOUNDS))))
                         (RPLACA PL1 LINE)
                         (RPLACA PLN LINE)
                         (bind (LL _ LINE) while (AND [COND
                                                         ((fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
                                                          (ILESSP (fetch (LINEDESCRIPTOR CHARLIM)
                                                                     of LL)
                                                                 PARAEND))
                                                         (T (NOT (fetch (LINEDESCRIPTOR CR\END)
                                                                    of LL]
                                                      (ILESSP (fetch (LINEDESCRIPTOR CHARLIM)
                                                                 of LL)
                                                             TEXTLEN))
                            do                               (* ; 
                           "Walk forward thru the lines, looking for the last line in the paragraph.")
                               [COND
                                  ((fetch (LINEDESCRIPTOR NEXTLINE) of LL)
                                   (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)))
                                  (T [replace (LINEDESCRIPTOR NEXTLINE) of LL
                                        with (\FORMATLINE TEXTOBJ NIL (ADD1 (fetch (LINEDESCRIPTOR
                                                                                    CHARLIM)
                                                                               of LL]
                                     (replace (LINEDESCRIPTOR PREVLINE) of (fetch (LINEDESCRIPTOR
                                                                                   NEXTLINE)
                                                                              of LL) with LL)
                                     (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL]
                            finally (RPLACA PLN LL))         (* ; 
         "Search back to a line with CR or beginning-of-text, if we aren't already on the first line")
                         (CL:WHEN (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                         1)
                             [bind (LL _ LINE)
                                while [AND (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LL)
                                                  1)
                                           (COND
                                              ((fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
                                               (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LL)
                                                      PARASTART))
                                              (T (NOT (fetch (LINEDESCRIPTOR CR\END)
                                                         of (fetch (LINEDESCRIPTOR PREVLINE)
                                                               of LL]
                                do 
                                   (* ;; "Back up until we find the first line of the paragraph, or we hit the dummy top line (which claims to end in CR.)")

                                   (SETQ LL (fetch (LINEDESCRIPTOR PREVLINE) of LL))
                                finally (RPLACA PL1
                                               (COND
                                                  ((AND (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
                                                        (IEQP (fetch (LINEDESCRIPTOR CHAR1)
                                                                 of LL)
                                                              PARASTART))
                                                             (* ; "We found a true start of para.")
                                                   LL)
                                                  ([AND (fetch (LINEDESCRIPTOR PREVLINE) of LL)
                                                        (NOT (ZEROP (fetch (LINEDESCRIPTOR CHARLIM)
                                                                       of (fetch (LINEDESCRIPTOR
                                                                                  PREVLINE)
                                                                             of LL]
                                                             (* ; 
                                            "We hit the first line in the paragraph, fair and square")
                                                   LL)
                                                  ((IEQP 1 (fetch (LINEDESCRIPTOR CHAR1) of LL))
                                                             (* ; "We hit the front of the document.")
                                                   LL)
                                                  (T (\BACKFORMAT LINES TEXTOBJ (fetch PTOP
                                                                                   of WREG))
                                                     (fetch (LINEDESCRIPTOR NEXTLINE) of LINES])
                         (with SELECTION SEL [SETQ CH# (OR PARASTART (fetch (LINEDESCRIPTOR CHAR1)
                                                                        of (CAR PL1]
                               [SETQ CHLIM (ADD1 (OR PARAEND (fetch (LINEDESCRIPTOR CHARLIM)
                                                                of (CAR PLN]
                               [SETQ POINT (COND
                                              ((ILEQ (IDIFFERENCE (fetch (LINEDESCRIPTOR CHAR1)
                                                                     of LINE)
                                                            (fetch (SELECTION CH#) of SEL))
                                                     (IDIFFERENCE (fetch (SELECTION CHLIM)
                                                                     of SEL)
                                                            (fetch (LINEDESCRIPTOR CHARLIM)
                                                               of LINE)))
                                               'LEFT)
                                              (T 'RIGHT]
                               (SETQ DCH (IDIFFERENCE CHLIM CH#)))
                         (COND
                            ((fetch (LINEDESCRIPTOR LHASPROT) of LINE)
                                                             (* ; 
  "We have cause to suspect there may be protected text around this para.  Fix the sel the hard way.")
                             (\FIXSEL SEL TEXTOBJ))
                            (T                               (* ; 
                                                 "No protected text is evident.  DO it the easy way.")
                               (with SELECTION SEL (SETQ Y0 (fetch (LINEDESCRIPTOR YBOT)
                                                               of (CAR PL1)))
                                     (SETQ YLIM (fetch (LINEDESCRIPTOR YBOT) of (CAR PLN)))
                                     (SETQ X0 (fetch (LINEDESCRIPTOR LEFTMARGIN) of (CAR PL1)))
                                     (SETQ XLIM (fetch (LINEDESCRIPTOR LXLIM) of (CAR PLN)))
                                     (SETQ DX (IPLUS 1 (IDIFFERENCE XLIM X0]
                        (T                                   (* ; 
                                                             "Select the line we're pointing at.")
                           (RPLACA PL1 LINE)
                           (RPLACA PLN LINE)
                           (with SELECTION SEL (SETQ SELKIND 'LINE)
                                 (SETQ CH# (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                 (SETQ CHLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINE)))
                                 (SETQ DX (IDIFFERENCE (fetch (LINEDESCRIPTOR LXLIM) of LINE)
                                                 (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE)))
                                 (SETQ X0 (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE))
                                 (SETQ XLIM (fetch (LINEDESCRIPTOR LXLIM) of LINE))
                                 (SETQ Y0 (fetch (LINEDESCRIPTOR YBOT) of LINE))
                                 (SETQ YLIM (fetch (LINEDESCRIPTOR YBOT) of LINE))
                                 (SETQ DCH (IDIFFERENCE CHLIM CH#))
                                 (SETQ POINT 'LEFT)
                                 (SETQ SET T])
               (SHOULDNT "Unknown text/line-bar region?"))
           (RETURN SEL)))
       (SETQ PREVLINE LINE])

(\TEDIT.SELECT.OBJECT
  [LAMBDA (TEXTOBJ SEL OBJ LINE X Y TXB SELWINDOW SELOPERATION WHERE)
                                                             (* ; "Edited 16-Oct-2022 21:42 by rmk")
                                                             (* ; "Edited 12-Oct-2022 11:28 by rmk")
                                                             (* ; "Edited 29-Mar-94 13:28 by jds")

    (* ;; "We have moved over an object, call in the selection function!")

    (replace (SELECTION SELOBJ) of SEL with OBJ)
    (replace (SELECTION X0) of SEL with TXB)
    (replace (SELECTION Y0) of SEL with (fetch (LINEDESCRIPTOR YBOT) of LINE))
    (PROG ([OBJBOX (OR (IMAGEOBJPROP OBJ 'BOUNDBOX)
                       (IMAGEBOX OBJ SELWINDOW 'DISPLAY]
           (DS (WINDOWPROP SELWINDOW 'DSP))
           SELRES)
          (RESETLST
              (RESETSAVE (DSPXOFFSET (IDIFFERENCE (IPLUS TXB (DSPXOFFSET NIL DS))
                                            (fetch XKERN of OBJBOX))
                                DS)
                     (LIST (FUNCTION DSPXOFFSET)
                           (DSPXOFFSET NIL DS)
                           DS))
              (RESETSAVE (DSPYOFFSET (IDIFFERENCE (IPLUS (fetch (LINEDESCRIPTOR YBASE) of LINE)
                                                         (DSPYOFFSET NIL DS))
                                            (fetch YDESC of OBJBOX))
                                DS)
                     (LIST (FUNCTION DSPYOFFSET)
                           (DSPYOFFSET NIL DS)
                           DS))
              (RESETSAVE (DSPCLIPPINGREGION (create REGION
                                                   LEFT _ 0
                                                   BOTTOM _ 0
                                                   WIDTH _ (IMIN (fetch XSIZE of OBJBOX)
                                                                 (IDIFFERENCE (fetch (TEXTOBJ WRIGHT)
                                                                                 of TEXTOBJ)
                                                                        TXB))
                                                   HEIGHT _ (fetch YSIZE of OBJBOX))
                                DS)
                     (LIST (FUNCTION DSPCLIPPINGREGION)
                           (DSPCLIPPINGREGION NIL DS)
                           DS))                              (* ; 
                                                             "Go tell him he's being pointed at.")
              (SETQ SELRES (ERSETQ (APPLY* (IMAGEOBJPROP OBJ 'BUTTONEVENTINFN)
                                          OBJ DS SEL (IDIFFERENCE X TXB)
                                          (IDIFFERENCE Y (fetch (LINEDESCRIPTOR YBASE) of LINE))
                                          SELWINDOW
                                          (fetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
                                          WHERE SELOPERATION))))
          (CL:UNLESS (LISTP SELRES)                          (* ; 
                                                   "If the event fn returns NIL, do nothing untoward")
              [COND
                 ((NULL (CAR SELRES))                        (* ; 
                               "If it returns something with a CAR of NIL, then UN-SET the selection")
                  (replace (SELECTION SELOBJ) of SEL with NIL))
                 (T (CL:WHEN (EQMEMB 'DON'T (CAR SELRES))    (* ; 
                            "The object declines to be selected.  Don't permit the select to happen.")
                        (replace (SELECTION SET) of SEL with NIL))
                    (CL:WHEN (EQMEMB 'CHANGED (CAR SELRES))  (* ; 
                                                      "If the object has changed, update the screen.")
                        (TEDIT.OBJECT.CHANGED TEXTOBJ (fetch (SELECTION SELOBJ) of SEL)))])])
)
(DEFINEQ

(\FIXSEL
  [LAMBDA (SEL TEXTOBJ THISWINDOW AVOIDINGTHISW)             (* ; "Edited  7-Oct-2022 23:22 by rmk")
                                                             (* ; "Edited  5-Oct-2022 16:13 by rmk")
                                                             (* ; "Edited  1-Oct-2022 15:59 by rmk")
                                                             (* ; "Edited 25-Sep-2022 18:43 by rmk")
                                                             (* ; "Edited 18-Sep-2022 23:42 by rmk")
                                                             (* ; "Edited 31-May-91 12:26 by jds")

    (* ;; "Given that the selection SEL contains the correct CH# and CHLIM, reset the Y0 X0, DX, and XLIM values.")

    (PROG* [(CH# (fetch (SELECTION CH#) of SEL))
            (CHLIM (fetch (SELECTION CHLIM) of SEL))
            (THISLINE (fetch (TEXTOBJ THISLINE) of TEXTOBJ))
            (WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
            (THISW (OR THISWINDOW (\TEDIT.MAINW TEXTOBJ)))
            (WREG (AND THISW (DSPCLIPPINGREGION NIL THISW]
           (CL:UNLESS (OR WINDOW THISW)                      (* ; "No window for this edit")
               (RETURN))
           (CL:UNLESS (AND AVOIDINGTHISW (fetch (SELECTION Y0) of SEL))
               (replace (SELECTION Y0) of SEL with (fetch PTOP of WREG)))
           (CL:UNLESS (AND AVOIDINGTHISW)
               (fetch (SELECTION YLIM) of SEL)
               (replace (SELECTION YLIM) of SEL with -1))
           (CL:UNLESS (fetch (SELECTION XLIM) of SEL)
               (replace (SELECTION XLIM) of SEL with -1))
           (CL:UNLESS (fetch (SELECTION SET) of SEL)
                  (RETURN))

     (* ;; "Selection L1 and L2 are lists of lines, one for each window that the selection appears in. The running (CAR L1) is the line for the current window")

           (for WW STARTFOUND inside WINDOW as L1 on (fetch (SELECTION L1) of SEL) as LN
              on (fetch (SELECTION LN) of SEL) as LINES inside (fetch (TEXTOBJ LINES) of TEXTOBJ)
              unless (AND THISWINDOW (EQ AVOIDINGTHISW (EQ THISWINDOW WW)))
              do                                             (* ; 
                                                             "Only if a 'real' SELECTION proceed")
                 (RPLACA L1 NIL)
                 (RPLACA LN NIL)
                 [for (LINE _ (fetch (LINEDESCRIPTOR NEXTLINE) of LINES))
                      TX by (fetch (LINEDESCRIPTOR NEXTLINE) of LINE) while LINE
                    do (COND
                          [(AND (IGEQ CH# (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                (ILEQ CH# (fetch (LINEDESCRIPTOR CHARLIM) of LINE)))
                                                             (* ; 
                                            "The selection starts in this line.  Fix L1, X0, and Y0.")
                           (SETQ STARTFOUND T)
                           (replace (SELECTION Y0) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                  of LINE))
                                                             (* ; 
                                                         "Remember that this is a hardcopy-mode line")
                           (RPLACA L1 LINE)
                           (SETQ TX (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE))
                                                             (* ; 
                                 "Temp.  X value for scanning the line from left margin to the right")
                           (replace (SELECTION X0) of SEL with (fetch (LINEDESCRIPTOR LEFTMARGIN)
                                                                  of LINE))
                           (CL:WHEN (IGREATERP CH# (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                                             (* ; 
              "Only bother formatting the line if the selection doesn't include the first character.")
                               (CL:UNLESS (EQ (fetch DESC of THISLINE)
                                              LINE)          (* ; 
                                                "If this line isn't cached in THISLINE, reformat it.")
                                   (SETQ LINE (\FORMATLINE TEXTOBJ NIL (fetch (LINEDESCRIPTOR CHAR1)
                                                                          of LINE)
                                                     LINE)))

                               (* ;; 
                      "Determine the CHARNO and x-location of the first selected character in LINE  ")

                               [for CHARSLOT (CHNO _ (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                  incharslots THISLINE until (IGEQ CHNO CH#)
                                  do 
                                     (* ;; 
                                     "Update our running X-position in the SEL. We skip look-slots")

                                     (if CHAR
                                         then (add CHNO 1)
                                              (add TX CHARW)
                                              (freplace (SELECTION X0) of SEL with TX)
                                       elseif (SMALLP CHARW)
                                         then (add CHNO (IMINUS CHARW])]
                          ((AND (IEQP CH# (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINE)))
                                (IGREATERP CH# (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))

                           (* ;; 
 "The selection starts after the end of this line, but it's also the end of the text.  Select there.")

                           (CL:UNLESS (EQ (fetch DESC of THISLINE)
                                          LINE)              (* ; 
                                                "If this line isn't cached in THISLINE, reformat it.")
                               (\FORMATLINE TEXTOBJ NIL (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                      LINE))
                           (replace (SELECTION Y0) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                  of LINE))
                           (RPLACA L1 LINE)                  (* ; 
                                                       "Make this line be the first in the selection")
                           (replace (SELECTION X0) of SEL with (fetch (LINEDESCRIPTOR LXLIM)
                                                                  of LINE)))
                          ((AND (NOT STARTFOUND)
                                (IGREATERP (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                       CH#)
                                (ILESSP (fetch (LINEDESCRIPTOR CHAR1) of LINE)
                                       CHLIM))               (* ; 
                                            "The selection starts before this line, so play catch-up")
                           (replace (SELECTION Y0) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                  of LINE))
                           (RPLACA L1 LINE)                  (* ; 
                                                "Grab this line and make it the apparent first line.")
                           (replace (SELECTION X0) of SEL with (fetch (LINEDESCRIPTOR LEFTMARGIN)
                                                                  of LINE))
                           (SETQ STARTFOUND T)))
                       (CL:WHEN [AND (ILEQ CH# (fetch (LINEDESCRIPTOR CHARLIM) of LINE))
                                     (IGEQ CHLIM (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                     (ILEQ CHLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINE]
                                                             (* ; 
                                          "The selection ends in this line.  Fix LN, XLIM, and YLIM.")

                           (* ;; "NB that it also has to START before the end of this line.  This eliminates the case of a 0-wide selection right after the last char on this line.")

                           (replace (SELECTION YLIM) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                    of LINE))
                                                             (* ; 
                                                           "Set the lowest-Y value for the selection")
                           (RPLACA LN LINE)                  (* ; "Remember the final line")
                           (SETQ TX (fetch (LINEDESCRIPTOR LEFTMARGIN) of LINE))
                                                             (* ; "Temp X position")
                           (replace (SELECTION XLIM) of SEL with (fetch (LINEDESCRIPTOR LXLIM)
                                                                    of LINE))
                                                             (* ; 
                           "Start by assuming that the selection extends all the way across the line")
                           [COND
                              [(AND (IEQP CHLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM) of LINE)))
                                    (EQ (fetch (SELECTION POINT) of SEL)
                                        'RIGHT)
                                    (IEQP (fetch (SELECTION DCH) of SEL)
                                          0)
                                    (fetch (LINEDESCRIPTOR NEXTLINE) of LINE)
                                    (fetch (LINEDESCRIPTOR CR\END) of LINE))
                                                             (* ; 
                              "This selection starts AFTER the CR on a line, and doesn't include it.")
                               (RPLACA LN (fetch (LINEDESCRIPTOR NEXTLINE) of LINE))
                                                             (* ; 
                            "Change the selection to start on the next line, at the margin, instead.")
                               (replace (SELECTION XLIM) of SEL with (fetch (LINEDESCRIPTOR 
                                                                                   LEFTMARGIN)
                                                                        of (CAR LN)))
                               (replace (SELECTION YLIM) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                        of (CAR LN]
                              ((ILEQ CHLIM (IMIN (fetch (LINEDESCRIPTOR CHARLIM) of LINE)
                                                 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
                                                             (* ; 
                  "Only bother formatting if the selection doesn't include the last char on the line")
                               (CL:UNLESS (EQ (fetch DESC of THISLINE)
                                              LINE)          (* ; 
                                           "If this line isn't cached in THISLINE, then reformat it.")
                                   (\FORMATLINE TEXTOBJ NIL (fetch (LINEDESCRIPTOR CHAR1)
                                                               of LINE)
                                          LINE))
                               (for CHARSLOT (CHNO _ (fetch (LINEDESCRIPTOR CHAR1) of LINE))
                                  incharslots THISLINE until (IGEQ CHNO CHLIM)
                                  do (if CHAR
                                         then                (* ; 
                                                "Not yet;  update our running X-position in the SEL.")
                                              (add CHNO 1)
                                              (add TX CHARW)
                                              (replace (SELECTION XLIM) of SEL with TX)
                                       elseif (SMALLP CHARW)
                                         then (add CHNO (IMINUS CHARW]
                           (RETURN)                          (* ; 
                                     "And stop looking for an ending line--we've obviously found it!")
                           (CL:WHEN (AND (IEQP CHLIM (ADD1 (fetch (LINEDESCRIPTOR CHARLIM)
                                                              of LINE)))
                                         (ILEQ CH# (fetch (LINEDESCRIPTOR CHARLIM) of LINE)))
                                                             (* ; 
                                   "The selection ends either here or at the start of the next line.")
                                                             (* ; 
                                                    "Something else on this line is really selected.")
                               (replace (SELECTION YLIM) of SEL with (fetch (LINEDESCRIPTOR YBOT)
                                                                        of LINE))
                               (RPLACA LN LINE)
                               (replace (SELECTION XLIM) of SEL with (fetch (LINEDESCRIPTOR LXLIM)
                                                                        of LINE))))]
                 (\FIXSEL.HCUNSCALE (CAR L1)
                        X0)                                  (* ; "Scale for hardcopy-display mode")
                 (\FIXSEL.HCUNSCALE (CAR LN)
                        XLIM)
                 (COND
                    [(IEQP 0 (fetch (SELECTION DCH) of SEL)) (* ; 
             "If this is a point selection, put it on the correct side of the character we selected.")
                     (replace (SELECTION DX) of SEL with 0)
                     (COND
                        ((EQ (fetch (SELECTION POINT) of SEL)
                             'LEFT)
                         (replace (SELECTION XLIM) of SEL with (fetch (SELECTION X0) of SEL)))
                        (T (replace (SELECTION X0) of SEL with (fetch (SELECTION XLIM) of SEL]
                    (T                                       (* ; 
                                                             "Otherwise, fix DX for the selection")
                       (replace (SELECTION DX) of SEL with (IDIFFERENCE (fetch (SELECTION XLIM)
                                                                           of SEL)
                                                                  (fetch (SELECTION X0) of SEL])

(\TEDIT.FIXDELSEL
  [LAMBDA (SELTOFIX TEXTOBJ CH#1 CH#LIM DCH)                 (* ; "Edited 23-Oct-2022 09:47 by rmk")
                                                             (* ; "Edited 21-Oct-2022 18:38 by rmk")
                                                             (* ; "Edited 30-May-91 23:00 by jds")

    (* ;; "Fix up a SELTOFIX after deletion inside that textobj")
                                                             (* ; 
                                               "Only if the Selection is set, and is in THIS textobj")
    (CL:WHEN (AND (fetch (SELECTION SET) of SELTOFIX)
                  (EQ TEXTOBJ (fetch (SELECTION SELTEXTOBJ) of SELTOFIX)))
        [COND
           ((IGEQ (fetch (SELECTION CH#) of SELTOFIX)
                  CH#LIM)                                    (* ; 
                                     "The selection is after the deleted text.  Just move it forward")
            (replace (SELECTION CH#) of SELTOFIX with (IDIFFERENCE (fetch (SELECTION CH#)
                                                                      of SELTOFIX)
                                                             DCH))
            (replace (SELECTION CHLIM) of SELTOFIX with (IDIFFERENCE (fetch (SELECTION CHLIM)
                                                                        of SELTOFIX)
                                                               DCH)))
           ((IGREATERP (fetch (SELECTION CHLIM) of SELTOFIX)
                   CH#1)                                     (* ; "It overlaps, at least partially.")
            (CL:WHEN (IGEQ (fetch (SELECTION CH#) of SELTOFIX)
                           CH#1)

                (* ;; "If the start of the selection was inside the deleted area, it now starts where the deletion left off.")

                (replace (SELECTION CH#) of SELTOFIX with CH#1))
            (replace (SELECTION CHLIM) of SELTOFIX with (IMAX CH#1 (IDIFFERENCE (fetch (SELECTION
                                                                                        CHLIM)
                                                                                   of SELTOFIX)
                                                                          DCH)))
            (replace (SELECTION DCH) of SELTOFIX with (CL:IF (IEQP (fetch (SELECTION CHLIM)
                                                                      of SELTOFIX)
                                                                   CH#1)
                                                          0
                                                          (IDIFFERENCE (fetch (SELECTION CHLIM)
                                                                          of SELTOFIX)
                                                                 (fetch (SELECTION CH#) of SELTOFIX)))
                   ])])

(\TEDIT.FIXINSSEL
  [LAMBDA (SELTOFIX TEXTOBJ CH#1 DCH)                        (* ; "Edited 21-Oct-2022 18:38 by rmk")
                                                             (* ; "Edited 23-Aug-2022 11:50 by rmk")
                                                             (* ; "Edited 30-May-91 23:00 by jds")

    (* ;; "Fix up a SELTOFIX after deletion inside that textobj, only if the Selection is set, and is in THIS textobj")

    (LET (CH# CHLIM)
         (CL:WHEN (AND (fetch (SELECTION SET) of SELTOFIX)
                       (EQ TEXTOBJ (fetch (SELECTION SELTEXTOBJ) of SELTOFIX)))
             (SETQ CH# (ffetch (SELECTION CH#) of SELTOFIX))
             (SETQ CHLIM (ffetch (SELECTION CHLIM) of SELTOFIX))
             (CL:WHEN (IGEQ CH# CH#1)                        (* ; 
                "Fix up the selection;  if we're beyond the insert point, move the whole sel forward")
                 (freplace (SELECTION CH#) of SELTOFIX with (IPLUS CH# DCH)))
             (CL:WHEN (IGREATERP CHLIM CH#1)                 (* ; "And the tail end of the sel, too.")
                 (freplace (SELECTION CHLIM) of SELTOFIX with (IPLUS CHLIM DCH))))])

(\TEDIT.FIXSELS
  [LAMBDA (TEXTOBJ EXCEPT)                                   (* ; "Edited 30-May-91 23:03 by jds")
                                                             (* Fixes all the sels for a given 
                                                             textobj.)
    (for SELN in (LIST (fetch (TEXTOBJ SEL) of TEXTOBJ)
                       (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                       (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                       (fetch (TEXTOBJ DELETESEL) of TEXTOBJ)) when (NEQ SELN EXCEPT)
       do (AND (fetch (SELECTION SET) of SELN)
               (\FIXSEL SELN TEXTOBJ])
)
(DEFINEQ

(TEDIT.RESET.EXTEND.PENDING.DELETE
  [LAMBDA (SEL)                                              (* ; "Edited 21-Oct-2022 18:41 by rmk")
                                                             (* ; "Edited 30-May-91 23:03 by jds")

    (* ;; "Reset the 'Extend Pending Delete' status")

    (AND SEL (\TEDIT.SET.SEL.LOOKS SEL 'NORMAL))
    (SETQ TEDIT.PENDINGDEL NIL)
    (CL:WHEN (fetch (SELECTION SELTEXTOBJ) of SEL)
        (replace (TEXTOBJ BLUEPENDINGDELETE) of (fetch (SELECTION SELTEXTOBJ) of SEL) with NIL))])

(\TEDIT.SET.SEL.LOOKS
  [LAMBDA (SEL OPERATION)                                    (* ; "Edited 30-May-91 23:00 by jds")
                                                             (* Set what the selection should be 
                                                             displayed like, given what it's for
                                                             (NORMAL, COPY, MOVE, etc.))
    (SELECTQ OPERATION
        (NORMAL                                              (* Regular selection)
                (replace (SELECTION HOW) of SEL with BLACKSHADE)
                (replace (SELECTION HOWHEIGHT) of SEL with 1)
                (replace (SELECTION HASCARET) of SEL with T))
        (COPY                                                (* Copy source)
              (replace (SELECTION HOW) of SEL with COPYSELSHADE)
              (replace (SELECTION HOWHEIGHT) of SEL with 1)
              (replace (SELECTION HASCARET) of SEL with NIL))
        (COPYLOOKS                                           (* copylooks source)
                   (replace (SELECTION HOW) of SEL with COPYLOOKSSELSHADE)
                   (replace (SELECTION HOWHEIGHT) of SEL with 2)
                   (replace (SELECTION HASCARET) of SEL with NIL))
        (MOVE                                                (* Copy source)
              (replace (SELECTION HOW) of SEL with EDITMOVESHADE)
              (replace (SELECTION HOWHEIGHT) of SEL with 16384)
              (replace (SELECTION HASCARET) of SEL with NIL))
        (DELETE                                              (* To be deleted instantly)
                (replace (SELECTION HOW) of SEL with BLACKSHADE)
                (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                (replace (SELECTION HASCARET) of SEL with NIL)
                NIL)
        (PENDINGDEL                                          (* Delete at next type-in)
                    (replace (SELECTION HOW) of SEL with BLACKSHADE)
                    (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                    (replace (SELECTION HASCARET) of SEL with T)
                    NIL)
        (INVERTED                                            (* For people who really want to see 
                                                             what's selected.)
                  (replace (SELECTION HOW) of SEL with BLACKSHADE)
                  (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                  (replace (SELECTION HASCARET) of SEL with T)
                  NIL)
        NIL])
)
(DEFINEQ

(\SHOWSEL
  [LAMBDA (SEL HOW ON)                                       (* ; "Edited 21-Oct-2022 18:41 by rmk")
                                                             (* ; "Edited  5-Oct-2022 16:03 by rmk")
                                                             (* ; "Edited 22-May-92 16:11 by jds")

    (* ;; "Highlight the selection SEL, according to HOW, turning it on or off according to ON")

    (PROG ((TEXTOBJ (fetch (SELECTION SELTEXTOBJ) of SEL))
           (SHADE (OR (fetch (SELECTION HOW) of SEL)
                      BLACKSHADE))
           (SHADEHEIGHT (OR (fetch (SELECTION HOWHEIGHT) of SEL)
                            1)))

     (* ;; "This operation only makes sense if there is a set selection and a window to highlighting, and we are allowed to update.")

          (CL:UNLESS (AND (fetch (SELECTION SET) of SEL)
                          (fetch (TEXTOBJ \WINDOW) of (fetch (SELECTION SELTEXTOBJ) of SEL))
                          (NOT (fetch (TEXTOBJ TXTDON'TUPDATE) of TEXTOBJ)))
                 (RETURN))
          [for DS inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as LINES
             inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as L1 in (fetch (SELECTION L1) of SEL)
             as LN in (fetch (SELECTION LN) of SEL) as CARET inside (fetch (TEXTOBJ CARET)
                                                                       of TEXTOBJ)
             do (CL:WHEN (fetch (SELECTION SELOBJ) of SEL)   (* ; "Hand off to the object")
                    (\TEDIT.OBJECT.SHOWSEL TEXTOBJ SEL ON DS)
                    (RETURN))
                (COND
                   [(AND ON (NOT (fetch (SELECTION ONFLG) of SEL)))
                                                             (* ; 
                                                             "It's off and we want to turn it on")
                    (\SHOWSEL.HILIGHT TEXTOBJ SEL LINES L1 LN DS SHADEHEIGHT SHADE)
                    (COND
                       [(AND (fetch (SELECTION HASCARET) of SEL)
                             (ffetch (TEXTOBJ TXTEDITING) of TEXTOBJ))

                        (* ;; 
      "If the selection has a caret, turn one on. But only if the document is actively being edited.")

                        (COND
                           [(EQ (fetch (SELECTION POINT) of SEL)
                                'LEFT)                       (* ; "At the LEFT end of the selection")
                            (COND
                               ((AND L1 (IGEQ (fetch (LINEDESCRIPTOR YBOT) of L1)
                                              0))
                                (\SETCARET (fetch (SELECTION X0) of SEL)
                                       (fetch (LINEDESCRIPTOR YBASE) of L1)
                                       DS TEXTOBJ CARET))
                               (T (MOVETO -10 -10 DS]
                           ((AND LN (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LN)
                                          0))                (* ; "Or at the RIGHT end.")
                            (\SETCARET (fetch (SELECTION XLIM) of SEL)
                                   (fetch (LINEDESCRIPTOR YBASE) of LN)
                                   DS TEXTOBJ CARET))
                           (T                                (* ; 
             "Neither end is on screen.  For self-caret flashers, move the caret location off-screen")
                              (MOVETO -10 -10 DS]
                       (T (SELECTQ (fetch (SELECTION POINT) of SEL)
                              (LEFT (AND L1 (MOVETO (fetch (SELECTION X0) of SEL)
                                                   (fetch (LINEDESCRIPTOR YBASE) of L1)
                                                   DS)))
                              (RIGHT (AND LN (MOVETO (fetch (SELECTION XLIM) of SEL)
                                                    (fetch (LINEDESCRIPTOR YBASE) of LN)
                                                    DS)))
                              NIL]
                   ((AND (NOT ON)
                         (fetch (SELECTION ONFLG) of SEL))   (* ; 
                                                         "Turn off a currently highlighted selection")
                    (COND
                       ((AND (fetch (SELECTION HASCARET) of SEL)
                             (NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ))
                             (ffetch (TEXTOBJ TXTEDITING) of TEXTOBJ))

                        (* ;; 
               "If the selection has a caret, make sure it's turned off, and pick it off the screen.")

                        (\EDIT.UPCARET CARET)))
                    (\SHOWSEL.HILIGHT TEXTOBJ SEL LINES L1 LN DS SHADEHEIGHT SHADE]
          (replace (SELECTION ONFLG) of SEL with ON])

(\SHOWSEL.HILIGHT
  [LAMBDA (TEXTOBJ SEL LINES L1 LN DS SHADEHEIGHT SHADE X0 XLIM)
                                                             (* ; "Edited 11-Oct-2022 20:55 by rmk")
                                                             (* ; "Edited  5-Oct-2022 16:12 by rmk")
                                                             (* ; "Edited  4-Oct-2022 13:12 by rmk")
                                                             (* ; "Edited  1-Oct-2022 16:11 by rmk")
                                                             (* ; "Edited 30-May-91 23:07 by jds")

(* ;;; "Do the actual highlighting and unhighlighting of a selection for \SHOWSEL")

    (PROG (LL LEFT RIGHT)
          (CL:WHEN (OR L1 LN)                                (* ; 
                  "One end or the other is on-screen, so it makes sense to try displaying something.")
              [COND
                 ((AND L1 (EQ L1 LN)
                       (IGEQ (fetch (LINEDESCRIPTOR YBOT) of L1)
                             0))                             (* ; 
                           "It's all in a single line;  just underline the right section and beat it")
                  (BITBLT NIL 0 0 DS (OR X0 (fetch (SELECTION X0) of SEL))
                         (fetch (LINEDESCRIPTOR YBOT) of L1)
                         (IDIFFERENCE (OR XLIM (fetch (SELECTION XLIM) of SEL))
                                (OR X0 (fetch (SELECTION X0) of SEL)))
                         (IMIN SHADEHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of L1))
                         'TEXTURE
                         'INVERT SHADE))
                 (T                                          (* ; "Different lines.")
                    (CL:WHEN (AND L1 (IGEQ (fetch (LINEDESCRIPTOR YBOT) of L1)
                                           0))               (* ; 
                                     "If the first line is known, underline the right section of it.")
                        (CL:SETQ RIGHT (\SHOWSEL.HCUNSCALE L1 (fetch (LINEDESCRIPTOR LXLIM)
                                                                 of L1)))
                        (BITBLT NIL 0 0 DS (OR X0 (fetch (SELECTION X0) of SEL))
                               (fetch (LINEDESCRIPTOR YBOT) of L1)
                               (IDIFFERENCE RIGHT (OR X0 (fetch (SELECTION X0) of SEL)))
                               (IMIN SHADEHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of L1))
                               'TEXTURE
                               'INVERT SHADE))
                    (SETQ LL (OR L1 LINES))
                    (AND LL (SETQ LL (fetch (LINEDESCRIPTOR NEXTLINE) of LL)))
                                                             (* ; 
          "The line after the first, or the top line on the screen -- if we didn't have a first line")
                    (for old LL by (fetch (LINEDESCRIPTOR NEXTLINE) of LL) while LL
                       until (OR (EQ LL LN)
                                 (ILESSP (fetch (LINEDESCRIPTOR YBOT) of LL)
                                        (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                       do                                    (* ; 
                                                        "Highlight every line between first and last")
                          (SETQ LEFT (\SHOWSEL.HCUNSCALE LL (fetch (LINEDESCRIPTOR LEFTMARGIN)
                                                               of LL)))
                          (SETQ RIGHT (\SHOWSEL.HCUNSCALE LL (fetch (LINEDESCRIPTOR LXLIM)
                                                                of LL)))
                          (BITBLT NIL 0 0 DS LEFT (fetch (LINEDESCRIPTOR YBOT) of LL)
                                 (IDIFFERENCE RIGHT LEFT)
                                 (IMIN SHADEHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LL))
                                 'TEXTURE
                                 'INVERT SHADE))
                    (CL:WHEN (AND LL (IGEQ (fetch (LINEDESCRIPTOR YBOT) of LL)
                                           (fetch (TEXTOBJ WBOTTOM) of TEXTOBJ)))
                                                             (* ; 
                                                     "The final line is on-screen.  Hilight it, too.")
                        (SETQ LEFT (\SHOWSEL.HCUNSCALE LL (fetch (LINEDESCRIPTOR LEFTMARGIN)
                                                             of LL)))
                        (BITBLT NIL 0 0 DS LEFT (fetch (LINEDESCRIPTOR YBOT) of LN)
                               (IDIFFERENCE (OR XLIM (fetch (SELECTION XLIM) of SEL))
                                      LEFT)
                               (IMIN SHADEHEIGHT (fetch (LINEDESCRIPTOR LHEIGHT) of LL))
                               'TEXTURE
                               'INVERT SHADE))])])

(\TEDIT.UPDATE.SHOWSEL
  [LAMBDA (NSEL OSEL TSTFLG)                                 (* ; "Edited 21-Oct-2022 18:41 by rmk")
                                                             (* ; "Edited 30-May-91 23:03 by jds")
                                                             (* Update the selection highlighting 
                                                             to reflect the differences between 
                                                             NSEL and OSEL)
    (PROG ((TEXTOBJ (fetch (SELECTION SELTEXTOBJ) of OSEL)))
          (PROG ((SHADE (OR (fetch (SELECTION HOW) of OSEL)
                            BLACKSHADE))
                 (SHADEHEIGHT (OR (fetch (SELECTION HOWHEIGHT) of OSEL)
                                  1))
                 (EXCHFLG NIL)
                 TSEL LL)
                (replace (SELECTION ONFLG) of NSEL with T)   (* Make the new selection think that 
                                                             we've really displayed all its new 
                                                             aspects.)
                [COND
                   ((fetch (SELECTION HASCARET) of OSEL)     (* Turn off the caret, if need be)
                    (for CARET inside (fetch (TEXTOBJ CARET) of TEXTOBJ) do (\EDIT.UPCARET CARET]
                [COND
                   ((NEQ (fetch (SELECTION CH#) of NSEL)
                         (fetch (SELECTION CH#) of OSEL))    (* The new selection starts earlier;
                                                             add hilight at the front)
                    (COND
                       ((ILESSP (fetch (SELECTION CH#) of OSEL)
                               (fetch (SELECTION CH#) of NSEL))
                                                             (* Actually, it starts later;
                                                             just exchange the selections)
                        (swap OSEL NSEL)
                        (SETQ EXCHFLG T)))
                    (for NEWL1 inside (fetch (SELECTION L1) of NSEL) as OLDL1
                       inside (fetch (SELECTION L1) of OSEL) as LINES
                       inside (fetch (TEXTOBJ LINES) of TEXTOBJ) as DS
                       inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
                       do (\SHOWSEL.HILIGHT TEXTOBJ OSEL LINES NEWL1 OLDL1 DS SHADEHEIGHT SHADE
                                 (fetch (SELECTION X0) of NSEL)
                                 (fetch (SELECTION X0) of OSEL]
                (COND
                   (EXCHFLG                                  (* Put the selections back as they 
                                                             were.)
                          (swap OSEL NSEL)
                          (SETQ EXCHFLG NIL)))
                (COND
                   ((ILESSP (fetch (SELECTION CHLIM) of NSEL)
                           (fetch (SELECTION CHLIM) of OSEL))

         (* Arrange for NSEL to be the selection that ends later, so that one set of code 
         will do both earlier AND later cases.)

                    (swap OSEL NSEL)
                    (SETQ EXCHFLG T)))
                (for OLDLN in (fetch (SELECTION LN) of OSEL) as NEWLN
                   in (fetch (SELECTION LN) of NSEL) as LINES inside (fetch (TEXTOBJ LINES)
                                                                        of TEXTOBJ) as OLDL1
                   in (fetch (SELECTION L1) of OSEL) as DS inside (fetch (TEXTOBJ \WINDOW)
                                                                     of TEXTOBJ)
                   do (\SHOWSEL.HILIGHT TEXTOBJ OSEL LINES OLDLN NEWLN DS SHADEHEIGHT SHADE
                             (fetch (SELECTION XLIM) of OSEL)
                             (fetch (SELECTION XLIM) of NSEL)))
                (COND
                   (EXCHFLG                                  (* Put the selections back as they 
                                                             were.)
                          (SETQ TSEL OSEL)
                          (SETQ OSEL NSEL)
                          (SETQ NSEL TSEL)))
                (COND
                   ((fetch (SELECTION HASCARET) of NSEL)     (* Now put the caret back up.)
                    (for L1 in (fetch (SELECTION L1) of NSEL) as LN in (fetch (SELECTION LN)
                                                                          of NSEL) as DS
                       inside (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) as CARET
                       inside (fetch (TEXTOBJ CARET) of TEXTOBJ)
                       do (COND
                             ((EQ (fetch (SELECTION POINT) of NSEL)
                                  'LEFT)                     (* Left end of the selection)
                              (AND L1 (\SETCARET (fetch (SELECTION X0) of NSEL)
                                             (fetch (LINEDESCRIPTOR YBOT) of L1)
                                             DS TEXTOBJ CARET)))
                             (LN                             (* Right end of the selection)
                                 (\SETCARET (fetch (SELECTION XLIM) of NSEL)
                                        (fetch (LINEDESCRIPTOR YBOT) of LN)
                                        DS TEXTOBJ CARET])

(\TEDIT.SHOWSELS
  [LAMBDA (TEXTOBJ HOW ON)                                   (* ; "Edited 30-May-91 23:03 by jds")
                                                             (* Turns all the selections for a 
                                                             given Textobj on or off)
    (for SELN in (LIST (fetch (TEXTOBJ SEL) of TEXTOBJ)
                       (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                       (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                       (fetch (TEXTOBJ DELETESEL) of TEXTOBJ))
       do (AND (fetch (SELECTION SET) of SELN)
               (\SHOWSEL SELN HOW ON])

(\TEDIT.REFRESH.SHOWSEL
  [LAMBDA (TEXTOBJ NEWSEL OLDSEL OLDOP NEWOP EXTENDING)      (* ; "Edited 30-May-91 23:03 by jds")

         (* * Update the screen hilighting to account for the changes that have taken 
         place between OLDSEL and NEWSEL.)

    (DECLARE (USEDFREE . GLOBALSEL))
    (PROG (NOSEL)
          (COND
             ((AND EXTENDING (EQ OLDOP NEWOP))

         (* If we're extending a selection and the looks haven't changed, we can do it the 
         fast way, to prevent flicker.)

              (\TEDIT.UPDATE.SHOWSEL NEWSEL OLDSEL)
              (\COPYSEL NEWSEL OLDSEL)
              (replace (SELECTION ONFLG) of OLDSEL with T))
             (T 

         (* Otherwise, we have to turn the old one off, change things, and turn the new 
         one on.)

                (\SHOWSEL OLDSEL NIL NIL)
                (COND
                   ((NEQ OLDOP NEWOP)

         (* He changed his mind about copying, deleting, or whatever --
         change the kind of selection it is.)

                    (SELECTQ NEWOP
                        ((NORMAL PENDINGDEL) 
                             (SETQ GLOBALSEL TEDIT.SELECTION)
                             (SETQ NOSEL (fetch (TEXTOBJ SEL) of TEXTOBJ)))
                        (COPY (SETQ GLOBALSEL TEDIT.SHIFTEDSELECTION)
                              (SETQ NOSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)))
                        (MOVE (SETQ GLOBALSEL TEDIT.MOVESELECTION)
                              (SETQ NOSEL (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)))
                        (DELETE (SETQ GLOBALSEL TEDIT.DELETESELECTION)
                                (SETQ NOSEL (fetch (TEXTOBJ DELETESEL) of TEXTOBJ)))
                        (COPYLOOKS (SETQ GLOBALSEL TEDIT.COPYLOOKSSELECTION)
                                   (SETQ NOSEL (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)))
                        NIL)                                 (* Remember the new operation type.)
                    (replace (SELECTION SET) of OLDSEL with NIL)
                                                             (* Turn off the old kind of selection, 
                                                             so it doesn't reappear to haunt us.)
                    (AND (fetch (SELECTION SET) of NOSEL)
                         (\SHOWSEL NOSEL NIL NIL))           (* If there was a new-type selection 
                                                             around, turn it off.)
                    (SETQ OLDSEL NOSEL)                      (* Now cut over to the new selection)
                    (\TEDIT.SET.SEL.LOOKS OLDSEL NEWOP)      (* And set it up looking right.)
                    ))
                (\COPYSEL NEWSEL OLDSEL)
                (replace (SELECTION ONFLG) of OLDSEL with NIL)
                                                             (* Make sure we can turn the 
                                                             highlighting on.)
                (\SHOWSEL OLDSEL NIL T)))
          (RETURN (OR NOSEL OLDSEL])
)
(DEFINEQ

(\COPYSEL
  [LAMBDA (FROM TO)                                          (* ; "Edited 21-Oct-2022 18:42 by rmk")
                                                             (* ; "Edited 31-May-91 12:27 by jds")

    (* ;; "Copy a SELECTION record from FROM to TO, without creating any new ones")

    (replace (SELECTION Y0) of TO with (fetch (SELECTION Y0) of FROM))
    (replace (SELECTION X0) of TO with (fetch (SELECTION X0) of FROM))
    (replace (SELECTION DX) of TO with (fetch (SELECTION DX) of FROM))
    (replace (SELECTION CH#) of TO with (fetch (SELECTION CH#) of FROM))
    (replace (SELECTION XLIM) of TO with (fetch (SELECTION XLIM) of FROM))
    (replace (SELECTION CHLIM) of TO with (fetch (SELECTION CHLIM) of FROM))
    (replace (SELECTION DCH) of TO with (fetch (SELECTION DCH) of FROM))
    (replace (SELECTION L1) of TO with (COPY (fetch (SELECTION L1) of FROM)))
    (replace (SELECTION LN) of TO with (COPY (fetch (SELECTION LN) of FROM)))
    (replace (SELECTION YLIM) of TO with (fetch (SELECTION YLIM) of FROM))
    (replace (SELECTION POINT) of TO with (fetch (SELECTION POINT) of FROM))
    (replace (SELECTION SET) of TO with (fetch (SELECTION SET) of FROM))
    (replace (SELECTION SELTEXTOBJ) of TO with (fetch (SELECTION SELTEXTOBJ) of FROM))
    (replace (SELECTION SELKIND) of TO with (fetch (SELECTION SELKIND) of FROM))
    (replace (SELECTION HOW) of TO with (fetch (SELECTION HOW) of FROM))
    (replace (SELECTION HOWHEIGHT) of TO with (fetch (SELECTION HOWHEIGHT) of FROM))
    (replace (SELECTION HASCARET) of TO with (fetch (SELECTION HASCARET) of FROM))
    (replace (SELECTION SELOBJ) of TO with (fetch (SELECTION SELOBJ) of FROM))
    (replace (SELECTION ONFLG) of TO with (fetch (SELECTION ONFLG) of FROM])

(\TEDIT.SEL.CHANGED?
  [LAMBDA (NEWSEL OLDSEL OLDSELOP NEWSELOP)                  (* ; "Edited 21-Oct-2022 18:41 by rmk")
                                                             (* ; "Edited 30-May-91 23:01 by jds")

         (* Decide whether there has been an interesting change in the selection, so we 
         can decide whether to refresh its hilighting on the screen.)

    (AND NEWSEL (fetch (SELECTION SET) of NEWSEL)
         (NOT (AND (fetch (SELECTION SET) of OLDSEL)
                   (EQ (fetch (SELECTION SET) of OLDSEL)
                       (fetch (SELECTION SET) of NEWSEL))
                   (EQUAL (fetch (SELECTION CH#) of NEWSEL)
                          (fetch (SELECTION CH#) of OLDSEL))
                   (EQUAL (fetch (SELECTION CHLIM) of NEWSEL)
                          (fetch (SELECTION CHLIM) of OLDSEL))
                   (EQ (fetch (SELECTION SELTEXTOBJ) of NEWSEL)
                       (fetch (SELECTION SELTEXTOBJ) of OLDSEL))
                   (IEQP (fetch (SELECTION DX) of NEWSEL)
                         (fetch (SELECTION DX) of OLDSEL))
                   (EQ (fetch (SELECTION POINT) of NEWSEL)
                       (fetch (SELECTION POINT) of OLDSEL))
                   (EQ (fetch (SELECTION HOW) of NEWSEL)
                       (fetch (SELECTION HOW) of OLDSEL))
                   (EQ (fetch (SELECTION HOWHEIGHT) of NEWSEL)
                       (fetch (SELECTION HOWHEIGHT) of OLDSEL))
                   (EQ OLDSELOP NEWSELOP])
)



(* ;; "User entries to the selection code")

(DEFINEQ

(TEDIT.GETPOINT
  [LAMBDA (STREAM SEL)                                       (* ; "Edited 30-May-91 23:03 by jds")

         (* Given a selection, tell the CH# that type-in would be inserted in front of.
         IF SEL is given, use it to decide. Otherwise, use STREAM's current selection.)

    (PROG [(TSEL (OR SEL (fetch (TEXTOBJ SEL) of (TEXTOBJ STREAM]
          (RETURN (IMAX 1 (SELECTQ (fetch (SELECTION POINT) of TSEL)
                              (LEFT (fetch (SELECTION CH#) of TSEL))
                              (RIGHT (fetch (SELECTION CHLIM) of TSEL))
                              (SHOULDNT "Selection's POINT is neither RIGHT nor LEFT."])

(TEDIT.GETSEL
  [LAMBDA (STREAM)                                           (* ; "Edited 30-May-91 23:03 by jds")
    (create SELECTION using (fetch (TEXTOBJ SEL) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM])

(TEDIT.MAKESEL
  [LAMBDA (STREAM CH# LEN POINT)                             (* ; "Edited 21-Oct-2022 18:37 by rmk")
                                                             (* ; "Edited 30-May-91 23:03 by jds")
    (PROG ((SEL (fetch (TEXTOBJ SEL) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
           (TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
          (\SHOWSEL SEL NIL NIL)
          (replace (SELECTION CH#) of SEL with CH#)
          (replace (SELECTION CHLIM) of SEL with (IMAX CH# (IPLUS CH# LEN)))
          (replace (SELECTION DCH) of SEL with LEN)
          (replace (SELECTION POINT) of SEL with (OR POINT 'LEFT))
          (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)
          (replace (SELECTION SET) of SEL with T)
          (AND (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
               (\FIXSEL SEL TEXTOBJ))
          (\SHOWSEL SEL NIL T])

(TEDIT.SCANSEL
  [LAMBDA (TSTREAM)                                          (* ; "Edited  8-Sep-2022 23:29 by rmk")
                                                             (* ; "Edited 30-May-91 23:03 by jds")

    (* ;; "Set up to read the selected text;  return the sel's length or NIL if nothing selected.")

    (LET (SEL)
         (SETQ SEL (fetch (TEXTOBJ SEL) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
         (CL:WHEN (fetch (SELECTION SET) of SEL)
             (\TEXTSETFILEPTR TSTREAM (SUB1 (fetch (SELECTION CH#) of SEL)))
             (fetch (SELECTION DCH) of SEL))])

(TEDIT.SET.SEL.LOOKS
  [LAMBDA (SEL OPERATION)                                    (* ; "Edited 30-May-91 23:01 by jds")
                                                             (* Set what the selection should be 
                                                             displayed like, given what it's for
                                                             (NORMAL, COPY, MOVE, etc.))
    (PROG ((WASON (fetch (SELECTION ONFLG) of SEL)))
          (\SHOWSEL SEL NIL NIL)
          (SELECTQ OPERATION
              (NORMAL                                        (* Regular selection)
                      (replace (SELECTION HOW) of SEL with BLACKSHADE)
                      (replace (SELECTION HOWHEIGHT) of SEL with 1)
                      (replace (SELECTION HASCARET) of SEL with T))
              (COPY                                          (* Copy source)
                    (replace (SELECTION HOW) of SEL with COPYSELSHADE)
                    (replace (SELECTION HOWHEIGHT) of SEL with 1)
                    (replace (SELECTION HASCARET) of SEL with NIL))
              (COPYLOOKS                                     (* copylooks source)
                         (replace (SELECTION HOW) of SEL with COPYLOOKSSELSHADE)
                         (replace (SELECTION HOWHEIGHT) of SEL with 2)
                         (replace (SELECTION HASCARET) of SEL with NIL))
              (MOVE                                          (* Copy source)
                    (replace (SELECTION HOW) of SEL with EDITMOVESHADE)
                    (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                    (replace (SELECTION HASCARET) of SEL with NIL))
              (DELETE                                        (* To be deleted instantly)
                      (replace (SELECTION HOW) of SEL with BLACKSHADE)
                      (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                      (replace (SELECTION HASCARET) of SEL with NIL)
                      NIL)
              (PENDINGDEL                                    (* Delete at next type-in)
                          (replace (SELECTION HOW) of SEL with BLACKSHADE)
                          (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                          (replace (SELECTION HASCARET) of SEL with T)
                          NIL)
              (INVERTED                                      (* For people who really want to see 
                                                             what's selected.)
                        (replace (SELECTION HOW) of SEL with BLACKSHADE)
                        (replace (SELECTION HOWHEIGHT) of SEL with 16384)
                        (replace (SELECTION HASCARET) of SEL with T)
                        NIL)
              NIL)
          (\SHOWSEL SEL NIL WASON])

(TEDIT.SETSEL
  [LAMBDA (STREAM CH# LEN POINT PENDINGDELFLG LEAVECARETLOOKS OPERATION)
                                                             (* ; "Edited 21-Oct-2022 18:35 by rmk")
                                                             (* ; "Edited 24-Aug-2022 14:11 by rmk")
                                                             (* ; "Edited 13-Aug-2022 21:32 by rmk")
                                                             (* ; "Edited  6-Aug-2022 21:51 by rmk")
                                                             (* ; "Edited 30-May-91 23:05 by jds")

    (* ;; "Given a text stream or textobj, and a piece of text to select, set the internal selection, and return it.")
                                                             (* ; "Make sure we got a stream")
    (LET ((TEXTOBJ (TEXTOBJ STREAM))
          SEL TEXTLEN PC)
         (SETQ SEL (fetch (TEXTOBJ SEL) of TEXTOBJ))
         (SETQ TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
         (\SHOWSEL SEL NIL NIL)                              (* ; "First turn the old sel off.")
         [COND
            ((type? SELECTION CH#)                           (* ; 
                                                          "He gave use a selection;  just plug it in")
             (\COPYSEL CH# SEL)
             (replace (SELECTION ONFLG) of SEL with NIL)     (* ; 
                                                             "And make sure it can be turned on.")
             )
            (T                                               (* ; "He fed us numbers;  use them")
               (replace (SELECTION CH#) of SEL with (IMIN (IMAX 1 CH#)
                                                          (ADD1 TEXTLEN)))
                                                             (* ; "Starting character")
               [replace (SELECTION CHLIM) of SEL with (IMAX 1 CH# (IMIN (IPLUS CH# LEN)
                                                                        (ADD1 TEXTLEN]
                                                             (* ; "Last selected character")
               [replace (SELECTION DCH) of SEL with (IMIN LEN TEXTLEN (IDIFFERENCE
                                                                       (fetch (SELECTION CHLIM)
                                                                          of SEL)
                                                                       (fetch (SELECTION CH#)
                                                                          of SEL]
               (replace (SELECTION POINT) of SEL with (OR (AND (IGREATERP CH# TEXTLEN)
                                                               'LEFT)
                                                          POINT
                                                          'LEFT))
                                                             (* ; "Which side the caret should go on")
               (freplace (SELECTION SELOBJ) of SEL with (CL:UNLESS (OR (IGREATERP (fetch (SELECTION
                                                                                          CH#)
                                                                                     of SEL)
                                                                              TEXTLEN)
                                                                       (NEQ 1 LEN))
                                                            (SETQ PC (\CHTOPC (fetch (SELECTION
                                                                                      CH#)
                                                                                 of SEL)
                                                                            TEXTOBJ))
                                                            (CL:WHEN (EQ OBJECT.PTYPE
                                                                         (ffetch (PIECE PTYPE)
                                                                            of PC))
                                                                (fetch (PIECE PCONTENTS) of PC)))]
         (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)(* ; 
                                                             "Link it back to the associated textobj")
         [COND
            (PENDINGDELFLG                                   (* ; 
                                                    "This selection is to be a pending-deletion sel.")
                   (replace (TEXTOBJ BLUEPENDINGDELETE) of TEXTOBJ with T)
                                                             (* ; 
                                                         "Warn TEdit that there's a deletion pending")
                   (\TEDIT.SET.SEL.LOOKS SEL (OR OPERATION 'PENDINGDEL))
                                                             (* ; 
                                                             "And make the selection look right.")
                   )
            (T                                               (* ; 
                                                    "This selection is to be a pending-deletion sel.")
               (TEDIT.RESET.EXTEND.PENDING.DELETE SEL)
               (\TEDIT.SET.SEL.LOOKS SEL (OR OPERATION 'NORMAL]
         (replace (SELECTION SET) of SEL with T)             (* ; 
                                                      "Mark the selection as valid for others to use")
         (CL:UNLESS LEAVECARETLOOKS                          (* ; 
                                                             "And set the insertion looks to follow.")
             (replace (TEXTOBJ CARETLOOKS) of TEXTOBJ with (\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ SEL)))
         (\FIXSEL SEL TEXTOBJ)                               (* ; 
                                                             "Update the selection's screen location")
         (\SHOWSEL SEL NIL T)                                (* ; "Highlight it on the screen")
         SEL])

(TEDIT.SHOWSEL
  [LAMBDA (STREAM ONFLG SEL)                                 (* ; "Edited 21-Oct-2022 18:36 by rmk")
                                                             (* ; "Edited 30-May-91 23:04 by jds")
    (PROG ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
          (CL:WHEN SEL                                       (* ; 
                              "He's giving us a selection to highlight.  Connect it to this textobj.")
              (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)
              (\FIXSEL SEL TEXTOBJ))
          (\SHOWSEL (OR SEL (fetch (TEXTOBJ SEL) of TEXTOBJ))
                 NIL ONFLG])
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (11845 24751 (TEDIT.SEL.AS.STRING 11855 . 13262) (TEDIT.SELECTED.PIECES 13264 . 14233) (
\TEDIT.FIND.FIRST.LINE 14235 . 18113) (\TEDIT.FIND.LAST.LINE 18115 . 19395) (
\TEDIT.FIND.OVERLAPPING.LINE 19397 . 19811) (\TEDIT.FIND.PROTECTED.END 19813 . 21741) (
\TEDIT.FIND.PROTECTED.START 21743 . 24086) (\TEDIT.WORD.BOUND 24088 . 24749)) (24795 25274 (
\CREATE.TEDIT.SELECTION 24805 . 24875) (\CREATE.TEDIT.SHIFTEDSELECTION 24877 . 24980) (
\CREATE.TEDIT.MOVESELECTION 24982 . 25111) (\CREATE.TEDIT.DELETESELECTION 25113 . 25272)) (26026 74644
 (TEDIT.EXTEND.SEL 26036 . 37692) (TEDIT.SELECT 37694 . 42731) (TEDIT.SCAN.LINE 42733 . 56328) (
TEDIT.SELECT.LINE.SCANNER 56330 . 70555) (\TEDIT.SELECT.OBJECT 70557 . 74642)) (74645 95313 (\FIXSEL 
74655 . 90275) (\TEDIT.FIXDELSEL 90277 . 93333) (\TEDIT.FIXINSSEL 93335 . 94597) (\TEDIT.FIXSELS 94599
 . 95311)) (95314 98768 (TEDIT.RESET.EXTEND.PENDING.DELETE 95324 . 95901) (\TEDIT.SET.SEL.LOOKS 95903
 . 98766)) (98769 118788 (\SHOWSEL 98779 . 103927) (\SHOWSEL.HILIGHT 103929 . 109071) (
\TEDIT.UPDATE.SHOWSEL 109073 . 114866) (\TEDIT.SHOWSELS 114868 . 115569) (\TEDIT.REFRESH.SHOWSEL 
115571 . 118786)) (118789 122634 (\COPYSEL 118799 . 120963) (\TEDIT.SEL.CHANGED? 120965 . 122632)) (
122687 135512 (TEDIT.GETPOINT 122697 . 123406) (TEDIT.GETSEL 123408 . 123648) (TEDIT.MAKESEL 123650 . 
124658) (TEDIT.SCANSEL 124660 . 125312) (TEDIT.SET.SEL.LOOKS 125314 . 128469) (TEDIT.SETSEL 128471 . 
134804) (TEDIT.SHOWSEL 134806 . 135510)))))
STOP
