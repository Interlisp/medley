(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "13-Jun-2023 15:07:03" {WMEDLEY}<library>tedit>TEDIT-STREAM.;410 140224 

      :EDIT-BY rmk

      :CHANGES-TO (RECORDS TEXTOBJ)

      :PREVIOUS-DATE " 9-Jun-2023 23:05:43" {WMEDLEY}<library>tedit>TEDIT-STREAM.;408)


(PRETTYCOMPRINT TEDIT-STREAMCOMS)

(RPAQQ TEDIT-STREAMCOMS
       [(DECLARE%: EVAL@COMPILE DONTCOPY (EXPORT (RECORDS PIECE TEXTOBJ TEXTSTREAM)
                                                (MACROS NEXTPIECE PREVPIECE PLEN PTYPE PCONTENTS 
                                                       PLOOKS PPARALOOKS PPARALAST PFPOS)
                                                (MACROS TEXTLEN TEXTSEL)
                                                (OPTIMIZERS TEXTPROP)
                                                (CONSTANTS (THINFILE.PTYPE 0)
                                                       (FATFILE1.PTYPE 1)
                                                       (FATFILE2.PTYPE 2)
                                                       (THINSTRING.PTYPE 3)
                                                       (FATSTRING.PTYPE 4)
                                                       (SUBSTREAM.PTYPE 5)
                                                       (OBJECT.PTYPE 6)
                                                       (LOOKS.PTYPE 7)
                                                       (FILE.PTYPES (LIST THINFILE.PTYPE 
                                                                          FATFILE1.PTYPE 
                                                                          FATFILE2.PTYPE))
                                                       (STRING.PTYPES (LIST THINSTRING.PTYPE 
                                                                            FATSTRING.PTYPE))
                                                       (BINABLE.PTYPES (LIST THINFILE.PTYPE 
                                                                             THINSTRING.PTYPE)))
                                                (GLOBALVARS \TEXTIMAGEOPS \TEXTFDEV)))
        (INITRECORDS PIECE TEXTOBJ TEXTSTREAM)
        (COMS 
              (* ;; "The BIN-level functions")

              (FNS \TEXTBIN \TEXTBIN.NEXT.PIECE \TEXTPEEKBIN \TEXTBACKFILEPTR \TEXTOUTCHARFN 
                   \INSTALL.FILEBUFFER \TEXTBOUT)
              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \FATFILE2.CHAR \ENDOFPIECEP \STARTOFPIECEP 
                                                      \ENDOFBUFFERP \STARTOFBUFFERP)))
        
        (* ;; "External format functions:  equivalent to BIN-level")

        (FNS \TEXTSTREAM.OUTCHARFN \TEXTSTREAM.INCCCODEFN \TEXTSTREAM.PEEKCCODEFN 
             \TEXTSTREAM.BACKCCODEFN \TEXTSTREAM.OUTCHARFN \TEXTSTREAM.FORMATBYTESTREAM)
        
        (* ;; "High-level stream operations")

        (FNS COPYTEXTSTREAM OPENTEXTSTREAM OPENTEXTSTREAM.DEFAULTLOOKS REOPENTEXTSTREAM 
             TEDIT.STREAMCHANGEDP TEXTSTREAMP TXTFILE \TEDIT.REOPEN.STREAM \TEXTINIT \TEXTTTYBOUT)
        
        (* ;; "Low-level generic stream operations")

        (FNS \TEXTCLOSEF \TEXTDSPFONT \TEXTEOFP \TEXTGETEOFPTR \TEXTGETFILEPTR \TEXTOPENF \TEXTSETEOF
             \TEXTSETFILEPTR \TEXTDSPXPOSITION \TEXTDSPYPOSITION \TEXTLEFTMARGIN \TEXTRIGHTMARGIN 
             \TEXTDSPCHARWIDTH \TEXTDSPSTRINGWIDTH \TEXTDSPLINEFEED)
        (COMS 
              (* ;; "Editing support")

              (DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (INSERTSTRINGLENGTH 512))
                     (MACROS \INSERTCH.EXTENDABLE \LASTPIECEP \NOTLASTPIECEP))
              (FNS \TEDIT.DELETE.SELPIECES \SETUPGETCH \INSERTCH \INSERTCH.HISTORY \INSERTEOL 
                   \INSERTCH.INSERTION \INSERTCH.EXTEND))
        (COMS                                                (* ; 
                                                             "Piece and piece-table manipulation")
              (FNS \DELETEPIECES \INSERTPIECES \ALIGNEDPIECE \INSTALL.PIECE)
              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \NEXT.VISIBLE.PIECE \PREV.VISIBLE.PIECE)))
        (COMS                                                (* ; "Support for TEXTPROP")
              (FNS CGETTEXTPROP CTEXTPROP GETTEXTPROP PUTTEXTPROP TEXTPROP))
        [COMS 
              (* ;; "Support for error handling:  The old error handler for the stream-not-open error.  This is here, because you only want to do this ONCE, even if you load TEXT-STREAM multiple times (as, e.g., in development)")

              (INITVARS (*TEDIT-OLD-STREAM-ERROR-HANDLER* (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN]
        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (\TEXTINIT)))
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)
                                                                             (NLAML)
                                                                             (LAMA TEXTPROP])
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE PIECE (                                            (* ; 
                 "The piece describes either a string or part of a file.  , or a generalized OBJECT.")
                 PCONTENTS                                   (* ; "The background source of data for this piece (stream, string, block, object, depending on the PTYPE).")
                 (PTYPE BITS 4)                              (* ; 
                           "How the characters are delivered: thinfile, fatstring, object, substream")
                 PBYTELEN                                    (* ; "PLEN in bytes (based on fat type)")
                 PFPOS                                       (* ; 
                                                  "The FILEPTR of the start of the piece in the file")
                 PLEN                                        (* ; 
                                                             "Length of the piece, in characters.")
                 NEXTPIECE                                   (* ; "-> Next piece in this textobj.")
                 (PREVPIECE FULLXPOINTER)                    (* ; 
                                                             "-> Prior piece in this text object.")
                 PLOOKS                                      (* ; 
                                                "Formatting info and formatting events in this piece")
                 PBYTESPERCHAR                               (* ; "The number of bytes per character if all characters in the piece are of the same length, otherwise NIL. WAS: OBJECT this piece describes")
                 (PPARALAST FLAG)                            (* ; "This piece ends paragraph")
                 PPARALOOKS                                  (* ; "Paragraph looks for this piece")
                 (PNEW FLAG)                                 (* ; 
             "This text is new here;  used by the tentative edit system, and anyone else interested.")
                 (NIL FLAG)                                  (* ; "Was PFATP")
                 (PBINABLE FLAG)                             (* ; "8-bit bytes are binable")
                 (PTREENODE XPOINTER)                        (* ; 
                                             "Points to the PCTB tree-node that contains this piece.")
                 (PEXTERNALFORMAT POINTER)                   (* ; 
                                                           "The external format of a piece on a file")
                 (PCHARSET POINTER))                         (* ; 
                                                    "The common charset for a run of thin characters")
                [ACCESSFNS ((POBJ (IMAGEOBJP (PCONTENTS DATUM]
                PFPOS _ 0 PLEN _ 0 PPARALOOKS _ TEDIT.DEFAULT.FMTSPEC PCHARSET _ 0)

(DATATYPE TEXTOBJ 
          (
           (* ;; 
   "This is where TEdit stores its state information, and internal data about the text being edited.")

           PCTB                                              (* ; "The piece table")
           TEXTLEN                                           (* ; "# of chars in the text")
           PANES                                             (* ; "A list of panes (subwindows) that are open on this document. Was INSERTPC: The string-piece that received the last insertion. Now HINTPC")
           LASTPIECE                                         (* ; 
                    "The last (end-of-stream) piece of the textstream, for easy insertion at the end")
           NIL                                               (* ; 
    "Was: INSERTNEXTCH CH# of next char which is typed into that piece. Taken over by HINTPCSTARTCH#")
           HINTPC                                            (* ; 
                                                             "Was: Space left in the type-in piece")
           HINTPCSTARTCH#                                    (* ; 
                                                          "Was # of characters already in the piece.")
           INSERTSTRING                                      (* ; 
                                         "A substring of storage that is available for an insertion.")
           TXTHISTORYUNDONE                                  (* ; "Events that result from undoing other events, for revoking the UNDO. Was: CH# of first char in the piece.")
           (NIL FLAG)                                        (* ; "Was \INSERTPCVALID. T if it's OK to use the cached piece.  Set to NIL by people who require that the next insertion/deletion use a different piece. Now just set HINTPC to NIL.")
           \WINDOW                                           (* ; 
                                                 "The window-pane<s> where this textobj is displayed")
           MOUSEREGION                                       (* ; 
                                                             "Section of the window the mouse is in.")
           LINES                                             (* ; "A list of lines (parallel to the panes in \WINDOW) each of which is the top of chain of line descriptors for the part of the text that is visible in the corresponding pane.")
           DS                                                (* ; 
                                                     "Display stream where this textobj is displayed")
           SEL                                               (* ; 
                                                             "The current selection within the text")
           SCRATCHSEL                                        (* ; 
                                                             "Scratch space for the selection code")
           MOVESEL                                           (* ; "Source for the next MOVE of text")
           SHIFTEDSEL                                        (* ; "Source for the next COPY")
           DELETESEL                                         (* ; "Text to be deleted imminently")
           WRIGHT                                            (* ; 
                                    "Right edge of the window (or subregion) where this is displayed")
           WTOP                                              (* ; "Top of the window/region")
           WBOTTOM                                           (* ; "Bottom of the window/region")
           WLEFT                                             (* ; "Left edge of the window/region")
           TXTFILE                                           (* ; 
                                                             "The original text file we're editing")
           (\XDIRTY FLAG)                                    (* ; "T => changed since last saved.")
           (STREAMHINT FULLXPOINTER)                         (* ; 
                                           "-> the TEXTOFD stream which gives access to this textobj")
           EDITFINISHEDFLG                                   (* ; 
                                                        "T => The guy has asked the editor to go way")
           CARET                                             (* ; 
                                                "Describes the flashing caret for the editing window")
           CARETLOOKS                                        (* ; 
                                                             "Font to be used for inserted text.")
           WINDOWTITLE                                       (* ; 
                                                  "Original title for this window, of there was one.")
           THISLINE                                          (* ; 
                                               "Cache of line-related info, to speed up selection &c")
           (MENUFLG FLAG)                                    (* ; 
                                                            "T if this TEXTOBJ is a tedit-style menu")
           FMTSPEC                                           (* ; 
                                      "Default Formatting Spec to be used when formatting paragraphs")
           (FORMATTEDP FLAG)                                 (* ; 
 "Flag for paragraph formatting.  T if this document is to contain paragraph formatting information.")
           (TXTREADONLY FLAG)                                (* ; 
                                                        "This is only available for shift selection.")
           (TXTEDITING FLAG)                                 (* ; "T => This document is in a window and there is an edit process behind it.  For example, it only makes sense to have a caret show up if you are editing.")
           (TXTNONSCHARS FLAG)                               (* ; "T => If TEdit rns into a 255, it won't attempt to convert to NS characters.  Used for REALLY plain-text manipulation.")
           TXTTERMSA                                         (* ; 
                                       "Special instructions for displaying characters on the screen")
           EDITOPACTIVE                                      (* ; 
                  "T if there is an editing operation in progress.  Used to interlock the TEdit menu")
           DEFAULTCHARLOOKS                                  (* ; "The default character looks -- if any -- to be applied to characters coming into the file from outside.")
           TXTRTBL                                           (* ; 
                                  "The READTABLE to be used by the command loop for command dispatch")
           TXTWTBL                                           (* ; 
                                                  "The READTABLE to be used to decide on word breaks")
           EDITPROPS                                         (* ; 
                                                  "The PROPS that were passed into this edit session")
           (BLUEPENDINGDELETE FLAG)                          (* ; "T if the next insertion in this document is to be preceded by a deletion of the then-current selection")
           TXTHISTORY                                        (* ; 
                                                            "The history list for this edit session.")
           (SELWINDOW FULLXPOINTER)                          (* ; "The window in which the last 'real' selection got made for this edit;  used to control caret placement")
           PROMPTWINDOW                                      (* ; 
   "A window to be used for unscheduled interactions;  normally a small window above the edit window")
           DISPLAYCACHE                                      (* ; 
                                "The bitmap to be used when building the image of a line for display")
           DISPLAYCACHEDS                                    (* ; 
                                                "The DISPLAYSTREAM that is used to build line images")
           DISPLAYHCPYDS                                     (* ; "The DISPLAYSTREAM used to build line images of lines that are displayed in 'hardcopy' simulation mode")
           TXTPAGEFRAMES                                     (* ; 
                              "A tree of page frames, specifying how the document is to be laid out.")
           TXTCHARLOOKSLIST                                  (* ; 
                             "List of all the CHARLOOKSs in the document, so they can be kept unique")
           TXTPARALOOKSLIST                                  (* ; 
                               "List of all the FMTSPECs in the document, so they can be kept unique")
           (TXTNEEDSUPDATE FLAG)                             (* ; 
                                                           "T => Screen invalid, need to run updater")
           (TXTDON'TUPDATE FLAG)                             (* ; "T if we're holding off on screen updates until later.  Used, e.g., by the menu-SHOW code so that you don't get piecemeal updates, but only one at the end of the SHOW.")
           TXTRAWINCLUDESTREAM                               (* ; 
                       "NODIRCORE stream used to cache RAW includes (and maybe later, all includes?)")
           DOCPROPS                                          (* ; 
                               "Document properties that are stored with the document (not used yet)")
           TXTSTYLESHEET                                     (* ; 
                      "Style sheet local to this document.  Not currently saved as part of the file.")
           )
          [ACCESSFNS TEXTOBJ ((\DIRTY (ffetch (TEXTOBJ \XDIRTY) of DATUM)
                                     (PROGN (IF (NEQ (FETCH (TEXTOBJ \XDIRTY) OF DATUM)
                                                     NEWVALUE)
                                                THEN         (* ; 
                                                             "update the title to reflect the change")
                                                     (\TEDIT.WINDOW.TITLE DATUM
                                                            (\TEDIT.ORIGINAL.WINDOW.TITLE
                                                             (ffetch (TEXTOBJ TXTFILE) of DATUM)
                                                             NEWVALUE)))
                                            (freplace \XDIRTY OF DATUM WITH NEWVALUE]
          SEL _ (create SELECTION)
          SCRATCHSEL _ (create SELECTION)
          MOVESEL _ (create SELECTION
                           HOWHEIGHT _ 32767
                           HASCARET _ NIL)
          SHIFTEDSEL _ (create SELECTION
                              HASCARET _ NIL)
          DELETESEL _ (create SELECTION
                             HOWHEIGHT _ 32767
                             HASCARET _ NIL)
          TEXTLEN _ 0 WRIGHT _ 0 WTOP _ 0 WLEFT _ 0 WBOTTOM _ 0 TXTFILE _ NIL \XDIRTY _ NIL 
          MOUSEREGION _ 'TEXT THISLINE _ (create THISLINE)
          MENUFLG _ NIL FMTSPEC _ TEDIT.DEFAULT.FMTSPEC FORMATTEDP _ NIL INSERTSTRING _ NIL)

(ACCESSFNS TEXTSTREAM 
           (
            (* ;; 
          "Overlay for the STREAM record to allow mnemonic access to stream fields for Text streams.")

            (* ;; "The # of characters that have already been read from the current piece")

            (TEXTOBJ (fetch (STREAM F3) of DATUM)
                   (REPLACE (STREAM F3) OF DATUM WITH NEWVALUE))
                                                             (* ; 
                                                             "The TEXTOBJ that is editing this text")
            (PIECE (fetch (STREAM F5) of DATUM)
                   (REPLACE (STREAM F5) OF DATUM WITH NEWVALUE))
                                                             (* ; 
                                   "The PIECE we're currently fetching chars from/putting chars into")
            (PCCHARSLEFT (fetch (STREAM F1) of DATUM)
                   (replace (STREAM F1) of DATUM with NEWVALUE))
                                                             (* ; 
                                                             "Runs from PLEN to 0: piece exhausted")
            (NIL)                                            (* ; 
                                 "WAS: PCSTARTPG The underlying file page# that this piece starts on")
            (NIL)                                            (* ; "WAS: PCSTARTCH The char within page of the underlying file that this piece starts on -- for backbin & co")
            (NIL)                                            (* ; "Was: PCOFFSET: The offset into the current piece, as of the last page cross, using TIPCOFFSET of TEXTIMAGEDATA")
            (CURRENTLOOKS (fetch (STREAM F10) of DATUM)
                   (replace (STREAM F10) of DATUM with NEWVALUE))
                                                             (* ; 
             "The CHARLOOKS that are currently applicable to characters being taken from the stream.")
            (CURRENTPARALOOKS (fetch (STREAM IMAGEDATA) of DATUM)
                   (REPLACE (STREAM IMAGEDATA) of DATUM with NEWVALUE))
                                                             (* ; "The FMTSPEC that is currently applicable to characters being taken from the stream. This was  the only residual field of TEXTIMAGEDATA, now gone.")
            (NIL                                             (* ; "Was CURRENTIMAGESTREAM: The image stream that this text is being put onto;  used for scaling decisions.  But the imagestream for scaling is passed as an argument, not a property of the textstream.  This was indirected through TEXTIMAGEDATA")
                 )
            (LOOKSUPDATEFN (fetch (STREAM F4) of DATUM)
                   (REPLACE (STREAM F4) OF DATUM with NEWVALUE))
                                                             (* ; 
                                  "Function to be called at every piece change when line-formatting.")
            (STARTINGCOFFSET (fetch (STREAM F2) of DATUM)
                   (replace (STREAM F2) of DATUM with NEWVALUE)))
           (CREATE (create STREAM
                          BINABLE _ NIL
                          BOUTABLE _ NIL
                          ACCESS _ 'BOTH
                          USERCLOSEABLE _ T
                          USERVISIBLE _ T
                          DEVICE _ \TEXTFDEV
                          F1 _ NIL
                          F2 _ 0
                          F3 _ NIL
                          F4 _ NIL
                          F5 _ NIL
                          MAXBUFFERS _ 10
                          IMAGEOPS _ \TEXTIMAGEOPS
                          IMAGEDATA _ NIL)))
)

(/DECLAREDATATYPE 'PIECE
       '(POINTER (BITS 4)
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER FLAG POINTER FLAG FLAG 
               FLAG XPOINTER POINTER POINTER)
       '((PIECE 0 POINTER)
         (PIECE 0 (BITS . 3))
         (PIECE 2 POINTER)
         (PIECE 4 POINTER)
         (PIECE 6 POINTER)
         (PIECE 8 POINTER)
         (PIECE 10 FULLXPOINTER)
         (PIECE 12 POINTER)
         (PIECE 14 POINTER)
         (PIECE 14 (FLAGBITS . 0))
         (PIECE 16 POINTER)
         (PIECE 16 (FLAGBITS . 0))
         (PIECE 16 (FLAGBITS . 16))
         (PIECE 16 (FLAGBITS . 32))
         (PIECE 18 XPOINTER)
         (PIECE 20 POINTER)
         (PIECE 22 POINTER))
       '24)

(/DECLAREDATATYPE 'TEXTOBJ
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER POINTER
               POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER FLAG FULLXPOINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER
               FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER 
               FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG FLAG POINTER
               POINTER POINTER)
       '((TEXTOBJ 0 POINTER)
         (TEXTOBJ 2 POINTER)
         (TEXTOBJ 4 POINTER)
         (TEXTOBJ 6 POINTER)
         (TEXTOBJ 8 POINTER)
         (TEXTOBJ 10 POINTER)
         (TEXTOBJ 12 POINTER)
         (TEXTOBJ 14 POINTER)
         (TEXTOBJ 16 POINTER)
         (TEXTOBJ 16 (FLAGBITS . 0))
         (TEXTOBJ 18 POINTER)
         (TEXTOBJ 20 POINTER)
         (TEXTOBJ 22 POINTER)
         (TEXTOBJ 24 POINTER)
         (TEXTOBJ 26 POINTER)
         (TEXTOBJ 28 POINTER)
         (TEXTOBJ 30 POINTER)
         (TEXTOBJ 32 POINTER)
         (TEXTOBJ 34 POINTER)
         (TEXTOBJ 36 POINTER)
         (TEXTOBJ 38 POINTER)
         (TEXTOBJ 40 POINTER)
         (TEXTOBJ 42 POINTER)
         (TEXTOBJ 44 POINTER)
         (TEXTOBJ 44 (FLAGBITS . 0))
         (TEXTOBJ 46 FULLXPOINTER)
         (TEXTOBJ 48 POINTER)
         (TEXTOBJ 50 POINTER)
         (TEXTOBJ 52 POINTER)
         (TEXTOBJ 54 POINTER)
         (TEXTOBJ 56 POINTER)
         (TEXTOBJ 56 (FLAGBITS . 0))
         (TEXTOBJ 58 POINTER)
         (TEXTOBJ 58 (FLAGBITS . 0))
         (TEXTOBJ 58 (FLAGBITS . 16))
         (TEXTOBJ 58 (FLAGBITS . 32))
         (TEXTOBJ 58 (FLAGBITS . 48))
         (TEXTOBJ 60 POINTER)
         (TEXTOBJ 62 POINTER)
         (TEXTOBJ 64 POINTER)
         (TEXTOBJ 66 POINTER)
         (TEXTOBJ 68 POINTER)
         (TEXTOBJ 70 POINTER)
         (TEXTOBJ 70 (FLAGBITS . 0))
         (TEXTOBJ 72 POINTER)
         (TEXTOBJ 74 FULLXPOINTER)
         (TEXTOBJ 76 POINTER)
         (TEXTOBJ 78 POINTER)
         (TEXTOBJ 80 POINTER)
         (TEXTOBJ 82 POINTER)
         (TEXTOBJ 84 POINTER)
         (TEXTOBJ 86 POINTER)
         (TEXTOBJ 88 POINTER)
         (TEXTOBJ 88 (FLAGBITS . 0))
         (TEXTOBJ 88 (FLAGBITS . 16))
         (TEXTOBJ 90 POINTER)
         (TEXTOBJ 92 POINTER)
         (TEXTOBJ 94 POINTER))
       '96)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS NEXTPIECE MACRO ((PC)
                           (ffetch (PIECE NEXTPIECE) of PC)))

(PUTPROPS PREVPIECE MACRO ((PC)
                           (ffetch (PIECE PREVPIECE) of PC)))

(PUTPROPS PLEN MACRO ((PC)
                      (ffetch (PIECE PLEN) of PC)))

(PUTPROPS PTYPE MACRO ((PC)
                       (ffetch (PIECE PTYPE) of PC)))

(PUTPROPS PCONTENTS MACRO ((PC)
                           (ffetch (PIECE PCONTENTS) of PC)))

(PUTPROPS PLOOKS MACRO ((PC)
                        (ffetch (PIECE PLOOKS) of PC)))

(PUTPROPS PPARALOOKS MACRO ((PC)
                            (ffetch (PIECE PPARALOOKS) of PC)))

(PUTPROPS PPARALAST MACRO ((PC)
                           (ffetch (PIECE PPARALAST) of PC)))

(PUTPROPS PFPOS MACRO ((PC)
                       (ffetch (PIECE PFPOS) of PC)))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS TEXTLEN MACRO ((TOBJ)
                         (fetch (TEXTOBJ TEXTLEN) of TOBJ)))

(PUTPROPS TEXTSEL MACRO ((TOBJ)
                         (fetch (TEXTOBJ SEL) of TOBJ)))
)

(DEFOPTIMIZER TEXTPROP (TEXTOBJ PROP &OPTIONAL (VAL NIL WRITING))

                       (* ;; "compiles calls to TEXTPROP")

                       [COND
                          ((NOT (LISTP PROP))                (* ; "property is not quoted.")
                           'IGNOREMACRO)
                          ((NOT (EQ (CAR PROP)
                                    'QUOTE))                 (* ; "property is not quoted.")
                           'IGNOREMACRO)
                          [(NOT WRITING)                     (* ; "fetching a TEXTPROP property.")
                           (SELECTQ (CADR PROP)
                               ((READONLY READ-ONLY) 
                                    `(fetch (TEXTOBJ TXTREADONLY) of (TEXTOBJ ,TEXTOBJ)))
                               ((BEING-EDITED ACTIVE) 
                                    `(fetch (TEXTOBJ TXTEDITING) of (TEXTOBJ ,TEXTOBJ)))
                               ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
                                    `(fetch (TEXTOBJ TXTNONSCHARS) of (TEXTOBJ ,TEXTOBJ)))
                               `(LISTGET (fetch (TEXTOBJ EDITPROPS) of (TEXTOBJ ,TEXTOBJ))
                                       ,PROP]
                          (T                                 (* ; "storing a window property")
                             (SELECTQ (CADR PROP)
                                 ((READONLY READ-ONLY) 
                                      `(REPLACE (TEXTOBJ TXTREADONLY) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 ((BEING-EDITED ACTIVE) 
                                      `(REPLACE (TEXTOBJ TXTEDITING) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
                                      `(REPLACE (TEXTOBJ TXTNONSCHARS) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 `(LET* (($$TEXTOBJ$$ (TEXTOBJ ,TEXTOBJ))
                                         ($$PROPLST$$ (FETCH EDITPROPS OF $$TEXTOBJ$$)))
                                        (COND
                                           ($$PROPLST$$ (LISTPUT $$PROPLST$$ ,PROP ,VAL))
                                           (T (REPLACE EDITPROPS OF $$TEXTOBJ$$
                                                 WITH (LIST ,PROP ,VAL])
(DECLARE%: EVAL@COMPILE 

(RPAQQ THINFILE.PTYPE 0)

(RPAQQ FATFILE1.PTYPE 1)

(RPAQQ FATFILE2.PTYPE 2)

(RPAQQ THINSTRING.PTYPE 3)

(RPAQQ FATSTRING.PTYPE 4)

(RPAQQ SUBSTREAM.PTYPE 5)

(RPAQQ OBJECT.PTYPE 6)

(RPAQQ LOOKS.PTYPE 7)

(RPAQ FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE))

(RPAQ STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE))

(RPAQ BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE))


(CONSTANTS (THINFILE.PTYPE 0)
       (FATFILE1.PTYPE 1)
       (FATFILE2.PTYPE 2)
       (THINSTRING.PTYPE 3)
       (FATSTRING.PTYPE 4)
       (SUBSTREAM.PTYPE 5)
       (OBJECT.PTYPE 6)
       (LOOKS.PTYPE 7)
       (FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE))
       (STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE))
       (BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE)))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS \TEXTIMAGEOPS \TEXTFDEV)
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'PIECE
       '(POINTER (BITS 4)
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER FLAG POINTER FLAG FLAG 
               FLAG XPOINTER POINTER POINTER)
       '((PIECE 0 POINTER)
         (PIECE 0 (BITS . 3))
         (PIECE 2 POINTER)
         (PIECE 4 POINTER)
         (PIECE 6 POINTER)
         (PIECE 8 POINTER)
         (PIECE 10 FULLXPOINTER)
         (PIECE 12 POINTER)
         (PIECE 14 POINTER)
         (PIECE 14 (FLAGBITS . 0))
         (PIECE 16 POINTER)
         (PIECE 16 (FLAGBITS . 0))
         (PIECE 16 (FLAGBITS . 16))
         (PIECE 16 (FLAGBITS . 32))
         (PIECE 18 XPOINTER)
         (PIECE 20 POINTER)
         (PIECE 22 POINTER))
       '24)

(/DECLAREDATATYPE 'TEXTOBJ
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER POINTER
               POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER FLAG FULLXPOINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER
               FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER 
               FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG FLAG POINTER
               POINTER POINTER)
       '((TEXTOBJ 0 POINTER)
         (TEXTOBJ 2 POINTER)
         (TEXTOBJ 4 POINTER)
         (TEXTOBJ 6 POINTER)
         (TEXTOBJ 8 POINTER)
         (TEXTOBJ 10 POINTER)
         (TEXTOBJ 12 POINTER)
         (TEXTOBJ 14 POINTER)
         (TEXTOBJ 16 POINTER)
         (TEXTOBJ 16 (FLAGBITS . 0))
         (TEXTOBJ 18 POINTER)
         (TEXTOBJ 20 POINTER)
         (TEXTOBJ 22 POINTER)
         (TEXTOBJ 24 POINTER)
         (TEXTOBJ 26 POINTER)
         (TEXTOBJ 28 POINTER)
         (TEXTOBJ 30 POINTER)
         (TEXTOBJ 32 POINTER)
         (TEXTOBJ 34 POINTER)
         (TEXTOBJ 36 POINTER)
         (TEXTOBJ 38 POINTER)
         (TEXTOBJ 40 POINTER)
         (TEXTOBJ 42 POINTER)
         (TEXTOBJ 44 POINTER)
         (TEXTOBJ 44 (FLAGBITS . 0))
         (TEXTOBJ 46 FULLXPOINTER)
         (TEXTOBJ 48 POINTER)
         (TEXTOBJ 50 POINTER)
         (TEXTOBJ 52 POINTER)
         (TEXTOBJ 54 POINTER)
         (TEXTOBJ 56 POINTER)
         (TEXTOBJ 56 (FLAGBITS . 0))
         (TEXTOBJ 58 POINTER)
         (TEXTOBJ 58 (FLAGBITS . 0))
         (TEXTOBJ 58 (FLAGBITS . 16))
         (TEXTOBJ 58 (FLAGBITS . 32))
         (TEXTOBJ 58 (FLAGBITS . 48))
         (TEXTOBJ 60 POINTER)
         (TEXTOBJ 62 POINTER)
         (TEXTOBJ 64 POINTER)
         (TEXTOBJ 66 POINTER)
         (TEXTOBJ 68 POINTER)
         (TEXTOBJ 70 POINTER)
         (TEXTOBJ 70 (FLAGBITS . 0))
         (TEXTOBJ 72 POINTER)
         (TEXTOBJ 74 FULLXPOINTER)
         (TEXTOBJ 76 POINTER)
         (TEXTOBJ 78 POINTER)
         (TEXTOBJ 80 POINTER)
         (TEXTOBJ 82 POINTER)
         (TEXTOBJ 84 POINTER)
         (TEXTOBJ 86 POINTER)
         (TEXTOBJ 88 POINTER)
         (TEXTOBJ 88 (FLAGBITS . 0))
         (TEXTOBJ 88 (FLAGBITS . 16))
         (TEXTOBJ 90 POINTER)
         (TEXTOBJ 92 POINTER)
         (TEXTOBJ 94 POINTER))
       '96)



(* ;; "The BIN-level functions")

(DEFINEQ

(\TEXTBIN
  [LAMBDA (TSTREAM)

    (* ;; "Edited  3-May-2023 15:09 by rmk")

    (* ;; "Edited 22-Dec-2021 10:29 by rmk: Return value of OBJECTCHAR property for image objects")

    (* ;; "Edited 28-Mar-94 15:33 by jds")

(* ;;; "The BIN slow case for a text stream.  For the fast, binable (THINFILE, THINSTRING) cases, this is called when an end-of-buffer is reached.  If it is not also an end-of-piece, get a new buffer and continue.  Otherwise, get a new piece (which may not be binable).")

(* ;;; "If the stream is not binable (all other piece types) this gets called on every BIN.  Then we start an extra test to distinguish between buffer overflow and piece overflow.")

(* ;;; "The external filepointer (GETFILEPTR, SETFILEPTR) is calculated in characters:  the total number of characters in all previous pieces, plus the characters (based on the offset) in the current piece.")

    (DECLARE (LOCALVARS . T))
    (LET ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
          (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (if (ffetch (STREAM BINABLE) of TSTREAM)
             then 
                  (* ;; "The BIN opcode detected a buffer overflow, move either to the next buffer for this piece, or the next piece. The opcode doesn't  manages only COFFSET, so here we have to figure out what4 PCCHARSOFFSET should have been.  NOTE: PCCHARSOFFSET cannot be changed in the stream unless the STARTINGCOFFSET is also bumped to the COFFSET.")

                  (* ;; "The COFFSET goes from 0 to CBUFFSIZE--when it is = to CBUFSIZE we get an overflow.  That maps to 0 in the next buffer.  When we come here in that case, we haven't actually read that characte.")

                  [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                             of TSTREAM)
                                                                    (ffetch (TEXTSTREAM 
                                                                                   STARTINGCOFFSET)
                                                                       of TSTREAM] 
                                                             (* ; "1-byte characters")
                  (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                      then 
                           (* ;; "Move to next piece.  EOF handled below")

                           (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
                    else 
                         (* ;; "Set up for the next buffer in the same piece. We want to set it for the next unread character. We don't SUB1 because the character hasn't yet been read.")

                         (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                  (CL:IF PC
                      (BIN TSTREAM)
                      (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM))
           else 
                (* ;; 
 "Not binable, more complicated return values.  Opcode kicked out, didn't test for buffer overflow .")

                (CL:WHEN (\ENDOFBUFFERP TSTREAM)

                    (* ;; "Buffer overflow. Installers replace PCCHARSLET")

                    (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                        then (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
                      else (\INSTALL.FILEBUFFER TSTREAM (SUB1 PCCHARSLEFT))))
                (if (NOT PC)
                    then (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM)
                  elseif (ffetch (STREAM BINABLE) of TSTREAM)
                    then (BIN TSTREAM)
                  else (ADD (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)
                            -1)                              (* ; 
                                                      "Where we will be when the operation completes")
                       (SELECTC (PTYPE PC)
                           (FATSTRING.PTYPE 
                                (PROG1 (\GETBASEFAT (ffetch (STREAM CBUFPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           (FATFILE1.PTYPE 
                                (PROG1 (LOGOR (ffetch (PIECE PCHARSET) of PC)
                                              (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                                     (ffetch (STREAM COFFSET) of TSTREAM)))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           (FATFILE2.PTYPE 
                                           (* ;; "This is the most complicated case, because the 2 bytes of a character could be in separate buffers.")

                                (\FATFILE2.CHAR TSTREAM PC NIL))
                           (OBJECT.PTYPE 
                                         (* ;; 
              "Return the object as BIN's result, and make sure we'll go to the next page next time.")

                                         (* ;; 
                    "OBJECTBYTE is for callers (like COMPARETEXT) that can't deal with image objects")

                                         (PROG1 (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ)
                                                                    of TSTREAM)
                                                           'OBJECTBYTE)
                                                    (PCONTENTS PC))
                                             (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                                  1)))
                           (SUBSTREAM.PTYPE                  (* ; "A substream stored as an object")
                                (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                            'SUBSTREAM)))
                           (BINABLE.PTYPES                   (* ; 
                                      "For completeness:  the BINABLE test should have picked it off")
                                (PROG1 (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           NIL])

(\TEXTBIN.NEXT.PIECE
  [LAMBDA (TSTREAM)                                          (* ; "Edited  6-Aug-2022 19:48 by rmk")
                                                             (* ; "Edited  2-Aug-2022 10:57 by rmk")

    (* ;; 
    "Walk over empty pieces. Easier to get them out of the next-chain than out of the piece tree.")

    (LET [(NPC (\NEXT.VISIBLE.PIECE (fetch (TEXTSTREAM PIECE) of TSTREAM]
         (CL:WHEN NPC
             (\INSTALL.PIECE TSTREAM NPC 0)
             NPC)])

(\TEXTPEEKBIN
  [LAMBDA (TSTREAM NOERROR)                                  (* ; "Edited  3-May-2023 15:06 by rmk")
                                                             (* ; "Edited 12-Oct-2022 15:27 by rmk")
                                                             (* ; "Edited  8-Sep-2022 20:24 by rmk")
                                                             (* ; "Edited  9-Aug-2022 10:19 by rmk")
                                                             (* ; "Edited  7-Aug-2022 23:53 by rmk")

    (* ;; "Return the next character (object) without advancing TSTREAM")

    (DECLARE (LOCALVARS . T))
    (LET (ORIGPC BUFFERCHANGED (PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
                (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)       (* ; "See notes at \TEXTBIN")
             [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                        of TSTREAM)
                                                               (ffetch (TEXTSTREAM STARTINGCOFFSET)
                                                                  of TSTREAM])
         (CL:WHEN (\ENDOFBUFFERP TSTREAM)                    (* ; "Buffer overflow.")
             (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                 then (SETQ ORIGPC PC)
                      (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
               else (SETQ BUFFERCHANGED T)
                    (\INSTALL.FILEBUFFER TSTREAM (SUB1 PCCHARSLEFT))))
         (if (NOT PC)
             then (CL:IF NOERROR
                      NIL
                      (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM))
           else (PROG1 (SELECTC (PTYPE PC)
                           (BINABLE.PTYPES 
                                (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                       (ffetch (STREAM COFFSET) of TSTREAM)))
                           (FATFILE1.PTYPE 
                                (LOGOR (ffetch (PIECE PCHARSET) of PC)
                                       (\GETBASEBYTE (ffetch (STREAM CPPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))))
                           (FATFILE2.PTYPE 
                                           (* ;; "This is the most complicated case, because the 2 bytes of a character could be in separate buffers.")

                                (\FATFILE2.CHAR TSTREAM PC T))
                           (OBJECT.PTYPE 
                                         (* ;; 
              "Return the object as BIN's result, and make sure we'll go to the next page next time.")

                                         (* ;; 
                    "OBJECTBYTE is for callers (like COMPARETEXT) that can't deal with image objects")

                                         (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)
                                                    'OBJECTBYTE)
                                             (PCONTENTS PC)))
                           (SUBSTREAM.PTYPE                  (* ; "A substream stored as an object")
                                (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                            'SUBSTREAM)))
                           NIL)

                    (* ;; "If we had to advance, go back to where we were.")

                    (if ORIGPC
                        then (\INSTALL.PIECE TSTREAM ORIGPC (IDIFFERENCE (PLEN ORIGPC)
                                                                   PCCHARSLEFT))
                      elseif BUFFERCHANGED
                        then (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT)))])

(\TEXTBACKFILEPTR
  [LAMBDA (TSTREAM)                                          (* ; "Edited  3-May-2023 15:05 by rmk")
                                                             (* ; "Edited 12-Oct-2022 15:26 by rmk")
                                                             (* ; "Edited 28-Mar-94 15:32 by jds")

    (* ;; "BACKFILEPTR of a text stream backs over a character.")

    (LET ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
          (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)
             [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                        of TSTREAM)
                                                               (ffetch (TEXTSTREAM STARTINGCOFFSET)
                                                                  of TSTREAM])
         (CL:WHEN (if (\STARTOFPIECEP TSTREAM PCCHARSLEFT)
                      then (CL:WHEN (SETQ PC (\PREV.VISIBLE.PIECE PC))
                                                             (* ; 
                                                    "Back up to last char of previous piece, if any.")
                               (\INSTALL.PIECE TSTREAM PC (SUB1 (PLEN PC)))
                               T)
                    elseif (AND (MEMB (PTYPE PC)
                                      FILE.PTYPES)
                                (\STARTOFBUFFERP TSTREAM))
                      then 
                           (* ;; "Must be a buffered file, needs to back up. O")

                           (\INSTALL.FILEBUFFER TSTREAM (ADD1 PCCHARSLEFT))
                    else 
                         (* ;; "This piece can be backed up at least one character ")

                         (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                              (CL:IF (EQ (PTYPE PC)
                                         FATFILE2.PTYPE)
                                  -2
                                  -1)))

             (* ;; "We have now backed up to a piece that has at least one character. We are supposed to return the character we backed over")

             (SELECTC (PTYPE PC)
                 (BINABLE.PTYPES 
                      (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                             (ffetch (STREAM COFFSET) of TSTREAM)))
                 (FATFILE1.PTYPE 
                      (LOGOR (ffetch (PIECE PCHARSET) of PC)
                             (\GETBASEBYTE (ffetch (STREAM CPPTR) of TSTREAM)
                                    (ffetch (STREAM COFFSET) of TSTREAM))))
                 (FATSTRING.PTYPE 
                      (\GETBASEFAT (ffetch (STREAM CBUFPTR) of TSTREAM)
                             (ffetch (STREAM COFFSET) of TSTREAM)))
                 (FATFILE2.PTYPE                             (* ; 
                                                          "The 2 bytes could cross a buffer boundary")
                      (\FATFILE2.CHAR TSTREAM PC T))
                 (OBJECT.PTYPE (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)
                                          'OBJECTBYTE)
                                   (PCONTENTS PC)))
                 (SUBSTREAM.PTYPE 
                      (HELP 'SUBSTREAM)
                      (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                  'SUBSTREAM)))
                 (SHOULDNT)))])

(\TEXTOUTCHARFN
  [LAMBDA (CH STREAM)                                        (* ; "Edited 31-May-91 13:59 by jds")
    (\INSERTCH CH (fetch (TEXTOBJ TEXTLEN) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
           (fetch (TEXTSTREAM TEXTOBJ) of STREAM])

(\INSTALL.FILEBUFFER
  [LAMBDA (TSTREAM PCCHARSLEFT)                              (* ; "Edited  8-Sep-2022 14:17 by rmk")
                                                             (* ; "Edited  6-Sep-2022 17:15 by rmk")
                                                             (* ; "Edited 21-Aug-2022 22:35 by rmk")
                                                             (* ; "Edited  7-Aug-2022 20:35 by rmk")
                                                             (* ; "Edited 31-Jul-2022 20:09 by rmk")

    (* ;; "Sets up the buffer and buffering parameters ofTSTREAM and the underlying PFILE of its piece so that the next BIN wlil return the character PCCHARSLEFT away from the end of the piece.  PCCHARSLEFT is piecewise, STARTINGCOFFSET and other buffering parameters are bufferwise.")

    (* ;; "The buffer may overflow even when the piece itself is not exhausted.")

    (* ;; "Called on buffer overflow when the piece itself is not exhausted.  .")

    (* ;; "A binable stream doesn't track the number of 1-byte chars left in this piece, but COFFSET minus STARTINGCOFFSET enables the PCCHARSLEFT to be determined at the end of the buffer.   ")

    (LET* ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
           (PFILE (PCONTENTS PC))
           (PLEN (PLEN PC))
           PCBYTEOFFSET PCBYTELENGTH CBUFSIZE)
          (CL:UNLESS (MEMB (PTYPE PC)
                           FILE.PTYPES)
                 (HELP "FILE BUFFER FOR STRING PIECE?" PC))
          (CL:UNLESS (AND PFILE (\GETSTREAM PFILE 'INPUT T)) (* ; 
                                                   "The file was closed for some reason;  reopen it.")
              (SETQ PFILE (\TEDIT.REOPEN.STREAM TSTREAM PFILE)))
          (CL:UNLESS PCCHARSLEFT                             (* ; "First character of the piece")
              (SETQ PCCHARSLEFT PLEN))

          (* ;; "PCBYTESLEFT is the number of bytes already covered so that PCCHARSLEFT characters are left in the piece..")

          (if (EQ FATFILE2.PTYPE (PTYPE PC))
              then (SETQ PCBYTEOFFSET (UNFOLD (IDIFFERENCE PLEN PCCHARSLEFT)
                                             2))
                   (SETQ PCBYTELENGTH (UNFOLD PLEN 2))
            else (SETQ PCBYTEOFFSET (IDIFFERENCE PLEN PCCHARSLEFT))
                 (SETQ PCBYTELENGTH PLEN))

          (* ;; "Set PFILE to the byte position of the next character of this piece, establishing the PFILE buffer, offset")

          (\SETFILEPTR PFILE (IPLUS (ffetch (PIECE PFPOS) of PC)
                                    PCBYTEOFFSET))
          (\PEEKBIN PFILE T)

          (* ;; 
    "PFILE's buffer parameters should now be good; steal the fields needed to simulate that stream. ")

          (* ;; 
   "The TSTREAM buffersize is reduced so that it only covers bytes that remain in the current piece.")

          (SETQ CBUFSIZE (IMIN (IPLUS (ffetch (STREAM COFFSET) of PFILE)
                                      (IDIFFERENCE PCBYTELENGTH PCBYTEOFFSET))
                               (ffetch (STREAM CBUFSIZE) of PFILE)))
          (freplace (STREAM CPPTR) of TSTREAM with (ffetch (STREAM CPPTR) of PFILE))
          (freplace (STREAM CBUFSIZE) of TSTREAM with CBUFSIZE)
          (freplace (STREAM COFFSET) of TSTREAM with (ffetch (STREAM COFFSET) of PFILE))
          (freplace (TEXTSTREAM STARTINGCOFFSET) of TSTREAM with (fetch (STREAM COFFSET) of TSTREAM))
          (freplace (TEXTSTREAM PCCHARSLEFT) of TSTREAM with PCCHARSLEFT])

(\TEXTBOUT
  [LAMBDA (TSTREAM CHAR)                                     (* ; "Edited 23-Feb-2023 15:26 by rmk")
                                                             (* ; "Edited 12-Aug-2022 23:26 by rmk")
                                                             (* ; "Edited 10-May-93 16:59 by jds")

    (* ;; "Do BOUT to a text stream, which is an insertion at the caret.")

    (* ;; "ADD1 to convert from %"byte%" indexing to TEDIT selection-indexing.")

    (* ;; "Seems foolish to use \TEXTGETFILEPTR here to map from the current piece to the absolute character index, just so \INSERTCH can map backwards from the character number to the piece.")

    (CL:UNLESS (\CHARCODEP CHAR)
           (\ILLEGAL.ARG CHAR))
    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          (CH# (ADD1 (\TEXTGETFILEPTR TSTREAM)))
          INSERTPC WINDOW)
         (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ) (* ; 
                                                      "Maybe should cause an error--stream not open?")
             (CL:WHEN (SETQ WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                    (\TEDIT.MARK.LINES.DIRTY TEXTOBJ CH# CH#))
             (CL:WHEN (SETQ INSERTPC (\INSERTCH CHAR CH# TEXTOBJ))

                 (* ;; "We inserted 1 char.  Whether or not we introduced a new piece or extended an old one, we want to be positioned at the first character of the next piece. ")

                 (\INSTALL.PIECE TSTREAM (ffetch (PIECE NEXTPIECE) of INSERTPC)
                        0)
                 (CL:WHEN WINDOW
                     (TEDIT.UPDATE.SCREEN TEXTOBJ)
                     (\INSTALL.PIECE TSTREAM (ffetch (PIECE NEXTPIECE) of INSERTPC)
                            0))))                            (* ; 
                                        "Reformatting advances the stream, go back to the insertion.")
         CHAR])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \FATFILE2.CHAR MACRO [(TSTREAM PC DONTADVANCE)

                                (* ;; "DONTADVANCE is T for calls from \TEXTPEEKBIN and \TEXTBACKFILEPTR, NIL for calls from \TEXTBIN.  In each case, the streams PCCHARSLEFT is set to what it should be AFTER this operation.  So, in the buffer-overflow case, we have to back up 1 character (2 bytes) in the SETFILEPTR so we can read the proper character. ")

                                (if (IGEQ (IDIFFERENCE (ffetch (STREAM CBUFSIZE) of TSTREAM)
                                                 (ffetch (STREAM COFFSET) of TSTREAM))
                                          2)
                                    then 
                                         (* ;; "Not so bad if both bytes are in the same buffer.")

                                         (PROG1 [LOGOR (UNFOLD (\GETBASEBYTE (ffetch (STREAM CBUFPTR)
                                                                                of TSTREAM)
                                                                      (ffetch (STREAM COFFSET)
                                                                         of TSTREAM))
                                                              256)
                                                       (\GETBASEBYTE (ffetch (STREAM CBUFPTR)
                                                                        of TSTREAM)
                                                              (ADD1 (ffetch (STREAM COFFSET)
                                                                       of TSTREAM]
                                             (CL:UNLESS DONTADVANCE
                                                 (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                                      2)))
                                  else 

                                 (* ;; "Otherwise, we have to cross a buffer boundary.  We do this by setting up the underlying file to the right position, read 2-byte word from there, and then reinstall the buffering parameters in TSTREAM, either to the new position or the old (DONTADVANCE).")

                                       (LET ((PFILE (PCONTENTS PC))
                                             (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT)
                                                             of TSTREAM)))
                                            (\SETFILEPTR PFILE
                                                   (IPLUS (ffetch (PIECE PFPOS) of PC)
                                                          (UNFOLD (IDIFFERENCE (PLEN PC)
                                                                         (CL:IF DONTADVANCE
                                                                             PCCHARSLEFT
                                                                             (ADD1 PCCHARSLEFT)))
                                                                 2)))

                                            (* ;; 
        "Return the 2-byte character after reverting to the previous (post-operation) configuration.")

                                            (PROG1 (\WIN PFILE)
                                                   (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT])

(PUTPROPS \ENDOFPIECEP MACRO ((TSTREAM PCLEFT)
                              (EQ 0 PCLEFT)))

(PUTPROPS \STARTOFPIECEP MACRO ((TSTREAM PCLEFT)
                                (IEQP (PLEN (ffetch (TEXTSTREAM PIECE) of TSTREAM))
                                      PCLEFT)))

(PUTPROPS \ENDOFBUFFERP MACRO ((TSTREAM)
                               (IGEQ (ffetch (STREAM COFFSET) of TSTREAM)
                                     (ffetch (STREAM CBUFSIZE) of TSTREAM))))

(PUTPROPS \STARTOFBUFFERP MACRO ((TSTREAM)
                                 (ILEQ (ffetch (STREAM COFFSET) of TSTREAM)
                                       (ffetch (TEXTSTREAM STARTINGCOFFSET) of TSTREAM))))
)
)



(* ;; "External format functions:  equivalent to BIN-level")

(DEFINEQ

(\TEXTSTREAM.OUTCHARFN
  [LAMBDA (STREAM CHARCODE)                                  (* ; "Edited 22-Jul-2022 19:05 by rmk")
                                                            (* ; "Edited 12-Oct-2021 15:38 by rmk:")

    (* ;; "OUTCCODEFN for TEXTSTREAM  -- BOUTs the  16-bit CHARCODE, because TEdit streams deal in complete charcodes rather than bytes (via \TEXTBOUT).  Updates the CHARPOSITION of the stream, which is used by some code to decide things.")

    (* ;; "\TEXTOUTCHARFN has ")
                                                             (* (\INSERTCH CH (fetch
                                                             (TEXTOBJ TEXTLEN) of
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
    (COND
       ((EQ CHARCODE (CHARCODE EOL))
        (\TEXTBOUT STREAM (CHARCODE CR))
        (freplace (STREAM CHARPOSITION) of STREAM with 0))
       (T (\TEXTBOUT STREAM CHARCODE)
          (freplace (STREAM CHARPOSITION) of STREAM with (PROGN 
                                                             (* ; "Ugh.  Don't overflow")
                                                                (IPLUS16 (ffetch (STREAM CHARPOSITION
                                                                                        )
                                                                            of STREAM)
                                                                       1])

(\TEXTSTREAM.INCCCODEFN
  [LAMBDA (STREAM COUNTP)                                    (* ; "Edited  7-Aug-2022 22:25 by rmk")
                                                             (* ; "Edited 22-Jul-2022 18:47 by rmk")
                                                            (* ; "Edited  6-Aug-2021 15:57 by rmk:")

(* ;;; "Returns a 16 bit character code.  SHIFTEDCSET is STREAM's char set left shifted 8.")

(* ;;; "If COUNTP is non-NIL, the variable *BYTECOUNTER* is set freely to 1, since we already read 1 16-bit %"byte%".")

    (DECLARE (USEDFREE *BYTECOUNTER*))
    (CL:WHEN COUNTP (SETQ *BYTECOUNTER* 1))
    (BIN STREAM])

(\TEXTSTREAM.PEEKCCODEFN
  [LAMBDA (STREAM NOERROR)                                   (* ; "Edited 22-Jul-2022 18:48 by rmk")
                                                            (* ; "Edited 21-Jun-2021 23:44 by rmk:")
    (\TEXTPEEKBIN STREAM NOERROR])

(\TEXTSTREAM.BACKCCODEFN
  [LAMBDA (STREAM COUNTP)                                    (* ; "Edited 22-Jul-2022 19:01 by rmk")
                                                             (* ; "Edited 19-Jul-2022 17:12 by rmk")
                                                            (* ; "Edited 13-Aug-2021 14:08 by rmk:")
    (DECLARE (USEDFREE *BYTECOUNTER*))
    (CL:WHEN COUNTP (SETQ *BYTECOUNTER* -1))
    (\TEXTBACKFILEPTR STREAM])

(\TEXTSTREAM.OUTCHARFN
  [LAMBDA (STREAM CHARCODE)                                  (* ; "Edited 22-Jul-2022 19:05 by rmk")
                                                            (* ; "Edited 12-Oct-2021 15:38 by rmk:")

    (* ;; "OUTCCODEFN for TEXTSTREAM  -- BOUTs the  16-bit CHARCODE, because TEdit streams deal in complete charcodes rather than bytes (via \TEXTBOUT).  Updates the CHARPOSITION of the stream, which is used by some code to decide things.")

    (* ;; "\TEXTOUTCHARFN has ")
                                                             (* (\INSERTCH CH (fetch
                                                             (TEXTOBJ TEXTLEN) of
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
    (COND
       ((EQ CHARCODE (CHARCODE EOL))
        (\TEXTBOUT STREAM (CHARCODE CR))
        (freplace (STREAM CHARPOSITION) of STREAM with 0))
       (T (\TEXTBOUT STREAM CHARCODE)
          (freplace (STREAM CHARPOSITION) of STREAM with (PROGN 
                                                             (* ; "Ugh.  Don't overflow")
                                                                (IPLUS16 (ffetch (STREAM CHARPOSITION
                                                                                        )
                                                                            of STREAM)
                                                                       1])

(\TEXTSTREAM.FORMATBYTESTREAM
  [LAMBDA (STREAM BYTESTREAM)                               (* ; "Edited 24-Jun-2021 16:47 by rmk:")
    (REPLACE (STREAM CHARSET) OF BYTESTREAM WITH (FETCH (STREAM CHARSET) OF STREAM])
)



(* ;; "High-level stream operations")

(DEFINEQ

(COPYTEXTSTREAM
  [LAMBDA (ORIGINAL CROSSCOPY)                               (* ; "Edited  7-May-2023 11:42 by rmk")
                                                             (* ; "Edited 25-Apr-2023 18:07 by rmk")
                                                             (* ; "Edited 18-Mar-2023 21:15 by rmk")
                                                             (* ; 
                                                        "Edited 24-Apr-95 12:02 by sybalsky:mv:envos")

    (* ;; "Given a stream, textobj or window, returns a new textstream with the same contents.  If CROSSCOPY then strings will really be allocated providing copies of the text else the fileptrs still will be aliases as in the rest of TEDIT.")

    (LET ((TEXTOBJ (TEXTOBJ ORIGINAL))
          NEWSTREAM NEWTEXTOBJ)                              (* ; 
                                   "Create an empty textstream into which the pieces can be hammered")
         (SETQ NEWSTREAM (OPENTEXTSTREAM NIL NIL NIL NIL (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ)))
         (SETQ NEWTEXTOBJ (TEXTOBJ NEWSTREAM))
         (for PC (LASTPIECE _ (\LASTPIECE NEWTEXTOBJ)) inpieces (\FIRSTPIECE TEXTOBJ)
            do (\INSERTPIECE (\TEDIT.COPYPIECE PC TEXTOBJ NEWTEXTOBJ)
                      LASTPIECE NEWTEXTOBJ))
         (replace (TEXTOBJ FORMATTEDP) of NEWTEXTOBJ with (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ))
         (replace (TEXTOBJ DEFAULTCHARLOOKS) of NEWTEXTOBJ with (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                                   of TEXTOBJ))
         (replace (TEXTOBJ FMTSPEC) of NEWTEXTOBJ with (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ))
         (replace (TEXTOBJ TXTRTBL) of NEWTEXTOBJ with (fetch (TEXTOBJ TXTRTBL) of TEXTOBJ))
         (replace (TEXTOBJ TXTWTBL) of NEWTEXTOBJ with (fetch (TEXTOBJ TXTWTBL) of TEXTOBJ))
         (replace (TEXTOBJ TXTSTYLESHEET) of NEWTEXTOBJ with (fetch (TEXTOBJ TXTSTYLESHEET)
                                                                of TEXTOBJ))
         (replace (TEXTOBJ TXTPARALOOKSLIST) of NEWTEXTOBJ with (fetch (TEXTOBJ TXTPARALOOKSLIST)
                                                                   of TEXTOBJ))
         (replace (TEXTOBJ TXTCHARLOOKSLIST) of NEWTEXTOBJ with (fetch (TEXTOBJ TXTCHARLOOKSLIST)
                                                                   of TEXTOBJ))
         (replace (TEXTOBJ MENUFLG) of NEWTEXTOBJ with (fetch (TEXTOBJ MENUFLG) of TEXTOBJ))
         NEWSTREAM])

(OPENTEXTSTREAM
  [LAMBDA (TEXT WINDOW START END PROPS)

    (* ;; "Edited  5-Jun-2023 22:44 by rmk")

    (* ;; "Edited  7-May-2023 22:56 by rmk")

    (* ;; "Edited  1-May-2023 08:39 by rmk")

    (* ;; "Edited 26-Apr-2023 14:37 by rmk")

    (* ;; "Edited 31-Jan-2022 17:25 by rmk: A string TEXT is converted here to a stream")

    (* ;; "Edited  4-May-93 14:38 by jds")

    (* ;; 
    "Create a text-type STREAM to describe TEXT.  Optionally, connect that to WINDOW for display.")

    (LET* ([WAS-TEXTSTREAM (AND (type? STREAM TEXT)
                                (type? TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TEXT]
           [TEXTOBJ (COND
                       (WAS-TEXTSTREAM                       (* ; 
                                 "If the guy gave us a text stream to edit, use its TEXTOBJ as ours.")
                              (create TEXTOBJ reusing (fetch (TEXTSTREAM TEXTOBJ) of TEXT)
                                                    HINTPC _ NIL LINES _ NIL))
                       ((type? TEXTOBJ TEXT)
                        (create TEXTOBJ using TEXT HINTPC _ NIL LINES _ NIL))
                       (T (create TEXTOBJ]
           (TEDIT.GET.FINISHEDFORMS NIL)
           (PROPS (APPEND PROPS TEDIT.DEFAULT.PROPS (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ)))
           [TEXTOBJ.WINDOW.VALID (AND WINDOW (EQ WINDOW (\TEDIT.PRIMARYW TEXTOBJ))
                                      (EQ TEXTOBJ (WINDOWPROP WINDOW 'TEXTOBJ]
           SEL TSTREAM OTEXTOBJ PROP)
          (replace (TEXTOBJ \WINDOW) of TEXTOBJ with (AND WINDOW (LIST WINDOW)))
                                                             (* ; 
                                                     "Some incoming objects want to know the window.")
          (replace (TEXTOBJ PANES) of TEXTOBJ with (CONS (create PANE
                                                                PWINDOW _ WINDOW)))
          (for PROPNAME in PROPS by (CDDR PROPNAME) as PROPVAL in (CDR PROPS)
             by (CDDR PROPVAL) do (TEXTPROP TEXTOBJ PROPNAME PROPVAL))
                                                             (* ; 
                                            "Save the PROPS for later people who'd like to know them")
          (OPENTEXTSTREAM.DEFAULTLOOKS TEXTOBJ PROPS)
          [COND
             (WAS-TEXTSTREAM                                 (* ; 
                                                          "We got a TEXTSTREAM to edit;  just use it")
                    (SETQ OTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TEXT))
                    (SETQ TSTREAM TEXT)
                    (for SELN in (\TEDIT.COLLECTSELS TEXTOBJ)
                       do 
                          (* ;; "Make all the selections point to the CURRENT textobj!")

                          (COND
                             ((EQ OTEXTOBJ (GETSEL SELN SELTEXTOBJ))
                              (SETSEL SELN SELTEXTOBJ TEXTOBJ))
                             (T (SETSEL SELN SET NIL)))
                          (SETSEL SELN ONFLG NIL))
                    (replace (TEXTSTREAM TEXTOBJ) of TSTREAM with TEXTOBJ)
                    (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
                    (replace (TEXTOBJ EDITFINISHEDFLG) of TEXTOBJ with NIL)
                                                             (* ; "Mark the edit incomplete.")
                    (replace (TEXTOBJ \DIRTY) of TEXTOBJ with NIL)
                                                             (* ; "And mark it not changed.")
                    )
             ((type? TEXTOBJ TEXT)                           (* ; 
                       "We got a TEXTOBJ to edit; fill in the stream, since it might have been GC'd.")
              (SETQ TSTREAM (create TEXTSTREAM
                                   TEXTOBJ _ TEXTOBJ))
              (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
              (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM)))
             (T                                              (* ; 
                                "Otherwise, create a TEXTSTREAM to describe the text we're editing.-")
                (CL:WHEN (AND TEXT (OR (LITATOM TEXT)
                                       (STRINGP TEXT)
                                       (CL:PATHNAMEP TEXT))) (* ; "rmk: Strings are now file names")
                    [SETQ TEXT (OPENSTREAM TEXT 'INPUT 'OLD
                                      `((TYPE TEXT)
                                        (FORMAT ,(LISTGET PROPS 'FORMAT])
                (SETQ TSTREAM (create TEXTSTREAM
                                     TEXTOBJ _ TEXTOBJ))
                (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
                (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM))
                (TEDIT.BUILD.PCTB TEXT TEXTOBJ START END (OR (LISTGET PROPS 'CLEARGET)
                                                             (LISTGET PROPS 'PLAINTEXT]
          (replace (TEXTOBJ TXTREADONLY) of TEXTOBJ with (LISTGET PROPS 'READONLY))
          (replace (TEXTOBJ TXTTERMSA) of TEXTOBJ with (AND (SETQ PROP (LISTGET PROPS 'TERMTABLE))
                                                            (fetch TERMSA of PROP)))
          (replace (TEXTOBJ TXTRTBL) of TEXTOBJ with (LISTGET PROPS 'READTABLE))
          (replace (TEXTOBJ TXTWTBL) of TEXTOBJ with (LISTGET PROPS 'BOUNDTABLE))
          (CL:WHEN (LISTGET PROPS 'PAGEFORMAT)               (* ; 
                                                  "Impose the default page formatting, if specified.")
              (TEDIT.PAGEFORMAT TEXTOBJ (LISTGET PROPS 'PAGEFORMAT)))
          (for S in (\TEDIT.COLLECTSELS TEXTOBJ) when S do (SETSEL S SELTEXTOBJ TEXTOBJ))
          (SETQ SEL (fetch (TEXTOBJ SEL) of TEXTOBJ))
          (SETQ PROP (LISTGET PROPS 'SEL))                   (* ; "Initial Selection, if any.")
          [COND
             ((EQ PROP 'DON'T)                               (* ; 
                                          "A SEL prop of DON'T means don't make an initial selection")
              (SETSEL SEL SET NIL))
             ((type? SELECTION PROP)                         (* ; 
                                               "We came in with an explicit initial sel.  Set it up.")
              (\COPYSEL PROP SEL)
              (SETSEL SEL SET T)
              (SETSEL SEL SELTEXTOBJ TEXTOBJ))
             ((AND (GETSEL SEL SET)
                   (NOT PROP))                               (* ; 
                                         "If we came into this with a valid selection, highlight it.")
              (SETSEL SEL SELTEXTOBJ TEXTOBJ))
             (T (if (LISTP PROP)
                    then (with SELECTION SEL (SETQ CH# (CAR PROP))
                               (SETQ DCH (CADR PROP))
                               (SETQ CHLIM (IPLUS (CAR PROP)
                                                  (CADR PROP)))
                               (SETQ POINT 'LEFT)
                               (SETQ SELKIND 'CHAR)
                               (SETQ SELTEXTOBJ TEXTOBJ))
                  else 
                       (* ;; "No selection specified:  Default start is a point selection that puts the caret before the first character.")

                       (TEDIT.MAKEPOINT SEL (OR PROP 1)
                              'LEFT))
                (SETSEL SEL SET (NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ]
          (replace (TEXTOBJ CARETLOOKS) of TEXTOBJ
             with (if (GETSEL SEL SET)
                      then                                   (* ; 
                                                  "An initial selection implies initial caret looks.")
                           (\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ SEL)
                    else (\TEDIT.UNIQUIFY.CHARLOOKS (\TEDIT.CARETLOOKS.VERIFY TEXTOBJ
                                                           (fetch (TEXTOBJ DEFAULTCHARLOOKS)
                                                              of TEXTOBJ))
                                TEXTOBJ)))
          (replace (TEXTOBJ CARET) of TEXTOBJ with (create TEDITCARET
                                                          TCCARETDS _ (AND WINDOW (WINDOWPROP
                                                                                   WINDOW
                                                                                   'DSP))
                                                          TCFORCEUP _ T))
          (\INSTALL.PIECE TSTREAM (\FIRSTPIECE TEXTOBJ)
                 0)                                          (* ; 
                                                      "Set the file ptr to 0 so that looks are good.")
          [COND
             ((AND WINDOW (NOT TEXTOBJ.WINDOW.VALID))        (* ; 
                                                         "Only if there's a window to display it in:")
              (replace (TEXTOBJ \WINDOW) of TEXTOBJ with NIL)(* ; 
                                                   "Set up the window, and display the initial text.")
              (\TEDIT.WINDOW.SETUP WINDOW TEXTOBJ TSTREAM PROPS))
             ((LISTGET PROPS 'PROMPTWINDOW)

              (* ;; "There is no window for the session, but he has passed in a promptwindow to use, install it in the textobj")

              (replace (TEXTOBJ PROMPTWINDOW) of TEXTOBJ with (LISTGET PROPS 'PROMPTWINDOW]
          TSTREAM])

(OPENTEXTSTREAM.DEFAULTLOOKS
  [LAMBDA (TEXTOBJ PROPS)                                    (* ; "Edited 26-Apr-2023 14:29 by rmk")

    (* ;; 
 "The default looks must be created before the first piece, so that they can provide field-defaults.")

    (LET (FONT CHARLOOKS PARALOOKS)

         (* ;; 
 "Find the default font for this session -- either what the guy tells us, or his global default font")

         (SETQ FONT (LISTGET PROPS 'FONT))
         (SETQ CHARLOOKS (LISTGET PROPS 'LOOKS))
         (SETQ CHARLOOKS (OR (AND CHARLOOKS (\TEDIT.PARSE.CHARLOOKS.LIST CHARLOOKS NIL TEXTOBJ))
                             (AND (type? CHARLOOKS FONT)
                                  FONT)
                             (AND FONT (CHARLOOKS.FROM.FONT (FONTCREATE FONT)))
                             (CHARLOOKS.FROM.FONT DEFAULTFONT)))
         (SETQ CHARLOOKS (\TEDIT.UNIQUIFY.CHARLOOKS CHARLOOKS TEXTOBJ))
         (SETQ PARALOOKS (\TEDIT.UNIQUIFY.PARALOOKS (\TEDIT.PARSE.PARALOOKS.LIST
                                                     (OR (LISTGET PROPS 'PARALOOKS)
                                                         (create FMTSPEC using TEDIT.DEFAULT.FMTSPEC)
                                                         ))
                                TEXTOBJ))
         (replace (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ with CHARLOOKS)
         (replace (TEXTOBJ FMTSPEC) of TEXTOBJ with PARALOOKS])

(REOPENTEXTSTREAM
  [LAMBDA (STREAM)                                           (* ; "Edited 31-May-91 14:18 by jds")
    (replace (STREAM ACCESS) of STREAM with 'BOTH)
    (replace (STREAM BINABLE) of STREAM with T)
    (replace (STREAM STRMBINFN) of STREAM with (FUNCTION \TEXTBIN))
    (replace (STREAM STRMBOUTFN) of STREAM with (FUNCTION \TEXTBOUT))
    STREAM])

(TEDIT.STREAMCHANGEDP
  [LAMBDA (STREAM RESET?)                                    (* ; "Edited 31-May-91 13:57 by jds")
    (PROG1 (fetch (TEXTOBJ \DIRTY) of (TEXTOBJ STREAM))
        (COND
           (RESET? (replace (TEXTOBJ \DIRTY) of (TEXTOBJ STREAM) with NIL))))])

(TEXTSTREAMP
  [LAMBDA (STREAM)                                           (* jds " 3-Apr-84 14:34")
                                                             (* Returns the stream if it is a text 
                                                             stream, else NIL)
    (AND (STREAMP STREAM)
         (type? TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
         STREAM])

(TXTFILE
  [LAMBDA (TEXTOBJ)                                          (* ; "Edited 31-May-91 13:58 by jds")
                                                             (* This function is for compiled 
                                                             access to the TXTFILE field in 
                                                             RESETSAVE expressions)
    (fetch (TEXTOBJ TXTFILE) of TEXTOBJ])

(\TEDIT.REOPEN.STREAM
  [LAMBDA (TSTREAM PIECESTREAM)                              (* ; "Edited 15-Sep-2022 22:56 by rmk")
                                                             (* ; "Edited 11-Jun-99 15:12 by rmk:")
                                                             (* ; "Edited 15-Apr-93 15:53 by jds")

    (* ;; "Re-open the backing file stream, and propogate the change thru the entire piece table.  Also, if TXTFILE is set to the closed stream, fill it in as well.  If there is a reopen operation that simply smashes the existing stream-datum, we wouldn't have to do the sweep.")

    (LET ([NEWSTREAM (OPENSTREAM PIECESTREAM 'INPUT NIL `((TYPE TEXT)
                                                          (FORMAT ,(STREAMPROP PIECESTREAM 
                                                                          :EXTERNAL-FORMAT]
          (TEXTOBJ (TEXTOBJ TSTREAM)))

         (* ;; "Run thru the pieces, correcting any that used this stream to use the new one:")

         (for PC _ (\FIRSTPIECE TEXTOBJ) by (NEXTPIECE PC) while PC when (EQ (PCONTENTS PC)
                                                                             PIECESTREAM)
            do (replace (PIECE PCONTENTS) of PC with NEWSTREAM))

         (* ;; "Check the TXTFILE, and if it uses the closed stream, fix it as well:")

         (CL:WHEN (EQ (fetch (TEXTOBJ TXTFILE) of TEXTOBJ)
                      PIECESTREAM)
             (replace (TEXTOBJ TXTFILE) of TEXTOBJ with NEWSTREAM))

         (* ;; "Return the new value for the stream:")

         NEWSTREAM])

(\TEXTINIT
  [LAMBDA NIL                                                (* ; "Edited  7-Mar-2023 15:01 by rmk")
                                                             (* ; "Edited 28-Aug-2022 22:19 by rmk")
                                                             (* ; "Edited 22-Jul-2022 20:02 by rmk")
                                                             (* ; "Edited  3-Jul-2022 00:34 by rmk")
                                                             (* ; "Edited  5-May-2022 15:12 by rmk")
                                                            (* ; "Edited  7-Oct-2021 08:40 by rmk:")
                                                             (* ; 
                                            "Create the FDEV and STREAM prototypes for TEXT streams.")

    (* ;; "TEXT streams make use of the following STREAM fields:")

    (* ;; "(DEVICE (* FDEV of this guy -- The TEXT device)")

    (* ;; "F1 Number of characters to the end of the current piece")

    (* ;; "F2 Starting offset for the character in this piece end of underlying file's page")

    (* ;; "F3 The TEXTOBJ for this stream")

    (* ;; "F4 LOOKSUPDATEFN")

    (* ;; "F5 The PIECE we're currently inside")

    (* ;; "(FW6 WORD) (* CPAGE for the start of the piece, for BACKFILEPTR)")

    (* ;; "(FW7 WORD) (* COFFSET for the start of the piece, for BACKFILEPTR)")

    (* ;; "(FW8 WORD)")

    [SETQ \TEXTIMAGEOPS (create IMAGEOPS
                               IMAGETYPE _ 'TEXT
                               IMXPOSITION _ (FUNCTION \TEXTDSPXPOSITION)
                               IMYPOSITION _ (FUNCTION \TEXTDSPYPOSITION)
                               IMLEFTMARGIN _ (FUNCTION \TEXTLEFTMARGIN)
                               IMRIGHTMARGIN _ (FUNCTION \TEXTRIGHTMARGIN)
                               IMFONT _ (FUNCTION \TEXTDSPFONT)
                               IMCLOSEFN _ (FUNCTION NILL)
                               IMFONTCREATE _ 'DISPLAY
                               IMLINEFEED _ (FUNCTION \TEXTDSPLINEFEED)
                               IMCHARWIDTH _ (FUNCTION \TEXTDSPCHARWIDTH)
                               IMSTRINGWIDTH _ (FUNCTION \TEXTDSPSTRINGWIDTH)
                               IMSCALE _ (FUNCTION (LAMBDA NIL 1]

    (* ;; "Maybe more functions later. The INCODE and BACK functions possibly need to count.  If \TEXTBACKFILEPTR takes a count variable, the extra level wouldn't be needed.  But INCCODE wants to go through the BIN opcode")

    (MAKE-EXTERNALFORMAT :TEXTSTREAM (FUNCTION \TEXTSTREAM.INCCCODEFN)
           (FUNCTION \TEXTPEEKBIN)
           (FUNCTION \TEXTSTREAM.BACKCCODEFN)
           (FUNCTION \TEXTSTREAM.OUTCHARFN)
           (FUNCTION \TEXTSTREAM.FORMATBYTESTREAM)
           'CR)
    (SETQ \TEXTFDEV (create FDEV
                           DEVICENAME _ 'TEXT
                           RESETABLE _ T
                           RANDOMACCESSP _ T
                           PAGEMAPPED _ NIL
                           GETFILENAME _ (FUNCTION NILL)
                           BIN _ (FUNCTION \TEXTBIN)
                           BOUT _ (FUNCTION \TEXTBOUT)
                           CLOSEFILE _ (FUNCTION \TEXTCLOSEF)
                           OPENFILE _ (FUNCTION \TEXTOPENF)
                           DELETEFILE _ (FUNCTION NILL)
                           DIRECTORYNAMEP _ (FUNCTION NILL)
                           EVENTFN _ (FUNCTION NILL)
                           GENERATEFILES _ (FUNCTION \GENERATENOFILES)
                           GETFILEINFO _ (FUNCTION NILL)
                           HOSTNAMEP _ (FUNCTION NILL)
                           READPAGES _ (FUNCTION NILL)
                           REOPENFILE _ [FUNCTION (LAMBDA (FILE ACCESS RECOG OTHERINFO FDEV STREAM)
                                                    (replace (STREAM ACCESS) of STREAM
                                                       with 'BOTH)
                                                    STREAM]
                           SETFILEINFO _ (FUNCTION NILL)
                           BACKFILEPTR _ (FUNCTION \TEXTBACKFILEPTR)
                           SETFILEPTR _ (FUNCTION \TEXTSETFILEPTR)
                           PEEKBIN _ (FUNCTION \TEXTPEEKBIN)
                           GETEOFPTR _ (FUNCTION \TEXTGETEOFPTR)
                           GETFILEPTR _ (FUNCTION \TEXTGETFILEPTR)
                           EOFP _ (FUNCTION \TEXTEOFP)
                           FDBINABLE _ T
                           FDBOUTABLE _ NIL
                           FDEXTENDABLE _ NIL
                           TRUNCATEFILE _ (FUNCTION NILL)
                           WRITEPAGES _ (FUNCTION NILL)
                           DEFAULTEXTERNALFORMAT _ :TEXTSTREAM))
    (CL:SETF (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN)
           (FUNCTION (LAMBDA (CONDITION)
                       (LET ((STREAM (STREAM-ERROR-STREAM CONDITION)))
                            (COND
                               [(AND (BOUNDP 'ERRORPOS)
                                     (TEXTSTREAMP STREAM))   (* ; 
             "This happened in the error handler, and it happened to a TEdit stream, so try the fix:")
                                (LET ((XCL::RESULT (REOPENTEXTSTREAM STREAM)))
                                     (CL:WHEN XCL::RESULT
                                         (ENVAPPLY (STKNAME ERRORPOS)
                                                (SUBST XCL::RESULT STREAM (STKARGS ERRORPOS))
                                                (STKNTH -1 ERRORPOS ERRORPOS)
                                                ERRORPOS T T))]
                               (*TEDIT-OLD-STREAM-ERROR-HANDLER* 
                                                             (* ; 
                           "Some other kind of stream, so punt to the old handler (if there is one):")
                                      (APPLY* *TEDIT-OLD-STREAM-ERROR-HANDLER* CONDITION])

(\TEXTTTYBOUT
  [LAMBDA (STREAM BYTE)                                      (* ; "Edited 18-Mar-2023 20:08 by rmk")
                                                             (* ; "Edited 31-May-91 14:18 by jds")
                                                             (* Do BOUT to a text stream, which is 
                                                             an insertion at the caret.)
    (PROG ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
          (COND
             ((EQ BYTE ERASECHARCODE)
              (\TEDIT.CHARDELETE TEXTOBJ (fetch (TEXTOBJ SEL) of TEXTOBJ)))
             ((EQ IGNORE.CCE (fetch CCECHO of (\SYNCODE (OR (fetch (TEXTOBJ TXTTERMSA) of TEXTOBJ)
                                                            \PRIMTERMSA)
                                                     BYTE))) (* Nothing, ignore it)
              )
             (T (SELCHARQ BYTE
                     ((EOL CR LF) 
                          (\TEXTBOUT STREAM BYTE)
                          (replace (STREAM CHARPOSITION) of STREAM with 0))
                     (PROGN (\TEXTBOUT STREAM BYTE)
                            (add (fetch (STREAM CHARPOSITION) of STREAM)
                                 1])
)



(* ;; "Low-level generic stream operations")

(DEFINEQ

(\TEXTCLOSEF
  [LAMBDA (TSTREAM)                                          (* ; "Edited 26-Oct-2022 11:17 by rmk")
                                                             (* ; "Edited 22-Aug-2022 14:18 by rmk")
                                                             (* ; "Edited  8-Aug-2022 14:56 by rmk")
                                                             (* ; "Edited 15-Apr-93 16:43 by jds")
                                                             (* ; 
                                                             "Close the files underlying a stream")
    (LET ((TEXTOBJ (TEXTOBJ TSTREAM)))
         (for (PC _ (\FIRSTPIECE TEXTOBJ)) by (NEXTPIECE PC) while PC
            when (AND (MEMB (PTYPE PC)
                            FILE.PTYPES)
                      (PCONTENTS PC)) do (CLOSEF? (PCONTENTS PC)))

         (* ;; "And close the REAL file as well, in case we'd made a local cache.")

         (CLOSEF? (fetch (TEXTOBJ TXTFILE) of TEXTOBJ])

(\TEXTDSPFONT
  [LAMBDA (STREAM NEWFONT)                                   (* ; "Edited  8-Sep-2022 14:16 by rmk")
                                                             (* ; "Edited 31-May-91 14:02 by jds")

    (* ;; "Set the font for a TEdit window.  Need change the caret looks, for character insertion, and the WINDOW's looks, so that TEXEC type-out to the window does the right thing.")

    (LET ((TEXTOBJ (TEXTOBJ STREAM)))
         (PROG1 (fetch (CHARLOOKS CLFONT) of (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ))
             (CL:WHEN NEWFONT                                (* ; 
                                                         "Only do this if there's a new font to set:")
                 (TEDIT.CARETLOOKS STREAM (\GETFONTDESC NEWFONT 'DISPLAY))
                 (CL:WHEN (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)

                     (* ;; "Update the windows, if there are any.")

                     (for WIN in (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) do (DSPFONT NEWFONT WIN)))))])

(\TEXTEOFP
  [LAMBDA (TSTREAM)                                          (* ; "Edited  1-Jun-2023 17:07 by rmk")
                                                             (* ; "Edited 10-Aug-2022 12:41 by rmk")
                                                             (* ; "Edited  5-Aug-2022 16:37 by rmk")
                                                             (* ; "Edited 31-May-91 14:18 by jds")

    (* ;; "Test for EOF on a text stream: At end of a piece, and there's no more visible pieces.")

    (OR (ZEROP (TEXTLEN (TEXTOBJ TSTREAM)))
        (CL:WHEN (\ENDOFBUFFERP TSTREAM)
            [LET ((PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
                 (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)
                     [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                                of TSTREAM)
                                                                       (ffetch (TEXTSTREAM 
                                                                                      STARTINGCOFFSET
                                                                                      ) of TSTREAM])
                 (AND (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                      (NULL (\NEXT.VISIBLE.PIECE (fetch (TEXTSTREAM PIECE) of TSTREAM])])

(\TEXTGETEOFPTR
  [LAMBDA (STREAM)                                           (* ; "Edited 31-May-91 13:58 by jds")
    (fetch (TEXTOBJ TEXTLEN) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM])

(\TEXTGETFILEPTR
  [LAMBDA (TSTREAM)                                          (* ; "Edited  2-Sep-2022 17:45 by rmk")
                                                             (* ; "Edited 30-Jul-2022 00:07 by rmk")
                                                             (* ; "Edited 28-Mar-94 15:32 by jds")

    (* ;; "GETFILEPTR fn for text streams.  Measured in characters (and objects), not 8-bit bytes.")

    (LET ((PC (\NOTLASTPIECEP (ffetch (TEXTSTREAM PIECE) of TSTREAM)
                     (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)))
          PCCHARSLEFT)
         (if PC
             then                                            (* ; "Somewhere inside the document")
                  (SETQ PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM))
                  (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)

                      (* ;; "PCCHARSLEFT may lag. If binable, everything is thin, no need to multiply. We don't change anything in TSTREAM")

                      [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET
                                                                                             )
                                                                                 of TSTREAM)
                                                                        (ffetch (TEXTSTREAM 
                                                                                      STARTINGCOFFSET
                                                                                       ) of TSTREAM])
                  
                  (* ;; "-1 to go from TEDIT-selection character-indexing back to nominal %"byte%" positions. SETFILEPTR goes the other way.")

                  (IPLUS -1 (\PCTOCH PC)
                         (IDIFFERENCE (PLEN PC)
                                PCCHARSLEFT))
           else 
                (* ;; "Lack of a current piece means empty document or end")

                (ffetch (TEXTOBJ TEXTLEN) of (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM])

(\TEXTOPENF
  [LAMBDA (TSTREAM ACCESS ASDF QWER ZXCV)                    (* ; "Edited 22-Aug-2022 15:16 by rmk")
                                                             (* ; "Edited 31-May-91 13:58 by jds")
                                                             (* ; 
                                                             "Return the stream, opened for input")
    (FOR PC _ (\FIRSTPIECE (TEXTOBJ TSTREAM)) BY (fetch (PIECE NEXTPIECE) of PC) WHILE PC
       WHEN [AND (MEMB (ffetch (PIECE PTYPE) of PC)
                       FILE.PTYPES)
                 (EQ NoBits (fetch (STREAM ACCESSBITS) of (fetch (PIECE PCONTENTS) of PC]
       DO (\TEDIT.REOPEN.STREAM TSTREAM (fetch (PIECE PCONTENTS) of PC)))
    TSTREAM])

(\TEXTSETEOF
  [LAMBDA (STREAM EOFPTR)                                    (* ; "Edited 31-May-91 14:19 by jds")
                                                             (* Set the EPAGE/EOFFSET of the stream 
                                                             to be (SUB1 of EOFPTR))
    (replace (STREAM EPAGE) of STREAM with (fetch (BYTEPTR PAGE) of EOFPTR))
    (replace (STREAM EOFFSET) of STREAM with (fetch (BYTEPTR OFFSET) of EOFPTR])

(\TEXTSETFILEPTR
  [LAMBDA (TSTREAM FILEPOS)                                  (* ; "Edited  2-Sep-2022 11:34 by rmk")
                                                             (* ; "Edited  8-Aug-2022 23:55 by rmk")
                                                             (* ; "Edited 22-Apr-93 13:44 by jds")
                                                             (* ; 
                                                             "Sets the file ptr for a text stream.")

    (* ;; "FILEPOS is known to be a positive number.  For other filedevices there is no error if the ptr is set beyond the EOF, and GETFILEPTR will return the new position.  But the length of an input file doesn't change and a BIN at any position after the EOF causes the error.  An output file grows.  Filepos is a %"byte%" position, have to add 1 to get to the notion of character in a Tedit selection.")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          START-OF-PIECE PC CH#)
         (DECLARE (SPECVARS START-OF-PIECE))
         (CL:WHEN (IGREATERP FILEPOS (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                                    "If the fileptr is not within the text, punt. OR: SET IT TO EOF?")
             (\ILLEGAL.ARG FILEPOS))
         (CL:UNLESS (ZEROP (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
             (SETQ CH# (ADD1 FILEPOS))
             (SETQ PC (\CHTOPC CH# TEXTOBJ T))
             (\INSTALL.PIECE TSTREAM PC (- CH# START-OF-PIECE)))])

(\TEXTDSPXPOSITION
  [LAMBDA (STREAM XPOSITION)                                (* ; "Edited  3-Jan-2001 17:27 by rmk:")
                                                  (* ; 
                                     "Edited 24-Oct-88 23:09 by rmk:; Edited 26-Sep-85 16:30 by ajb:")

    (* ;; 
  "Simply returns the XPOSITION of the primary window's display stream, this is a read-only function")

    (LET [(WINDOW (CAR (fetch \WINDOW of (TEXTOBJ STREAM]
         (COND
            (WINDOW (DSPXPOSITION NIL WINDOW))
            (T                                               (* ; 
                                            "If there is no window, estimate from character position")
               (TIMES (CHARWIDTH (CHARCODE SPACE)
                             STREAM)
                      (POSITION STREAM])

(\TEXTDSPYPOSITION
  [LAMBDA (STREAM YPOSITION)                                 (* ; "Edited 31-May-91 13:59 by jds")

         (* Simply returns the XPOSITION of the primary window's display stream, this is a 
         read-only function)

    (LET [(WINDOW (CAR (fetch (TEXTOBJ \WINDOW) of (TEXTOBJ STREAM]
         (IF WINDOW
             THEN (DSPYPOSITION NIL WINDOW)
           ELSE (AND \#DISPLAYLINES (NEQ \CURRENTDISPLAYLINE -1)
                     (DIFFERENCE \#DISPLAYLINES \CURRENTDISPLAYLINE])

(\TEXTLEFTMARGIN
  [LAMBDA (STREAM XPOSITION)                                 (* ; "Edited 31-May-91 14:03 by jds")

(* ;;; "Returns the left margin of the textstream.  This is a read-only function")

    (IF (CAR (fetch (TEXTOBJ \WINDOW) of (TEXTOBJ STREAM)))
        THEN [IPLUS 8 (fetch (FMTSPEC LEFTMAR) of (fetch (TEXTOBJ FMTSPEC) of (TEXTOBJ STREAM]
      ELSE 0])

(\TEXTRIGHTMARGIN
  [LAMBDA (STREAM XPOSITION)                                 (* ; "Edited 31-May-91 14:03 by jds")

(* ;;; "Returns the right margin of the textstream.  This is a read-only function")

    (LET ((TEXTOBJ (TEXTOBJ STREAM)))
         (IF (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
             THEN (LET [(RIGHTMAR (fetch (FMTSPEC RIGHTMAR) of (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ]
                       (IF (ZEROP RIGHTMAR)
                           THEN (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                         ELSE RIGHTMAR))
           ELSE (TIMES (CHARWIDTH (CHARCODE A)
                              STREAM)
                       (LINELENGTH NIL STREAM])

(\TEXTDSPCHARWIDTH
  [LAMBDA (STREAM CHARCODE)                                 (* ; "Edited  9-Feb-99 12:59 by kaplan")
    (CHARWIDTH CHARCODE (DSPFONT NIL STREAM])

(\TEXTDSPSTRINGWIDTH
  [LAMBDA (STREAM STRING)                                   (* ; "Edited  9-Feb-99 13:00 by kaplan")
    (STRINGWIDTH STRING (DSPFONT NIL STREAM])

(\TEXTDSPLINEFEED
  [LAMBDA (STREAM VALUE)
    (FONTPROP (DSPFONT NIL STREAM)
           'HEIGHT])
)



(* ;; "Editing support")

(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ INSERTSTRINGLENGTH 512)


(CONSTANTS (INSERTSTRINGLENGTH 512))
)

(DECLARE%: EVAL@COMPILE 

(PUTPROPS \INSERTCH.EXTENDABLE MACRO [(PREVPC INSERTION INSERTPTYPE)

                                      (* ;; 
                                     "Is INSERTION physcially adjacent to the PCONTENTS of PREVPC ? ")

                                      (AND (EQ INSERTPTYPE (PTYPE PREVPC))
                                           (EQ (ffetch (STRINGP BASE) of INSERTION)
                                               (ffetch (STRINGP BASE) of (PCONTENTS PREVPC)))
                                           (IEQP (IPLUS (PLEN PREVPC)
                                                        (ffetch (STRINGP OFFST) of (PCONTENTS PREVPC)
                                                               ))
                                                 (ffetch (STRINGP OFFST) of INSERTION])

(PUTPROPS \LASTPIECEP MACRO ((PC TOBJ)
                             (EQ PC (ffetch (TEXTOBJ LASTPIECE) of TOBJ))))

(PUTPROPS \NOTLASTPIECEP MACRO (OPENLAMBDA (PC TOBJ)
                                 (CL:UNLESS (EQ PC (ffetch (TEXTOBJ LASTPIECE) of TOBJ))
                                        PC)))
)
)
(DEFINEQ

(\TEDIT.DELETE.SELPIECES
  [LAMBDA (TEXTOBJ FIRSTCHANGEDCHNO NCHARSCHANGED)           (* ; "Edited  3-Jun-2023 22:31 by rmk")
                                                            (* ; "Edited 29-Jan-99 17:28 by kaplan")

    (* ;; "Delete the selected characters.  FIRSTCHANGEDCHNO may be a selection.  If any of the pieces contains an objecting object, nothing is done.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)

        (* ;; "Only delete characters if changes are permitted. ")

        (BTVALIDATE '\TEDIT.DELETE.SELPIECES 'START TEXTOBJ)
        (CL:WHEN (type? SELECTION FIRSTCHANGEDCHNO)
            (SETQ NCHARSCHANGED (GETSEL FIRSTCHANGEDCHNO DCH))
            (SETQ FIRSTCHANGEDCHNO (GETSEL FIRSTCHANGEDCHNO CH#)))
        [PROG ((SELPIECES (\SELPIECES FIRSTCHANGEDCHNO (IPLUS FIRSTCHANGEDCHNO NCHARSCHANGED)
                                 TEXTOBJ))
               PREVPC)
              (CL:WHEN (AND (fetch (SELPIECES SPFIRST) of SELPIECES)
                            (for PC inselpieces SELPIECES always (OBJECT.ALLOWS PC 'DELETE TEXTOBJ)))

                  (* ;; "First deleted piece still points back into the TEXTOBJ sequence")

                  (SETQ PREVPC (PREVPIECE (fetch (SELPIECES SPFIRST) of SELPIECES)))
                  (\DELETEPIECES SELPIECES TEXTOBJ)

                  (* ;; "If the the effect of the deletion is to concatenate a (non-empty) prefix of one paragraph with a (non-empty) suffix of another, propagate the prefix PARALOOKS all the way through to the end of the newly combined paragraph. All the pieces of a paragraph must have the same PARALOOKS.")

                  (CL:WHEN (AND PREVPC (NOT (PPARALAST PREVPC)))
                                                             (* ; "Retained a non-empty prefix")
                      (freplace (TEXTOBJ \DIRTY) of TEXTOBJ with T)
                      (for PC (PPLOOKS _ (PPARALOOKS PREVPC)) inpieces (NEXTPIECE PREVPC)
                         do 
                            (* ;; 
                        "(NEXTPIECE PREVPC) is the first retained piece linked in after the deletion")

                            (replace (PIECE PPARALOOKS) of PC with PPLOOKS) repeatuntil (PPARALAST
                                                                                         PC)))
                  (BTVALIDATE '\TEDIT.DELETE.SELPIECES 'END TEXTOBJ)

                  (* ;; "")

                  (* ;; 
                  "The pieces are now properly linked with the proper looks.  Now for the history:")

                  (\TEDIT.HISTORYADD TEXTOBJ
                         (create TEDITHISTORYEVENT
                                THACTION _ :Delete
                                THCH# _ FIRSTCHANGEDCHNO
                                THLEN _ NCHARSCHANGED
                                THDELETEDPIECES _ SELPIECES)))])])

(\SETUPGETCH
  [LAMBDA (CH# TEXTOBJ)                                      (* ; "Edited 22-Aug-2022 13:04 by rmk")
                                                             (* ; "Edited 10-Aug-2022 17:20 by rmk")
                                                             (* ; "Edited  8-Aug-2022 15:07 by rmk")
                                                             (* ; "Edited 31-Jul-2022 21:27 by rmk")
                                                             (* ; "Edited 14-Apr-93 17:14 by jds")

(* ;;; "Set up TEXTOBJ so that the next \GETCH will retrieve character # CH#")

    (* ;; "NB that 1st char in the textobj is #1.")

    (* ;; "NOBODY CALLS IT WITH A PIECE.  CALLS |INSTALL.PIECE INSTEAD")

    (COND
       ((TYPE? PIECE CH#)
        (HELP "\SETUPGETCH CALLED WITH PIECE")
        (\INSTALL.PIECE (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
               CH# 0))
       (T (LET (START-OF-PIECE PC)
               (DECLARE (SPECVARS START-OF-PIECE))
               (SETQ PC (\CHTOPC CH# TEXTOBJ T))
               (\INSTALL.PIECE (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
                      PC
                      (- CH# START-OF-PIECE])

(\INSERTCH
  [LAMBDA (CH CH# TEXTOBJ)                                   (* ; "Edited 25-May-2023 09:14 by rmk")
                                                             (* ; "Edited 23-May-2023 22:44 by rmk")
                                                             (* ; "Edited 25-Oct-2022 12:48 by rmk")

    (* ;; "This inserts CH (a character code or string) into the text just in front of character CH#. After execution the first character of CH will be CH# in the text, the previous CH# char is at CH#+ (NCHAR CH).")

    (* ;; "This is optimized for the common case that the next character to be inserted is at the position one beyond the position of the previous inserted character.")

    (* ;; "   1.  \INSERTCH.INSERTION allocates a string to contain the new character, by chomping the next character from the TEXTOBJ's INSERTSTRING resource.")

    (* ;; "    2.  The insertion will go into a piece at position CH#, and this stores that piece in the HINTPC field of the TEXTOBJ, together with its starting position.  If the next insertion comes immediately have that piece, \CHTOPC can find that piece without searching the BTREE. ")

    (* ;; "     3.  If the piece just before the target is a string piece whose string ends at the position in the same string just before the insertion, then the insertion can be accomplished by extending the string of the previous piece, by adjusting the string offset and length of that piece's string and compensating by shrinking the INSERTIONSTRING resource.")

    (* ;; "")

    (* ;; "The net effect is that typically the target piece is found quickly, and that a sequence of characters that are inserted individually end up in a single string in a single piece (until a paragraph break, or some jumping around that eliminates the string contiguity).")

    (* ;; "")

    (* ;; "In the nonoptimal, atypical case, the next insertion point is unrelated to the last one, a jump to a new place in the stream.  In which case it might be between 2 existing pieces, or it might come in the middle of an existing piece that has to be split.  At that point a new string piece can be introduced to hold the insertion, maybe still sucking from the existing insertion string.")

    (* ;; "")

    (BTVALIDATE '\INSERTCH 'BEGIN TEXTOBJ)

    (* ;; "")

    [SETQ CH# (MIN CH# (ADD1 (TEXTLEN TEXTOBJ]
    (PROG (PREVPC INSERTPTYPE INSERTPC INSERTION (ILEN (CL:IF (type? STRINGP CH)
                                                           (NCHARS CH)
                                                           1)))
          (CL:WHEN (ZEROP ILEN)                              (* ; "Nothing to insert, really!")
              (RETURN))

     (* ;; "")

     (* ;; "Step 1:  Construct the insertion string, presumably chomping the TEXTOBJ resource. May or may not be contiguous with last insertion.")

          (SETQ INSERTION (\INSERTCH.INSERTION CH TEXTOBJ))
          (SETQ INSERTPTYPE (CL:IF (fetch (STRINGP FATSTRINGP) of INSERTION)
                                FATSTRING.PTYPE
                                THINSTRING.PTYPE))

     (* ;; "")

     (* ;; "Step 2:  Find or create a piece with CH#at offset 0. This may involve splitting off an initial substring into a separate previous piece.")

          (SETQ INSERTPC (\ALIGNEDPIECE CH# TEXTOBJ))

     (* ;; "")

     (* ;; "Step 3: Insert the insertion, with luck, just by extending the previous piece, otherwise the insertion goes into its own new previous piece.")

          (freplace (TEXTOBJ HINTPC) of TEXTOBJ with NIL)    (* ; 
                        "The hint has been used, but becomes invalid until the updates are complete.")
          (SETQ PREVPC (PREVPIECE INSERTPC))
          (if (AND PREVPC (\INSERTCH.EXTENDABLE PREVPC INSERTION INSERTPTYPE)
                   (EQ (PLOOKS PREVPC)
                       (ffetch (TEXTOBJ CARETLOOKS) of TEXTOBJ))
                   (NOT (PPARALAST PREVPC)))
              then 
                   (* ;; "Heuristic optimization: avoid a new piece if it is clear that won't get us into trouble. We can't append to a paralast candidate piece, because the new material would become part of a new paragraph that may or may not eventually end a different paragraph.")

                   (\INSERTCH.EXTEND PREVPC ILEN TEXTOBJ)
            else (SETQ PREVPC (create PIECE
                                     PTYPE _ INSERTPTYPE
                                     PCONTENTS _ INSERTION
                                     PLEN _ ILEN
                                     PLOOKS _ (ffetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                     PPARALOOKS _ (PPARALOOKS INSERTPC)
                                     PNEW _ T
                                     PBINABLE _ (EQ INSERTPTYPE THINSTRING.PTYPE)))
                 (\INSERTPIECE PREVPC INSERTPC TEXTOBJ))

     (* ;; "The insertion is done and the pieces are properly integrated into the stream. ")

     (* ;; "")

     (* ;; " Register this event in the TEDIT history.")

          (\INSERTCH.HISTORY TEXTOBJ PREVPC CH# ILEN)

     (* ;; "Finally, as a heuristic for continuous typing, set up the TEXTOBJ hint  to speed up the \CHTOPC piece search if  the next insertion comes just after this one. This really doesn't matter for typing, but may make it noticeaby faster for programmatic insertions..")

          (freplace (TEXTOBJ HINTPCSTARTCH#) of TEXTOBJ with (IPLUS ILEN CH#))
          (freplace (TEXTOBJ HINTPC) of TEXTOBJ with INSERTPC)
          (BTVALIDATE '\INSERTCH 'END TEXTOBJ)
          (RETURN INSERTPC])

(\INSERTCH.HISTORY
  [LAMBDA (TEXTOBJ PREVPC CH# ILEN)                          (* ; "Edited  8-Jun-2023 08:39 by rmk")
                                                             (* ; "Edited 28-May-2023 00:01 by rmk")
                                                             (* ; "Edited 25-May-2023 09:13 by rmk")

    (* ;; "Fix the history to reflect the character/string insertion by extending the event for previous characters in an insertion run.  Backspace removes individual characters, Undo removes the whole sequence.")

    (LET ((EVENT (\TEDIT.LASTEVENT TEXTOBJ)))                (* ; "Immediately prior edit event.")
         (CL:UNLESS (type? TEDITHISTORYEVENT EVENT)          (* ; 
                                                             "Don't do composites, fall thru to add.")
             (SETQ EVENT NIL))
         (if [AND EVENT (EQ PREVPC (GETTH EVENT THFIRSTPIECE))
                  (FMEMB (GETTH EVENT THACTION)
                         '(:Insert :Replace]
             then 
                  (* ;; "We're continuing a prior insertion, just continue the old history event too. Critical that insertions and replacements save PREVPC as THFIRSTPIECE")

                  (add (GETTH EVENT THLEN)
                       ILEN)
           else                                              (* ; 
                                           "A new insertion/replacemen requires a new history event.")
                (if (AND EVENT (EQ (GETTH EVENT THACTION)
                                   :Delete)
                         (IEQP CH# (GETTH EVENT THCH#)))
                    then (SETTH EVENT THACTION :Replace)     (* ; 
                                                             "Upgrade the deletion to a replacement")
                         (SETTH EVENT THCH# CH#)
                         (SETTH EVENT THLEN (PLEN PREVPC))
                         (SETTH EVENT THPOINT 'RIGHT)
                         (SETTH EVENT THFIRSTPIECE PREVPC)
                  else 
                       (* ;; "This insertion is unrelated to the previous user action, we push a new event to support undo sequences.")

                       (* ;; "A deletion followed by a first insertion got converted to a replace above. We are now adding a character to the end.  We want to start where it started before, and end one beyond where it ended before.  Why aren't we in the above :Replace case?")

                       (* ;; "In the replace case above, maybe the  PREVPC test isn't right?")

                       (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                         THACTION _ :Insert
                                                         THLEN _ (PLEN PREVPC)
                                                         THCH# _ CH#
                                                         THFIRSTPIECE _ PREVPC
                                                         THPOINT _ 'RIGHT])

(\INSERTEOL
  [LAMBDA (CH CH# TEXTOBJ)                                   (* ; "Edited  5-May-2023 17:00 by rmk")
                                                             (* ; "Edited 31-May-91 14:00 by jds")

    (* ;; "Handle insertion of EOL and meta-EOL.  The former causes a paragraph break, while the latter doesn't.  Note that inserting a meta-EOL causes the document to become formatted.    \INSERTEOL might add this on to an extendable insertion piece, but a subsequent extension is foreclosed by setting PPARALAST.")

    (* ;; "")

    (* ;; "RMK:  Is it really necessary to convert to formatted?  If \FORMATLINE forces a line break when it seems a meta-EO, then it is only EOL that forces the PARALAST for paragraph formatting and paragraph selection. meta-EOL can be treated just as an ordinary character and not come through (if meta-EOL can appear with the same significance in an otherwise plain-text file.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)
        (LET (INPC)
             (CL:UNLESS (OR (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
                            (EQ (CHARCODE EOL)))             (* ; 
               "Inserting a meta-EOL into an unformatted document.  Start by setting up para breaks.")
                 (\TEDIT.CONVERT.TO.FORMATTED TEXTOBJ))
             (SETQ INPC (\INSERTCH (CHARCODE EOL)
                               CH# TEXTOBJ))                 (* ; "Put the EOL in")
             (CL:WHEN (AND (EQ CH (CHARCODE EOL))
                           (PREVPIECE INPC))                 (* ; 
                                    "It's really an EOL, rather than a meta-EOL so do para breaking.")
                 (freplace (PIECE PPARALAST) of (PREVPIECE INPC) with T)
                 T)))])

(\INSERTCH.INSERTION
  [LAMBDA (CH TEXTOBJ)                                       (* ; "Edited 12-Apr-2023 16:55 by rmk")
                                                             (* ; "Edited 13-Aug-2022 12:48 by rmk")

    (* ;; "Find string-storage that can hold the insertion, and stick it in. Try to chomp from the current INSERTSTRING resource held in the TEXTOBJ, if any.")

    (LET ((INSERTSTRING (ffetch (TEXTOBJ INSERTSTRING) of TEXTOBJ))
          (LEN (CL:IF (type? STRINGP CH)
                   (NCHARS CH)
                   1))
          FATP INSERTION)
         (SETQ FATP (CL:IF (type? STRINGP CH)
                        (AND (fetch (STRINGP FATSTRINGP) of CH)
                             (for C instring CH never (IGREATERP C \MAXTHINCHAR)))
                        (IGREATERP CH \MAXTHINCHAR)))
         [if (AND INSERTSTRING (EQ FATP (fetch (STRINGP FATSTRINGP) of INSERTSTRING))
                  (ILEQ LEN (NCHARS INSERTSTRING)))
             then (SETQ INSERTION (SUBSTRING INSERTSTRING 1 LEN)) 
                                                             (* ; 
                                                          "Chunk it off, keep whatever might be left")
                  (freplace (TEXTOBJ INSERTSTRING) of TEXTOBJ with (SUBSTRING INSERTSTRING
                                                                          (ADD1 LEN)
                                                                          -1 INSERTSTRING))
           else 
                (* ;; "Allocate a string of the right type, to avoid an extra fattening pass")

                (if (IGREATERP LEN INSERTSTRINGLENGTH)
                    then 
                         (* ;; 
                         "Don't throw out the current cached resource if our new one is already full")

                         (SETQ INSERTION (ALLOCSTRING LEN NIL NIL FATP))
                  else (SETQ INSERTSTRING (ALLOCSTRING INSERTSTRINGLENGTH NIL NIL FATP))
                       (SETQ INSERTION (SUBSTRING INSERTSTRING 1 LEN)) 
                                                             (* ; 
                                        "Let the old one go--we may be starting a new sequential run")
                       (freplace (TEXTOBJ INSERTSTRING) of TEXTOBJ with (SUBSTRING INSERTSTRING
                                                                               (ADD1 LEN)
                                                                               -1 INSERTSTRING]

         (* ;; "INSERTION can now hold the insertion, smash it in")

         (CL:IF (type? STRINGP CH)
             (RPLSTRING INSERTION 1 CH)
             (RPLCHARCODE INSERTION 1 CH))
         INSERTION])

(\INSERTCH.EXTEND
  [LAMBDA (PC ILEN TEXTOBJ)                                  (* ; "Edited 12-Apr-2023 09:37 by rmk")
                                                             (* ; "Edited  1-Sep-2022 08:26 by rmk")
                                                             (* ; "Edited 30-Aug-2022 11:13 by rmk")
                                                             (* ; "Edited 21-Aug-2022 08:50 by rmk")

    (* ;; "Since INSERTION is physically adjacent to the PCONTENTS of PC, we can smash it on and adjust the lengths above.  We also have to adjust the DLEN for PC in its node.  ")

    (add (PLEN PC)
         ILEN)
    (add (ffetch (STRINGP LENGTH) of (PCONTENTS PC))
         ILEN)
    (add (ffetch (BTSLOT DLEN) of (\FINDSLOT (ffetch (PIECE PTREENODE) of PC)
                                         PC))
         ILEN)
    (\UPDATEPCNODES PC ILEN TEXTOBJ])
)



(* ; "Piece and piece-table manipulation")

(DEFINEQ

(\DELETEPIECES
  [LAMBDA (SELPIECES TEXTOBJ)                                (* ; "Edited  8-Jun-2023 23:12 by rmk")
                                                             (* ; "Edited  3-Jun-2023 22:44 by rmk")
                                                             (* ; "Edited 30-May-2023 08:57 by rmk")
                                                             (* ; "Edited 20-Apr-93 19:06 by jds")

    (* ;; "Removes all pieces in SELPIECES from TEXTOBJ. The chain is disconnected from the tree but is kept intact so the whole chain can still be recovered by following the NEXTPIECE links from the first piece (for history/undo). ")

    (* ;; "Returns NIL if an object objected, otherwise T.")

    (* ;; " Since the pieces are not unlinked on the fly, the tree may be invalid until all the pieces are gone.")

    (BTVALIDATE '\DELETEPIECES 'BEFORE TEXTOBJ)
    (for PC PREV NEXT first (SETQ PREV (PREVPIECE (fetch (SELPIECES SPFIRST) of SELPIECES))) 
                                                             (* ; "For incremental chain-update")
                            (SETQ NEXT (OR (NEXTPIECE (fetch (SELPIECES SPLAST) of SELPIECES))
                                           (ffetch (TEXTOBJ LASTPIECE) of TEXTOBJ))) inselpieces
                                                                                     SELPIECES
       do (UNINTERRUPTABLY
              (\DELETETREE PC (ffetch (PIECE PTREENODE) of PC)
                     TEXTOBJ)

              (* ;; "This piece is gone but its links are still there. To keep the tree valid, we incrementally splice it out.")

              (freplace (PIECE NEXTPIECE) of PREV with (NEXTPIECE PC))
              (freplace (PIECE PREVPIECE) of NEXT with PREV)
              (\UPDATEPCNODES PC (IMINUS (PLEN PC))
                     TEXTOBJ)) finally (CL:WHEN PREV
                                           (replace (PIECE PREVPIECE) of (fetch (SELPIECES SPFIRST)
                                                                            of SELPIECES)
                                              with NIL))
                                     (replace (PIECE NEXTPIECE) of (fetch (SELPIECES SPLAST)
                                                                      of SELPIECES) with NIL))
    (BTVALIDATE '\DELETEPIECES 'AFTER TEXTOBJ])

(\INSERTPIECES
  [LAMBDA (SELPIECES TEXTOBJ CH#)                            (* ; "Edited  3-Jun-2023 20:53 by rmk")
                                                             (* ; "Edited 21-May-2023 21:00 by rmk")

    (* ;; "")

    (* ;; " ")

    (* ;; "Inserts pieces in  SELPIECES into TEXTOBJ starting at CH#.  This assumes that these pieces are already properly copied, if need be, and they are initially linked from SFIRST to SPLAST. So the chain in TEXTOBJ would be correct if we simply link SPFIRST to the preceding piece and SPLAST to the following piece.  But then we would have to make a separate pass to install the new pieces in the b-tree.")

    (replace (TEXTOBJ \DIRTY) of TEXTOBJ with T)
    (for (PC _ (fetch (SELPIECES SPFIRST) of SELPIECES))
         (LASTPC _ (fetch (SELPIECES SPLAST) of SELPIECES))
         (POSTINSERTPC _ (\ALIGNEDPIECE CH# TEXTOBJ))
         NEXTPC PREINSERTPC by (SETQ PC NEXTPC) first (SETQ PREINSERTPC (PREVPIECE POSTINSERTPC)) 
                                                             (* ; "Hold it for looks diffusion")
       while PC do (SETQ NEXTPC (NEXTPIECE PC))              (* ; "\INSERTPIECE smashes the next")
                   (\INSERTPIECE PC POSTINSERTPC TEXTOBJ) repeatuntil (EQ PC LASTPC)
       finally (\TEDIT.DIFFUSE.PARALOOKS PREINSERTPC POSTINSERTPC])

(\ALIGNEDPIECE
  [LAMBDA (CHNO TEXTOBJ)                                     (* ; "Edited 29-May-2023 23:48 by rmk")
                                                             (* ; "Edited 20-May-2023 13:53 by rmk")
                                                             (* ; "Edited  3-May-2023 18:47 by rmk")
                                                             (* ; "Edited 21-Apr-93 17:49 by jds")

    (* ;; "CHNO is a character offset in the text.  If CHNO is not the beginning of a piece, this modifies the piecetable so that it is. If  the piece table is modified, a new piece is created for the characters  before CHNO  (characters from original 0 to original (SUB1 CHNO)), and the original piece is shortened so that it no longer includes those characters.   The new piece is linked into the piece sequence. ")

    (* ;; "The return is the (possibly shortened) original piece with character CHNO now at offset 0. Its PREVPIECE may or may not be new.   ")

    (if (IGREATERP CHNO (TEXTLEN TEXTOBJ))
        then 
             (* ;; "Doesn't return NIL in this case, returns the last piece.")

             (ffetch (TEXTOBJ LASTPIECE) of TEXTOBJ)
      elseif (ILEQ CHNO 1)
        then (\FIRSTPIECE TEXTOBJ)
      else (LET (PC START-OF-PIECE)
                (DECLARE (SPECVARS START-OF-PIECE))
                (SETQ PC (\CHTOPC CHNO TEXTOBJ T))
                (CL:UNLESS (IEQP CHNO START-OF-PIECE)        (* ; 
                                   "There can be no para break before the split, as things now work.")
                    (\SPLITPIECE PC (IDIFFERENCE CHNO START-OF-PIECE)
                           TEXTOBJ))
                PC])

(\INSTALL.PIECE
  [LAMBDA (TSTREAM PC CHOFFSET)                              (* ; "Edited  3-May-2023 15:10 by rmk")
                                                             (* ; "Edited 11-Oct-2022 18:14 by rmk")
                                                             (* ; "Edited 27-Sep-2022 23:43 by rmk")
                                                             (* ; "Edited 25-Sep-2022 13:29 by rmk")
                                                             (* ; "Edited 16-Sep-2022 15:19 by rmk")
                                                             (* ; "Edited 11-Sep-2022 14:40 by rmk")
                                                             (* ; "Edited  8-Sep-2022 20:46 by rmk")

    (* ;; "Makes PC be the current piece in TSTREAM. set up so that the next character is at CHOFFSET relative to the start of the piece. ")

    (* ;; "Note that, since we are setting up the TSTREAM looks here, the LOOKSUPDATEFN's don't need to do that part.")

    (* ;; "SHOULD PARTS OF THIS BE UNINTERRUPTABLE? ")

    (CL:WHEN PC
        (CL:UNLESS CHOFFSET (SETQ CHOFFSET 0))
        (LET (PCONTENTS PLEN PCCHARSLEFT (LOOKSUPDATEFN (ffetch (TEXTSTREAM LOOKSUPDATEFN)
                                                           of TSTREAM)))

             (* ;; "Install PC and its looks in TSTREAM.")

             (freplace (TEXTSTREAM PIECE) of TSTREAM with PC)

             (* ;; "The LOOKSUPDATEFN is non-NIL only for calls from \FORMATLINE and \TEDIT.HARDCOPY.FORMATLINE.  It updates their formatting variables.  ")

             (if LOOKSUPDATEFN
                 then (APPLY* LOOKSUPDATEFN TSTREAM PC)
               else (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with (PLOOKS PC))
                    (freplace (TEXTSTREAM CURRENTPARALOOKS) of TSTREAM with (PPARALOOKS PC)))

             (* ;; "")

             (* ;; "Now set up for binning.")

             (SETQ PLEN (PLEN PC))
             (SETQ PCCHARSLEFT (IDIFFERENCE PLEN CHOFFSET))
             (freplace (TEXTSTREAM PIECE) of TSTREAM with PC)(* ; "Initial values")
             (freplace (STREAM BINABLE) of TSTREAM with NIL) (* ; "Other than 1-byte characters")
             (freplace (STREAM COFFSET) of TSTREAM with 0)
             (SELECTC (PTYPE PC)
                 (THINFILE.PTYPE                             (* ; "Sets up the buffers")
                      (freplace (STREAM BINABLE) of TSTREAM with T)
                      (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                 ((LIST FATFILE1.PTYPE FATFILE2.PTYPE) 
                      (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                 (STRING.PTYPES (SETQ PCONTENTS (PCONTENTS PC))
                                (freplace (STREAM CPPTR) of TSTREAM with (ffetch (STRINGP BASE)
                                                                            of PCONTENTS))
                                (freplace (STREAM COFFSET) of TSTREAM
                                   with (IPLUS (ffetch (STRINGP OFFST) of PCONTENTS)
                                               CHOFFSET))
                                (freplace (STREAM CBUFSIZE) of TSTREAM
                                   with (IPLUS (ffetch (STRINGP OFFST) of PCONTENTS)
                                               PLEN))

                                (* ;; 
                             "The fatness of the string may have changed by the RPL--- in \INSERTCH.")

                                (if (ffetch (STRINGP FATSTRINGP) of PCONTENTS)
                                    then (freplace (PIECE PTYPE) of PC with FATSTRING.PTYPE)
                                         (freplace (PIECE PBINABLE) of PC with NIL)
                                  else (freplace (STREAM BINABLE) of TSTREAM with T)))
                 (OBJECT.PTYPE (freplace (STREAM CBUFSIZE) of TSTREAM with 1))
                 (SUBSTREAM.PTYPE                            (* ; 
    "Maybe just set PC to the piece of the (freplace (STREAM BINABLE) of TSTREAM with NIL)substream?")
                      (CL:UNLESS LOOKSUPDATEFN
                          (freplace (TEXTSTREAM CURRENTPARALOOKS) of TSTREAM
                             with (ffetch (TEXTSTREAM CURRENTPARALOOKS) of (PCONTENTS PC)))
                          (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with (ffetch (TEXTSTREAM
                                                                                       CURRENTLOOKS)
                                                                                 of (PCONTENTS PC)))))
                 NIL)
             (freplace (TEXTSTREAM STARTINGCOFFSET) of TSTREAM with (ffetch (STREAM COFFSET)
                                                                       of TSTREAM))
             (freplace (TEXTSTREAM PCCHARSLEFT) of TSTREAM with PCCHARSLEFT)))])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \NEXT.VISIBLE.PIECE MACRO ((PC)
                                     (for (NPC _ PC) by (NEXTPIECE NPC)
                                        first (CL:UNLESS NPC (RETURN NIL))
                                              (SETQ NPC (NEXTPIECE NPC)) while NPC
                                        unless (OR (EQ 0 (PLEN NPC))
                                                   (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS NPC)))
                                        do (RETURN NPC))))

(PUTPROPS \PREV.VISIBLE.PIECE MACRO ((PC)
                                     (for (PPC _ PC) by (PREVPIECE PPC)
                                        first (CL:UNLESS PPC (RETURN NIL))
                                              (SETQ PPC (PREVPIECE PPC)) while PPC
                                        unless (OR (EQ 0 (PLEN PPC))
                                                   (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PPC)))
                                        do (RETURN PPC))))
)
)



(* ; "Support for TEXTPROP")

(DEFINEQ

(CGETTEXTPROP
  [LAMBDA (TEXTOBJ PROP)                                     (* ; "Edited 20-Oct-87 12:36 by jds")

    (* ;; "compiles calls on TEXTPROP that are fetching values.  This needs to be changed whenever GETTEXTPROP is changed.")

    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             `(fetch (TEXTOBJ TXTREADONLY) of ,TEXTOBJ))
        `(LISTGET (fetch (TEXTOBJ EDITPROPS) of ,TEXTOBJ)
                ',PROP])

(CTEXTPROP
  [LAMBDA (FORMTAIL)                                         (* ; "Edited 31-May-91 13:59 by jds")

    (* ;; "compiles calls to TEXTPROP")

    (COND
       ((NULL (CDR FORMTAIL))                                (* ; "less that 2 args")
        (printout T "Possible error in call to TEXTPROP: less than 2 args" T (LIST 'TEXTPROP FORMTAIL
                                                                                   )
               T)
        (CGETTEXTPROP (LIST 'TEXTOBJ (CAR FORMTAIL))
               NIL))
       ((NOT (EQ (CAADR FORMTAIL)
                 'QUOTE))                                    (* ; "property is not quoted.")
        'IGNOREMACRO)
       [(NULL (CDDR FORMTAIL))                               (* ; "fetching a TEXTPROP property.")
        (CGETTEXTPROP (LIST 'TEXTOBJ (CAR FORMTAIL))
               (CADR (CADR FORMTAIL]
       (T                                                    (* ; "storing a window property")
          (LET ((TEXTOBJ (CAR FORMTAIL))
                (PROP (CDADR FORMTAIL))
                (VAL (CADDR FORMTAIL)))
               [SELECTQ PROP
                   ((READONLY READ-ONLY) 
                        `(REPLACE (TEXTOBJ TXTREADONLY) OF ,TEXTOBJ WITH ,VAL))
                   `(COND
                       [(FETCH (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ))
                        (LISTPUT (FETCH (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ))
                               ',PROP
                               ',VAL]
                       (T (REPLACE (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ)
                             WITH (LIST ,PROP ,VAL]
               (LIST 'COND (LIST (LIST 'FETCH 'EDITPROPS 'OF (LIST 'TEXTOBJ (CAR FORMTAIL)))
                                 (LIST 'LISTPUT (LIST 'FETCH 'EDITPROPS 'OF (LIST 'TEXTOBJ
                                                                                  (CAR FORMTAIL)))
                                       (CADR FORMTAIL)
                                       (CADDR FORMTAIL)))
                     (LIST T (LIST 'REPLACE 'EDITPROPS 'OF (LIST 'TEXTOBJ (CAR FORMTAIL))
                                   'WITH
                                   (LIST 'LIST (CADR FORMTAIL)
                                         (CADDR FORMTAIL])

(GETTEXTPROP
  [LAMBDA (TEXTOBJ PROP)                                     (* ; "Edited 30-Oct-2022 23:21 by rmk")
                                                             (* ; "Edited  9-Feb-89 11:20 by jds")

    (* ;; "Gets values for document properties.  Used by TEXTPROP.")

    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             (FETCH (TEXTOBJ TXTREADONLY) OF TEXTOBJ))
        ((BEING-EDITED ACTIVE) 
             (FETCH (TEXTOBJ TXTEDITING) OF TEXTOBJ))
        ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
             (FETCH (TEXTOBJ TXTNONSCHARS) OF TEXTOBJ))
        (READTABLE (fetch (TEXTOBJ TXTRTBL) of TEXTOBJ))
        (BOUNDTABLE (fetch (TEXTOBJ TXTWTBL) of TEXTOBJ))
        (LISTGET (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ)
               PROP])

(PUTTEXTPROP
  [LAMBDA (TEXTOBJ PROP VALUE)                               (* ; "Edited 30-Oct-2022 23:21 by rmk")
                                                             (* ; "Edited  9-Feb-89 11:19 by jds")
                                                             (* ; 
                                                             "put a value on prop list for a textobj")
    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             (PROG1 (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)
                 (replace (TEXTOBJ TXTREADONLY) of TEXTOBJ with VALUE)))
        ((BEING-EDITED ACTIVE) 
             (PROG1 (fetch (TEXTOBJ TXTEDITING) of TEXTOBJ)
                 (replace (TEXTOBJ TXTEDITING) of TEXTOBJ with VALUE)))
        ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
             (PROG1 (fetch (TEXTOBJ TXTNONSCHARS) of TEXTOBJ)
                 (replace (TEXTOBJ TXTNONSCHARS) of TEXTOBJ with VALUE)))
        (READTABLE (replace (TEXTOBJ TXTRTBL) of TEXTOBJ with VALUE))
        (BOUNDTABLE (replace (TEXTOBJ TXTWTBL) of TEXTOBJ with VALUE))
        (COND
           ((fetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
            (PROG1 (LISTGET (ffetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
                          PROP)
                (LISTPUT (ffetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
                       PROP VALUE)))
           (T (freplace (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ) with (LIST PROP VALUE))
              NIL])

(TEXTPROP
  [LAMBDA X                                                  (* ; "Edited  9-Feb-89 11:20 by jds")

    (* ;; "general top level entry for both fetching and setting window properties.")

    (COND
       ((IGREATERP X 2)
        (PUTTEXTPROP (TEXTOBJ (ARG X 1))
               (ARG X 2)
               (ARG X 3)))
       ((EQ X 2)
        (GETTEXTPROP (TEXTOBJ (ARG X 1))
               (ARG X 2)))
       (T (\ILLEGAL.ARG NIL])
)



(* ;; 
"Support for error handling:  The old error handler for the stream-not-open error.  This is here, because you only want to do this ONCE, even if you load TEXT-STREAM multiple times (as, e.g., in development)"
)


(RPAQ? *TEDIT-OLD-STREAM-ERROR-HANDLER* (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN))
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(\TEXTINIT)
)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA TEXTPROP)
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (34474 55402 (\TEXTBIN 34484 . 41237) (\TEXTBIN.NEXT.PIECE 41239 . 41774) (\TEXTPEEKBIN 
41776 . 45755) (\TEXTBACKFILEPTR 45757 . 49414) (\TEXTOUTCHARFN 49416 . 49707) (\INSTALL.FILEBUFFER 
49709 . 53400) (\TEXTBOUT 53402 . 55400)) (59680 64683 (\TEXTSTREAM.OUTCHARFN 59690 . 61334) (
\TEXTSTREAM.INCCCODEFN 61336 . 62019) (\TEXTSTREAM.PEEKCCODEFN 62021 . 62306) (\TEXTSTREAM.BACKCCODEFN
 62308 . 62786) (\TEXTSTREAM.OUTCHARFN 62788 . 64432) (\TEXTSTREAM.FORMATBYTESTREAM 64434 . 64681)) (
64730 89550 (COPYTEXTSTREAM 64740 . 67483) (OPENTEXTSTREAM 67485 . 77434) (OPENTEXTSTREAM.DEFAULTLOOKS
 77436 . 78910) (REOPENTEXTSTREAM 78912 . 79338) (TEDIT.STREAMCHANGEDP 79340 . 79642) (TEXTSTREAMP 
79644 . 80058) (TXTFILE 80060 . 80513) (\TEDIT.REOPEN.STREAM 80515 . 82181) (\TEXTINIT 82183 . 88231) 
(\TEXTTTYBOUT 88233 . 89548)) (89604 101611 (\TEXTCLOSEF 89614 . 90669) (\TEXTDSPFONT 90671 . 91753) (
\TEXTEOFP 91755 . 93210) (\TEXTGETEOFPTR 93212 . 93426) (\TEXTGETFILEPTR 93428 . 95599) (\TEXTOPENF 
95601 . 96427) (\TEXTSETEOF 96429 . 96944) (\TEXTSETFILEPTR 96946 . 98560) (\TEXTDSPXPOSITION 98562 . 
99422) (\TEXTDSPYPOSITION 99424 . 99971) (\TEXTLEFTMARGIN 99973 . 100395) (\TEXTRIGHTMARGIN 100397 . 
101145) (\TEXTDSPCHARWIDTH 101147 . 101324) (\TEXTDSPSTRINGWIDTH 101326 . 101505) (\TEXTDSPLINEFEED 
101507 . 101609)) (102995 121783 (\TEDIT.DELETE.SELPIECES 103005 . 106007) (\SETUPGETCH 106009 . 
107269) (\INSERTCH 107271 . 113062) (\INSERTCH.HISTORY 113064 . 116144) (\INSERTEOL 116146 . 117979) (
\INSERTCH.INSERTION 117981 . 120821) (\INSERTCH.EXTEND 120823 . 121781)) (121835 132778 (\DELETEPIECES
 121845 . 124346) (\INSERTPIECES 124348 . 125777) (\ALIGNEDPIECE 125779 . 127537) (\INSTALL.PIECE 
127539 . 132776)) (133961 139695 (CGETTEXTPROP 133971 . 134431) (CTEXTPROP 134433 . 136781) (
GETTEXTPROP 136783 . 137622) (PUTTEXTPROP 137624 . 139229) (TEXTPROP 139231 . 139693)))))
STOP
