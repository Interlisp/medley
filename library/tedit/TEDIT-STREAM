(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "30-Oct-2022 23:22:01" 
{DSK}<users>kaplan>local>medley3.5>working-medley>library>tedit>TEDIT-STREAM.;323 148616 

      :CHANGES-TO (FNS GETTEXTPROP PUTTEXTPROP)

      :PREVIOUS-DATE "26-Oct-2022 11:18:53" 
{DSK}<users>kaplan>local>medley3.5>working-medley>library>tedit>TEDIT-STREAM.;322)


(PRETTYCOMPRINT TEDIT-STREAMCOMS)

(RPAQQ TEDIT-STREAMCOMS
       [(DECLARE%: EVAL@COMPILE DONTCOPY (EXPORT (RECORDS PIECE TEXTOBJ TEXTIMAGEDATA TEXTSTREAM)
                                                (MACROS NEXTPIECE PREVPIECE PLEN PTYPE PCONTENTS 
                                                       PLOOKS PPARALOOKS PPARALAST)
                                                (OPTIMIZERS TEXTPROP)
                                                (CONSTANTS (THINFILE.PTYPE 0)
                                                       (FATFILE1.PTYPE 1)
                                                       (FATFILE2.PTYPE 2)
                                                       (THINSTRING.PTYPE 3)
                                                       (FATSTRING.PTYPE 4)
                                                       (SUBSTREAM.PTYPE 5)
                                                       (OBJECT.PTYPE 6)
                                                       (LOOKS.PTYPE 7)
                                                       (THINBLOCK.PTYPE 8)
                                                       (FATBLOCK.PTYPE 8)
                                                       (FILE.PTYPES (LIST THINFILE.PTYPE 
                                                                          FATFILE1.PTYPE 
                                                                          FATFILE2.PTYPE))
                                                       (STRING.PTYPES (LIST THINSTRING.PTYPE 
                                                                            FATSTRING.PTYPE))
                                                       (BINABLE.PTYPES (LIST THINFILE.PTYPE 
                                                                             THINSTRING.PTYPE 
                                                                             THINBLOCK.PTYPE))
                                                       (BLOCK.PTYPES (LIST THINBLOCK.PTYPE 
                                                                           FATBLOCK.PTYPE)))
                                                (GLOBALVARS \TEXTIMAGEOPS \TEXTFDEV)))
        (INITRECORDS PIECE TEXTOBJ TEXTIMAGEDATA TEXTSTREAM)
        (COMS 
              (* ;; "The BIN-level functions")

              (FNS \TEXTBIN \TEXTBIN.NEXT.PIECE \TEXTPEEKBIN \TEXTBACKFILEPTR \TEXTOUTCHARFN 
                   \INSTALL.FILEBUFFER \TEXTBOUT)
              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \FATFILE2.CHAR \ENDOFPIECEP \STARTOFPIECEP 
                                                      \ENDOFBUFFERP \STARTOFBUFFERP)))
        
        (* ;; "External format functions:  equivalent to BIN-level")

        (FNS \TEXTSTREAM.OUTCHARFN \TEXTSTREAM.INCCCODEFN \TEXTSTREAM.PEEKCCODEFN 
             \TEXTSTREAM.BACKCCODEFN \TEXTSTREAM.OUTCHARFN \TEXTSTREAM.FORMATBYTESTREAM)
        
        (* ;; "High-level stream operations")

        (FNS COPYTEXTSTREAM OPENTEXTSTREAM REOPENTEXTSTREAM TEDIT.STREAMCHANGEDP TEXTSTREAMP TXTFILE
             \TEDIT.REOPEN.STREAM \TEXTINIT \TEXTTTYBOUT)
        
        (* ;; "Low-level generic stream operations")

        (FNS \TEXTCLOSEF \TEXTDSPFONT \TEXTEOFP \TEXTGETEOFPTR \TEXTGETFILEPTR \TEXTOPENF \TEXTSETEOF
             \TEXTSETFILEPTR \TEXTDSPXPOSITION \TEXTDSPYPOSITION \TEXTLEFTMARGIN \TEXTRIGHTMARGIN 
             \TEXTDSPCHARWIDTH \TEXTDSPSTRINGWIDTH \TEXTDSPLINEFEED)
        (COMS 
              (* ;; "Editing support")

              (DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (INSERTSTRINGLENGTH 512))
                     (MACROS \INSERTCH.EXTENDABLE \LASTPIECEP \NOTLASTPIECEP))
              (FNS \DELETECH \SETUPGETCH \INSERTCH \INSERTCR \INSERTCH.INSERTION \INSERTCH.EXTEND))
        (COMS                                                (* ; 
                                                             "Piece and piece-table manipulation")
              (FNS \DELETEPIECES \INSERTPIECE \SPLITPIECE \INSTALL.PIECE)
              (DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \NEXT.VISIBLE.PIECE \PREV.VISIBLE.PIECE)))
        (COMS                                                (* ; "Support for TEXTPROP")
              (FNS CGETTEXTPROP CTEXTPROP GETTEXTPROP PUTTEXTPROP TEXTPROP))
        [COMS 
              (* ;; "Support for error handling:  The old error handler for the stream-not-open error.  This is here, because you only want to do this ONCE, even if you load TEXT-STREAM multiple times (as, e.g., in development)")

              (INITVARS (*TEDIT-OLD-STREAM-ERROR-HANDLER* (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN]
        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (\TEXTINIT)))
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)
                                                                             (NLAML)
                                                                             (LAMA TEXTPROP])
(DECLARE%: EVAL@COMPILE DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE PIECE 
          (                                                  (* ; 
                 "The piece describes either a string or part of a file.  , or a generalized OBJECT.")
           PCONTENTS                                         (* ; "The background source of data for this piece (stream, string, block, object, depending on the PTYPE).")
           (PTYPE BITS 4)                                    (* ; 
                           "How the characters are delivered: thinfile, fatstring, object, substream")
           PBYTELEN                                          (* ; "PLEN in bytes (based on fat type)")
           PFPOS                                             (* ; 
                                                  "The FILEPTR of the start of the piece in the file")
           PLEN                                              (* ; 
                                                             "Length of the piece, in characters.")
           NEXTPIECE                                         (* ; "-> Next piece in this textobj.")
           (PREVPIECE FULLXPOINTER)                          (* ; 
                                                             "-> Prior piece in this text object.")
           PLOOKS                                            (* ; 
                                                "Formatting info and formatting events in this piece")
           NIL                                               (* ; "WAS: OBJECT this piece describes")
           (PPARALAST FLAG)                                  (* ; 
                                                             "This piece contains a paragraph break")
           PPARALOOKS                                        (* ; "Paragraph looks for this piece")
           (PNEW FLAG)                                       (* ; 
             "This text is new here;  used by the tentative edit system, and anyone else interested.")
           (NIL FLAG)                                        (* ; "Was PFATP")
           (PBINABLE FLAG)                                   (* ; "8-bit bytes are binable")
           (PTREENODE XPOINTER)                              (* ; 
                                             "Points to the PCTB tree-node that contains this piece.")
           (PEXTERNALFORMAT POINTER)                         (* ; 
                                                           "The external format of a piece on a file")
           (PCHARSET POINTER))                               (* ; 
                                                    "The common charset for a run of thin characters")
          PCONTENTS _ NIL PFPOS _ 0 PLEN _ 0 PPARALOOKS _ TEDIT.DEFAULT.FMTSPEC PTREENODE _ NIL 
          PCHARSET _ 0)

(DATATYPE TEXTOBJ 
          (
           (* ;; 
   "This is where TEdit stores its state information, and internal data about the text being edited.")

           PCTB                                              (* ; "The piece table")
           TEXTLEN                                           (* ; "# of chars in the text")
           NIL                                               (* ; 
                        "Was INSERTPC: The string-piece that received the last insertion. Now HINTPC")
           LASTPIECE                                         (* ; 
                    "The last (end-of-stream) piece of the textstream, for easy insertion at the end")
           NIL                                               (* ; 
    "Was: INSERTNEXTCH CH# of next char which is typed into that piece. Taken over by HINTPCSTARTCH#")
           HINTPC                                            (* ; 
                                                             "Was: Space left in the type-in piece")
           HINTPCSTARTCH#                                    (* ; 
                                                          "Was # of characters already in the piece.")
           INSERTSTRING                                      (* ; 
                                         "A substring of storage that is available for an insertion.")
           NIL                                               (* ; 
                                                             "Was: CH# of first char in the piece.")
           (NIL FLAG)                                        (* ; "Was \INSERTPCVALID. T if it's OK to use the cached piece.  Set to NIL by people who require that the next insertion/deletion use a different piece. Now just set HINTPC to NIL.")
           \WINDOW                                           (* ; 
                                                      "The window<s> where this textobj is displayed")
           MOUSEREGION                                       (* ; 
                                                             "Section of the window the mouse is in.")
           LINES                                             (* ; 
                                          "-> to top of chain of line descriptors for displayed text")
           DS                                                (* ; 
                                                     "Display stream where this textobj is displayed")
           SEL                                               (* ; 
                                                             "The current selection within the text")
           SCRATCHSEL                                        (* ; 
                                                             "Scratch space for the selection code")
           MOVESEL                                           (* ; "Source for the next MOVE of text")
           SHIFTEDSEL                                        (* ; "Source for the next COPY")
           DELETESEL                                         (* ; "Text to be deleted imminently")
           WRIGHT                                            (* ; 
                                    "Right edge of the window (or subregion) where this is displayed")
           WTOP                                              (* ; "Top of the window/region")
           WBOTTOM                                           (* ; "Bottom of the window/region")
           WLEFT                                             (* ; "Left edge of the window/region")
           TXTFILE                                           (* ; 
                                                             "The original text file we're editing")
           (\XDIRTY FLAG)                                    (* ; "T => changed since last saved.")
           (STREAMHINT FULLXPOINTER)                         (* ; 
                                           "-> the TEXTOFD stream which gives access to this textobj")
           EDITFINISHEDFLG                                   (* ; 
                                                        "T => The guy has asked the editor to go way")
           CARET                                             (* ; 
                                                "Describes the flashing caret for the editing window")
           CARETLOOKS                                        (* ; 
                                                             "Font to be used for inserted text.")
           WINDOWTITLE                                       (* ; 
                                                  "Original title for this window, of there was one.")
           THISLINE                                          (* ; 
                                               "Cache of line-related info, to speed up selection &c")
           (MENUFLG FLAG)                                    (* ; 
                                                            "T if this TEXTOBJ is a tedit-style menu")
           FMTSPEC                                           (* ; 
                                      "Default Formatting Spec to be used when formatting paragraphs")
           (FORMATTEDP FLAG)                                 (* ; 
 "Flag for paragraph formatting.  T if this document is to contain paragraph formatting information.")
           (TXTREADONLY FLAG)                                (* ; 
                                                        "This is only available for shift selection.")
           (TXTEDITING FLAG)                                 (* ; "T => This document is in a window and there is an edit process behind it.  For example, it only makes sense to have a caret show up if you are editing.")
           (TXTNONSCHARS FLAG)                               (* ; "T => If TEdit rns into a 255, it won't attempt to convert to NS characters.  Used for REALLY plain-text manipulation.")
           TXTTERMSA                                         (* ; 
                                       "Special instructions for displaying characters on the screen")
           EDITOPACTIVE                                      (* ; 
                  "T if there is an editing operation in progress.  Used to interlock the TEdit menu")
           DEFAULTCHARLOOKS                                  (* ; "The default character looks -- if any -- to be applied to characters coming into the file from outside.")
           TXTRTBL                                           (* ; 
                                  "The READTABLE to be used by the command loop for command dispatch")
           TXTWTBL                                           (* ; 
                                                  "The READTABLE to be used to decide on word breaks")
           EDITPROPS                                         (* ; 
                                                  "The PROPS that were passed into this edit session")
           (BLUEPENDINGDELETE FLAG)                          (* ; "T if the next insertion in this document is to be preceded by a deletion of the then-current selection")
           TXTHISTORY                                        (* ; 
                                                            "The history list for this edit session.")
           (SELWINDOW FULLXPOINTER)                          (* ; "The window in which the last 'real' selection got made for this edit;  used to control caret placement")
           PROMPTWINDOW                                      (* ; 
   "A window to be used for unscheduled interactions;  normally a small window above the edit window")
           DISPLAYCACHE                                      (* ; 
                                "The bitmap to be used when building the image of a line for display")
           DISPLAYCACHEDS                                    (* ; 
                                                "The DISPLAYSTREAM that is used to build line images")
           DISPLAYHCPYDS                                     (* ; "The DISPLAYSTREAM used to build line images of lines that are displayed in 'hardcopy' simulation mode")
           TXTPAGEFRAMES                                     (* ; 
                              "A tree of page frames, specifying how the document is to be laid out.")
           TXTCHARLOOKSLIST                                  (* ; 
                             "List of all the CHARLOOKSs in the document, so they can be kept unique")
           TXTPARALOOKSLIST                                  (* ; 
                               "List of all the FMTSPECs in the document, so they can be kept unique")
           (TXTNEEDSUPDATE FLAG)                             (* ; 
                                                           "T => Screen invalid, need to run updater")
           (TXTDON'TUPDATE FLAG)                             (* ; "T if we're holding off on screen updates until later.  Used, e.g., by the menu-SHOW code so that you don't get piecemeal updates, but only one at the end of the SHOW.")
           TXTRAWINCLUDESTREAM                               (* ; 
                       "NODIRCORE stream used to cache RAW includes (and maybe later, all includes?)")
           DOCPROPS                                          (* ; 
                               "Document properties that are stored with the document (not used yet)")
           TXTSTYLESHEET                                     (* ; 
                      "Style sheet local to this document.  Not currently saved as part of the file.")
           )
          [ACCESSFNS TEXTOBJ ((\DIRTY (ffetch (TEXTOBJ \XDIRTY) of DATUM)
                                     (PROGN (IF (NEQ (FETCH (TEXTOBJ \XDIRTY) OF DATUM)
                                                     NEWVALUE)
                                                THEN         (* ; 
                                                             "update the title to reflect the change")
                                                     (\TEDIT.WINDOW.TITLE DATUM
                                                            (\TEDIT.ORIGINAL.WINDOW.TITLE
                                                             (ffetch (TEXTOBJ TXTFILE) of DATUM)
                                                             NEWVALUE)))
                                            (freplace \XDIRTY OF DATUM WITH NEWVALUE]
          SEL _ (create SELECTION)
          SCRATCHSEL _ (create SELECTION)
          MOVESEL _ (create SELECTION
                           HOWHEIGHT _ 32767
                           HASCARET _ NIL)
          SHIFTEDSEL _ (create SELECTION
                              HASCARET _ NIL)
          DELETESEL _ (create SELECTION
                             HOWHEIGHT _ 32767
                             HASCARET _ NIL)
          TEXTLEN _ 0 WRIGHT _ 0 WTOP _ 0 WLEFT _ 0 WBOTTOM _ 0 TXTFILE _ NIL \XDIRTY _ NIL 
          MOUSEREGION _ 'TEXT THISLINE _ (create THISLINE)
          MENUFLG _ NIL FMTSPEC _ TEDIT.DEFAULT.FMTSPEC FORMATTEDP _ NIL INSERTSTRING _ NIL)

(DATATYPE TEXTIMAGEDATA (
                         (* ;; "Fills the IMAGEDATA field of text streams.")

                         TICURPARALOOKS                      (* ; "The current paragraph looks")
                         TICURIMAGESTREAM                    (* ; 
                                                    "The image stream for this hardcopy transduction")
                         TILOOKSUPDATEFN                     (* ; 
                                               "The function to call to update looks for this stream")
                         TIPCOFFSET                          (* ; 
                                      "The offset into the current piece, as of the last page cross.")
                         ))

(ACCESSFNS TEXTSTREAM 
           (
            (* ;; 
          "Overlay for the STREAM record to allow mnemonic access to stream fields for Text streams.")

            (* ;; "The # of characters that have already been read from the current piece")

            (TEXTOBJ (fetch F3 of DATUM)
                   (REPLACE F3 OF DATUM WITH NEWVALUE))      (* ; 
                                                             "The TEXTOBJ that is editing this text")
            (PIECE (fetch F5 of DATUM)
                   (REPLACE F5 OF DATUM WITH NEWVALUE))      (* ; 
                                   "The PIECE we're currently fetching chars from/putting chars into")
            (PCCHARSLEFT (fetch (STREAM F1) of DATUM)
                   (replace (STREAM F1) of DATUM with NEWVALUE))
                                                             (* ; 
                                                             "Runs from PLEN to 0: piece exhausted")
            (NIL)                                            (* ; 
                                 "WAS: PCSTARTPG The underlying file page# that this piece starts on")
            (NIL)                                            (* ; "WAS: PCSTARTCH The char within page of the underlying file that this piece starts on -- for backbin & co")
            (PCOFFSET (fetch TIPCOFFSET of (fetch IMAGEDATA of DATUM))
                   (REPLACE TIPCOFFSET OF (fetch IMAGEDATA of DATUM) with NEWVALUE))
                                                             (* ; 
                                      "The offset into the current piece, as of the last page cross.")
            (CURRENTLOOKS (fetch F10 of DATUM)
                   (replace F10 of DATUM with NEWVALUE))     (* ; 
             "The CHARLOOKS that are currently applicable to characters being taken from the stream.")
            (CURRENTPARALOOKS (fetch TICURPARALOOKS of (fetch IMAGEDATA of DATUM))
                   (REPLACE TICURPARALOOKS OF (fetch IMAGEDATA of DATUM) with NEWVALUE))
                                                             (* ; 
                "The FMTSPEC that is currently applicable to characters being taken from the stream.")
            (CURRENTIMAGESTREAM (fetch TICURIMAGESTREAM of (fetch IMAGEDATA of DATUM))
                   (REPLACE TICURIMAGESTREAM OF (fetch IMAGEDATA of DATUM) with NEWVALUE)
                                                             (* ; 
                     "The image stream that this text is being put onto;  used for scaling decisions")
                   )
            (LOOKSUPDATEFN (fetch TILOOKSUPDATEFN of (fetch IMAGEDATA of DATUM))
                   (REPLACE TILOOKSUPDATEFN OF (fetch IMAGEDATA of DATUM) with NEWVALUE))
                                                             (* ; 
                                            "Function to be called each time character looks change.")
            (STARTINGCOFFSET (fetch (STREAM F2) of DATUM)
                   (replace (STREAM F2) of DATUM with NEWVALUE))
                                                             (* ; 
                                                       "T if the current piece is 16 bit characters.")
            )
           (CREATE (create STREAM
                          BINABLE _ NIL
                          BOUTABLE _ NIL
                          ACCESS _ 'BOTH
                          USERCLOSEABLE _ T
                          USERVISIBLE _ T
                          DEVICE _ \TEXTFDEV
                          F1 _ NIL
                          F2 _ 0
                          F3 _ NIL
                          F5 _ NIL
                          MAXBUFFERS _ 10
                          IMAGEOPS _ \TEXTIMAGEOPS
                          IMAGEDATA _ (create TEXTIMAGEDATA))))
)

(/DECLAREDATATYPE 'PIECE
       '(POINTER (BITS 4)
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER FLAG POINTER FLAG FLAG 
               FLAG XPOINTER POINTER POINTER)
       '((PIECE 0 POINTER)
         (PIECE 0 (BITS . 3))
         (PIECE 2 POINTER)
         (PIECE 4 POINTER)
         (PIECE 6 POINTER)
         (PIECE 8 POINTER)
         (PIECE 10 FULLXPOINTER)
         (PIECE 12 POINTER)
         (PIECE 14 POINTER)
         (PIECE 14 (FLAGBITS . 0))
         (PIECE 16 POINTER)
         (PIECE 16 (FLAGBITS . 0))
         (PIECE 16 (FLAGBITS . 16))
         (PIECE 16 (FLAGBITS . 32))
         (PIECE 18 XPOINTER)
         (PIECE 20 POINTER)
         (PIECE 22 POINTER))
       '24)

(/DECLAREDATATYPE 'TEXTOBJ
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER POINTER
               POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER FLAG FULLXPOINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER
               FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER 
               FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG FLAG POINTER
               POINTER POINTER)
       '((TEXTOBJ 0 POINTER)
         (TEXTOBJ 2 POINTER)
         (TEXTOBJ 4 POINTER)
         (TEXTOBJ 6 POINTER)
         (TEXTOBJ 8 POINTER)
         (TEXTOBJ 10 POINTER)
         (TEXTOBJ 12 POINTER)
         (TEXTOBJ 14 POINTER)
         (TEXTOBJ 16 POINTER)
         (TEXTOBJ 16 (FLAGBITS . 0))
         (TEXTOBJ 18 POINTER)
         (TEXTOBJ 20 POINTER)
         (TEXTOBJ 22 POINTER)
         (TEXTOBJ 24 POINTER)
         (TEXTOBJ 26 POINTER)
         (TEXTOBJ 28 POINTER)
         (TEXTOBJ 30 POINTER)
         (TEXTOBJ 32 POINTER)
         (TEXTOBJ 34 POINTER)
         (TEXTOBJ 36 POINTER)
         (TEXTOBJ 38 POINTER)
         (TEXTOBJ 40 POINTER)
         (TEXTOBJ 42 POINTER)
         (TEXTOBJ 44 POINTER)
         (TEXTOBJ 44 (FLAGBITS . 0))
         (TEXTOBJ 46 FULLXPOINTER)
         (TEXTOBJ 48 POINTER)
         (TEXTOBJ 50 POINTER)
         (TEXTOBJ 52 POINTER)
         (TEXTOBJ 54 POINTER)
         (TEXTOBJ 56 POINTER)
         (TEXTOBJ 56 (FLAGBITS . 0))
         (TEXTOBJ 58 POINTER)
         (TEXTOBJ 58 (FLAGBITS . 0))
         (TEXTOBJ 58 (FLAGBITS . 16))
         (TEXTOBJ 58 (FLAGBITS . 32))
         (TEXTOBJ 58 (FLAGBITS . 48))
         (TEXTOBJ 60 POINTER)
         (TEXTOBJ 62 POINTER)
         (TEXTOBJ 64 POINTER)
         (TEXTOBJ 66 POINTER)
         (TEXTOBJ 68 POINTER)
         (TEXTOBJ 70 POINTER)
         (TEXTOBJ 70 (FLAGBITS . 0))
         (TEXTOBJ 72 POINTER)
         (TEXTOBJ 74 FULLXPOINTER)
         (TEXTOBJ 76 POINTER)
         (TEXTOBJ 78 POINTER)
         (TEXTOBJ 80 POINTER)
         (TEXTOBJ 82 POINTER)
         (TEXTOBJ 84 POINTER)
         (TEXTOBJ 86 POINTER)
         (TEXTOBJ 88 POINTER)
         (TEXTOBJ 88 (FLAGBITS . 0))
         (TEXTOBJ 88 (FLAGBITS . 16))
         (TEXTOBJ 90 POINTER)
         (TEXTOBJ 92 POINTER)
         (TEXTOBJ 94 POINTER))
       '96)

(/DECLAREDATATYPE 'TEXTIMAGEDATA '(POINTER POINTER POINTER POINTER)
       '((TEXTIMAGEDATA 0 POINTER)
         (TEXTIMAGEDATA 2 POINTER)
         (TEXTIMAGEDATA 4 POINTER)
         (TEXTIMAGEDATA 6 POINTER))
       '8)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS NEXTPIECE MACRO ((PC)
                           (ffetch (PIECE NEXTPIECE) of PC)))

(PUTPROPS PREVPIECE MACRO ((PC)
                           (ffetch (PIECE PREVPIECE) of PC)))

(PUTPROPS PLEN MACRO ((PC)
                      (ffetch (PIECE PLEN) of PC)))

(PUTPROPS PTYPE MACRO ((PC)
                       (ffetch (PIECE PTYPE) of PC)))

(PUTPROPS PCONTENTS MACRO ((PC)
                           (ffetch (PIECE PCONTENTS) of PC)))

(PUTPROPS PLOOKS MACRO ((PC)
                        (ffetch (PIECE PLOOKS) of PC)))

(PUTPROPS PPARALOOKS MACRO ((PC)
                            (ffetch (PIECE PPARALOOKS) of PC)))

(PUTPROPS PPARALAST MACRO ((PC)
                           (ffetch (PIECE PPARALAST) of PC)))
)

(DEFOPTIMIZER TEXTPROP (TEXTOBJ PROP &OPTIONAL (VAL NIL WRITING))

                       (* ;; "compiles calls to TEXTPROP")

                       [COND
                          ((NOT (LISTP PROP))                (* ; "property is not quoted.")
                           'IGNOREMACRO)
                          ((NOT (EQ (CAR PROP)
                                    'QUOTE))                 (* ; "property is not quoted.")
                           'IGNOREMACRO)
                          [(NOT WRITING)                     (* ; "fetching a TEXTPROP property.")
                           (SELECTQ (CADR PROP)
                               ((READONLY READ-ONLY) 
                                    `(fetch (TEXTOBJ TXTREADONLY) of (TEXTOBJ ,TEXTOBJ)))
                               ((BEING-EDITED ACTIVE) 
                                    `(fetch (TEXTOBJ TXTEDITING) of (TEXTOBJ ,TEXTOBJ)))
                               ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
                                    `(fetch (TEXTOBJ TXTNONSCHARS) of (TEXTOBJ ,TEXTOBJ)))
                               `(LISTGET (fetch (TEXTOBJ EDITPROPS) of (TEXTOBJ ,TEXTOBJ))
                                       ,PROP]
                          (T                                 (* ; "storing a window property")
                             (SELECTQ (CADR PROP)
                                 ((READONLY READ-ONLY) 
                                      `(REPLACE (TEXTOBJ TXTREADONLY) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 ((BEING-EDITED ACTIVE) 
                                      `(REPLACE (TEXTOBJ TXTEDITING) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
                                      `(REPLACE (TEXTOBJ TXTNONSCHARS) OF (TEXTOBJ ,TEXTOBJ)
                                          WITH ,VAL))
                                 `(LET* (($$TEXTOBJ$$ (TEXTOBJ ,TEXTOBJ))
                                         ($$PROPLST$$ (FETCH EDITPROPS OF $$TEXTOBJ$$)))
                                        (COND
                                           ($$PROPLST$$ (LISTPUT $$PROPLST$$ ,PROP ,VAL))
                                           (T (REPLACE EDITPROPS OF $$TEXTOBJ$$
                                                 WITH (LIST ,PROP ,VAL])
(DECLARE%: EVAL@COMPILE 

(RPAQQ THINFILE.PTYPE 0)

(RPAQQ FATFILE1.PTYPE 1)

(RPAQQ FATFILE2.PTYPE 2)

(RPAQQ THINSTRING.PTYPE 3)

(RPAQQ FATSTRING.PTYPE 4)

(RPAQQ SUBSTREAM.PTYPE 5)

(RPAQQ OBJECT.PTYPE 6)

(RPAQQ LOOKS.PTYPE 7)

(RPAQQ THINBLOCK.PTYPE 8)

(RPAQQ FATBLOCK.PTYPE 8)

(RPAQ FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE))

(RPAQ STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE))

(RPAQ BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE THINBLOCK.PTYPE))

(RPAQ BLOCK.PTYPES (LIST THINBLOCK.PTYPE FATBLOCK.PTYPE))


(CONSTANTS (THINFILE.PTYPE 0)
       (FATFILE1.PTYPE 1)
       (FATFILE2.PTYPE 2)
       (THINSTRING.PTYPE 3)
       (FATSTRING.PTYPE 4)
       (SUBSTREAM.PTYPE 5)
       (OBJECT.PTYPE 6)
       (LOOKS.PTYPE 7)
       (THINBLOCK.PTYPE 8)
       (FATBLOCK.PTYPE 8)
       (FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE))
       (STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE))
       (BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE THINBLOCK.PTYPE))
       (BLOCK.PTYPES (LIST THINBLOCK.PTYPE FATBLOCK.PTYPE)))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS \TEXTIMAGEOPS \TEXTFDEV)
)

(* "END EXPORTED DEFINITIONS")

)

(/DECLAREDATATYPE 'PIECE
       '(POINTER (BITS 4)
               POINTER POINTER POINTER POINTER FULLXPOINTER POINTER POINTER FLAG POINTER FLAG FLAG 
               FLAG XPOINTER POINTER POINTER)
       '((PIECE 0 POINTER)
         (PIECE 0 (BITS . 3))
         (PIECE 2 POINTER)
         (PIECE 4 POINTER)
         (PIECE 6 POINTER)
         (PIECE 8 POINTER)
         (PIECE 10 FULLXPOINTER)
         (PIECE 12 POINTER)
         (PIECE 14 POINTER)
         (PIECE 14 (FLAGBITS . 0))
         (PIECE 16 POINTER)
         (PIECE 16 (FLAGBITS . 0))
         (PIECE 16 (FLAGBITS . 16))
         (PIECE 16 (FLAGBITS . 32))
         (PIECE 18 XPOINTER)
         (PIECE 20 POINTER)
         (PIECE 22 POINTER))
       '24)

(/DECLAREDATATYPE 'TEXTOBJ
       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER POINTER
               POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER 
               POINTER POINTER FLAG FULLXPOINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER
               FLAG FLAG FLAG FLAG POINTER POINTER POINTER POINTER POINTER POINTER FLAG POINTER 
               FULLXPOINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER FLAG FLAG POINTER
               POINTER POINTER)
       '((TEXTOBJ 0 POINTER)
         (TEXTOBJ 2 POINTER)
         (TEXTOBJ 4 POINTER)
         (TEXTOBJ 6 POINTER)
         (TEXTOBJ 8 POINTER)
         (TEXTOBJ 10 POINTER)
         (TEXTOBJ 12 POINTER)
         (TEXTOBJ 14 POINTER)
         (TEXTOBJ 16 POINTER)
         (TEXTOBJ 16 (FLAGBITS . 0))
         (TEXTOBJ 18 POINTER)
         (TEXTOBJ 20 POINTER)
         (TEXTOBJ 22 POINTER)
         (TEXTOBJ 24 POINTER)
         (TEXTOBJ 26 POINTER)
         (TEXTOBJ 28 POINTER)
         (TEXTOBJ 30 POINTER)
         (TEXTOBJ 32 POINTER)
         (TEXTOBJ 34 POINTER)
         (TEXTOBJ 36 POINTER)
         (TEXTOBJ 38 POINTER)
         (TEXTOBJ 40 POINTER)
         (TEXTOBJ 42 POINTER)
         (TEXTOBJ 44 POINTER)
         (TEXTOBJ 44 (FLAGBITS . 0))
         (TEXTOBJ 46 FULLXPOINTER)
         (TEXTOBJ 48 POINTER)
         (TEXTOBJ 50 POINTER)
         (TEXTOBJ 52 POINTER)
         (TEXTOBJ 54 POINTER)
         (TEXTOBJ 56 POINTER)
         (TEXTOBJ 56 (FLAGBITS . 0))
         (TEXTOBJ 58 POINTER)
         (TEXTOBJ 58 (FLAGBITS . 0))
         (TEXTOBJ 58 (FLAGBITS . 16))
         (TEXTOBJ 58 (FLAGBITS . 32))
         (TEXTOBJ 58 (FLAGBITS . 48))
         (TEXTOBJ 60 POINTER)
         (TEXTOBJ 62 POINTER)
         (TEXTOBJ 64 POINTER)
         (TEXTOBJ 66 POINTER)
         (TEXTOBJ 68 POINTER)
         (TEXTOBJ 70 POINTER)
         (TEXTOBJ 70 (FLAGBITS . 0))
         (TEXTOBJ 72 POINTER)
         (TEXTOBJ 74 FULLXPOINTER)
         (TEXTOBJ 76 POINTER)
         (TEXTOBJ 78 POINTER)
         (TEXTOBJ 80 POINTER)
         (TEXTOBJ 82 POINTER)
         (TEXTOBJ 84 POINTER)
         (TEXTOBJ 86 POINTER)
         (TEXTOBJ 88 POINTER)
         (TEXTOBJ 88 (FLAGBITS . 0))
         (TEXTOBJ 88 (FLAGBITS . 16))
         (TEXTOBJ 90 POINTER)
         (TEXTOBJ 92 POINTER)
         (TEXTOBJ 94 POINTER))
       '96)

(/DECLAREDATATYPE 'TEXTIMAGEDATA '(POINTER POINTER POINTER POINTER)
       '((TEXTIMAGEDATA 0 POINTER)
         (TEXTIMAGEDATA 2 POINTER)
         (TEXTIMAGEDATA 4 POINTER)
         (TEXTIMAGEDATA 6 POINTER))
       '8)



(* ;; "The BIN-level functions")

(DEFINEQ

(\TEXTBIN
  [LAMBDA (TSTREAM)

    (* ;; "Edited 12-Oct-2022 15:25 by rmk")

    (* ;; "Edited  2-Sep-2022 17:20 by rmk")

    (* ;; "Edited  9-Aug-2022 10:27 by rmk")

    (* ;; "Edited  7-Aug-2022 23:46 by rmk")

    (* ;; "Edited 22-Dec-2021 10:29 by rmk: Return value of OBJECTCHAR property for image objects")

    (* ;; "Edited 28-Mar-94 15:33 by jds")

(* ;;; "The BIN slow case for a text stream.  For the fast, binable (THINFILE, THINSTRING) cases, this is called when an end-of-buffer is reached.  If it is not also an end-of-piece, get a new buffer and continue.  Otherwise, get a new piece (which may not be binable).")

(* ;;; "If the stream is not binable (all other piece types) this gets called on every BIN.  Then we start an extra test to distinguish between buffer overflow and piece overflow.")

(* ;;; "The external filepointer (GETFILEPTR, SETFILEPTR) is calculated in characters:  the total number of characters in all previous pieces, plus the characters (based on the offset) in the current piece.")

    (DECLARE (LOCALVARS . T))
    (LET ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
          (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (if (ffetch (STREAM BINABLE) of TSTREAM)
             then 
                  (* ;; "The BIN opcode detected a buffer overflow, move either to the next buffer for this piece, or the next piece. The opcode doesn't  manages only COFFSET, so here we have to figure out what4 PCCHARSOFFSET should have been.  NOTE: PCCHARSOFFSET cannot be changed in the stream unless the STARTINGCOFFSET is also bumped to the COFFSET.")

                  (* ;; "The COFFSET goes from 0 to CBUFFSIZE--when it is = to CBUFSIZE we get an overflow.  That maps to 0 in the next buffer.  When we come here in that case, we haven't actually read that characte.")

                  [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                             of TSTREAM)
                                                                    (ffetch (TEXTSTREAM 
                                                                                   STARTINGCOFFSET)
                                                                       of TSTREAM] 
                                                             (* ; "1-byte characters")
                  (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                      then 
                           (* ;; "Move to next piece.  EOF handled below")

                           (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
                    else 
                         (* ;; "Set up for the next buffer in the same piece. We want to set it for the next unread character. We don't SUB1 because the character hasn't yet been read.")

                         (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                  (CL:IF PC
                      (BIN TSTREAM)
                      (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM))
           else 
                (* ;; 
 "Not binable, more complicated return values.  Opcode kicked out, didn't test for buffer overflow .")

                (CL:WHEN (\ENDOFBUFFERP TSTREAM)

                    (* ;; "Buffer overflow. Installers replace PCCHARSLET")

                    (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                        then (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
                      else (\INSTALL.FILEBUFFER TSTREAM (SUB1 PCCHARSLEFT))))
                (if (NOT PC)
                    then (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM)
                  elseif (ffetch (STREAM BINABLE) of TSTREAM)
                    then (BIN TSTREAM)
                  else (ADD (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)
                            -1)                              (* ; 
                                                      "Where we will be when the operation completes")
                       (SELECTC (PTYPE PC)
                           ((LIST FATSTRING.PTYPE FATBLOCK.PTYPE) 
                                (PROG1 (\GETBASEFAT (ffetch (STREAM CBUFPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           (FATFILE1.PTYPE 
                                (PROG1 (LOGOR (ffetch (PIECE PCHARSET) of PC)
                                              (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                                     (ffetch (STREAM COFFSET) of TSTREAM)))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           (FATFILE2.PTYPE 
                                           (* ;; "This is the most complicated case, because the 2 bytes of a character could be in separate buffers.")

                                (\FATFILE2.CHAR TSTREAM PC NIL))
                           (OBJECT.PTYPE 
                                         (* ;; 
              "Return the object as BIN's result, and make sure we'll go to the next page next time.")

                                         (* ;; 
                    "OBJECTBYTE is for callers (like COMPARETEXT) that can't deal with image objects")

                                         (PROG1 (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ)
                                                                    of TSTREAM)
                                                           'OBJECTBYTE)
                                                    (PCONTENTS PC))
                                             (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                                  1)))
                           (SUBSTREAM.PTYPE                  (* ; "A substream stored as an object")
                                (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                            'SUBSTREAM)))
                           (BINABLE.PTYPES                   (* ; 
                                      "For completeness:  the BINABLE test should have picked it off")
                                (PROG1 (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))
                                    (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                         1)))
                           NIL])

(\TEXTBIN.NEXT.PIECE
  [LAMBDA (TSTREAM)                                          (* ; "Edited  6-Aug-2022 19:48 by rmk")
                                                             (* ; "Edited  2-Aug-2022 10:57 by rmk")

    (* ;; 
    "Walk over empty pieces. Easier to get them out of the next-chain than out of the piece tree.")

    (LET [(NPC (\NEXT.VISIBLE.PIECE (fetch (TEXTSTREAM PIECE) of TSTREAM]
         (CL:WHEN NPC
             (\INSTALL.PIECE TSTREAM NPC 0)
             NPC)])

(\TEXTPEEKBIN
  [LAMBDA (TSTREAM NOERROR)                                  (* ; "Edited 12-Oct-2022 15:27 by rmk")
                                                             (* ; "Edited  8-Sep-2022 20:24 by rmk")
                                                             (* ; "Edited  9-Aug-2022 10:19 by rmk")
                                                             (* ; "Edited  7-Aug-2022 23:53 by rmk")

    (* ;; "Return the next character (object) without advancing TSTREAM")

    (DECLARE (LOCALVARS . T))
    (LET (ORIGPC BUFFERCHANGED (PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
                (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)       (* ; "See notes at \TEXTBIN")
             [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                        of TSTREAM)
                                                               (ffetch (TEXTSTREAM STARTINGCOFFSET)
                                                                  of TSTREAM])
         (CL:WHEN (\ENDOFBUFFERP TSTREAM)                    (* ; "Buffer overflow.")
             (if (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                 then (SETQ ORIGPC PC)
                      (SETQ PC (\TEXTBIN.NEXT.PIECE TSTREAM))
               else (SETQ BUFFERCHANGED T)
                    (\INSTALL.FILEBUFFER TSTREAM (SUB1 PCCHARSLEFT))))
         (if (NOT PC)
             then (CL:IF NOERROR
                      NIL
                      (STREAMOP 'ENDOFSTREAMOP TSTREAM TSTREAM))
           else (PROG1 (SELECTC (PTYPE PC)
                           (BINABLE.PTYPES 
                                (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                                       (ffetch (STREAM COFFSET) of TSTREAM)))
                           ((LIST FATSTRING.PTYPE FATBLOCK.PTYPE) 
                                                             (* ; "Fat strings are not buffered")
                                (\GETBASEFAT (ffetch (STREAM CBUFPTR) of TSTREAM)
                                       (ffetch (STREAM COFFSET) of TSTREAM)))
                           (FATFILE1.PTYPE 
                                (LOGOR (ffetch (PIECE PCHARSET) of PC)
                                       (\GETBASEBYTE (ffetch (STREAM CPPTR) of TSTREAM)
                                              (ffetch (STREAM COFFSET) of TSTREAM))))
                           (FATFILE2.PTYPE 
                                           (* ;; "This is the most complicated case, because the 2 bytes of a character could be in separate buffers.")

                                (\FATFILE2.CHAR TSTREAM PC T))
                           (OBJECT.PTYPE 
                                         (* ;; 
              "Return the object as BIN's result, and make sure we'll go to the next page next time.")

                                         (* ;; 
                    "OBJECTBYTE is for callers (like COMPARETEXT) that can't deal with image objects")

                                         (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)
                                                    'OBJECTBYTE)
                                             (PCONTENTS PC)))
                           (SUBSTREAM.PTYPE                  (* ; "A substream stored as an object")
                                (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                            'SUBSTREAM)))
                           NIL)

                    (* ;; "If we had to advance, go back to where we were.")

                    (if ORIGPC
                        then (\INSTALL.PIECE TSTREAM ORIGPC (IDIFFERENCE (PLEN ORIGPC)
                                                                   PCCHARSLEFT))
                      elseif BUFFERCHANGED
                        then (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT)))])

(\TEXTBACKFILEPTR
  [LAMBDA (TSTREAM)                                          (* ; "Edited 12-Oct-2022 15:26 by rmk")
                                                             (* ; "Edited  8-Sep-2022 20:57 by rmk")
                                                             (* ; "Edited 10-Aug-2022 13:14 by rmk")
                                                             (* ; "Edited  7-Aug-2022 23:59 by rmk")
                                                             (* ; "Edited  3-Aug-2022 11:04 by rmk")
                                                             (* ; "Edited 28-Jul-2022 23:00 by rmk")
                                                             (* ; "Edited 28-Mar-94 15:32 by jds")

    (* ;; "BACKFILEPTR of a text stream backs over a character.")

    (LET ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
          (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
         (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)
             [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                        of TSTREAM)
                                                               (ffetch (TEXTSTREAM STARTINGCOFFSET)
                                                                  of TSTREAM])
         (CL:WHEN (if (\STARTOFPIECEP TSTREAM PCCHARSLEFT)
                      then (CL:WHEN (SETQ PC (\PREV.VISIBLE.PIECE PC))
                                                             (* ; 
                                                    "Back up to last char of previous piece, if any.")
                               (\INSTALL.PIECE TSTREAM PC (SUB1 (PLEN PC)))
                               T)
                    elseif (AND (MEMB (PTYPE PC)
                                      FILE.PTYPES)
                                (\STARTOFBUFFERP TSTREAM))
                      then 
                           (* ;; "Must be a buffered file, needs to back up. O")

                           (\INSTALL.FILEBUFFER TSTREAM (ADD1 PCCHARSLEFT))
                    else 
                         (* ;; "This piece can be backed up at least one character ")

                         (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                              (CL:IF (MEMB (PTYPE PC)
                                           (LIST FATFILE2.PTYPE FATBLOCK.PTYPE))
                                  -2
                                  -1)))

             (* ;; "We have now backed up to a piece that has at least one character. We are supposed to return the character we backed over")

             (SELECTC (PTYPE PC)
                 (BINABLE.PTYPES 
                      (\GETBASEBYTE (ffetch (STREAM CBUFPTR) of TSTREAM)
                             (ffetch (STREAM COFFSET) of TSTREAM)))
                 (FATFILE1.PTYPE 
                      (LOGOR (ffetch (PIECE PCHARSET) of PC)
                             (\GETBASEBYTE (ffetch (STREAM CPPTR) of TSTREAM)
                                    (ffetch (STREAM COFFSET) of TSTREAM))))
                 ((LIST FATSTRING.PTYPE FATBLOCK.PTYPE) 
                      (\GETBASEFAT (ffetch (STREAM CBUFPTR) of TSTREAM)
                             (ffetch (STREAM COFFSET) of TSTREAM)))
                 (FATFILE2.PTYPE                             (* ; 
                                                          "The 2 bytes could cross a buffer boundary")
                      (\FATFILE2.CHAR TSTREAM PC T))
                 (OBJECT.PTYPE (OR (GETTEXTPROP (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)
                                          'OBJECTBYTE)
                                   (PCONTENTS PC)))
                 (SUBSTREAM.PTYPE 
                      (HELP 'SUBSTREAM)
                      (BIN (IMAGEOBJPROP (PCONTENTS PC)
                                  'SUBSTREAM)))
                 (SHOULDNT)))])

(\TEXTOUTCHARFN
  [LAMBDA (CH STREAM)                                        (* ; "Edited 31-May-91 13:59 by jds")
    (\INSERTCH CH (fetch (TEXTOBJ TEXTLEN) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
           (fetch (TEXTSTREAM TEXTOBJ) of STREAM])

(\INSTALL.FILEBUFFER
  [LAMBDA (TSTREAM PCCHARSLEFT)                              (* ; "Edited  8-Sep-2022 14:17 by rmk")
                                                             (* ; "Edited  6-Sep-2022 17:15 by rmk")
                                                             (* ; "Edited 21-Aug-2022 22:35 by rmk")
                                                             (* ; "Edited  7-Aug-2022 20:35 by rmk")
                                                             (* ; "Edited 31-Jul-2022 20:09 by rmk")

    (* ;; "Sets up the buffer and buffering parameters ofTSTREAM and the underlying PFILE of its piece so that the next BIN wlil return the character PCCHARSLEFT away from the end of the piece.  PCCHARSLEFT is piecewise, STARTINGCOFFSET and other buffering parameters are bufferwise.")

    (* ;; "The buffer may overflow even when the piece itself is not exhausted.")

    (* ;; "Called on buffer overflow when the piece itself is not exhausted.  .")

    (* ;; "A binable stream doesn't track the number of 1-byte chars left in this piece, but COFFSET minus STARTINGCOFFSET enables the PCCHARSLEFT to be determined at the end of the buffer.   ")

    (LET* ((PC (fetch (TEXTSTREAM PIECE) of TSTREAM))
           (PFILE (PCONTENTS PC))
           (PLEN (PLEN PC))
           PCBYTEOFFSET PCBYTELENGTH CBUFSIZE)
          (CL:UNLESS (MEMB (PTYPE PC)
                           FILE.PTYPES)
                 (HELP "FILE BUFFER FOR STRING PIECE?" PC))
          (CL:UNLESS (AND PFILE (\GETSTREAM PFILE 'INPUT T)) (* ; 
                                                   "The file was closed for some reason;  reopen it.")
              (SETQ PFILE (\TEDIT.REOPEN.STREAM TSTREAM PFILE)))
          (CL:UNLESS PCCHARSLEFT                             (* ; "First character of the piece")
              (SETQ PCCHARSLEFT PLEN))

          (* ;; "PCBYTESLEFT is the number of bytes already covered so that PCCHARSLEFT characters are left in the piece..")

          (if (EQ FATFILE2.PTYPE (PTYPE PC))
              then (SETQ PCBYTEOFFSET (UNFOLD (IDIFFERENCE PLEN PCCHARSLEFT)
                                             2))
                   (SETQ PCBYTELENGTH (UNFOLD PLEN 2))
            else (SETQ PCBYTEOFFSET (IDIFFERENCE PLEN PCCHARSLEFT))
                 (SETQ PCBYTELENGTH PLEN))

          (* ;; "Set PFILE to the byte position of the next character of this piece, establishing the PFILE buffer, offset")

          (\SETFILEPTR PFILE (IPLUS (ffetch (PIECE PFPOS) of PC)
                                    PCBYTEOFFSET))
          (\PEEKBIN PFILE T)

          (* ;; 
    "PFILE's buffer parameters should now be good; steal the fields needed to simulate that stream. ")

          (* ;; 
   "The TSTREAM buffersize is reduced so that it only covers bytes that remain in the current piece.")

          (SETQ CBUFSIZE (IMIN (IPLUS (ffetch (STREAM COFFSET) of PFILE)
                                      (IDIFFERENCE PCBYTELENGTH PCBYTEOFFSET))
                               (ffetch (STREAM CBUFSIZE) of PFILE)))
          (freplace (STREAM CPPTR) of TSTREAM with (ffetch (STREAM CPPTR) of PFILE))
          (freplace (STREAM CBUFSIZE) of TSTREAM with CBUFSIZE)
          (freplace (STREAM COFFSET) of TSTREAM with (ffetch (STREAM COFFSET) of PFILE))
          (freplace (TEXTSTREAM STARTINGCOFFSET) of TSTREAM with (fetch (STREAM COFFSET) of TSTREAM))
          (freplace (TEXTSTREAM PCCHARSLEFT) of TSTREAM with PCCHARSLEFT])

(\TEXTBOUT
  [LAMBDA (TSTREAM CHAR)                                     (* ; "Edited 12-Aug-2022 23:26 by rmk")
                                                             (* ; "Edited 10-May-93 16:59 by jds")

    (* ;; "Do BOUT to a text stream, which is an insertion at the caret.")

    (* ;; "ADD1 to convert from %"byte%" indexing to TEDIT selection-indexing.")

    (* ;; "Seems foolish to use \TEXTGETFILEPTR here to map from the current piece to the absolute character index, just so \INSERTCH can map backwards from the character number to the piece.")

    (CL:UNLESS (\CHARCODEP CHAR)
           (\ILLEGAL.ARG CHAR))
    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          (CH# (ADD1 (\TEXTGETFILEPTR TSTREAM)))
          INSERTPC WINDOW)
         (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ) (* ; 
                                                      "Maybe should cause an error--stream not open?")
             (CL:WHEN (SETQ WINDOW (fetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                    (\TEDIT.MARK.LINES.DIRTY TEXTOBJ CH# CH#))
             (CL:WHEN (SETQ INSERTPC (\INSERTCH CHAR CH# TEXTOBJ))

                 (* ;; "We inserted 1 char.  Whether or not we introduced a new piece or extended an old one, we want to be positioned at the first character of the next piece. ")

                 (\INSTALL.PIECE TSTREAM (ffetch (PIECE NEXTPIECE) of INSERTPC)
                        0)
                 (CL:WHEN WINDOW (TEDIT.UPDATE.SCREEN TEXTOBJ))))
         CHAR])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \FATFILE2.CHAR MACRO [(TSTREAM PC DONTADVANCE)

                                (* ;; "DONTADVANCE is T for calls from \TEXTPEEKBIN and \TEXTBACKFILEPTR, NIL for calls from \TEXTBIN.  In each case, the streams PCCHARSLEFT is set to what it should be AFTER this operation.  So, in the buffer-overflow case, we have to back up 1 character (2 bytes) in the SETFILEPTR so we can read the proper character. ")

                                (if (IGEQ (IDIFFERENCE (ffetch (STREAM CBUFSIZE) of TSTREAM)
                                                 (ffetch (STREAM COFFSET) of TSTREAM))
                                          2)
                                    then 
                                         (* ;; "Not so bad if both bytes are in the same buffer.")

                                         (PROG1 [LOGOR (UNFOLD (\GETBASEBYTE (ffetch (STREAM CBUFPTR)
                                                                                of TSTREAM)
                                                                      (ffetch (STREAM COFFSET)
                                                                         of TSTREAM))
                                                              256)
                                                       (\GETBASEBYTE (ffetch (STREAM CBUFPTR)
                                                                        of TSTREAM)
                                                              (ADD1 (ffetch (STREAM COFFSET)
                                                                       of TSTREAM]
                                             (CL:UNLESS DONTADVANCE
                                                 (ADD (ffetch (STREAM COFFSET) of TSTREAM)
                                                      2)))
                                  else 

                                 (* ;; "Otherwise, we have to cross a buffer boundary.  We do this by setting up the underlying file to the right position, read 2-byte word from there, and then reinstall the buffering parameters in TSTREAM, either to the new position or the old (DONTADVANCE).")

                                       (LET ((PFILE (PCONTENTS PC))
                                             (PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT)
                                                             of TSTREAM)))
                                            (\SETFILEPTR PFILE
                                                   (IPLUS (ffetch (PIECE PFPOS) of PC)
                                                          (UNFOLD (IDIFFERENCE (PLEN PC)
                                                                         (CL:IF DONTADVANCE
                                                                             PCCHARSLEFT
                                                                             (ADD1 PCCHARSLEFT)))
                                                                 2)))

                                            (* ;; 
        "Return the 2-byte character after reverting to the previous (post-operation) configuration.")

                                            (PROG1 (\WIN PFILE)
                                                   (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT])

(PUTPROPS \ENDOFPIECEP MACRO ((TSTREAM PCLEFT)
                              (EQ 0 PCLEFT)))

(PUTPROPS \STARTOFPIECEP MACRO ((TSTREAM PCLEFT)
                                (IEQP (PLEN (ffetch (TEXTSTREAM PIECE) of TSTREAM))
                                      PCLEFT)))

(PUTPROPS \ENDOFBUFFERP MACRO ((TSTREAM)
                               (IGEQ (ffetch (STREAM COFFSET) of TSTREAM)
                                     (ffetch (STREAM CBUFSIZE) of TSTREAM))))

(PUTPROPS \STARTOFBUFFERP MACRO ((TSTREAM)
                                 (ILEQ (ffetch (STREAM COFFSET) of TSTREAM)
                                       (ffetch (TEXTSTREAM STARTINGCOFFSET) of TSTREAM))))
)
)



(* ;; "External format functions:  equivalent to BIN-level")

(DEFINEQ

(\TEXTSTREAM.OUTCHARFN
  [LAMBDA (STREAM CHARCODE)                                  (* ; "Edited 22-Jul-2022 19:05 by rmk")
                                                            (* ; "Edited 12-Oct-2021 15:38 by rmk:")

    (* ;; "OUTCCODEFN for TEXTSTREAM  -- BOUTs the  16-bit CHARCODE, because TEdit streams deal in complete charcodes rather than bytes (via \TEXTBOUT).  Updates the CHARPOSITION of the stream, which is used by some code to decide things.")

    (* ;; "\TEXTOUTCHARFN has ")
                                                             (* (\INSERTCH CH (fetch
                                                             (TEXTOBJ TEXTLEN) of
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
    (COND
       ((EQ CHARCODE (CHARCODE EOL))
        (\TEXTBOUT STREAM (CHARCODE CR))
        (freplace (STREAM CHARPOSITION) of STREAM with 0))
       (T (\TEXTBOUT STREAM CHARCODE)
          (freplace (STREAM CHARPOSITION) of STREAM with (PROGN 
                                                             (* ; "Ugh.  Don't overflow")
                                                                (IPLUS16 (ffetch (STREAM CHARPOSITION
                                                                                        )
                                                                            of STREAM)
                                                                       1])

(\TEXTSTREAM.INCCCODEFN
  [LAMBDA (STREAM COUNTP)                                    (* ; "Edited  7-Aug-2022 22:25 by rmk")
                                                             (* ; "Edited 22-Jul-2022 18:47 by rmk")
                                                            (* ; "Edited  6-Aug-2021 15:57 by rmk:")

(* ;;; "Returns a 16 bit character code.  SHIFTEDCSET is STREAM's char set left shifted 8.")

(* ;;; "If COUNTP is non-NIL, the variable *BYTECOUNTER* is set freely to 1, since we already read 1 16-bit %"byte%".")

    (DECLARE (USEDFREE *BYTECOUNTER*))
    (CL:WHEN COUNTP (SETQ *BYTECOUNTER* 1))
    (BIN STREAM])

(\TEXTSTREAM.PEEKCCODEFN
  [LAMBDA (STREAM NOERROR)                                   (* ; "Edited 22-Jul-2022 18:48 by rmk")
                                                            (* ; "Edited 21-Jun-2021 23:44 by rmk:")
    (\TEXTPEEKBIN STREAM NOERROR])

(\TEXTSTREAM.BACKCCODEFN
  [LAMBDA (STREAM COUNTP)                                    (* ; "Edited 22-Jul-2022 19:01 by rmk")
                                                             (* ; "Edited 19-Jul-2022 17:12 by rmk")
                                                            (* ; "Edited 13-Aug-2021 14:08 by rmk:")
    (DECLARE (USEDFREE *BYTECOUNTER*))
    (CL:WHEN COUNTP (SETQ *BYTECOUNTER* -1))
    (\TEXTBACKFILEPTR STREAM])

(\TEXTSTREAM.OUTCHARFN
  [LAMBDA (STREAM CHARCODE)                                  (* ; "Edited 22-Jul-2022 19:05 by rmk")
                                                            (* ; "Edited 12-Oct-2021 15:38 by rmk:")

    (* ;; "OUTCCODEFN for TEXTSTREAM  -- BOUTs the  16-bit CHARCODE, because TEdit streams deal in complete charcodes rather than bytes (via \TEXTBOUT).  Updates the CHARPOSITION of the stream, which is used by some code to decide things.")

    (* ;; "\TEXTOUTCHARFN has ")
                                                             (* (\INSERTCH CH (fetch
                                                             (TEXTOBJ TEXTLEN) of
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
                                                             (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
    (COND
       ((EQ CHARCODE (CHARCODE EOL))
        (\TEXTBOUT STREAM (CHARCODE CR))
        (freplace (STREAM CHARPOSITION) of STREAM with 0))
       (T (\TEXTBOUT STREAM CHARCODE)
          (freplace (STREAM CHARPOSITION) of STREAM with (PROGN 
                                                             (* ; "Ugh.  Don't overflow")
                                                                (IPLUS16 (ffetch (STREAM CHARPOSITION
                                                                                        )
                                                                            of STREAM)
                                                                       1])

(\TEXTSTREAM.FORMATBYTESTREAM
  [LAMBDA (STREAM BYTESTREAM)                               (* ; "Edited 24-Jun-2021 16:47 by rmk:")
    (REPLACE (STREAM CHARSET) OF BYTESTREAM WITH (FETCH (STREAM CHARSET) OF STREAM])
)



(* ;; "High-level stream operations")

(DEFINEQ

(COPYTEXTSTREAM
  [LAMBDA (ORIGINAL CROSSCOPY)                               (* ; "Edited  9-Oct-2022 12:03 by rmk")
                                                             (* ; "Edited  6-Oct-2022 10:28 by rmk")
                                                             (* ; "Edited  7-Sep-2022 23:01 by rmk")
                                                             (* ; "Edited  5-Sep-2022 15:33 by rmk")
                                                             (* ; "Edited 21-Aug-2022 19:37 by rmk")
                                                             (* ; 
                                                        "Edited 24-Apr-95 12:02 by sybalsky:mv:envos")

    (* ;; "Given a stream, textobj or window, returns a new textstream with the same contents.  If CROSSCOPY then strings will really be allocated providing copies of the text else the fileptrs still will be aliases as in the rest of TEDIT.")

    (LET ((TEXTOBJ (TEXTOBJ ORIGINAL))
          TSEL PCLST NEWSTREAM NEWTEXTOBJ)
         (SETQ TSEL (fetch (TEXTOBJ SCRATCHSEL) of TEXTOBJ))
         (SETQ NEWSTREAM (OPENTEXTSTREAM NIL NIL NIL NIL (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ)))
                                                             (* ; 
                             "First create an empty textstream into which the pieces can be hammered")
         (SETQ NEWTEXTOBJ (TEXTOBJ NEWSTREAM))
         (replace (SELECTION CH#) of TSEL with 1)            (* ; 
                                                             "Set up to select the whole source text")
         (replace (SELECTION CHLIM) of TSEL with (ADD1 (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
         (replace (SELECTION DCH) of TSEL with (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
         (SETQ PCLST (TEDIT.SELECTED.PIECES TEXTOBJ TSEL (FUNCTION \TEDIT.COPYPIECE)
                            TEXTOBJ NEWTEXTOBJ))             (* ; 
                    "now get a list of copies of the pieces to be inserted into the empty textstream")
         (\TEDIT.INSERT.PIECES NEWTEXTOBJ 1 PCLST (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)
                NIL CROSSCOPY)                               (* ; 
                                                            "Put the pieces into the copy textstream")
                                                             (* ; 
                                                        "The copy is the same length as the original")
         (replace (TEXTOBJ MENUFLG) of NEWTEXTOBJ with (fetch (TEXTOBJ MENUFLG) of TEXTOBJ))
                                                             (* ; 
                                                       "And if the original is a menu, so's the copy")
         NEWSTREAM])

(OPENTEXTSTREAM
  [LAMBDA (TEXT WINDOW START END PROPS)

    (* ;; "Edited 21-Oct-2022 18:43 by rmk")

    (* ;; "Edited  5-Sep-2022 22:07 by rmk")

    (* ;; "Edited 22-Aug-2022 14:26 by rmk")

    (* ;; "Edited 13-Aug-2022 09:00 by rmk")

    (* ;; "Edited  9-Aug-2022 21:02 by rmk")

    (* ;; "Edited  8-Aug-2022 00:14 by rmk")

    (* ;; "Edited 31-Jan-2022 17:25 by rmk: A string TEXT is converted here to a stream")

    (* ;; "Edited  4-May-93 14:38 by jds")
                                                             (* ; 
       "Create a text-type STREAM to describe TEXT.  Optionally, connect that to WINDOW for display.")
    (LET* ([WAS-TEXTSTREAM (AND (type? STREAM TEXT)
                                (type? TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TEXT]
           [TEXTOBJ (COND
                       (WAS-TEXTSTREAM                       (* ; 
                                 "If the guy gave us a text stream to edit, use its TEXTOBJ as ours.")
                              (create TEXTOBJ reusing (fetch (TEXTSTREAM TEXTOBJ) of TEXT)
                                                    HINTPC _ NIL))
                       ((type? TEXTOBJ TEXT)
                        (create TEXTOBJ using TEXT HINTPC _ NIL))
                       (T (create TEXTOBJ]
           (TEDIT.GET.FINISHEDFORMS NIL)
           [PROPS (APPEND PROPS (COPY TEDIT.DEFAULT.PROPS)
                         (COPY (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ]
           [TEXTOBJ.WINDOW.VALID (AND WINDOW (EQ WINDOW (\TEDIT.PRIMARYW TEXTOBJ))
                                      (EQ TEXTOBJ (WINDOWPROP WINDOW 'TEXTOBJ]
           FONT SEL TSTREAM OTEXTOBJ PROP CLEARGET? PARALOOKS PWINDOW)
                                                             (* ; 
                                                      "Remember if the textobj had a window already.")
          (replace (TEXTOBJ \WINDOW) of TEXTOBJ with (AND WINDOW (LIST WINDOW)))
                                                             (* ; 
                "Necessary because some incoming object types depend on knowing where the window is.")
          (replace (TEXTOBJ LINES) of TEXTOBJ with NIL)

          (* ;; "This is here so if we re-OPENTEXTSTREAM an existing stream/window pair we don't get two sets of line descriptors")

          (for PROPNAME in PROPS by (CDDR PROPNAME) as PROPVAL in (CDR PROPS)
             by (CDDR PROPVAL) do (TEXTPROP TEXTOBJ PROPNAME PROPVAL))
                                                             (* ; 
                                            "Save the PROPS for later people who'd like to know them")
          [SETQ FONT (COND
                        ((type? CHARLOOKS (LISTGET PROPS 'FONT))
                         (LISTGET PROPS 'FONT))
                        (T (\TEDIT.PARSE.CHARLOOKS.LIST [OR (LISTGET PROPS 'LOOKS)
                                                            (COND
                                                               [(LISTP (LISTGET PROPS 'FONT))
                                                                (FONTCREATE (LISTGET PROPS
                                                                                   'FONT]
                                                               (T (OR (LISTGET PROPS 'FONT)
                                                                      DEFAULTFONT]
                                  NIL TEXTOBJ]               (* ; 
 "Find the default font for this session -- either what the guy tells us, or the global default font")
          (SETQ PARALOOKS (LISTGET PROPS 'PARALOOKS))

          (* ;; "Get the default paragraph looks.  This must come before the first piece is created, so its fields can be filled in right.")

          (replace (TEXTOBJ FMTSPEC) of TEXTOBJ with (\TEDIT.UNIQUIFY.PARALOOKS
                                                      [SETQ PARALOOKS
                                                       (\TEDIT.PARSE.PARALOOKS.LIST
                                                        (OR PARALOOKS (create FMTSPEC using 
                                                                                TEDIT.DEFAULT.FMTSPEC
                                                                             ]
                                                      TEXTOBJ))
          [COND
             [WAS-TEXTSTREAM                                 (* ; 
                                                      "We got a TEXTOFD stream to edit;  just use it")
                    (SETQ OTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TEXT))
                    (SETQ TSTREAM TEXT)
                    (for SELN in (LIST (fetch (TEXTOBJ SEL) of TEXTOBJ)
                                       (fetch (TEXTOBJ SCRATCHSEL) of TEXTOBJ)
                                       (fetch (TEXTOBJ SHIFTEDSEL) of TEXTOBJ)
                                       (fetch (TEXTOBJ MOVESEL) of TEXTOBJ)
                                       (fetch (TEXTOBJ DELETESEL) of TEXTOBJ))
                       do 
                          (* ;; "Make all the selections point to the CURRENT textobj!")

                          (COND
                             ((EQ OTEXTOBJ (fetch (SELECTION SELTEXTOBJ) of SELN))
                              (replace (SELECTION SELTEXTOBJ) of SELN with TEXTOBJ))
                             (T (replace (SELECTION SET) of SELN with NIL)))
                          (replace (SELECTION ONFLG) of SELN with NIL))
                    (replace (TEXTSTREAM TEXTOBJ) of TSTREAM with TEXTOBJ)
                    (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
                    (replace (TEXTOBJ EDITFINISHEDFLG) of TEXTOBJ with NIL)
                                                             (* ; "Mark the edit incomplete.")
                    (replace (TEXTOBJ \DIRTY) of TEXTOBJ with NIL)
                                                             (* ; "And mark it not changed.")
                    (CL:WHEN FONT                            (* ; 
                                                    "If a new default font was specified, set it up.")
                        (replace (TEXTOBJ DEFAULTCHARLOOKS) of TEXTOBJ with (
                                                                            \TEDIT.UNIQUIFY.CHARLOOKS
                                                                             FONT TEXTOBJ)))]
             ((type? TEXTOBJ TEXT)                           (* ; 
                       "We got a TEXTOBJ to edit; fill in the stream, since it might have been GC'd.")
              (SETQ TSTREAM (create TEXTSTREAM
                                   TEXTOBJ _ TEXTOBJ))
              (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
              (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM)))
             (T                                              (* ; 
                                "Otherwise, create a TEXTSTREAM to describe the text we're editing.-")
                (CL:WHEN (AND TEXT (OR (LITATOM TEXT)
                                       (STRINGP TEXT)
                                       (CL:PATHNAMEP TEXT))) (* ; "rmk: Strings are now file names")
                    [SETQ TEXT (OPENSTREAM TEXT 'INPUT 'OLD
                                      `((TYPE TEXT)
                                        (FORMAT ,(LISTGET PROPS 'FORMAT])
                (SETQ TSTREAM (create TEXTSTREAM
                                     TEXTOBJ _ TEXTOBJ))
                (replace (TEXTOBJ STREAMHINT) of TEXTOBJ with TSTREAM)
                (for FORM in TEDIT.GET.FINISHEDFORMS do (EVAL FORM))
                (TEDIT.BUILD.PCTB TEXT TEXTOBJ START END FONT PARALOOKS (LISTGET PROPS 'CLEARGET]
          (replace (TEXTOBJ CARETLOOKS) of TEXTOBJ with (\TEDIT.UNIQUIFY.CHARLOOKS
                                                         (\TEDIT.CARETLOOKS.VERIFY
                                                          TEXTOBJ
                                                          (replace (TEXTOBJ DEFAULTCHARLOOKS)
                                                             of TEXTOBJ with (
                                                                            \TEDIT.UNIQUIFY.CHARLOOKS
                                                                              FONT TEXTOBJ)))
                                                         TEXTOBJ))
          (replace (TEXTOBJ CARET) of TEXTOBJ with (create TEDITCARET
                                                          TCCARETDS _ (AND WINDOW (WINDOWPROP
                                                                                   WINDOW
                                                                                   'DSP))
                                                          TCFORCEUP _ T))
          (replace (TEXTOBJ TXTREADONLY) of TEXTOBJ with (LISTGET PROPS 'READONLY))
          (replace (TEXTOBJ TXTTERMSA) of TEXTOBJ with (AND (SETQ PROP (LISTGET PROPS 'TERMTABLE))
                                                            (fetch TERMSA of PROP)))
          (replace (TEXTOBJ TXTRTBL) of TEXTOBJ with (LISTGET PROPS 'READTABLE))
          (replace (TEXTOBJ TXTWTBL) of TEXTOBJ with (LISTGET PROPS 'BOUNDTABLE))
          (CL:WHEN (LISTGET PROPS 'PAGEFORMAT)               (* ; 
                                "A default page formatting was supplied.  Impose it on the document.")
              (TEDIT.PAGEFORMAT TEXTOBJ (LISTGET PROPS 'PAGEFORMAT)))
          (SETQ SEL (fetch (TEXTOBJ SEL) of TEXTOBJ))
          (SETQ PROP (LISTGET PROPS 'SEL))                   (* ; "Initial Selection, if any.")
          (COND
             ((EQ PROP 'DON'T)                               (* ; 
                                          "A SEL prop of DON'T means don't make an initial selection")
              (replace (SELECTION SET) of SEL with NIL))
             ((type? SELECTION PROP)                         (* ; 
                                               "We came in with an explicit initial sel.  Set it up.")
              (\COPYSEL PROP SEL)
              (replace (SELECTION SET) of SEL with T)
              (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ))
             ((AND (fetch (SELECTION SET) of SEL)
                   (NOT PROP))                               (* ; 
                                         "If we came into this with a valid selection, highlight it.")
              (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ))
             (T                                              (* ; 
      "Starting without a selection;  let's start with a point selection before the first character.")
                (replace (SELECTION CH#) of SEL with (COND
                                                        ((FIXP PROP))
                                                        (PROP (CAR PROP))
                                                        (1)))
                (replace (SELECTION CHLIM) of SEL with (COND
                                                          ((FIXP PROP))
                                                          (PROP (IPLUS (CAR PROP)
                                                                       (CADR PROP)))
                                                          (1)))
                (replace (SELECTION DCH) of SEL with (COND
                                                        ((FIXP PROP)
                                                         0)
                                                        (PROP (CADR PROP))
                                                        (0)))
                (replace (SELECTION DX) of SEL with 0)
                (replace (SELECTION POINT) of SEL with 'LEFT)
                (replace (SELECTION SELKIND) of SEL with 'CHAR)
                (replace (SELECTION SET) of SEL with (NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)))
                (replace (SELECTION SELTEXTOBJ) of SEL with TEXTOBJ)))
          (CL:WHEN (fetch (SELECTION SET) of SEL)            (* ; 
                                   "If there's an initial selection, it implies initial caret looks.")
              (replace (TEXTOBJ CARETLOOKS) of TEXTOBJ with (\TEDIT.GET.INSERT.CHARLOOKS TEXTOBJ SEL)
                     ))
          (\INSTALL.PIECE TSTREAM (\FIRSTPIECE TEXTOBJ)
                 0)                                          (* ; 
                                                      "Set the file ptr to 0 so that looks are good.")
          (COND
             ((AND WINDOW (NOT TEXTOBJ.WINDOW.VALID))        (* ; 
                                                         "Only if there's a window to display it in:")
              (replace (TEXTOBJ \WINDOW) of TEXTOBJ with NIL)(* ; 
                                                   "Set up the window, and display the initial text.")
              (\TEDIT.WINDOW.SETUP WINDOW TEXTOBJ TSTREAM PROPS)
                                                             (* ; 
                                                             "Back to 0: WINDOW.SETUP moves around")
              (\INSTALL.PIECE TSTREAM (\FIRSTPIECE TEXTOBJ)
                     0))
             ((SETQ PWINDOW (LISTGET PROPS 'PROMPTWINDOW))

              (* ;; "There is no window for the session, but he has passed in a promptwindow to use, install it in the textobj")

              (replace (TEXTOBJ PROMPTWINDOW) of TEXTOBJ with PWINDOW)))
          TSTREAM])

(REOPENTEXTSTREAM
  [LAMBDA (STREAM)                                           (* ; "Edited 31-May-91 14:18 by jds")
    (replace (STREAM ACCESS) of STREAM with 'BOTH)
    (replace (STREAM BINABLE) of STREAM with T)
    (replace (STREAM STRMBINFN) of STREAM with (FUNCTION \TEXTBIN))
    (replace (STREAM STRMBOUTFN) of STREAM with (FUNCTION \TEXTBOUT))
    STREAM])

(TEDIT.STREAMCHANGEDP
  [LAMBDA (STREAM RESET?)                                    (* ; "Edited 31-May-91 13:57 by jds")
    (PROG1 (fetch (TEXTOBJ \DIRTY) of (TEXTOBJ STREAM))
        (COND
           (RESET? (replace (TEXTOBJ \DIRTY) of (TEXTOBJ STREAM) with NIL))))])

(TEXTSTREAMP
  [LAMBDA (STREAM)                                           (* jds " 3-Apr-84 14:34")
                                                             (* Returns the stream if it is a text 
                                                             stream, else NIL)
    (AND (STREAMP STREAM)
         (type? TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM))
         STREAM])

(TXTFILE
  [LAMBDA (TEXTOBJ)                                          (* ; "Edited 31-May-91 13:58 by jds")
                                                             (* This function is for compiled 
                                                             access to the TXTFILE field in 
                                                             RESETSAVE expressions)
    (fetch (TEXTOBJ TXTFILE) of TEXTOBJ])

(\TEDIT.REOPEN.STREAM
  [LAMBDA (TSTREAM PIECESTREAM)                              (* ; "Edited 15-Sep-2022 22:56 by rmk")
                                                             (* ; "Edited 11-Jun-99 15:12 by rmk:")
                                                             (* ; "Edited 15-Apr-93 15:53 by jds")

    (* ;; "Re-open the backing file stream, and propogate the change thru the entire piece table.  Also, if TXTFILE is set to the closed stream, fill it in as well.  If there is a reopen operation that simply smashes the existing stream-datum, we wouldn't have to do the sweep.")

    (LET ([NEWSTREAM (OPENSTREAM PIECESTREAM 'INPUT NIL `((TYPE TEXT)
                                                          (FORMAT ,(STREAMPROP PIECESTREAM 
                                                                          :EXTERNAL-FORMAT]
          (TEXTOBJ (TEXTOBJ TSTREAM)))

         (* ;; "Run thru the pieces, correcting any that used this stream to use the new one:")

         (for PC _ (\FIRSTPIECE TEXTOBJ) by (NEXTPIECE PC) while PC when (EQ (PCONTENTS PC)
                                                                             PIECESTREAM)
            do (replace (PIECE PCONTENTS) of PC with NEWSTREAM))

         (* ;; "Check the TXTFILE, and if it uses the closed stream, fix it as well:")

         (CL:WHEN (EQ (fetch (TEXTOBJ TXTFILE) of TEXTOBJ)
                      PIECESTREAM)
             (replace (TEXTOBJ TXTFILE) of TEXTOBJ with NEWSTREAM))

         (* ;; "Return the new value for the stream:")

         NEWSTREAM])

(\TEXTINIT
  [LAMBDA NIL                                                (* ; "Edited 28-Aug-2022 22:19 by rmk")
                                                             (* ; "Edited 22-Jul-2022 20:02 by rmk")
                                                             (* ; "Edited  3-Jul-2022 00:34 by rmk")
                                                             (* ; "Edited  5-May-2022 15:12 by rmk")
                                                            (* ; "Edited  7-Oct-2021 08:40 by rmk:")
                                                             (* ; 
                                            "Create the FDEV and STREAM prototypes for TEXT streams.")

    (* ;; "TEXT streams make use of the following STREAM fields:")

    (* ;; "(DEVICE (* FDEV of this guy -- The TEXT device)")

    (* ;; "F1 (* The STREAM for the PFILE of the current piece (or NIL))")

    (* ;; "F2 (* # chars left in piece at end of underlying file's page)")

    (* ;; "F3 (* The TEXTOBJ for this stream)")

    (* ;; "F4")

    (* ;; "F5 (* The PIECE we're currently inside)")

    (* ;; "(FW6 WORD) (* CPAGE for the start of the piece, for BACKFILEPTR)")

    (* ;; "(FW7 WORD) (* COFFSET for the start of the piece, for BACKFILEPTR)")

    (* ;; "(FW8 WORD)")

    [SETQ \TEXTIMAGEOPS (create IMAGEOPS
                               IMAGETYPE _ 'TEXT
                               IMXPOSITION _ (FUNCTION \TEXTDSPXPOSITION)
                               IMYPOSITION _ (FUNCTION \TEXTDSPYPOSITION)
                               IMLEFTMARGIN _ (FUNCTION \TEXTLEFTMARGIN)
                               IMRIGHTMARGIN _ (FUNCTION \TEXTRIGHTMARGIN)
                               IMFONT _ (FUNCTION \TEXTDSPFONT)
                               IMCLOSEFN _ (FUNCTION NILL)
                               IMFONTCREATE _ 'DISPLAY
                               IMLINEFEED _ (FUNCTION \TEXTDSPLINEFEED)
                               IMCHARWIDTH _ (FUNCTION \TEXTDSPCHARWIDTH)
                               IMSTRINGWIDTH _ (FUNCTION \TEXTDSPSTRINGWIDTH)
                               IMSCALE _ (FUNCTION (LAMBDA NIL 1]

    (* ;; "Maybe more functions later. The INCODE and BACK functions possibly need to count.  If \TEXTBACKFILEPTR takes a count variable, the extra level wouldn't be needed.  But INCCODE wants to go through the BIN opcode")

    (MAKE-EXTERNALFORMAT :TEXTSTREAM (FUNCTION \TEXTSTREAM.INCCCODEFN)
           (FUNCTION \TEXTPEEKBIN)
           (FUNCTION \TEXTSTREAM.BACKCCODEFN)
           (FUNCTION \TEXTSTREAM.OUTCHARFN)
           (FUNCTION \TEXTSTREAM.FORMATBYTESTREAM)
           'CR)
    (SETQ \TEXTFDEV (create FDEV
                           DEVICENAME _ 'TEXT
                           RESETABLE _ T
                           RANDOMACCESSP _ T
                           PAGEMAPPED _ NIL
                           GETFILENAME _ (FUNCTION NILL)
                           BIN _ (FUNCTION \TEXTBIN)
                           BOUT _ (FUNCTION \TEXTBOUT)
                           CLOSEFILE _ (FUNCTION \TEXTCLOSEF)
                           OPENFILE _ (FUNCTION \TEXTOPENF)
                           DELETEFILE _ (FUNCTION NILL)
                           DIRECTORYNAMEP _ (FUNCTION NILL)
                           EVENTFN _ (FUNCTION NILL)
                           GENERATEFILES _ (FUNCTION \GENERATENOFILES)
                           GETFILEINFO _ (FUNCTION NILL)
                           HOSTNAMEP _ (FUNCTION NILL)
                           READPAGES _ (FUNCTION NILL)
                           REOPENFILE _ [FUNCTION (LAMBDA (FILE ACCESS RECOG OTHERINFO FDEV STREAM)
                                                    (replace (STREAM ACCESS) of STREAM
                                                       with 'BOTH)
                                                    STREAM]
                           SETFILEINFO _ (FUNCTION NILL)
                           BACKFILEPTR _ (FUNCTION \TEXTBACKFILEPTR)
                           SETFILEPTR _ (FUNCTION \TEXTSETFILEPTR)
                           PEEKBIN _ (FUNCTION \TEXTPEEKBIN)
                           GETEOFPTR _ (FUNCTION \TEXTGETEOFPTR)
                           GETFILEPTR _ (FUNCTION \TEXTGETFILEPTR)
                           EOFP _ (FUNCTION \TEXTEOFP)
                           FDBINABLE _ T
                           FDBOUTABLE _ NIL
                           FDEXTENDABLE _ NIL
                           TRUNCATEFILE _ (FUNCTION NILL)
                           WRITEPAGES _ (FUNCTION NILL)
                           DEFAULTEXTERNALFORMAT _ :TEXTSTREAM))
    (CL:SETF (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN)
           (FUNCTION (LAMBDA (CONDITION)
                       (LET ((STREAM (STREAM-ERROR-STREAM CONDITION)))
                            (COND
                               [(AND (BOUNDP 'ERRORPOS)
                                     (TEXTSTREAMP STREAM))   (* ; 
             "This happened in the error handler, and it happened to a TEdit stream, so try the fix:")
                                (LET ((XCL::RESULT (REOPENTEXTSTREAM STREAM)))
                                     (CL:WHEN XCL::RESULT
                                         (ENVAPPLY (STKNAME ERRORPOS)
                                                (SUBST XCL::RESULT STREAM (STKARGS ERRORPOS))
                                                (STKNTH -1 ERRORPOS ERRORPOS)
                                                ERRORPOS T T))]
                               (*TEDIT-OLD-STREAM-ERROR-HANDLER* 
                                                             (* ; 
                           "Some other kind of stream, so punt to the old handler (if there is one):")
                                      (APPLY* *TEDIT-OLD-STREAM-ERROR-HANDLER* CONDITION])

(\TEXTTTYBOUT
  [LAMBDA (STREAM BYTE)                                      (* ; "Edited 31-May-91 14:18 by jds")
                                                             (* Do BOUT to a text stream, which is 
                                                             an insertion at the caret.)
    (PROG ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of STREAM)))
          (COND
             ((EQ BYTE ERASECHARCODE)
              (\TEDIT.CHARDELETE TEXTOBJ "" (fetch (TEXTOBJ SEL) of TEXTOBJ)))
             ((EQ IGNORE.CCE (fetch CCECHO of (\SYNCODE (OR (fetch (TEXTOBJ TXTTERMSA) of TEXTOBJ)
                                                            \PRIMTERMSA)
                                                     BYTE))) (* Nothing, ignore it)
              )
             (T (SELCHARQ BYTE
                     ((EOL CR LF) 
                          (\TEXTBOUT STREAM BYTE)
                          (replace (STREAM CHARPOSITION) of STREAM with 0))
                     (PROGN (\TEXTBOUT STREAM BYTE)
                            (add (fetch (STREAM CHARPOSITION) of STREAM)
                                 1])
)



(* ;; "Low-level generic stream operations")

(DEFINEQ

(\TEXTCLOSEF
  [LAMBDA (TSTREAM)                                          (* ; "Edited 26-Oct-2022 11:17 by rmk")
                                                             (* ; "Edited 22-Aug-2022 14:18 by rmk")
                                                             (* ; "Edited  8-Aug-2022 14:56 by rmk")
                                                             (* ; "Edited 15-Apr-93 16:43 by jds")
                                                             (* ; 
                                                             "Close the files underlying a stream")
    (LET ((TEXTOBJ (TEXTOBJ TSTREAM)))
         (for (PC _ (\FIRSTPIECE TEXTOBJ)) by (NEXTPIECE PC) while PC
            when (AND (MEMB (PTYPE PC)
                            FILE.PTYPES)
                      (PCONTENTS PC)) do (CLOSEF? (PCONTENTS PC)))

         (* ;; "And close the REAL file as well, in case we'd made a local cache.")

         (CLOSEF? (fetch (TEXTOBJ TXTFILE) of TEXTOBJ])

(\TEXTDSPFONT
  [LAMBDA (STREAM NEWFONT)                                   (* ; "Edited  8-Sep-2022 14:16 by rmk")
                                                             (* ; "Edited 31-May-91 14:02 by jds")

    (* ;; "Set the font for a TEdit window.  Need change the caret looks, for character insertion, and the WINDOW's looks, so that TEXEC type-out to the window does the right thing.")

    (LET ((TEXTOBJ (TEXTOBJ STREAM)))
         (PROG1 (fetch (CHARLOOKS CLFONT) of (fetch (TEXTOBJ CARETLOOKS) of TEXTOBJ))
             (CL:WHEN NEWFONT                                (* ; 
                                                         "Only do this if there's a new font to set:")
                 (TEDIT.CARETLOOKS STREAM (\GETFONTDESC NEWFONT 'DISPLAY))
                 (CL:WHEN (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)

                     (* ;; "Update the windows, if there are any.")

                     (for WIN in (fetch (TEXTOBJ \WINDOW) of TEXTOBJ) do (DSPFONT NEWFONT WIN)))))])

(\TEXTEOFP
  [LAMBDA (TSTREAM)                                          (* ; "Edited 10-Aug-2022 12:41 by rmk")
                                                             (* ; "Edited  5-Aug-2022 16:37 by rmk")
                                                             (* ; "Edited 31-May-91 14:18 by jds")

    (* ;; "Test for EOF on a text stream: At end of a piece, and there's no more visible pieces.")

    (CL:WHEN (\ENDOFBUFFERP TSTREAM)
        [LET ((PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM)))
             (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)
                 [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET)
                                                                            of TSTREAM)
                                                                   (ffetch (TEXTSTREAM 
                                                                                  STARTINGCOFFSET)
                                                                      of TSTREAM])
             (AND (\ENDOFPIECEP TSTREAM PCCHARSLEFT)
                  (NULL (\NEXT.VISIBLE.PIECE (fetch (TEXTSTREAM PIECE) of TSTREAM])])

(\TEXTGETEOFPTR
  [LAMBDA (STREAM)                                           (* ; "Edited 31-May-91 13:58 by jds")
    (fetch (TEXTOBJ TEXTLEN) of (fetch (TEXTSTREAM TEXTOBJ) of STREAM])

(\TEXTGETFILEPTR
  [LAMBDA (TSTREAM)                                          (* ; "Edited  2-Sep-2022 17:45 by rmk")
                                                             (* ; "Edited 30-Jul-2022 00:07 by rmk")
                                                             (* ; "Edited 28-Mar-94 15:32 by jds")

    (* ;; "GETFILEPTR fn for text streams.  Measured in characters (and objects), not 8-bit bytes.")

    (LET ((PC (\NOTLASTPIECEP (ffetch (TEXTSTREAM PIECE) of TSTREAM)
                     (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM)))
          PCCHARSLEFT)
         (if PC
             then                                            (* ; "Somewhere inside the document")
                  (SETQ PCCHARSLEFT (ffetch (TEXTSTREAM PCCHARSLEFT) of TSTREAM))
                  (CL:WHEN (ffetch (STREAM BINABLE) of TSTREAM)

                      (* ;; "PCCHARSLEFT may lag. If binable, everything is thin, no need to multiply. We don't change anything in TSTREAM")

                      [SETQ PCCHARSLEFT (IDIFFERENCE PCCHARSLEFT (IDIFFERENCE (ffetch (STREAM COFFSET
                                                                                             )
                                                                                 of TSTREAM)
                                                                        (ffetch (TEXTSTREAM 
                                                                                      STARTINGCOFFSET
                                                                                       ) of TSTREAM])
                  
                  (* ;; "-1 to go from TEDIT-selection character-indexing back to nominal %"byte%" positions. SETFILEPTR goes the other way.")

                  (IPLUS -1 (\PCTOCH PC)
                         (IDIFFERENCE (PLEN PC)
                                PCCHARSLEFT))
           else 
                (* ;; "Lack of a current piece means empty document or end")

                (ffetch (TEXTOBJ TEXTLEN) of (ffetch (TEXTSTREAM TEXTOBJ) of TSTREAM])

(\TEXTOPENF
  [LAMBDA (TSTREAM ACCESS ASDF QWER ZXCV)                    (* ; "Edited 22-Aug-2022 15:16 by rmk")
                                                             (* ; "Edited 31-May-91 13:58 by jds")
                                                             (* ; 
                                                             "Return the stream, opened for input")
    (FOR PC _ (\FIRSTPIECE (TEXTOBJ TSTREAM)) BY (fetch (PIECE NEXTPIECE) of PC) WHILE PC
       WHEN [AND (MEMB (ffetch (PIECE PTYPE) of PC)
                       FILE.PTYPES)
                 (EQ NoBits (fetch (STREAM ACCESSBITS) of (fetch (PIECE PCONTENTS) of PC]
       DO (\TEDIT.REOPEN.STREAM TSTREAM (fetch (PIECE PCONTENTS) of PC)))
    TSTREAM])

(\TEXTSETEOF
  [LAMBDA (STREAM EOFPTR)                                    (* ; "Edited 31-May-91 14:19 by jds")
                                                             (* Set the EPAGE/EOFFSET of the stream 
                                                             to be (SUB1 of EOFPTR))
    (replace (STREAM EPAGE) of STREAM with (fetch (BYTEPTR PAGE) of EOFPTR))
    (replace (STREAM EOFFSET) of STREAM with (fetch (BYTEPTR OFFSET) of EOFPTR])

(\TEXTSETFILEPTR
  [LAMBDA (TSTREAM FILEPOS)                                  (* ; "Edited  2-Sep-2022 11:34 by rmk")
                                                             (* ; "Edited  8-Aug-2022 23:55 by rmk")
                                                             (* ; "Edited 22-Apr-93 13:44 by jds")
                                                             (* ; 
                                                             "Sets the file ptr for a text stream.")

    (* ;; "FILEPOS is known to be a positive number.  For other filedevices there is no error if the ptr is set beyond the EOF, and GETFILEPTR will return the new position.  But the length of an input file doesn't change and a BIN at any position after the EOF causes the error.  An output file grows.  Filepos is a %"byte%" position, have to add 1 to get to the notion of character in a Tedit selection.")

    (LET ((TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of TSTREAM))
          START-OF-PIECE PC CH#)
         (DECLARE (SPECVARS START-OF-PIECE))
         (CL:WHEN (IGREATERP FILEPOS (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
                                                             (* ; 
                                    "If the fileptr is not within the text, punt. OR: SET IT TO EOF?")
             (\ILLEGAL.ARG FILEPOS))
         (CL:UNLESS (ZEROP (ffetch (TEXTOBJ TEXTLEN) of TEXTOBJ))
             (SETQ CH# (ADD1 FILEPOS))
             (SETQ PC (\CHTOPC CH# TEXTOBJ T))
             (\INSTALL.PIECE TSTREAM PC (- CH# START-OF-PIECE)))])

(\TEXTDSPXPOSITION
  [LAMBDA (STREAM XPOSITION)                                (* ; "Edited  3-Jan-2001 17:27 by rmk:")
                                                  (* ; 
                                     "Edited 24-Oct-88 23:09 by rmk:; Edited 26-Sep-85 16:30 by ajb:")

    (* ;; 
  "Simply returns the XPOSITION of the primary window's display stream, this is a read-only function")

    (LET [(WINDOW (CAR (fetch \WINDOW of (TEXTOBJ STREAM]
         (COND
            (WINDOW (DSPXPOSITION NIL WINDOW))
            (T                                               (* ; 
                                            "If there is no window, estimate from character position")
               (TIMES (CHARWIDTH (CHARCODE SPACE)
                             STREAM)
                      (POSITION STREAM])

(\TEXTDSPYPOSITION
  [LAMBDA (STREAM YPOSITION)                                 (* ; "Edited 31-May-91 13:59 by jds")

         (* Simply returns the XPOSITION of the primary window's display stream, this is a 
         read-only function)

    (LET [(WINDOW (CAR (fetch (TEXTOBJ \WINDOW) of (TEXTOBJ STREAM]
         (IF WINDOW
             THEN (DSPYPOSITION NIL WINDOW)
           ELSE (AND \#DISPLAYLINES (NEQ \CURRENTDISPLAYLINE -1)
                     (DIFFERENCE \#DISPLAYLINES \CURRENTDISPLAYLINE])

(\TEXTLEFTMARGIN
  [LAMBDA (STREAM XPOSITION)                                 (* ; "Edited 31-May-91 14:03 by jds")

(* ;;; "Returns the left margin of the textstream.  This is a read-only function")

    (IF (CAR (fetch (TEXTOBJ \WINDOW) of (TEXTOBJ STREAM)))
        THEN [IPLUS 8 (fetch (FMTSPEC LEFTMAR) of (fetch (TEXTOBJ FMTSPEC) of (TEXTOBJ STREAM]
      ELSE 0])

(\TEXTRIGHTMARGIN
  [LAMBDA (STREAM XPOSITION)                                 (* ; "Edited 31-May-91 14:03 by jds")

(* ;;; "Returns the right margin of the textstream.  This is a read-only function")

    (LET ((TEXTOBJ (TEXTOBJ STREAM)))
         (IF (fetch (TEXTOBJ \WINDOW) of TEXTOBJ)
             THEN (LET [(RIGHTMAR (fetch (FMTSPEC RIGHTMAR) of (fetch (TEXTOBJ FMTSPEC) of TEXTOBJ]
                       (IF (ZEROP RIGHTMAR)
                           THEN (fetch (TEXTOBJ WRIGHT) of TEXTOBJ)
                         ELSE RIGHTMAR))
           ELSE (TIMES (CHARWIDTH (CHARCODE A)
                              STREAM)
                       (LINELENGTH NIL STREAM])

(\TEXTDSPCHARWIDTH
  [LAMBDA (STREAM CHARCODE)                                 (* ; "Edited  9-Feb-99 12:59 by kaplan")
    (CHARWIDTH CHARCODE (DSPFONT NIL STREAM])

(\TEXTDSPSTRINGWIDTH
  [LAMBDA (STREAM STRING)                                   (* ; "Edited  9-Feb-99 13:00 by kaplan")
    (STRINGWIDTH STRING (DSPFONT NIL STREAM])

(\TEXTDSPLINEFEED
  [LAMBDA (STREAM VALUE)
    (FONTPROP (DSPFONT NIL STREAM)
           'HEIGHT])
)



(* ;; "Editing support")

(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ INSERTSTRINGLENGTH 512)


(CONSTANTS (INSERTSTRINGLENGTH 512))
)

(DECLARE%: EVAL@COMPILE 

(PUTPROPS \INSERTCH.EXTENDABLE MACRO [(PREVPC INSERTION)

                                      (* ;; 
                                     "Is INSERTION physcially adjacent to the PCONTENTS of PREVPC ? ")

                                      (AND (MEMB (PTYPE PREVPC)
                                                 STRING.PTYPES)
                                           (EQ (ffetch (STRINGP BASE) of INSERTION)
                                               (ffetch (STRINGP BASE) of (PCONTENTS PREVPC)))
                                           (IEQP (IPLUS (PLEN PREVPC)
                                                        (ffetch (STRINGP OFFST) of (PCONTENTS PREVPC)
                                                               ))
                                                 (ffetch (STRINGP OFFST) of INSERTION])

(PUTPROPS \LASTPIECEP MACRO ((PC TOBJ)
                             (EQ PC (ffetch (TEXTOBJ LASTPIECE) of TOBJ))))

(PUTPROPS \NOTLASTPIECEP MACRO (OPENLAMBDA (PC TOBJ)
                                 (CL:UNLESS (EQ PC (ffetch (TEXTOBJ LASTPIECE) of TOBJ))
                                        PC)))
)
)
(DEFINEQ

(\DELETECH
  [LAMBDA (CH# CHLIM TEXTOBJ DONTDIRTY)                      (* ; "Edited  5-Sep-2022 14:35 by rmk")
                                                            (* ; "Edited 29-Jan-99 17:28 by kaplan")

    (* ;; "Delete the characters from CH# to CHLIM-1")

    (* ;; "If DONTDIRTY is non-NIL, then don't notice this change for purposes of UNDO or dirtiness.")

    (CL:WHEN (OR DONTDIRTY (NOT (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)))

        (* ;; "Only delete characters if changes are permitted, or if it's a TEdit-internal fixup change, e.g., when an NS character 255-x sequence is seen.  NS SHOULD NEVER HAPPEN:  IS THAT WHAT DONTDIRTY IS ALL ABOUT? ")

        (BTVALIDATE '\DELETECH 'START TEXTOBJ)
        (LET ((RANGE (\PIECERANGE CH# CHLIM TEXTOBJ)))
             (\DELETEPIECES RANGE TEXTOBJ)
             (CL:UNLESS DONTDIRTY

                 (* ;; "If we know that the deletion is at the end of the most recent insert (PC1=THFIRSTPIECE of most recent event??), maybe we can just shorten the length in the history.")
                                                             (* (add (ffetch THLEN of
                                                             (ffetch (TEXTOBJ TXTHISTORY) of 
                                                             TEXTOBJ)) (IMINUS (CADDR RANGE))))
                 (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                   THACTION _ 'Delete
                                                   THLEN _ (CADDR RANGE)
                                                   THCH# _ CH#
                                                   THFIRSTPIECE _ (CAR RANGE)))
                 (freplace (TEXTOBJ \DIRTY) of TEXTOBJ with T))

             (* ;; "Propagate paragraph looks from one side of the deletion to the other.")

             [\TEDIT.DIFFUSE.PARALOOKS (AND (CAR RANGE)
                                            (PREVPIECE (CAR RANGE)))
                    (AND (CADR RANGE)
                         (NEXTPIECE (CADR RANGE]
             (BTVALIDATE '\DELETECH 'END TEXTOBJ)
             T))])

(\SETUPGETCH
  [LAMBDA (CH# TEXTOBJ)                                      (* ; "Edited 22-Aug-2022 13:04 by rmk")
                                                             (* ; "Edited 10-Aug-2022 17:20 by rmk")
                                                             (* ; "Edited  8-Aug-2022 15:07 by rmk")
                                                             (* ; "Edited 31-Jul-2022 21:27 by rmk")
                                                             (* ; "Edited 14-Apr-93 17:14 by jds")

(* ;;; "Set up TEXTOBJ so that the next \GETCH will retrieve character # CH#")

    (* ;; "NB that 1st char in the textobj is #1.")

    (* ;; "NOBODY CALLS IT WITH A PIECE.  CALLS |INSTALL.PIECE INSTEAD")

    (COND
       ((TYPE? PIECE CH#)
        (HELP "\SETUPGETCH CALLED WITH PIECE")
        (\INSTALL.PIECE (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
               CH# 0))
       (T (LET (START-OF-PIECE PC)
               (DECLARE (SPECVARS START-OF-PIECE))
               (SETQ PC (\CHTOPC CH# TEXTOBJ T))
               (\INSTALL.PIECE (ffetch (TEXTOBJ STREAMHINT) of TEXTOBJ)
                      PC
                      (- CH# START-OF-PIECE])

(\INSERTCH
  [LAMBDA (CH CH# TEXTOBJ)                                   (* ; "Edited 25-Oct-2022 12:48 by rmk")
                                                             (* ; "Edited  6-Oct-2022 10:44 by rmk")
                                                             (* ; "Edited 16-Sep-2022 23:34 by rmk")
                                                             (* ; "Edited  8-Sep-2022 14:08 by rmk")
                                                             (* ; "Edited  2-Sep-2022 00:23 by rmk")
                                                             (* ; "Edited 30-Aug-2022 11:14 by rmk")

    (* ;; "")

    (* ;; "This is optimized for the common case that the next character to be inserted is at the position one beyond the position of the previous inserted character.")

    (* ;; "   1.  \INSERTCH.INSERTION allocates a string to contain the new character, by chomping the next character from the TEXTOBJ's INSERTSTRING resource.")

    (* ;; "    2.  The insertion will go into a piece at position CH#, and this stores that piece in the HINTPC field of the TEXTOBJ, together with its starting position.  If the next insertion comes immediately have that piece, \CHTOPC can find that piece without searching the BTREE. ")

    (* ;; "     3.  If the piece just before the target is a string piece whose string ends at the position in the same string just before the insertion, then the insertion can be accomplished by extending the string of the previous pieces, by adjusting the string offset and length of that pieces string and compensating by shrinking the INSERTIONSTRING resource.")

    (* ;; "The net effect is that the target piece is found quickly, and that a sequence of characters that are inserted individually end up in a single string in a single piece (until a paragraph break, or some jumping around that elimiates the string contiguity).")

    (* ;; "In the nonoptimal, atypical case, the next insertion point is unrelated to the last one, a jump to a new place in the stream.  In which case it might between 2 existing pieces, or it might come in the middle of an existing piece that has to be split.  At that point a new string piece can be introduced to hold the insertion, maybe sucking from the existing insertion string.")

    (* ;; "")

    (BTVALIDATE '\INSERTCH 'BEGIN TEXTOBJ)

    (* ;; "")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)

        (* ;; "Only insert if the document is allowed to change.")

        (PROG (PREVPC EVENT REPLACING START-OF-PIECE INSERTPC INSERTION
                     (ILEN (CL:IF (type? STRINGP CH)
                               (NCHARS CH)
                               1))
                     (TEXTLEN (fetch (TEXTOBJ TEXTLEN) of TEXTOBJ)))
              (DECLARE (SPECVARS START-OF-PIECE))
              (CL:WHEN (ZEROP ILEN)                          (* ; "Nothing to insert, really!")
                  (RETURN))

(* ;;; "Step 1:  Construct the insertion string, presumably chomping the TEXTOBJ resource. May or may not be contiguous with last insertion.")

              (SETQ INSERTION (\INSERTCH.INSERTION CH TEXTOBJ))

(* ;;; "")

(* ;;; "Step 2:  Find or construct a piece that ends just before the new material is to be inserted.")

              (CL:WHEN (IGREATERP CH# TEXTLEN)

                  (* ;; "Beyond the end-of-stream, assume we are appending to the current end")

                  (SETQ CH# (ADD1 TEXTLEN)))
              (SETQ PREVPC (\CHTOPC (SUB1 CH#)
                                  TEXTOBJ T))

         (* ;; "The insertion will now happen just after PREVPC")

(* ;;; "")

(* ;;; "Step 3: Insert the insertion, with luck, just by extending PREVPC, otherwise the insertion gets its own piece.")

              [SETQ INSERTPC
               (if (NULL PREVPC)
                   then 
                        (* ;; "Insert as the very first piece")

                        (SETQ START-OF-PIECE 1)
                        (\INSERTPIECE (create PIECE
                                             PTYPE _ (CL:IF (ffetch (STRINGP FATSTRINGP) of INSERTION
                                                                   )
                                                         FATSTRING.PTYPE
                                                         THINSTRING.PTYPE)
                                             PCONTENTS _ INSERTION
                                             PLEN _ ILEN
                                             PLOOKS _ (ffetch (TEXTOBJ CARETLOOKS) of TEXTOBJ)
                                             PPARALOOKS _ NIL
                                             PNEW _ T)
                               (\FIRSTPIECE TEXTOBJ)
                               TEXTOBJ)
                 else (CL:UNLESS (IEQP (PLEN PREVPC)
                                       (IDIFFERENCE CH# START-OF-PIECE))
                          (SETQ PREVPC (\SPLITPIECE PREVPC (IDIFFERENCE CH# START-OF-PIECE)
                                              TEXTOBJ)))
                      (if (AND (\INSERTCH.EXTENDABLE PREVPC INSERTION)
                               (EQ (PLOOKS PREVPC)
                                   (ffetch (TEXTOBJ CARETLOOKS) of TEXTOBJ))
                               (NOT (PPARALAST PREVPC)))
                          then 
                               (* ;; 
           "Heuristic optimization: avoid a new piece if it is clear that won't get us into trouble.")

                               (\INSERTCH.EXTEND PREVPC ILEN TEXTOBJ)
                               PREVPC
                        else (SETQ START-OF-PIECE CH#)
                             (\INSERTPIECE (create PIECE
                                                  PTYPE _ (CL:IF (ffetch (STRINGP FATSTRINGP)
                                                                    of INSERTION)
                                                              FATSTRING.PTYPE
                                                              THINSTRING.PTYPE)
                                                  PCONTENTS _ INSERTION
                                                  PLEN _ ILEN
                                                  PLOOKS _ (PLOOKS PREVPC)
                                                  PPARALOOKS _ NIL
                                                  PNEW _ T)
                                    (NEXTPIECE PREVPC)
                                    TEXTOBJ]
              (freplace (PIECE PBINABLE) of INSERTPC with (EQ THINSTRING.PTYPE (PTYPE INSERTPC)))

(* ;;; "The insertion is done and the pieces are properly integrated into the stream. ")

(* ;;; "")

(* ;;; "Make sure we have the intended looks")

              (freplace (PIECE PLOOKS) of INSERTPC with (ffetch (TEXTOBJ CARETLOOKS) of TEXTOBJ))
              (CL:UNLESS (PPARALOOKS INSERTPC)

                  (* ;; "If no paragraph looks, try those of previous, next, or textobj")

                  (freplace (PIECE PPARALOOKS) of INSERTPC with (OR (AND PREVPC (PPARALOOKS PREVPC))
                                                                    (AND (NEXTPIECE INSERTPC)
                                                                         (PPARALOOKS (NEXTPIECE
                                                                                      INSERTPC)))
                                                                    (fetch (TEXTOBJ FMTSPEC)
                                                                       of TEXTOBJ))))
              (freplace (TEXTOBJ \DIRTY) of TEXTOBJ with T)

(* ;;; "")

(* ;;; "This insertion is now complete.  Register this event in the TEDIT history.")

              (SETQ EVENT (fetch (TEXTOBJ TXTHISTORY) of TEXTOBJ))
                                                             (* ; "Prior edit event.")
              [if [AND (EQ INSERTPC PREVPC)
                       (FMEMB (fetch THACTION of EVENT)
                              '(Insert Replace]
                  then 
                       (* ;; 
                      "We're continuing a prior insertion, just continue the old history event, too.")

                       (add (fetch THLEN of EVENT)
                            ILEN)
                else                                         (* ; 
                                           "A new insertion/replacemen requires a new history event.")
                     [SETQ REPLACING (AND (EQ (fetch THACTION of EVENT)
                                              'Delete)
                                          (IEQP CH# (fetch THCH# of EVENT]
                     (\TEDIT.HISTORYADD TEXTOBJ (create TEDITHISTORYEVENT
                                                       THACTION _ (CL:IF REPLACING
                                                                      'Replace
                                                                      'Insert)
                                                       THLEN _ (PLEN INSERTPC)
                                                       THCH# _ CH#
                                                       THFIRSTPIECE _ INSERTPC
                                                       THPOINT _ 'RIGHT
                                                       THOLDINFO _ (AND REPLACING EVENT]

         (* ;; "Finally, as a heuristic for continuous typing, set up the TEXTOBJ hint  to speed up the \CHTOPC piece search if  the next insertion comes just after this one.")

              (freplace (TEXTOBJ HINTPCSTARTCH#) of TEXTOBJ with START-OF-PIECE)
              (freplace (TEXTOBJ HINTPC) of TEXTOBJ with INSERTPC)
              (BTVALIDATE '\INSERTCH 'END TEXTOBJ)
              (RETURN INSERTPC)))])

(\INSERTCR
  [LAMBDA (CH CH# TEXTOBJ)                                   (* ; "Edited  6-Sep-2022 23:51 by rmk")
                                                             (* ; "Edited 12-Aug-2022 17:30 by rmk")
                                                             (* ; "Edited 31-May-91 14:00 by jds")

    (* ;; "Handle insertion of CR and meta-CR.  The former causes a paragraph break, while the latter doesn't.  Note that inserting a meta-CR causes the document to become formatted. If CH is not CR, it's meta.  \INSERTCH might add this on to an extendable insertion piece, but a subsequent extension is foreclosed by setting PPARALAST.")

    (CL:UNLESS (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)
        (LET (INPC)
             (CL:UNLESS (OR (fetch (TEXTOBJ FORMATTEDP) of TEXTOBJ)
                            (EQ CH (CHARCODE EOL)))          (* ; 
                "Inserting a meta-CR into an unformatted document.  Start by setting up para breaks.")
                 (\TEDIT.CONVERT.TO.FORMATTED TEXTOBJ))
             (SETQ INPC (\INSERTCH (CHARCODE EOL)
                               CH# TEXTOBJ))                 (* ; "Put the CR in")
             (CL:WHEN (EQ CH (CHARCODE EOL))                 (* ; 
                                       "It's really a CR, rather than a meta-CR so do para breaking.")
                 (freplace (PIECE PPARALAST) of INPC with T))))])

(\INSERTCH.INSERTION
  [LAMBDA (CH TEXTOBJ)                                       (* ; "Edited 13-Aug-2022 12:48 by rmk")

    (* ;; "Find string-storage that can hold the insertion, and stick it in. Try to chomp from the current INSERTSTRING resource held in the TEXTOBJ, if any.")

    (LET ((INSERTSTRING (ffetch (TEXTOBJ INSERTSTRING) of TEXTOBJ))
          (LEN (CL:IF (type? STRINGP CH)
                   (NCHARS CH)
                   1))
          FATP INSERTION)
         [if (AND INSERTSTRING (ILEQ LEN (NCHARS INSERTSTRING)))
             then (SETQ INSERTION (SUBSTRING INSERTSTRING 1 LEN)) 
                                                             (* ; 
                                                          "Chunk it off, keep whatever might be left")
                  (freplace (TEXTOBJ INSERTSTRING) of TEXTOBJ with (SUBSTRING INSERTSTRING
                                                                          (ADD1 LEN)
                                                                          -1 INSERTSTRING))
           else 
                (* ;; "Allocate a string of the right type, to avoid an extra fattening pass")

                (SETQ FATP (CL:IF (type? STRINGP CH)
                               (AND (fetch (STRINGP FATSTRINGP) of CH)
                                    (for C instring CH never (IGREATERP C \MAXTHINCHAR)))
                               (IGREATERP CH \MAXTHINCHAR)))
                (if (IGREATERP LEN INSERTSTRINGLENGTH)
                    then 
                         (* ;; 
                         "Don't throw out the current cached resource if our new one is already full")

                         (SETQ INSERTION (ALLOCSTRING LEN NIL NIL FATP))
                  else (SETQ INSERTSTRING (ALLOCSTRING INSERTSTRINGLENGTH NIL NIL FATP))
                       (SETQ INSERTION (SUBSTRING INSERTSTRING 1 LEN)) 
                                                             (* ; 
                                        "Let the old one go--we may be starting a new sequential run")
                       (freplace (TEXTOBJ INSERTSTRING) of TEXTOBJ with (SUBSTRING INSERTSTRING
                                                                               (ADD1 LEN)
                                                                               -1 INSERTSTRING]

         (* ;; "INSERTION can now hold the insertion, smash it in")

         (CL:IF (type? STRINGP CH)
             (RPLSTRING INSERTION 1 CH)
             (RPLCHARCODE INSERTION 1 CH))
         INSERTION])

(\INSERTCH.EXTEND
  [LAMBDA (PC ILEN TEXTOBJ)                                  (* ; "Edited  1-Sep-2022 08:26 by rmk")
                                                             (* ; "Edited 30-Aug-2022 11:13 by rmk")
                                                             (* ; "Edited 21-Aug-2022 08:50 by rmk")

    (* ;; "Since INSERTION is physically adjacent to the PCONTENTS of PC, we can smash it on and adjust the lengths above.  We also have to adjust the DLEN for PC in its node.  When ")

    (add (ffetch (PIECE PLEN) of PC)
         ILEN)
    (add (ffetch (STRINGP LENGTH) of (ffetch (PIECE PCONTENTS) of PC))
         ILEN)
    (add (ffetch (BTSLOT DLEN) of (\FINDSLOT (ffetch (PIECE PTREENODE) of PC)
                                         PC))
         ILEN)
    (\UPDATEPCNODES PC ILEN TEXTOBJ])
)



(* ; "Piece and piece-table manipulation")

(DEFINEQ

(\DELETEPIECES
  [LAMBDA (RANGE TEXTOBJ)                                    (* ; "Edited  5-Sep-2022 14:36 by rmk")
                                                             (* ; "Edited 20-Apr-93 19:06 by jds")

    (* ;; "Removes all pieces in RANGE from TEXTOBJ. The chain is disconnected from the tree but is kept intact so the whole chain can still be recovered by following the NEXTPIECE links from the first piece (for history/undo).")

    (BTVALIDATE '\DELETEPIECES 'BEFORE TEXTOBJ)
    (for PC FN PREV NEXT inpiecerange RANGE do (CL:WHEN [AND (EQ OBJECT.PTYPE (PTYPE PC))
                                                             (SETQ FN (IMAGEOBJPROP (PCONTENTS PC)
                                                                             'WHENDELETEDFN]
                                                   (APPLY* FN (PCONTENTS PC)
                                                          (CAR (ffetch (TEXTOBJ \WINDOW) of TEXTOBJ))
                                                          ))
                                               (\DELETETREE PC (ffetch (PIECE PTREENODE) of PC))
                                               (\UPDATEPCNODES PC (IMINUS (PLEN PC))
                                                      TEXTOBJ)
       finally (SETQ PREV (PREVPIECE $$PC1))
             (SETQ NEXT (NEXTPIECE $$PCN))
             (CL:WHEN PREV
                 (freplace (PIECE NEXTPIECE) of PREV with NEXT))
             (freplace (PIECE PREVPIECE) of (OR NEXT (ffetch (TEXTOBJ LASTPIECE) of TEXTOBJ))
                with PREV)
             (freplace (TEXTOBJ HINTPC) of TEXTOBJ with NIL))
    (BTVALIDATE '\DELETEPIECES 'AFTER TEXTOBJ])

(\INSERTPIECE
  [LAMBDA (NEW NEXT TEXTOBJ SPLITTING)                       (* ; "Edited  2-Sep-2022 17:31 by rmk")
                                                             (* ; "Edited 29-Aug-2022 12:02 by rmk")
                                                             (* ; "Edited 26-Aug-2022 08:32 by rmk")
                                                             (* ; "Edited 20-Aug-2022 23:33 by rmk")

    (* ;; "Insert the piece NEW in front of the piece NEXT.  At the end, NEW is inserted before NEXT in the piece tree, and all counts and lengths are consistent.")

    (* ;; "The last piece LASTPIECE is always a piece in the last node whose NEXTPIECE is NIL and whose PREVPIECE is always the last real piece of the text stream.")

    (* ;; "SPLITTING is T from \SPLITPIECE.  NEW, NEXT, and NEXT's parent and ancestors all have the correct TOTLENs, so no further adjustment.")

    (CL:UNLESS SPLITTING
        (BTVALIDATE '\INSERTPIECE 'START TEXTOBJ))
    (CL:WHEN (\LASTPIECEP NEXT TEXTOBJ)
           (SETQ NEXT NIL))

    (* ;; "The tree may not be valid at this point (don't test CHECK-BTREE), because \INSERTPIECE may not have set up all the links and \SPLITPIECE's lengths are in an intermediate state.  But it should be valid on exit..")

    (UNINTERRUPTABLY
        (LET* ((NEXTPC (OR NEXT (ffetch (TEXTOBJ LASTPIECE) of TEXTOBJ)))
               (NEXTPREV (PREVPIECE NEXTPC)))

              (* ;; "NIL means last, whose PREV points to the truly last piece.  Could be just a prev link in the TEXTOBJ")

              (* ;; "Set up the linear-chain links")

              (freplace (PIECE NEXTPIECE) of NEW with NEXT)
              (freplace (PIECE PREVPIECE) of NEW with NEXTPREV)
                                                             (* ; 
                                                             "Do the new piece first, interrupts OK")
              (CL:WHEN NEXTPREV                              (* ; "Not at the very beginning?")
                  (freplace (PIECE NEXTPIECE) of NEXTPREV with NEW))
              (freplace (PIECE PREVPIECE) of NEXTPC with NEW)

              (* ;; "Get the new piece into the tree before NEXTPC (= NEXT or LAST). NEXTPC is always a pre-existing piece in the tree. ")

              (\INSERTTREE NEW NEXTPC (ffetch (PIECE PTREENODE) of NEXTPC))
              (CL:UNLESS SPLITTING
                  (\UPDATEPCNODES NEW (PLEN NEW)
                         TEXTOBJ)
                  (BTVALIDATE '\INSERTPIECE 'AFTER-UPDATE TEXTOBJ))
              (BTVALIDATE '\INSERTPIECE 'END TEXTOBJ)
              NEW))])

(\SPLITPIECE
  [LAMBDA (PC CHNO TEXTOBJ)                                  (* ; "Edited 16-Sep-2022 12:56 by rmk")
                                                             (* ; "Edited  7-Sep-2022 21:40 by rmk")
                                                             (* ; "Edited  5-Sep-2022 09:20 by rmk")
                                                             (* ; "Edited  1-Sep-2022 08:16 by rmk")
                                                             (* ; "Edited 29-Aug-2022 12:05 by rmk")
                                                             (* ; "Edited 25-Aug-2022 12:54 by rmk")
                                                             (* ; "Edited 21-Apr-93 17:49 by jds")

    (* ;; "Split the piece PC before CHNO (rel to its start);  return the old second piece.")

    (* ;; "Original code asserted that a split piece cannot be spit again (INSERTPCVALID _ NIL).  But that is no longer the case, since there is an independent test in \INSERTCH that determines whether extending is possible--if the INSERTION is adjacent to the PCONTENTS of the piece.")

    (CL:WHEN (ILEQ CHNO 0)
           (SHOULDNT "Splitting a piece at the start."))
    (BTVALIDATE '\SPLITPIECE 'START TEXTOBJ)
    (CL:WHEN PC                                              (* ; 
                                                "Doesn't make sense to split  before the first piece")
        (LET ((NEWPC (create PIECE using PC PPARALAST _ NIL)))
                                                             (* ; 
                                   "There can be no para break before the split, as things now work.")

             (* ;; "NEWPC is the prefix before the split point, PC will be the suffix, a shortened version of a piece that was already in the piece tree. The character-counting PLEN's are adjusted below.  Here we have to deal with the offsets.")

             (SELECTC (PTYPE PC)
                 (STRING.PTYPES                              (* ; 
                                                         "Adjust the offsets and lengths for strings")
                                (freplace (PIECE PCONTENTS) of NEWPC with (SUBSTRING (PCONTENTS
                                                                                      PC)
                                                                                 1 CHNO))
                                (freplace (PIECE PCONTENTS) of PC with (SUBSTRING (PCONTENTS PC)
                                                                              (ADD1 CHNO))))
                 ((LIST THINFILE.PTYPE FATFILE1.PTYPE) 
                      (ADD (ffetch (PIECE PFPOS) of PC)
                           CHNO))
                 (FATFILE2.PTYPE 
                      (ADD (ffetch (PIECE PFPOS) of PC)
                           (UNFOLD CHNO 2)))
                 (BLOCK.PTYPES 
                               (* ;; "Like files, we can view the underlying block in two parts, with a modifable string in the middle. The block is unchanged.")

                               (HELP "BLOCK SPLITTING NOT IMPLEMENTED"))
                 (SHOULDNT "ATTEMPT TO SPLIT A NONSTRING NONFILE PIECE"))
             (freplace (PIECE PLEN) of NEWPC with CHNO)

             (* ;; "NEWPC is now complete, and covers the first CHNO characters of PC.")

             (* ;; "")

             (* ;; " PC itself must now be shortened, including the DLEN of its parent.")

             (freplace (PIECE PLEN) of PC with (IDIFFERENCE (PLEN PC)
                                                      CHNO))

             (* ;; 
   "Make sure the DLEN corresponding to PC matches its new PLEN.  We don't have to propagate upwards")

             (freplace (BTSLOT DLEN) of (\FINDSLOT (ffetch (PIECE PTREENODE) of PC)
                                               PC) with (PLEN PC))

             (* ;; "PC has its new length, and its node's DLEN is consistent.  We haven't adjusted the parent's TOTLEN, because the length is conserved between the NEWPC and the adjusted PC.  We have to tell \INSERTPIECE that we are in the middle of splitting, so that it knows not to propagate NEWPC's length.")

             (* ;; "Insert NEWPC into the piece tree in front of PC.  ")

             (freplace (TEXTOBJ HINTPC) of TEXTOBJ with NIL)
             (\INSERTPIECE NEWPC PC TEXTOBJ T)
             (BTVALIDATE '\SPLITPIECE 'AFTER-INSERTPIECE TEXTOBJ)
             NEWPC))])

(\INSTALL.PIECE
  [LAMBDA (TSTREAM PC CHOFFSET)                              (* ; "Edited 11-Oct-2022 18:14 by rmk")
                                                             (* ; "Edited 27-Sep-2022 23:43 by rmk")
                                                             (* ; "Edited 25-Sep-2022 13:29 by rmk")
                                                             (* ; "Edited 16-Sep-2022 15:19 by rmk")
                                                             (* ; "Edited 11-Sep-2022 14:40 by rmk")
                                                             (* ; "Edited  8-Sep-2022 20:46 by rmk")

    (* ;; "Makes PC be the current piece in TSTREAM. set up so that the next character is at CHOFFSET relative to the start of the piece. ")

    (* ;; "Note that, since we are setting up the TSTREAM looks here, the LOOKSUPDATEFN's don't need to do that part.")

    (* ;; "SHOULD PARTS OF THIS BE UNINTERRUPTABLE? ")

    (CL:WHEN PC
        (CL:UNLESS CHOFFSET (SETQ CHOFFSET 0))
        (LET (PCONTENTS PLEN PCCHARSLEFT (LOOKSUPDATEFN (ffetch (TEXTSTREAM LOOKSUPDATEFN)
                                                           of TSTREAM)))

             (* ;; "Install PC and its looks in TSTREAM.")

             (freplace (TEXTSTREAM PIECE) of TSTREAM with PC)

             (* ;; "The LOOKSUPDATEFN is non-NIL only for calls from \FORMATLINE and \TEDIT.HARDCOPY.FORMATLINE.  It updates their formatting variables.  ")

             (if LOOKSUPDATEFN
                 then (APPLY* LOOKSUPDATEFN TSTREAM PC)
               else (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with (PLOOKS PC))
                    (freplace (TEXTSTREAM CURRENTPARALOOKS) of TSTREAM with (PPARALOOKS PC)))

             (* ;; "")

             (* ;; "Now set up for binning.")

             (SETQ PLEN (PLEN PC))
             (SETQ PCCHARSLEFT (IDIFFERENCE PLEN CHOFFSET))
             (freplace (TEXTSTREAM PIECE) of TSTREAM with PC)(* ; "Initial values")
             (freplace (STREAM BINABLE) of TSTREAM with NIL) (* ; "Other than 1-byte characters")
             (freplace (STREAM COFFSET) of TSTREAM with 0)
             (SELECTC (PTYPE PC)
                 (THINFILE.PTYPE                             (* ; "Sets up the buffers")
                      (freplace (STREAM BINABLE) of TSTREAM with T)
                      (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                 ((LIST FATFILE1.PTYPE FATFILE2.PTYPE) 
                      (\INSTALL.FILEBUFFER TSTREAM PCCHARSLEFT))
                 (STRING.PTYPES (SETQ PCONTENTS (PCONTENTS PC))
                                (freplace (STREAM CPPTR) of TSTREAM with (ffetch (STRINGP BASE)
                                                                            of PCONTENTS))
                                (freplace (STREAM COFFSET) of TSTREAM
                                   with (IPLUS (ffetch (STRINGP OFFST) of PCONTENTS)
                                               CHOFFSET))
                                (freplace (STREAM CBUFSIZE) of TSTREAM
                                   with (IPLUS (ffetch (STRINGP OFFST) of PCONTENTS)
                                               PLEN))

                                (* ;; 
                             "The fatness of the string may have changed by the RPL--- in \INSERTCH.")

                                (if (ffetch (STRINGP FATSTRINGP) of PCONTENTS)
                                    then (freplace (PIECE PTYPE) of PC with FATSTRING.PTYPE)
                                         (freplace (PIECE PBINABLE) of PC with NIL)
                                  else (freplace (STREAM BINABLE) of TSTREAM with T)))
                 (OBJECT.PTYPE (freplace (STREAM CBUFSIZE) of TSTREAM with 1))
                 (SUBSTREAM.PTYPE                            (* ; 
    "Maybe just set PC to the piece of the (freplace (STREAM BINABLE) of TSTREAM with NIL)substream?")
                      (CL:UNLESS LOOKSUPDATEFN
                          (freplace (TEXTSTREAM CURRENTPARALOOKS) of TSTREAM
                             with (ffetch (TEXTSTREAM CURRENTPARALOOKS) of (PCONTENTS PC)))
                          (freplace (TEXTSTREAM CURRENTLOOKS) of TSTREAM with (ffetch (TEXTSTREAM
                                                                                       CURRENTLOOKS)
                                                                                 of (PCONTENTS PC)))))
                 (FATBLOCK.PTYPE 
                      (freplace (STREAM CPPTR) of TSTREAM with (PCONTENTS PC))
                      (freplace (STREAM COFFSET) of TSTREAM with (ffetch (PIECE PFPOS) of PC))
                      (freplace (STREAM CBUFSIZE) of TSTREAM with PLEN))
                 NIL)
             (freplace (TEXTSTREAM STARTINGCOFFSET) of TSTREAM with (ffetch (STREAM COFFSET)
                                                                       of TSTREAM))
             (freplace (TEXTSTREAM PCCHARSLEFT) of TSTREAM with PCCHARSLEFT)))])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \NEXT.VISIBLE.PIECE MACRO ((PC)
                                     (for (NPC _ PC) by (NEXTPIECE NPC)
                                        first (CL:UNLESS NPC (RETURN NIL))
                                              (SETQ NPC (NEXTPIECE NPC)) while NPC
                                        unless (OR (EQ 0 (PLEN NPC))
                                                   (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS NPC)))
                                        do (RETURN NPC))))

(PUTPROPS \PREV.VISIBLE.PIECE MACRO ((PC)
                                     (for (PPC _ PC) by (PREVPIECE PPC)
                                        first (CL:UNLESS PPC (RETURN NIL))
                                              (SETQ PPC (PREVPIECE PPC)) while PPC
                                        unless (OR (EQ 0 (PLEN PPC))
                                                   (fetch (CHARLOOKS CLINVISIBLE) of (PLOOKS PPC)))
                                        do (RETURN PPC))))
)
)



(* ; "Support for TEXTPROP")

(DEFINEQ

(CGETTEXTPROP
  [LAMBDA (TEXTOBJ PROP)                                     (* ; "Edited 20-Oct-87 12:36 by jds")

    (* ;; "compiles calls on TEXTPROP that are fetching values.  This needs to be changed whenever GETTEXTPROP is changed.")

    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             `(fetch (TEXTOBJ TXTREADONLY) of ,TEXTOBJ))
        `(LISTGET (fetch (TEXTOBJ EDITPROPS) of ,TEXTOBJ)
                ',PROP])

(CTEXTPROP
  [LAMBDA (FORMTAIL)                                         (* ; "Edited 31-May-91 13:59 by jds")

    (* ;; "compiles calls to TEXTPROP")

    (COND
       ((NULL (CDR FORMTAIL))                                (* ; "less that 2 args")
        (printout T "Possible error in call to TEXTPROP: less than 2 args" T (LIST 'TEXTPROP FORMTAIL
                                                                                   )
               T)
        (CGETTEXTPROP (LIST 'TEXTOBJ (CAR FORMTAIL))
               NIL))
       ((NOT (EQ (CAADR FORMTAIL)
                 'QUOTE))                                    (* ; "property is not quoted.")
        'IGNOREMACRO)
       [(NULL (CDDR FORMTAIL))                               (* ; "fetching a TEXTPROP property.")
        (CGETTEXTPROP (LIST 'TEXTOBJ (CAR FORMTAIL))
               (CADR (CADR FORMTAIL]
       (T                                                    (* ; "storing a window property")
          (LET ((TEXTOBJ (CAR FORMTAIL))
                (PROP (CDADR FORMTAIL))
                (VAL (CADDR FORMTAIL)))
               [SELECTQ PROP
                   ((READONLY READ-ONLY) 
                        `(REPLACE (TEXTOBJ TXTREADONLY) OF ,TEXTOBJ WITH ,VAL))
                   `(COND
                       [(FETCH (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ))
                        (LISTPUT (FETCH (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ))
                               ',PROP
                               ',VAL]
                       (T (REPLACE (TEXTOBJ EDITPROPS) OF (TEXTOBJ ,TEXTOBJ)
                             WITH (LIST ,PROP ,VAL]
               (LIST 'COND (LIST (LIST 'FETCH 'EDITPROPS 'OF (LIST 'TEXTOBJ (CAR FORMTAIL)))
                                 (LIST 'LISTPUT (LIST 'FETCH 'EDITPROPS 'OF (LIST 'TEXTOBJ
                                                                                  (CAR FORMTAIL)))
                                       (CADR FORMTAIL)
                                       (CADDR FORMTAIL)))
                     (LIST T (LIST 'REPLACE 'EDITPROPS 'OF (LIST 'TEXTOBJ (CAR FORMTAIL))
                                   'WITH
                                   (LIST 'LIST (CADR FORMTAIL)
                                         (CADDR FORMTAIL])

(GETTEXTPROP
  [LAMBDA (TEXTOBJ PROP)                                     (* ; "Edited 30-Oct-2022 23:21 by rmk")
                                                             (* ; "Edited  9-Feb-89 11:20 by jds")

    (* ;; "Gets values for document properties.  Used by TEXTPROP.")

    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             (FETCH (TEXTOBJ TXTREADONLY) OF TEXTOBJ))
        ((BEING-EDITED ACTIVE) 
             (FETCH (TEXTOBJ TXTEDITING) OF TEXTOBJ))
        ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
             (FETCH (TEXTOBJ TXTNONSCHARS) OF TEXTOBJ))
        (READTABLE (fetch (TEXTOBJ TXTRTBL) of TEXTOBJ))
        (BOUNDTABLE (fetch (TEXTOBJ TXTWTBL) of TEXTOBJ))
        (LISTGET (fetch (TEXTOBJ EDITPROPS) of TEXTOBJ)
               PROP])

(PUTTEXTPROP
  [LAMBDA (TEXTOBJ PROP VALUE)                               (* ; "Edited 30-Oct-2022 23:21 by rmk")
                                                             (* ; "Edited  9-Feb-89 11:19 by jds")
                                                             (* ; 
                                                             "put a value on prop list for a textobj")
    (SELECTQ PROP
        ((READONLY READ-ONLY) 
             (PROG1 (fetch (TEXTOBJ TXTREADONLY) of TEXTOBJ)
                 (replace (TEXTOBJ TXTREADONLY) of TEXTOBJ with VALUE)))
        ((BEING-EDITED ACTIVE) 
             (PROG1 (fetch (TEXTOBJ TXTEDITING) of TEXTOBJ)
                 (replace (TEXTOBJ TXTEDITING) of TEXTOBJ with VALUE)))
        ((NO-NS-CHARS NONSCHARS NO-NSCHARS) 
             (PROG1 (fetch (TEXTOBJ TXTNONSCHARS) of TEXTOBJ)
                 (replace (TEXTOBJ TXTNONSCHARS) of TEXTOBJ with VALUE)))
        (READTABLE (replace (TEXTOBJ TXTRTBL) of TEXTOBJ with VALUE))
        (BOUNDTABLE (replace (TEXTOBJ TXTWTBL) of TEXTOBJ with VALUE))
        (COND
           ((fetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
            (PROG1 (LISTGET (ffetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
                          PROP)
                (LISTPUT (ffetch (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ))
                       PROP VALUE)))
           (T (freplace (TEXTOBJ EDITPROPS) of (TEXTOBJ TEXTOBJ) with (LIST PROP VALUE))
              NIL])

(TEXTPROP
  [LAMBDA X                                                  (* ; "Edited  9-Feb-89 11:20 by jds")

    (* ;; "general top level entry for both fetching and setting window properties.")

    (COND
       ((IGREATERP X 2)
        (PUTTEXTPROP (TEXTOBJ (ARG X 1))
               (ARG X 2)
               (ARG X 3)))
       ((EQ X 2)
        (GETTEXTPROP (TEXTOBJ (ARG X 1))
               (ARG X 2)))
       (T (\ILLEGAL.ARG NIL])
)



(* ;; 
"Support for error handling:  The old error handler for the stream-not-open error.  This is here, because you only want to do this ONCE, even if you load TEXT-STREAM multiple times (as, e.g., in development)"
)


(RPAQ? *TEDIT-OLD-STREAM-ERROR-HANDLER* (CONDITION-HANDLER 'XCL:STREAM-NOT-OPEN))
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(\TEXTINIT)
)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA TEXTPROP)
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (36143 57562 (\TEXTBIN 36153 . 43078) (\TEXTBIN.NEXT.PIECE 43080 . 43615) (\TEXTPEEKBIN 
43617 . 47832) (\TEXTBACKFILEPTR 47834 . 51975) (\TEXTOUTCHARFN 51977 . 52268) (\INSTALL.FILEBUFFER 
52270 . 55961) (\TEXTBOUT 55963 . 57560)) (61840 66843 (\TEXTSTREAM.OUTCHARFN 61850 . 63494) (
\TEXTSTREAM.INCCCODEFN 63496 . 64179) (\TEXTSTREAM.PEEKCCODEFN 64181 . 64466) (\TEXTSTREAM.BACKCCODEFN
 64468 . 64946) (\TEXTSTREAM.OUTCHARFN 64948 . 66592) (\TEXTSTREAM.FORMATBYTESTREAM 66594 . 66841)) (
66890 94537 (COPYTEXTSTREAM 66900 . 69816) (OPENTEXTSTREAM 69818 . 84131) (REOPENTEXTSTREAM 84133 . 
84559) (TEDIT.STREAMCHANGEDP 84561 . 84863) (TEXTSTREAMP 84865 . 85279) (TXTFILE 85281 . 85734) (
\TEDIT.REOPEN.STREAM 85736 . 87402) (\TEXTINIT 87404 . 93324) (\TEXTTTYBOUT 93326 . 94535)) (94591 
106392 (\TEXTCLOSEF 94601 . 95656) (\TEXTDSPFONT 95658 . 96740) (\TEXTEOFP 96742 . 97991) (
\TEXTGETEOFPTR 97993 . 98207) (\TEXTGETFILEPTR 98209 . 100380) (\TEXTOPENF 100382 . 101208) (
\TEXTSETEOF 101210 . 101725) (\TEXTSETFILEPTR 101727 . 103341) (\TEXTDSPXPOSITION 103343 . 104203) (
\TEXTDSPYPOSITION 104205 . 104752) (\TEXTLEFTMARGIN 104754 . 105176) (\TEXTRIGHTMARGIN 105178 . 105926
) (\TEXTDSPCHARWIDTH 105928 . 106105) (\TEXTDSPSTRINGWIDTH 106107 . 106286) (\TEXTDSPLINEFEED 106288
 . 106390)) (107817 126475 (\DELETECH 107827 . 110022) (\SETUPGETCH 110024 . 111288) (\INSERTCH 111290
 . 121408) (\INSERTCR 121410 . 122885) (\INSERTCH.INSERTION 122887 . 125565) (\INSERTCH.EXTEND 125567
 . 126473)) (126527 141170 (\DELETEPIECES 126537 . 128309) (\INSERTPIECE 128311 . 131039) (\SPLITPIECE
 131041 . 135713) (\INSTALL.PIECE 135715 . 141168)) (142353 148087 (CGETTEXTPROP 142363 . 142823) (
CTEXTPROP 142825 . 145173) (GETTEXTPROP 145175 . 146014) (PUTTEXTPROP 146016 . 147621) (TEXTPROP 
147623 . 148085)))))
STOP
