(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED " 1-Aug-2025 14:59:31" 
{DSK}<Users>kaplan>Local>medley3.5>working-medley>library>tedit>tedit-exports.all;239 53083  

      :EDIT-BY rmk

      :PREVIOUS-DATE "28-Jul-2025 23:52:50" 
{DSK}<Users>kaplan>Local>medley3.5>working-medley>library>tedit>tedit-exports.all;238)


(PRETTYCOMPRINT ((E (MAPC (MKLIST FROMFILES) (FUNCTION (LAMBDA (F) (MAPC (IMPORTFILE F FLG) (FUNCTION 
PRINT))))))))
(FILESLOAD (FROM LOADUPS) EXPORTS.ALL)
(PUTPROPS TEDIT-ASSERT MACRO (ARGS (COND (CHECK-TEDIT-ASSERTIONS (BQUOTE (CL:UNLESS (\, (CAR ARGS)) (
\TEDIT.THELP "TEDIT-ASSERT FAILURE" (\, (KWOTE (CAR ARGS))))))) (T (BQUOTE (* (TEDIT-ASSERT (\,@ ARGS)
)))))))
(PUTPROPS FTEXTOBJ MACRO ((X) (TEXTOBJ! (CL:IF (type? TEXTOBJ X) X (GETTSTR X TEXTOBJ)))))
(GLOBALVARS CHECK-TEDIT-ASSERTIONS)
(RPAQ? CHECK-TEDIT-ASSERTIONS T)
(PUTPROP (QUOTE TEDIT) (QUOTE IMPORTDATE) (IDATE " 1-Aug-2025 14:50:15"))
(RPAQQ \BTREEWORDSPERSLOT 4)
(RPAQQ \BTREEMAXCOUNT 8)
(CONSTANTS (\BTREEWORDSPERSLOT 4) (\BTREEMAXCOUNT 8))
(DATATYPE BTREENODE ((* ;; "An order-4 BTREE node for representing the piece table for TEdit.") DOWN1 
DLEN1 DOWN2 DLEN2 DOWN3 DLEN3 DOWN4 DLEN4 DOWN5 DLEN5 DOWN6 DLEN6 DOWN7 DLEN7 DOWN8 DLEN8 (COUNT BYTE)
 (* ; 
"# of children of this node. Must not be BITS 4 because \PUTBASEPTR optimizations smash the high-order bits."
) (UPWARD XPOINTER) (* ; "Parent of this node, if any.") TOTLEN (* ; 
"Total length of this tree and subtrees")))
(BLOCKRECORD BTSLOT (DOWN DLEN))
(PUTPROPS \NTHSLOT MACRO ((BTREENODE N) (\ADDBASE BTREENODE (UNFOLD (SUB1 N) \BTREEWORDSPERSLOT))))
(PUTPROPS \NEXTSLOT MACRO ((SLOT) (\ADDBASE SLOT \BTREEWORDSPERSLOT)))
(PUTPROPS \PREVSLOT MACRO ((SLOT) (\ADDBASE SLOT (IMINUS \BTREEWORDSPERSLOT))))
(PUTPROPS \LASTSLOT MACRO ((BTNODE) (\ADDBASE BTNODE (UNFOLD (SUB1 (ffetch (BTREENODE COUNT) of BTNODE
)) \BTREEWORDSPERSLOT))))
(PUTPROPS \FIRSTSLOT MACRO ((BTNODE) BTNODE))
(PUTPROPS \MOVESLOT MACRO ((FROMSLOT TOSLOT) (* ;; 
"Moves the slot information from FROMSLOT to TOSLOT, and also clears FROMSLOT. ") (\PUTBASEPTR TOSLOT 
0 (ffetch (BTSLOT DOWN) of FROMSLOT)) (* ; "Avoid refcnt fiddling (assumes we are uninterruptable)") (
\PUTBASEPTR FROMSLOT 0 NIL) (freplace (BTSLOT DLEN) of TOSLOT with (ffetch (BTSLOT DLEN) of FROMSLOT))
 (freplace (BTSLOT DLEN) of FROMSLOT with 0)))
(PUTPROPS \FILLSLOT MACRO ((SLOT DWN DWNL) (freplace (BTSLOT DOWN) of SLOT with DWN) (freplace (BTSLOT
 DLEN) of SLOT with DWNL)))
(PUTPROPS \FINDSLOT MACRO ((BTNODE ITEM) (find S inslots BTNODE suchthat (EQ ITEM (ffetch (BTSLOT DOWN
) of S)))))
(PUTPROPS \SUFFIXPIECEP MACRO (OPENLAMBDA (PC TOBJ) (AND (EQ PC (FGETTOBJ TOBJ SUFFIXPIECE)) PC)))
(I.S.OPR (QUOTE inslots) NIL (QUOTE (SUBST (GETDUMMYVAR) (QUOTE $$BTBODY) (QUOTE (bind $$BTBODY _ BODY
 $$BTEND declare (LOCALVARS $$BTBODY $$BTEND) first (SETQ I.V. (\FIRSTSLOT $$BTBODY)) (SETQ $$BTEND (
\LASTSLOT $$BTBODY)) repeatuntil (EQ I.V. $$BTEND) by (\ADDBASE I.V. \BTREEWORDSPERSLOT))))) T)
(I.S.OPR (QUOTE inpieces) NIL (QUOTE (first (SETQ I.V. (\DTEST (OR BODY (GO $$OUT)) (QUOTE PIECE))) by
 (\DTEST (OR (NEXTPIECE I.V.) (GO $$OUT)) (QUOTE PIECE)))))
(I.S.OPR (QUOTE backpieces) NIL (QUOTE (first (SETQ I.V. (\DTEST (OR BODY (GO $$OUT)) (QUOTE PIECE))) 
by (\DTEST (OR (PREVPIECE I.V.) (GO $$OUT)) (QUOTE PIECE)))))
(PUTPROP (QUOTE TEDIT-PCTREE) (QUOTE IMPORTDATE) (IDATE "28-Jul-2025 23:25:19"))
(DATATYPE SELECTION ((* ;; 
"Description of a piece of selected text for TEdit.  Text has to be selected before it can be operated on by the user. The caret is to the left of CH# if POINT is LEFT, to the keft of CHLIM if POINT is RIGHT."
) (* ;; "If DCH > 0, highlighting goes from CH# to (SUB1 CHLIM = (SUB1 (IPLUS CH# DCH)).") (* ;; 
"If DCH=0, this is a caret-only selection, with no highlighting.  In that case CHLIM=(ADD1 CH#) and POINT essentially indicates whether the caret blinks before or after CH#."
) NIL (* ; "Was Y0: Y value of topmost line of selection") X0 (* ; 
"X value of left edge of selection on the first line") SELLINES (* ; 
"A list of (L1 L2) pairs one for each pane, to replace the separate L1 L2 lists. Was DX: Width of the selection, if it's on one line."
) CH# (* ; "CH# of the first selected character") XLIM (* ; 
"X value of right edge of last selected character on the last line") CHLIM (* ; 
"Last character is at (SUB1 CHLIM)") DCH (* ; 
"# of characters selected (can be zero, for empty/point selection.) This controls highlighting") L1 (*
 ; "-> line descriptor for the line where the first selected character is") LN (* ; 
"-> line descriptor for the line which contains the end of the selection") NIL (* ; 
"Was YLIM: Y value of the bottom of the line that ends the selection") POINT (* ; 
"Which end should the caret appear at?  (LEFT or RIGHT)") (SET FLAG) (* ; 
"T if this selection is real;  NIL if not") (SELTEXTSTREAM FULLXPOINTER) (* ; 
"TEXTSTREAM that describes the selected text") SELKIND (* ; 
"What kind of selection?  CHAR or WORD or LINE or PARA") HOW (* ; 
"SHADE used to highlight this selection") HOWHEIGHT (* ; 
"Height of the highlight (1 usually, full line for delete selection...)") (HASCARET FLAG) (* ; 
"T if there should be a caret for this selection") SELOBJ (* ; 
"If this selection is inside an object, which object?") (ONFLG FLAG) (* ; 
"T if the selection is highlighted on the screen, else NIL") SELOBJINFO (* ; 
"A Place for the selected object to put info about selection inside itself.")) (INIT (DEFPRINT (QUOTE 
SELECTION) (FUNCTION \TEDIT.SELECTION.DEFPRINT))) (ACCESSFNS ((SELTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) 
of (GETSEL DATUM SELTEXTSTREAM))) (CHLAST (STANDARD (SUB1 (GETSEL DATUM CHLIM)) (SETSEL DATUM CHLIM (
ADD1 NEWVALUE))) (FAST (SUB1 (FSETSEL DATUM CHLIM)) (FSETSEL DATUM CHLIM (ADD1 NEWVALUE)))))) SET _ 
NIL HOW _ BLACKSHADE HOWHEIGHT _ 1 HASCARET _ T X0 _ 0 POINT _ (QUOTE LEFT) L1 _ (LIST NIL) LN _ (LIST
 NIL))
(DATATYPE SELPIECES (SPFIRST SPLAST SPLEN SPFIRSTCHAR SPLASTCHAR))
(DEFPRINT (QUOTE SELECTION) (FUNCTION \TEDIT.SELECTION.DEFPRINT))
(RPAQQ COPYSELSHADE 30583)
(RPAQQ COPYLOOKSSELSHADE 30583)
(RPAQ EDITMOVESHADE BLACKSHADE)
(RPAQQ EDITGRAY 32800)
(CONSTANTS (COPYSELSHADE 30583) (COPYLOOKSSELSHADE 30583) (EDITMOVESHADE BLACKSHADE) (EDITGRAY 32800))
(PUTPROPS WITHINLINEP MACRO (OPENLAMBDA (CHNO LINE) (AND (IGEQ CHNO (GETLD LINE LCHAR1)) (ILESSP CHNO 
(FGETLD LINE LCHARLIM)) LINE)))
(PUTPROPS FWITHINLINEP MACRO (OPENLAMBDA (CHNO LINE) (AND (IGEQ CHNO (FGETLD LINE LCHAR1)) (ILESSP 
CHNO (FGETLD LINE LCHARLIM)) LINE)))
(PUTPROPS LINESELECTEDP MACRO (OPENLAMBDA (L CH# CHLAST) (AND (IGEQ (GETLD L LCHARLAST) CH#) (ILEQ (
FGETLD L LCHAR1) CHLAST))))
(PUTPROPS FLINESELECTEDP MACRO (OPENLAMBDA (L CH# CHLAST) (* ; 
"True if a CH#..CHLAST selection would include L") (AND (IGREATERP (FGETLD L LCHARLIM) CH#) (ILEQ (
FGETLD L LCHAR1) CHLAST))))
(PUTPROPS IBETWEENP MACRO (OPENLAMBDA (X LOW HIGH) (* ; "within the closed interval") (AND (IGEQ X LOW
) (ILEQ X HIGH))))
(PUTPROPS GETSEL MACRO ((S FIELD) (fetch (SELECTION FIELD) of S)))
(PUTPROPS SETSEL MACRO ((S FIELD NEWVALUE) (replace (SELECTION FIELD) of S with NEWVALUE)))
(PUTPROPS FGETSEL MACRO ((S FIELD) (ffetch (SELECTION FIELD) of S)))
(PUTPROPS FSETSEL MACRO ((S FIELD NEWVALUE) (freplace (SELECTION FIELD) of S with NEWVALUE)))
(PUTPROPS SELECTION! MACRO ((SEL) (\DTEST SEL (QUOTE SELECTION))))
(I.S.OPR (QUOTE inselpieces) NIL (QUOTE (SUBST (GETDUMMYVAR) (QUOTE $$SELPIECES) (QUOTE (BIND 
$$SPFIRST $$SPLAST $$SPLENGTH $$SELPIECES _ BODY DECLARE (LOCALVARS $$SELPIECES $$SPFIRST $$SPLAST 
$$SPLENGTH) FIRST (\DTEST (OR $$SELPIECES (GO $$OUT)) (QUOTE SELPIECES)) (SETQ I.V. (SETQ $$SPFIRST (
\DTEST (ffetch (SELPIECES SPFIRST) of $$SELPIECES) (QUOTE PIECE)))) (SETQ $$SPLAST (\DTEST (ffetch (
SELPIECES SPLAST) of $$SELPIECES) (QUOTE PIECE))) (SETQ $$SPLENGTH (ffetch (SELPIECES SPLEN) of 
$$SELPIECES)) REPEATUNTIL (EQ I.V. $$SPLAST) BY (\DTEST (NEXTPIECE I.V.) (QUOTE PIECE)))))) T)
(PUTPROPS GETSPC MACRO ((SP FIELD) (fetch (SELPIECES FIELD) of SP)))
(PUTPROPS SETSPC MACRO ((SP FIELD NEWVALUE) (replace (SELPIECES FIELD) of SP with NEWVALUE)))
(PUTPROPS FGETSPC MACRO ((SP FIELD) (ffetch (SELPIECES FIELD) of SP)))
(PUTPROPS FSETSPC MACRO ((SP FIELD NEWVALUE) (freplace (SELPIECES FIELD) of SP with NEWVALUE)))
(PUTPROPS SELPIECES! MACRO ((SPC) (\DTEST SPC (QUOTE SELPIECES))))
(GLOBALVARS TEDIT.EXTEND.PENDING.DELETE)
(GLOBALVARS TEDIT.SELECTION TEDIT.SHIFTEDSELECTION TEDIT.MOVESELECTION TEDIT.COPYLOOKSSELECTION 
TEDIT.DELETESELECTION)
(PUTPROPS \TEDIT.NOSEL MACRO ((TSTREAM SEL ONLYPANE) (* ; 
"Takes down SEL in TSTREAM, where SEL defaults to the current selection") (\TEDIT.SHOWSEL SEL NIL 
TSTREAM ONLYPANE)))
(PUTPROPS \TEDIT.SEL.ON MACRO ((TSTREAM SEL ONLYPANE DONTFIX) (* ; 
"Takes down SEL in TSTREAM, where SEL defaults to the current selection") (\TEDIT.SHOWSEL SEL T 
TSTREAM ONLYPANE DONTFIX)))
(PUTPROPS \TEDIT.SEL.OFF MACRO ((TSTREAM SEL ONLYPANE) (* ; 
"Takes down SEL in TSTREAM, where SEL defaults to the current selection") (\TEDIT.SHOWSEL SEL NIL 
TSTREAM ONLYPANE)))
(PUTPROP (QUOTE TEDIT-SELECTION) (QUOTE IMPORTDATE) (IDATE "29-Jul-2025 11:22:10"))
(RECORD TAB (TABX . TABKIND))
(RECORD TABSPEC (DEFAULTTAB . TABS))
(DATATYPE LINECACHE ((* ;; "Image cache for display lines.") LCBITMAP (* ; 
"The bitmap that will be used by this instance of the cache") (LCNEXTCACHE FULLXPOINTER) (* ; 
"The next cache in the chain, for screen updates.")))
(* ; "LINEDESCRIPTORS")
(DATATYPE LINEDESCRIPTOR ((* ;; 
"Description of a single line of formatted text, either on the display or for a printed page.") YBOT (
* ; "Y value for the bottom of the line (below the descent)") YBASE (* ; 
"Yvalue for the base line the characters sit on") LEFTMARGIN (* ; "Left margin, in screen points") 
RIGHTMARGIN (* ; "Right margin, in screen points") LXLIM (* ; 
"X value of right edge of LCHARLIM character on the line (may exceed right margin, if char is a space.). In natural stream units"
) LX1 (* ; "X value of the left edge of LCHAR1 from the left margin, in stream natural units.") 
LHEIGHT (* ; 
"Total height of hte line, Ascent+Descent plus leading. Includes paragraph and line leading") LASCENT 
(* ; "Ascent of the line above YBASE, adjusted for line and paragraph leading") LDESCENT (* ; 
"How far line descends below YBASE, adjusted for line leading") LTRUEDESCENT (* ; 
"The TRUE DESCENT for this line, unadjusted for line leading.") LTRUEASCENT (* ; 
"The TRUE ASCENT for this line, unadjusted for pre-paragraph leading.") LCHAR1 (* ; 
"CH# of the first character on the line.") LCHARLAST (* ; "CH# of the last character on the line") 
FORCED-END (* ; "NIL or character (EOL, FORM...) that forces a line break") (* ; 
"Was CHARTOP: CH# of the character which forced the line break (may be less than  CHARLIM)") NEXTLINE 
(* ; "Next line chain pointer") (PREVLINE FULLXPOINTER) (* ; "Previous line chain pointer") LMARK (* ;
 
"One of SOLID, GREY, NIL.  Tells what kind of special-line marker should be put in the left margin for this paragraph.  (For hardcopy, can also be an indicator for special processing?)"
) LTEXTSTREAM (* ; 
"A cached textstream that this line took its text from.  Filled in by \TEDIT.FORMATLINE only in hardcopy, used temporarily and the cleared by \TEDIT.FORMATBOX to avoid the circularity."
) NIL (* ; 
"Was CACHE: A cached THISLINE, for keeping hardcopy info around while we crunch with the line descriptors to make things fit.  Now:  THISLINE comes from TEXTOBJ"
) LFIRSTSEPR (* ; 
"Character position of the first separator on the line, for detecting the last valid line.") 
LPARALOOKS (* ; "The paragraph looks for this line's paragraph (eventually)") (NIL FLAG) (* ; 
"Was LDIRTY: T if this line has changed since it was last formatted.") (NIL FLAG) (* ; 
"Was FORCED-END flag") (NIL FLAG) (* ; 
"Was DELETED: T if this line has been completely deleted since it was last formatted or displayed.  (Used by deletion routines to detect garbage lines)"
) (NIL FLAG) (* ; "Was LHASPROT This line contains protected text.") (LDUMMY FLAG) (* ; 
"This is a dummy line. Was: LHASTABS.  But never fetched and this descriptions wasn't true: If this line has a tab in it, this is the line-relative ch# of the final tab.  This is to let us punt properly with tabs in a line."
) (1STLN FLAG) (* ; "This line is the first line in a paragraph") (LSTLN FLAG) (* ; 
"This is the last line in a paragraph")) (INIT (DEFPRINT (QUOTE LINEDESCRIPTOR) (FUNCTION 
\TEDIT.LINEDESCRIPTOR.DEFPRINT))) (ACCESSFNS ((YTOP (STANDARD (IPLUS (GETLD DATUM YBASE) (GETLD DATUM 
LASCENT)) FAST (IPLUS (FGETLD DATUM YBASE) (FGETLD DATUM LASCENT)))) (LTRUEYTOP (STANDARD (IPLUS (
GETLD DATUM YBASE) (FGETLD DATUM LTRUEASCENT)) FAST (IPLUS (FGETLD DATUM YBASE) (FGETLD DATUM 
LTRUEASCENT)))) (LTRUEHEIGHT (STANDARD (IPLUS (GETLD DATUM LTRUEASCENT) (FGETLD DATUM LTRUEDESCENT)) 
FAST (IPLUS (FGETLD DATUM LTRUEASCENT) (FGETLD DATUM LTRUEDESCENT)))) (LTRUEYBOT (STANDARD (
IDIFFERENCE (GETLD DATUM YBASE) (FGETLD DATUM LTRUEDESCENT)) FAST (IDIFFERENCE (FGETLD DATUM YBASE) (
FGETLD DATUM LTRUEDESCENT)))) (LLEADBEFORE (STANDARD (IDIFFERENCE (GETLD DATUM LASCENT) (FGETLD DATUM 
LTRUEASCENT)) FAST (IDIFFERENCE (FGETLD DATUM LASCENT) (FGETLD DATUM LTRUEASCENT)))) (LCHARLIM (
STANDARD (ADD1 (GETLD DATUM LCHARLAST)) FAST (ADD1 (FGETLD DATUM LCHARLAST))) (STANDARD (SETLD DATUM 
LCHARLAST (SUB1 NEWVALUE)) FAST (FSETLD DATUM LCHARLAST (SUB1 NEWVALUE)))) (LNCH (STANDARD (
IDIFFERENCE (GETLD DATUM LCHARLIM) (GETLD DATUM LCHAR1)) FAST (IDIFFERENCE (FGETLD DATUM LCHARLIM) (
FGETLD DATUM LCHAR1)))))) LHEIGHT _ 0 LTRUEASCENT _ 0 LTRUEDESCENT _ 0 YBOT _ 0 YBASE _ 0 LEFTMARGIN _
 0)
(DEFPRINT (QUOTE LINEDESCRIPTOR) (FUNCTION \TEDIT.LINEDESCRIPTOR.DEFPRINT))
(I.S.OPR (QUOTE inlines) NIL (QUOTE (bind $$PREVLINE declare (LOCALVARS $$PREVLINE) first (SETQ I.V. (
\DTEST (OR BODY (GO $$OUT)) (QUOTE LINEDESCRIPTOR))) by (PROGN (SETQ $$PREVLINE I.V.) (\DTEST (OR (
fetch (LINEDESCRIPTOR NEXTLINE) of I.V.) (GO $$OUT)) (QUOTE LINEDESCRIPTOR))))))
(I.S.OPR (QUOTE backlines) NIL (QUOTE (bind $$NEXTLINE declare (LOCALVARS $$NEXTLINE) first (SETQ I.V.
 (\DTEST (OR BODY (GO $$OUT)) (QUOTE LINEDESCRIPTOR))) by (PROGN (SETQ $$NEXTLINE I.V.) (\DTEST (OR (
fetch (LINEDESCRIPTOR PREVLINE) of I.V.) (GO $$OUT)) (QUOTE LINEDESCRIPTOR))))))
(PUTPROPS GETLD MACRO ((L FIELD) (fetch (LINEDESCRIPTOR FIELD) of L)))
(PUTPROPS FGETLD MACRO ((L FIELD) (ffetch (LINEDESCRIPTOR FIELD) of L)))
(PUTPROPS SETLD MACRO ((L FIELD NEWVALUE) (replace (LINEDESCRIPTOR FIELD) of L with NEWVALUE)))
(PUTPROPS FSETLD MACRO ((L FIELD NEWVALUE) (freplace (LINEDESCRIPTOR FIELD) of L with NEWVALUE)))
(PUTPROPS SETYBOT MACRO (OPENLAMBDA (LINE BOTTOM) (FSETLD LINE YBASE (IPLUS (GETLD LINE LDESCENT) (
FSETLD LINE YBOT BOTTOM)))))
(PUTPROPS SETYTOP MACRO (OPENLAMBDA (LINE TOP) (SETYBOT LINE (IDIFFERENCE TOP (GETLD LINE LHEIGHT)))))
(PUTPROPS SETYBASE MACRO (OPENLAMBDA (LINE BASE) (FSETLD LINE YBOT (IDIFFERENCE (GETLD LINE LDESCENT) 
(FSETLD LINE YBASE BASE)))))
(PUTPROPS LINKLD MACRO (OPENLAMBDA (LINE1 LINE2) (CL:WHEN LINE1 (SETLD LINE1 NEXTLINE LINE2)) (CL:WHEN
 LINE2 (SETLD LINE2 PREVLINE LINE1))))
(PUTPROPS LINEDESCRIPTOR! MACRO ((LD) (\DTEST LD (QUOTE LINEDESCRIPTOR))))
(PUTPROPS HCSCALE MACRO (OPENLAMBDA (SCALE ITEM) (CL:IF (LISTP ITEM) (for I in ITEM collect (FIXR (
FTIMES SCALE ITEM))) (FIXR (FTIMES SCALE ITEM)))))
(PUTPROPS HCUNSCALE MACRO (OPENLAMBDA (SCALE ITEM) (CL:IF (LISTP ITEM) (for I in ITEM collect (FIXR (
FQUOTIENT I SCALE))) (FIXR (FQUOTIENT ITEM SCALE)))))
(PUTPROPS SCALEUP MACRO (OPENLAMBDA (SCALE ITEM) (* ; "List = region?") (CL:IF (LISTP ITEM) (for I in 
ITEM collect (FIXR (FTIMES SCALE ITEM))) (FIXR (FTIMES SCALE ITEM)))))
(PUTPROPS SCALEDOWN MACRO (OPENLAMBDA (SCALE ITEM) (* ; "List = region?") (CL:IF (LISTP ITEM) (for I 
in ITEM collect (FIXR (FQUOTIENT I SCALE))) (FIXR (FQUOTIENT ITEM SCALE)))))
(GLOBALVARS TEDIT.DONT.BREAK.CHARS TEDIT.DONT.LAST.CHARS)
(ADDTOVAR CHARACTERNAMES (EM-DASH "357,045") (SOFT-HYPHEN "357,043") (NONBREAKING-HYPHEN "357,042") (
NONBREAKING-SPACE "357,041"))
(PUTPROPS DIACRITICP MACRO (OPENLAMBDA (CHAR) (* ;; "An XCCS diacritic") (AND (SMALLP CHAR) (IGEQ CHAR
 192) (ILEQ CHAR 207))))
(PUTPROPS \TEDIT.LINE.TALLP MACRO ((LINE HEIGHT) (OR (IGREATERP (FGETLD LINE LHEIGHT) 50) (IGREATERP (
FGETLD LINE LHEIGHT) HEIGHT))))
(* ; "Formatting slots held by THISLINE")
(DATATYPE THISLINE ((* ;; 
"Cache for line-related character location info, for selection and line-display code to use.") (DESC 
FULLXPOINTER) (* ; "Line descriptor for the line this describes now") TLSPACEFACTOR (* ; 
"The SPACEFACTOR to be used in printing this line") TLFIRSTSPACE (* ; 
"The first space to which SPACEFACTOR is to apply.  This is used sothat spaces to the left of a TAB have their default width."
) CHARSLOTS (* ; 
"Pointer block holdomg char/width slots MAXCHARSLOTS (with an extra slot so that there is always storage behind NEXTAVAILABLECHARSLOT"
) NEXTAVAILABLECHARSLOT) (* ; "The last used CHARSLOT is at (PREVCHARSLOT NEXTAVAILABLECHARSLOT)") 
CHARSLOTS _ (\ALLOCBLOCK (ITIMES (ADD1 MAXCHARSLOTS) CELLSPERCHARSLOT) PTRBLOCK.GCT))
(BLOCKRECORD CHARSLOT (CHAR CHARW (* ; "If CHAR is NIL, then CHARW is CHARLOOKS.") CHARCL))
(PUTPROPS CHAR MACRO ((CSLOT) (ffetch (CHARSLOT CHAR) of CSLOT)))
(PUTPROPS CHARW MACRO ((CSLOT) (ffetch (CHARSLOT CHARW) of CSLOT)))
(PUTPROPS CHARCL MACRO ((CSLOT) (ffetch (CHARSLOT CHARCL) of CSLOT)))
(PUTPROPS PREVCHARSLOT MACRO ((CSLOT) (\ADDBASE CSLOT (IMINUS WORDSPERCHARSLOT))))
(PUTPROPS NEXTCHARSLOT MACRO ((CSLOT) (\ADDBASE CSLOT WORDSPERCHARSLOT)))
(PUTPROPS FIRSTCHARSLOT MACRO ((TLINE) (fetch (THISLINE CHARSLOTS) of TLINE)))
(PUTPROPS NTHCHARSLOT MACRO ((TLINE N) (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE) (ITIMES N 
WORDSPERCHARSLOT))))
(PUTPROPS LASTCHARSLOT MACRO ((TLINE) (\ADDBASE (fetch (THISLINE CHARSLOTS) of TLINE) (TIMES (SUB1 
MAXCHARSLOTS) WORDSPERCHARSLOT))))
(PUTPROPS FILLCHARSLOT MACRO ((CSLOT C W R) (freplace (CHARSLOT CHAR) of CSLOT with C) (freplace (
CHARSLOT CHARW) of CSLOT with W) (freplace (CHARSLOT CHARCL) of CSLOT with R)))
(PUTPROPS PUSHCHAR MACRO ((CSLOTVAR C W CL) (FILLCHARSLOT CSLOTVAR C W CL) (SETQ CSLOTVAR (
NEXTCHARSLOT CSLOTVAR))))
(RPAQQ CELLSPERCHARSLOT 3)
(RPAQ WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL))
(RPAQQ MAXCHARSLOTS 256)
(CONSTANTS (CELLSPERCHARSLOT 3) (WORDSPERCHARSLOT (TIMES CELLSPERCHARSLOT WORDSPERCELL)) (MAXCHARSLOTS
 256))
(* ;; 
"incharslots can be used only if THISLINE is properly bound in the environment, to provide upperbound checking.  Operand can be THISLINE (= FIRSTCHARSLOT) or a within-range slot pointer.  The latter case is not current checked for validity (some \HILOC \LOLOC address calculations?). backcharslots runs backwards."
)
(I.S.OPR (QUOTE incharslots) NIL (QUOTE (SUBST (GETDUMMYVAR) (QUOTE $$STARTSLOT) (QUOTE (bind 
$$STARTSLOT _ BODY CHAR CHARW CHARCL $$CHARSLOTLIMIT declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT) 
first (SETQ I.V. (COND ((TYPE? THISLINE $$STARTSLOT) (FIRSTCHARSLOT $$STARTSLOT)) (T $$STARTSLOT))) (
SETQ $$CHARSLOTLIMIT (fetch (THISLINE NEXTAVAILABLECHARSLOT) of THISLINE)) by (NEXTCHARSLOT I.V.) 
until (EQ I.V. $$CHARSLOTLIMIT) eachtime (SETQ CHAR (fetch (CHARSLOT CHAR) of I.V.)) (SETQ CHARW (
fetch (CHARSLOT CHARW) of I.V.)) (SETQ CHARCL (fetch (CHARSLOT CHARCL) of I.V.)))))) T)
(I.S.OPR (QUOTE backcharslots) NIL (QUOTE (SUBST (GETDUMMYVAR) (QUOTE $$STARTSLOT) (QUOTE (bind 
$$STARTSLOT _ BODY CHAR CHARW CHARCL $$CHARSLOTLIMIT declare (LOCALVARS $$STARTSLOT $$CHARSLOTLIMIT) 
first (SETQ I.V. (COND ((TYPE? THISLINE $$STARTSLOT) (PREVCHARSLOT (fetch (THISLINE 
NEXTAVAILABLECHARSLOT) of THISLINE))) (T $$STARTSLOT))) (SETQ $$CHARSLOTLIMIT (FIRSTCHARSLOT THISLINE)
) by (PREVCHARSLOT I.V.) eachtime (SETQ CHAR (fetch (CHARSLOT CHAR) of I.V.)) (SETQ CHARW (fetch (
CHARSLOT CHARW) of I.V.)) (SETQ CHARCL (fetch (CHARSLOT CHARCL) of I.V.)) repeatuntil (EQ I.V. 
$$CHARSLOTLIMIT))))) T)
(PUTPROP (QUOTE TEDIT-SCREEN) (QUOTE IMPORTDATE) (IDATE "28-Jul-2025 23:23:33"))
(DATATYPE PIECE ((* ; 
"The piece describes either a string or part of a file.  , or a generalized OBJECT.") PCONTENTS (* ; 
"The background source of data for this piece (stream, string, block, object, depending on the PTYPE)."
) (PTYPE BITS 4) (* ; "How the characters are delivered: thinfile, fatstring, object, substream") 
PBYTELEN (* ; "Length of this character piece in bytes.  PBYTELEN = PLEN*PBYTESPERCHAR") PFPOS (* ; 
"The FILEPTR of the start of the piece in the file") PLEN (* ; "Length of the piece, in characters.") 
NEXTPIECE (* ; "-> Next piece in this textobj.") (PREVPIECE FULLXPOINTER) (* ; 
"-> Prior piece in this text object.") PCHARLOOKS (* ; "Character formatting info ") PBYTESPERCHAR (* 
; "The number of bytes per character, given that all characters in a piece are the same length.") (
PPARALAST FLAG) (* ; "This piece ends paragraph") PPARALOOKS (* ; "Paragraph looks for this piece") (
PNEW FLAG) (* ; 
"This text is new here;  used by the tentative edit system, and anyone else interested.") (NIL FLAG) (
* ; "Was PFATP") (PBINABLE FLAG) (* ; "8-bit bytes are binable (THINSTRING and THINFILE) ") (PTREENODE
 XPOINTER) (* ; "Points to the PCTB tree-node that contains this piece.") (PCHARSET BYTE) (* ; 
"High-order charset for FATFILE1 pieces") (PUTF8BYTESPERCHAR BYTE)) (* ; 
"The number of bytes in the UTF-8 encoding of all the Unicode characters in this piece") (ACCESSFNS ((
POBJ (AND (EQ OBJECT.PTYPE (PTYPE DATUM)) (type? IMAGEOBJ (PCONTENTS DATUM)) (PCONTENTS DATUM))))) 
PFPOS _ 0 PLEN _ 0 PBYTELEN _ 0)
(DATATYPE TEXTOBJ ((* ;; 
"This is where TEdit stores its state information, and internal data about the text being edited.") 
PCTB (* ; "The piece table") TEXTLEN (* ; "# of chars in the text") PRIMARYPANE (* ; 
"A sequence of panes (split subwindows) that are open on this document. Was INSERTPC: The string-piece that received the last insertion. Now HINTPC"
) SUFFIXPIECE (* ; "The last (end-of-stream) piece of the textstream, for easy insertion at the end") 
CHARFN (* ; 
"Was: INSERTNEXTCH CH# of next char which is typed into that piece. Taken over by HINTPCSTARTCH#") 
HINTPC (* ; "Was: Space left in the type-in piece") HINTPCSTARTCH# (* ; 
"Was # of characters already in the piece.") INSERTSTRING (* ; 
"A substring of storage that is available for an insertion.") TXTHISTORYUNDONE (* ; 
"Events that result from undoing other events, for revoking the UNDO. Was: CH# of first char in the piece."
) (NIL FLAG) (* ; 
" Was \INSERTPCVALID. T if it's OK to use the cached piece.  Set to NIL by people who require that the next insertion/deletion use a different piece. Now just set HINTPC to NIL."
) (TXTREADONLYQUIET FLAG) (* ; "T => don't print READONLY abort messages") PARABREAKCHARS (* ; 
"Characters that cause a paragraph break.Was \WINDOW. The window-pane<s> where this textobj is displayed. Now chained through PRIMARYPANE"
) MOUSEREGION (* ; "Section of the window the mouse is in.") LOOPFN (* ; 
"Was: A list of lines (parallel to the panes in \WINDOW) each of which is the top of chain of line descriptors for the part of the text that is visible in the corresponding pane. Now: each PANE has its own PLINES."
) DS (* ; 
"NOTE:  THIS IS ONLY USED INCORRECTLY BY TEDIT-CHAT Display stream where this textobj is displayed") 
SEL (* ; "The current selection within the text") LASTARROWX (* ; 
"X for next arrow up or arrow down. Was: Scratch space for the selection code") NIL (* ; 
"Was MOVESEL: Source for the next MOVE of text") NIL (* ; "Was SHIFTEDSEL: Source for the next COPY") 
NIL (* ; "Was DELETESEL: Text to be deleted imminently") NIL (* ; 
"Was WRIGHT: Right edge of the window (or subregion) where this is displayed") WTOP (* ; 
"Top of the window/region") NIL (* ; "Was WBOTTOM: Bottom of the window/region") NIL (* ; 
"Was WLEFT: Left edge of the window/region") TXTFILE (* ; "The original text file we're editing") (
\XDIRTY FLAG) (* ; "T => changed since last saved.") (STREAMHINT FULLXPOINTER) (* ; 
"-> the TEXTOFD stream which gives access to this textobj") EDITFINISHEDFLG (* ; 
"T => The guy has asked the editor to go way") NIL (* ; 
"Was CARET: Describes the flashing caret for the editing window") CARETLOOKS (* ; 
"Font to be used for inserted text.") WINDOWTITLE (* ; 
"Original title for this window, of there was one.") THISLINE (* ; 
"Cache of line-related info, to speed up selection &c") (MENUFLG FLAG) (* ; 
"T if this TEXTOBJ is a tedit-style menu") DEFAULTPARALOOKS (* ; 
"Default Formatting Spec to be used when formatting paragraphs") (FORMATTEDP FLAG) (* ; 
"Flag for paragraph formatting.  T if this document is to contain paragraph formatting information.") 
(TXTREADONLY FLAG) (* ; "This is only available for shift selection.") (UNDERTEDIT FLAG) (* ; 
"Was TXTEDITING, but it was never fetched. T => This document is in a window and there is an edit process behind it.  For example, it only makes sense to have a caret show up if you are editing."
) (TXTNOTSPLITTABLE FLAG) (* ; 
"Can't split into panes, split-region not show. Was TXTNONSCHARS: T => If TEdit rns into a 255, it won't attempt to convert to NS characters.  Used for REALLY plain-text manipulation."
) TXTTERMSA (* ; "Special instructions for displaying characters on the screen") EDITOPACTIVE (* ; 
"T if there is an editing operation in progress.  Used to interlock the TEdit menu") DEFAULTCHARLOOKS 
(* ; 
"The default character looks -- if any -- to be applied to characters coming into the file from outside."
) TXTRTBL (* ; "The READTABLE to be used by the command loop for command dispatch") TXTWTBL (* ; 
"The READTABLE to be used to decide on word breaks") EDITPROPS (* ; 
"The PROPS that were passed into this edit session") (BLUEPENDINGDELETE FLAG) (* ; 
"T if the next insertion in this document is to be preceded by a deletion of the then-current selection"
) (TXTHISTORYINACTIVE FLAG) (* ; "T if history events are not recorded (e.g. for transcript files)") 
TXTHISTORY (* ; "The history list for this edit session.") (SELPANE FULLXPOINTER) (* ; 
"The pane in which the last 'real' selection got made for this edit;  used by TEDIT.NORMALIZECAREET") 
PROMPTWINDOW (* ; 
"A window to be used for unscheduled interactions;  normally a small window above the edit window") 
DISPLAYCACHE (* ; "The bitmap to be used when building the image of a line for display") 
DISPLAYCACHEDS (* ; "The DISPLAYSTREAM that is used to build line images") DISPLAYHCPYDS (* ; 
"The DISPLAYSTREAM used to build line images of lines that are displayed in 'hardcopy' simulation mode"
) TXTPAGEFRAMES (* ; "A tree of page frames, specifying how the document is to be laid out.") 
TXTCHARLOOKSLIST (* ; "List of all the CHARLOOKSs in the document, so they can be kept unique") 
TXTPARALOOKSLIST (* ; "List of all the PARALOOKS in the document, so they can be kept unique") (
TXTAPPENDONLY FLAG) (* ; 
"Allows updates only at the end of the stream.  Was TXTNEEDSUPDATE: T => Screen invalid, need to run updater"
) (TXTDON'TUPDATE FLAG) (* ; 
"T if we're holding off on screen updates until later.  Used, e.g., by the menu-SHOW code so that you don't get piecemeal updates, but only one at the end of the SHOW."
) TXTRAWINCLUDESTREAM (* ; 
"NODIRCORE stream used to cache RAW includes (and maybe later, all includes?)") DOCPROPS (* ; 
"Document properties that are stored with the document (not used yet)") TXTSTYLESHEET (* ; 
"Style sheet local to this document.  Not currently saved as part of the file.")) (ACCESSFNS TEXTOBJ (
(\DIRTY (ffetch (TEXTOBJ \XDIRTY) of DATUM) (PROGN (FSETTOBJ DATUM LASTARROWX NIL) (CL:UNLESS (EQ 
NEWVALUE (ffetch (TEXTOBJ \XDIRTY) of DATUM)) (\TEDIT.WINDOW.TITLE DATUM NEWVALUE) (freplace \XDIRTY 
OF DATUM WITH NEWVALUE)))))) SEL _ (create SELECTION) TEXTLEN _ 0 WTOP _ 0 MOUSEREGION _ (QUOTE TEXT) 
THISLINE _ (create THISLINE) PARABREAKCHARS _ (CHARCODE (EOL FORM LF CR)))
(ACCESSFNS TEXTSTREAM ((* ;; 
"Overlay for the STREAM record to allow mnemonic access to stream fields for Text streams.") (* ;; 
"The # of characters that have already been read from the current piece") (TEXTOBJ (fetch (STREAM F3) 
of DATUM) (REPLACE (STREAM F3) OF DATUM WITH NEWVALUE)) (* ; "The TEXTOBJ that is editing this text") 
(PIECE (fetch (STREAM F5) of DATUM) (REPLACE (STREAM F5) OF DATUM WITH NEWVALUE)) (* ; 
"The PIECE we're currently fetching chars from/putting chars into") (PCCHARSLEFT (fetch (STREAM F1) of
 DATUM) (replace (STREAM F1) of DATUM with NEWVALUE)) (* ; "Runs from PLEN to 0: piece exhausted") (
NIL) (* ; 
"Was CURRENTLOOKS at F10: The CHARLOOKS that are currently applicable to characters being taken from the stream. This is now CARETLOOKS of the TEXTOBJ."
) (CURRENTPARALOOKS (fetch (STREAM IMAGEDATA) of DATUM) (replace (STREAM IMAGEDATA) of DATUM with 
NEWVALUE)) (* ; 
"THIS IS SOMEHOW INVOLVED IN STYLES, NOT SENSIBLE. REMOVE? The PARALOOKS that is currently applicable to characters being taken from the stream. This was  the only residual field of TEXTIMAGEDATA, now gone."
) (APPLYLOOKSUPDATEFN (fetch (STREAM F4) of DATUM) (replace (STREAM F4) OF DATUM with NEWVALUE)) (* ; 
"Determines whether to call \TEDIT.FORMATLINE.UPDATELOOKS at every piece change when line-formatting."
) (STARTINGCOFFSET (fetch (STREAM F2) of DATUM) (replace (STREAM F2) of DATUM with NEWVALUE))) (TYPE? 
(AND (type? STREAM DATUM) (type? TEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of DATUM)))) (CREATE (create 
STREAM BINABLE _ NIL BOUTABLE _ NIL ACCESS _ (QUOTE BOTH) USERCLOSEABLE _ T USERVISIBLE _ T DEVICE _ 
\TEXTFDEV F1 _ NIL F2 _ 0 F3 _ NIL F4 _ NIL F5 _ NIL MAXBUFFERS _ 10 IMAGEOPS _ \TEXTIMAGEOPS 
IMAGEDATA _ NIL)))
(PUTPROPS NEXTPIECE MACRO ((PC) (ffetch (PIECE NEXTPIECE) of PC)))
(PUTPROPS PREVPIECE MACRO ((PC) (ffetch (PIECE PREVPIECE) of PC)))
(PUTPROPS PLEN MACRO ((PC) (ffetch (PIECE PLEN) of PC)))
(PUTPROPS PTYPE MACRO ((PC) (ffetch (PIECE PTYPE) of PC)))
(PUTPROPS PCONTENTS MACRO ((PC) (ffetch (PIECE PCONTENTS) of PC)))
(PUTPROPS PCHARLOOKS MACRO ((PC) (ffetch (PIECE PCHARLOOKS) of PC)))
(PUTPROPS PCHARSET MACRO ((PC) (ffetch (PIECE PCHARSET) of PC)))
(PUTPROPS PPARALOOKS MACRO ((PC) (ffetch (PIECE PPARALOOKS) of PC)))
(PUTPROPS PPARALAST MACRO ((PC) (ffetch (PIECE PPARALAST) of PC)))
(PUTPROPS PFPOS MACRO ((PC) (ffetch (PIECE PFPOS) of PC)))
(PUTPROPS PBYTELEN MACRO ((PC) (ffetch (PIECE PBYTELEN) of PC)))
(PUTPROPS PNEW MACRO ((PC) (ffetch (PIECE PNEW) of PC)))
(PUTPROPS PBINABLE MACRO ((PC) (ffetch (PIECE PBINABLE) of PC)))
(PUTPROPS PBYTESPERCHAR MACRO ((PC) (ffetch (PIECE PBYTESPERCHAR) of PC)))
(PUTPROPS POBJ MACRO ((PC) (ffetch (PIECE POBJ) of PC)))
(PUTPROPS SETPC MACRO ((PC FIELD NEWVALUE) (replace (PIECE FIELD) of PC with NEWVALUE)))
(PUTPROPS FSETPC MACRO ((PC FIELD NEWVALUE) (freplace (PIECE FIELD) of PC with NEWVALUE)))
(PUTPROPS GETPC MACRO ((PC FIELD) (fetch (PIECE FIELD) of PC)))
(PUTPROPS FGETPC MACRO ((PC FIELD) (ffetch (PIECE FIELD) of PC)))
(PUTPROPS THINPIECEP MACRO ((PC) (* ;; 
"Assume that objects start out thin, for  CHARSET in \TEDIT.PUT.PCTB. The putfn might immediately change that, but we don't care."
) (SELECTC (PTYPE PC) (THIN.PTYPES T) (UTF8.PTYPE (EQ 1 (FGETPC PC PUTF8BYTESPERCHAR))) NIL)))
(PUTPROPS VISIBLEPIECEP MACRO ((PC) (AND PC (NEQ 0 (PLEN PC)) (NOT (FGETCLOOKS (PCHARLOOKS PC) 
CLINVISIBLE)))))
(PUTPROPS \NEXT.VISIBLE.PIECE MACRO ((PC) (find NPC inpieces (AND PC (NEXTPIECE PC)) suchthat (
VISIBLEPIECEP NPC))))
(PUTPROPS \PREV.VISIBLE.PIECE MACRO ((PC) (find PPC backpieces (AND PC (PREVPIECE PC)) suchthat (
VISIBLEPIECEP PPC))))
(PUTPROPS GETTOBJ MACRO ((TOBJ FIELD) (fetch (TEXTOBJ FIELD) of TOBJ)))
(PUTPROPS SETTOBJ MACRO ((TOBJ FIELD NEWVALUE) (replace (TEXTOBJ FIELD) of TOBJ with NEWVALUE)))
(PUTPROPS FGETTOBJ MACRO ((TOBJ FIELD) (ffetch (TEXTOBJ FIELD) of TOBJ)))
(PUTPROPS FSETTOBJ MACRO ((TOBJ FIELD NEWVALUE) (freplace (TEXTOBJ FIELD) of TOBJ with NEWVALUE)))
(PUTPROPS TEXTLEN MACRO ((TOBJ) (ffetch (TEXTOBJ TEXTLEN) of TOBJ)))
(PUTPROPS TEXTSEL MACRO ((TEXTOBJ) (SELECTION! (GETTOBJ TEXTOBJ SEL))))
(PUTPROPS TEXTOBJ! MACRO ((TOBJ) (\DTEST TOBJ (QUOTE TEXTOBJ))))
(PUTPROPS GETTSTR MACRO ((TSTR FIELD) (fetch (TEXTSTREAM FIELD) of TSTR)))
(PUTPROPS SETTSTR MACRO ((TSTR FIELD NEWVALUE) (replace (TEXTSTREAM FIELD) of TSTR with NEWVALUE)))
(PUTPROPS FGETTSTR MACRO ((TSTR FIELD) (ffetch (TEXTSTREAM FIELD) of TSTR)))
(PUTPROPS FSETTSTR MACRO ((TSTR FIELD NEWVALUE) (freplace (TEXTSTREAM FIELD) of TSTR with NEWVALUE)))
(PUTPROPS TEXTSTREAM! MACRO (OPENLAMBDA (TSTR) (AND (\DTEST TSTR (QUOTE STREAM)) (TEXTOBJ! (FGETTSTR 
TSTR TEXTOBJ)) TSTR)))
(RPAQQ PTYPES ((THINFILE.PTYPE 0) (FATFILE1.PTYPE 1) (FATFILE2.PTYPE 2) (THINSTRING.PTYPE 3) (
FATSTRING.PTYPE 4) (SUBSTREAM.PTYPE 5) (OBJECT.PTYPE 6) (LOOKS.PTYPE 7) (UTF16BE.PTYPE 8) (
UTF16LE.PTYPE 9) (UTF8.PTYPE 11) (FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE 
UTF8.PTYPE UTF16BE.PTYPE UTF16LE.PTYPE)) (STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE)) (
BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE)) (THIN.PTYPES (LIST THINFILE.PTYPE 
THINSTRING.PTYPE)) (FAT.PTYPES (LIST FATFILE2.PTYPE FATSTRING.PTYPE FATFILE1.PTYPE))))
(RPAQQ THINFILE.PTYPE 0)
(RPAQQ FATFILE1.PTYPE 1)
(RPAQQ FATFILE2.PTYPE 2)
(RPAQQ THINSTRING.PTYPE 3)
(RPAQQ FATSTRING.PTYPE 4)
(RPAQQ SUBSTREAM.PTYPE 5)
(RPAQQ OBJECT.PTYPE 6)
(RPAQQ LOOKS.PTYPE 7)
(RPAQQ UTF16BE.PTYPE 8)
(RPAQQ UTF16LE.PTYPE 9)
(RPAQQ UTF8.PTYPE 11)
(RPAQ FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE UTF8.PTYPE UTF16BE.PTYPE 
UTF16LE.PTYPE))
(RPAQ STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE))
(RPAQ BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE))
(RPAQ THIN.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE))
(RPAQ FAT.PTYPES (LIST FATFILE2.PTYPE FATSTRING.PTYPE FATFILE1.PTYPE))
(CONSTANTS (THINFILE.PTYPE 0) (FATFILE1.PTYPE 1) (FATFILE2.PTYPE 2) (THINSTRING.PTYPE 3) (
FATSTRING.PTYPE 4) (SUBSTREAM.PTYPE 5) (OBJECT.PTYPE 6) (LOOKS.PTYPE 7) (UTF16BE.PTYPE 8) (
UTF16LE.PTYPE 9) (UTF8.PTYPE 11) (FILE.PTYPES (LIST THINFILE.PTYPE FATFILE1.PTYPE FATFILE2.PTYPE 
UTF8.PTYPE UTF16BE.PTYPE UTF16LE.PTYPE)) (STRING.PTYPES (LIST THINSTRING.PTYPE FATSTRING.PTYPE)) (
BINABLE.PTYPES (LIST THINFILE.PTYPE THINSTRING.PTYPE)) (THIN.PTYPES (LIST THINFILE.PTYPE 
THINSTRING.PTYPE)) (FAT.PTYPES (LIST FATFILE2.PTYPE FATSTRING.PTYPE FATFILE1.PTYPE)))
(GLOBALVARS \TEXTIMAGEOPS \TEXTFDEV)
(PUTPROP (QUOTE TEDIT-STREAM) (QUOTE IMPORTDATE) (IDATE "29-Jul-2025 11:58:01"))
(PUTPROPS \TEDIT.MOUSESTATE MACRO (BUTTON (* ;; 
"Test to see if only the specified mouse button is down.  DOES NOT call GETMOUSESTATE, so the mouse-button info is the same as the last time it was called."
) (SELECTQ (CAR BUTTON) (LEFT (QUOTE (EQ LASTMOUSEBUTTONS 4))) (MIDDLE (QUOTE (EQ LASTMOUSEBUTTONS 1))
) (RIGHT (QUOTE (EQ LASTMOUSEBUTTONS 2))) (SHOULDNT))))
(PUTPROPS \TEDIT.CHECK MACRO (ARGS (COND ((AND (BOUNDP (QUOTE CHECK)) CHECK) (CONS (QUOTE PROGN) (for 
I in ARGS as J on ARGS when (NOT (STRINGP I)) collect (LIST (QUOTE OR) I (LIST (QUOTE HELP) 
"TEdit consistency-check failure [RETURN to continue]:  " (COND ((STRINGP (CADR J))) (T (KWOTE I))))))
)) (T (CONS COMMENTFLG ARGS)))))
(PUTPROP (QUOTE TEDIT-COMMAND) (QUOTE IMPORTDATE) (IDATE "17-Jul-2025 00:24:49"))
(PUTPROPS \SMALLPIN MACRO (OPENLAMBDA (STREAM) (SIGNED (create WORD HIBYTE _ (\BIN STREAM) LOBYTE _ (
\BIN STREAM)) BITSPERWORD)))
(PUTPROPS \SMALLPOUT MACRO (OPENLAMBDA (STREAM W) (* ; "Signed smallp, unlike \WOUT") (\BOUT STREAM (
LOGAND 255 (LRSH W 8))) (\BOUT STREAM (LOGAND W 255))))
(PUTPROP (QUOTE TEDIT-FILE) (QUOTE IMPORTDATE) (IDATE " 1-Aug-2025 14:53:19"))
(PUTPROP (QUOTE TEDIT-OLDFILE) (QUOTE IMPORTDATE) (IDATE " 1-Aug-2025 14:58:21"))
(DATATYPE CHARLOOKS ((* ;; "Describes the appearance (%"Looks%") of characters in a TEdit document.") 
(* ;; "NOTE:  If fields change EQCLOOKS should change too.") CLFONT (* ; 
"The font descriptor for these characters") CLFONTUNPARSE (* ;; 
"Name of the font (e.g., HELVETICA) THIS FIELD IS A HINT, OR FOR USE IN CHARLOOKS-BUILDING CODE.  USE FONTPROP TO GET THE RIGHT VALUE FROM CLFONT."
) NIL (* ; "Was  CLSIZE. Font size, in points") (NIL FLAG) (* ; 
"Was CLITAL: T if the characters are italic, else NIL") (NIL FLAG) (* ; 
"Was CLBoldT if the characters are bold, else NIL") (CLULINE FLAG) (* ; 
"T if the characters are to be underscored, else NIL") (CLOLINE FLAG) (* ; 
"T if the characters are to be overscored, else NIL") (CLSTRIKE FLAG) (* ; 
"T if the characters are to be struck thru, else nil.") CLOFFSET (* ; 
"A superscripting offset in points (?) else NIL (SUBSCRIPTING IF NEGATIVE.)") (CLSMALLCAP FLAG) (* ; 
"T if small caps, else NIL") (CLINVERTED FLAG) (* ; 
"T if the characters are to be shown white-on-black") (CLPROTECTED FLAG) (* ; 
"T if chars can't be selected, else NIL") (CLINVISIBLE FLAG) (* ; 
"T if TEDIT is to ignore these chars;  else NIL") (CLSELAFTER FLAG) (* ; 
"T if TEDIT can put selection after this char (for menu fields).") (* ;; "Was CLSELHERE. ") (CLCANCOPY
 FLAG) (* ;; 
"T if this text can be selected for copying, even tho protected (it will become unprotected after the copy;  for Dribble/TTY interface)"
) (CLUNBREAKABLE FLAG) (* ; "Spaces are treated as nonbreaking spaces") CLSTYLE (* ; 
"The style to be used in marking these characters;  overridden by the other fields") CLPROPS (* ; 
"Was CLUSERINFO:Any information that an outsider wants to include") CLLEADER (* ; 
"For creating dotted and other kinds of leader") CLRULES (* ;; 
"For arbitrarily-places horizontal rules.  List of pairs, of (widthinpts  . offsetfrombaselineinpts).  Should be taken account of in ascent/descent calcs."
) (CLMARK FLAG) (* ;; 
"Used for a mark-&-sweep of looks at PUT time -- T means this set of looks really IS in use in the document"
) (CLSELBEFORE FLAG) (* ; "T if TEDIT can put selection before this char (for menu fields).") CLCOLOR)
 CLOFFSET _ 0 CLCOLOR _ (QUOTE BLACK) (INIT (DEFPRINT (QUOTE CHARLOOKS) (FUNCTION 
\TEDIT.CHARLOOKS.DEFPRINT))) (ASSOCRECORD CLPROPS (CLUSERINFO CLCHARENCODING)) (ACCESSFNS ((CLNAME (
fetch (CHARLOOKS CLFONTUNPARSE) of DATUM) (replace (CHARLOOKS CLFONTUNPARSE) of DATUM with NEWVALUE)))
))
(DATATYPE PARALOOKS ((* ;; "Describe the paragraph formatting for a paragraph in a TEdit document.") 
1STLEFTMAR (* ; "Left margin of the first line of the paragraph") LEFTMAR (* ; 
"Left margin of the rest of the lines in the paragraph") RIGHTMAR (* ; 
"Right margin for the paragraph") LEADBEFORE (* ; 
"Leading above the paragraph's first line, in points") LEADAFTER (* ; 
"Leading below the paragraph's bottom line, in points.  NOT IMPLEMENTED.") LINELEAD (* ; 
"Leading between lines, in points.  This space is added BELOW each line in the para when TEDIT.LINELEADING.BELOW, otherwise above, which is how it is documented."
) FMTBASETOBASE (* ; 
"The baseline-to-baseline spacing between lines in this paragraph.  THIS  OVERRIDES THE LINE LEADING")
 NIL (* ; "Was TABSPEC: The list of tabs for this paragraph, including CAR for a default tab width") 
QUAD (* ; "How the para is formatted: one of LEFT, RIGHT, CENTERED, JUSTIFIED") FMTSTYLE (* ; 
"The STYLE that controls this paragraph's appearance") FMTCHARSTYLES (* ; 
"The characterstyles that control the appearance of characters in this para (maybe?  may be part of the fmtstyle.)"
) FMTUSERINFO (* ; "Space for a PLIST of user info") FMTSPECIALX (* ; 
"A special horizontal location on the printed page for this para.") FMTSPECIALY (* ; 
"A special vertical location on the page for this para") (FMTHEADINGKEEP FLAG) (* ; 
"This para should be kept with the top line or so of the next para..") FMTPARATYPE (* ; 
"What kind of para this is: TEXT, PAGEHEADING, whatever") FMTPARASUBTYPE (* ; 
"Sub type of the type, e.g., what KIND of page heading this is.") FMTNEWPAGEBEFORE (* ; 
"Start a new box (if T) or back up the page formatting tree to make a new box of the type named in the value -- by going the least distance back up the tree, then back down until you find that kind of box."
) FMTNEWPAGEAFTER (* ; "Similarly") FMTKEEP (* ; 
"For information about how this paragraph is to be kept with other paragraphs.") FMTCOLUMN (* ; 
"For setting up side-by-side paragraphs easily ala BravoX") FMTVERTRULES (* ; 
"For Keeping track of vertical rules in force") (FMTMARK FLAG) (* ; 
"Used to keep track of which PARALOOKSs are really being used -- a mark & collect is done just before a PUT, so that only 'real' PARALOOKSs make it into the file"
) (* ; 
"Used for a mark&sweep of para looks at PUT time -- T means this looks really IS in use in the document, so it makes sense to save it on the file."
) (FMTHARDCOPY FLAG) (* ; "T if this paragraph is to be displayed in hardcopy-format.") FMTREVISED (* 
; 
"T (or perhaps a revision level or revision-mark spec??) if this paragraph is to be marked as changed on output."
) FMTHARDCOPYSCALE (* ; 
"The units-per-point (DSPSCALE) of the hardcopy stream that is simulated in hardcopy-display mode (FMTHARDCOPY=T"
) FMTDEFAULTTAB (* ; "Default tab in points)") FMTTABS) (* ; "List of tabs (in points)") (INIT (
DEFPRINT (QUOTE PARALOOKS) (FUNCTION \TEDIT.PARALOOKS.DEFPRINT))) LEADBEFORE _ 0 LEADAFTER _ 0 
LINELEAD _ 0)
(DEFPRINT (QUOTE CHARLOOKS) (FUNCTION \TEDIT.CHARLOOKS.DEFPRINT))
(DEFPRINT (QUOTE PARALOOKS) (FUNCTION \TEDIT.PARALOOKS.DEFPRINT))
(PUTPROPS \WORDSETA DMACRO (OPENLAMBDA (A J V) (CHECK (AND (ARRAYP A) (ZEROP (fetch (ARRAYP ORIG) of A
)) (EQ \ST.POS16 (fetch (ARRAYP TYP) of A)))) (CHECK (IGREATERP (fetch (ARRAYP LENGTH) of A) J)) (
\PUTBASE (fetch (ARRAYP BASE) of A) (IPLUS (fetch (ARRAYP OFFST) of A) J) V)))
(PUTPROPS ONOFF MACRO (OPENLAMBDA (VAL) (COND (VAL (QUOTE ON)) (T (QUOTE OFF)))))
(PUTPROPS GETCLOOKS MACRO ((CL FIELD) (fetch (CHARLOOKS FIELD) of CL)))
(PUTPROPS SETCLOOKS MACRO ((CL FIELD NEWVALUE) (replace (CHARLOOKS FIELD) of CL with NEWVALUE)))
(PUTPROPS FGETCLOOKS MACRO ((CL FIELD) (ffetch (CHARLOOKS FIELD) of CL)))
(PUTPROPS FSETCLOOKS MACRO ((CL FIELD NEWVALUE) (freplace (CHARLOOKS FIELD) of CL with NEWVALUE)))
(PUTPROPS CHARLOOKS! MACRO ((CL) (\DTEST CL (QUOTE CHARLOOKS))))
(PUTPROPS GETPLOOKS MACRO ((PLOOKS FIELD) (fetch (PARALOOKS FIELD) of PLOOKS)))
(PUTPROPS SETPLOOKS MACRO ((PLOOKS FIELD NEWVALUE) (replace (PARALOOKS FIELD) of PLOOKS with NEWVALUE)
))
(PUTPROPS FGETPLOOKS MACRO ((PLOOKS FIELD) (ffetch (PARALOOKS FIELD) of PLOOKS)))
(PUTPROPS FSETPLOOKS MACRO ((PLOOKS FIELD NEWVALUE) (freplace (PARALOOKS FIELD) of PLOOKS with 
NEWVALUE)))
(PUTPROPS PARALOOKS! MACRO ((PL) (\DTEST PL (QUOTE PARALOOKS))))
(PUTPROP (QUOTE TEDIT-LOOKS) (QUOTE IMPORTDATE) (IDATE " 1-Aug-2025 13:43:51"))
(PUTPROP (QUOTE TEDIT-STYLES) (QUOTE IMPORTDATE) (IDATE "28-Jul-2025 23:25:43"))
(DATATYPE TEDITCARET (TCNOWTIME (* Used to hold the current time, when checking to see if a transition
 is due) TCTHENTIME (* Time when the next transition is to take place) TCFORCEDDOWN (* TCFORCEDOWN = T
 means (Make the caret visible at the next call to \EDIT.FLIPCARET.)) TCUP (* TCUP = T => The caret is
 NOT VISIBLE. Used to track the current state of the caret) TCCARETDS (* The display stream that the 
caret appears in) TCCURSORBM (* The CURSOR representing the caret) TCCARETRATE (* %# of MSEC between 
caret up/down transitions) TCFORCEUP (* T => The caret is not allowed to become visible. Used to keep 
the caret up during screen updates) TCCARETX (* X position in the window that the caret appears at) 
TCCARETY (* Y position in the window where the caret appears) TCCARET (* A lisp CARET to be flashed (
eventually))) TCNOWTIME _ (CREATECELL \FIXP) TCTHENTIME _ (CREATECELL \FIXP) TCCURSORBM _ BXCARET 
TCCARETRATE _ \CARETRATE TCUP _ T TCCARET _ (\CARET.CREATE BXCARET))
(ACCESSFNS TEXTWINDOW ((WTEXTSTREAM (GETWINDOWPROP DATUM (QUOTE TEXTSTREAM)) (PUTWINDOWPROP DATUM (
QUOTE TEXTSTREAM) NEWVALUE)) (PTEXTOBJ (fetch (TEXTSTREAM TEXTOBJ) of (fetch (TEXTWINDOW WTEXTSTREAM) 
of DATUM))) (CURSORREGION (GETWINDOWPROP DATUM (QUOTE TEDIT.CURSORREGION)) (PUTWINDOWPROP DATUM (QUOTE
 TEDIT.CURSORREGION) NEWVALUE)) (CLOSINGFILE (GETWINDOWPROP DATUM (QUOTE TEDIT-CLOSING-FILE)) (
PUTWINDOWPROP DATUM (QUOTE TEDIT-CLOSING-FILE) NIL)) (PANEPROPS (GETWINDOWPROP DATUM (QUOTE PANEPROPS)
) (PUTWINDOWPROP DATUM (QUOTE PANEPROPS) NEWVALUE))) (TYPE? (AND (WINDOWP DATUM) (TYPENAMEP (fetch (
TEXTWINDOW PTEXTOBJ) of DATUM) (QUOTE TEXTOBJ)))))
(DATATYPE PANEPROPS ((PWINDOW FULLXPOINTER) (* ; "The window with these PANEPROPS") PREFIXLINE (* ; 
"Dummy line that covers all the characters above the first visible line") SUFFIXLINE (* ; 
"Dummy line that covers all the characters below the last visible line") PCARET NEXTPANE (PREVPANE 
XPOINTER) PANEHEIGHT PANEWIDTH PANELEFT PANERIGHT PANEBOTTOM PANETOP PANEREGION OTHERPAMEPROPS) 
PANELEFT _ 0 PANERIGHT _ 0 PANEBOTTOM _ 0 PANETOP _ 0 PANEWIDTH _ 0 PANEHEIGHT _ 0 PANEREGION _ (
CREATEREGION 0 0 0 0))
(PUTPROPS FGETPANEPROP MACRO ((P FIELD) (ffetch (PANEPROPS FIELD) of P)))
(PUTPROPS GETPANEPROP MACRO ((P FIELD) (fetch (PANEPROPS FIELD) of P)))
(PUTPROPS SETPANEPROP MACRO ((P FIELD NEWVALUE) (replace (PANEPROPS FIELD) of P with NEWVALUE)))
(PUTPROPS FSETPANEPROP MACRO ((P FIELD NEWVALUE) (freplace (PANEPROPS FIELD) of P with NEWVALUE)))
(PUTPROPS PANEWINDOW MACRO ((PANE) PANE))
(PUTPROPS PANEPROPS MACRO ((PANE) (fetch (TEXTWINDOW PANEPROPS) of PANE)))
(PUTPROPS PANEPREFIX MACRO ((PANE) (LINEDESCRIPTOR! (GETPANEPROP (PANEPROPS PANE) PREFIXLINE))))
(PUTPROPS PANESUFFIX MACRO ((PANE) (GETPANEPROP (PANEPROPS PANE) SUFFIXLINE)))
(PUTPROPS PANETOPLINE MACRO ((PANE) (FGETLD (PANEPREFIX PANE) NEXTLINE)))
(PUTPROPS PANECARET MACRO ((PANE) (\DTEST (GETPANEPROP (PANEPROPS PANE) PCARET) (QUOTE TEDITCARET))))
(PUTPROPS PANECARETY MACRO ((PANE) (fetch (TEDITCARET TCCARETY) of (GETPANEPROP (PANEPROPS PANE) 
PCARET))))
(PUTPROPS PANETEXTSTREAM MACRO ((PANE) (fetch (TEXTWINDOW WTEXTSTREAM) of PANE)))
(PUTPROPS PANETEXTOBJ MACRO ((PANE) (FTEXTOBJ (PANETEXTSTREAM PANE))))
(PUTPROPS PANEBOTTOMLINE MACRO ((PANE) (GETLD (PANESUFFIX PANE) PREVLINE)))
(PUTPROPS NEXTPANE MACRO ((PANE) (GETPANEPROP (PANEPROPS PANE) NEXTPANE)))
(PUTPROPS PREVPANE MACRO ((PANE) (GETPANEPROP (PANEPROPS PANE) PREVPANE)))
(PUTPROPS PANETOP MACRO ((PANE PREG) (fetch (REGION TOP) of (OR PREG (DSPCLIPPINGREGION NIL PANE)))))
(PUTPROPS PANEPTOP MACRO ((PANE PREG) (fetch (REGION PTOP) of (OR PREG (DSPCLIPPINGREGION NIL PANE))))
)
(PUTPROPS PANEWIDTH MACRO ((PANE PREG) (fetch (REGION WIDTH) of (OR PREG (DSPCLIPPINGREGION NIL PANE))
)))
(PUTPROPS PANELEFT MACRO ((PANE PREG) (fetch (REGION LEFT) of (OR PREG (DSPCLIPPINGREGION NIL PANE))))
)
(PUTPROPS PANERIGHT MACRO ((PANE PREG) (fetch (REGION RIGHT) of (OR PREG (DSPCLIPPINGREGION NIL PANE))
)))
(PUTPROPS PANEBOTTOM MACRO ((PANE PREG) (fetch (REGION BOTTOM) of (OR PREG (DSPCLIPPINGREGION NIL PANE
)))))
(PUTPROPS PANEHEIGHT MACRO ((PANE PREG) (GETPANEPROP (PANEPROPS PANE) PANEHEIGHT)))
(PUTPROPS PANEREGION MACRO ((PANE PREG) (OR PREG (GETPANEPROP (PANEPROPS PANE) PANEREGION) (
DSPCLIPPINGREGION NIL (PANEWINDOW PANE)))))
(I.S.OPR (QUOTE inpanes) NIL (QUOTE (bind $$BODY _ BODY declare (LOCALVARS $$BODY) first (SETQ I.V. (
OR (CL:IF (TYPENAMEP $$BODY (QUOTE TEXTOBJ)) (FGETTOBJ $$BODY PRIMARYPANE) $$BODY) (GO $$OUT))) by (OR
 (GETPANEPROP (PANEPROPS I.V.) NEXTPANE) (GO $$OUT)))))
(I.S.OPR (QUOTE backpanes) NIL (QUOTE (first (SETQ I.V. (OR (find P inpanes BODY suchthat (NULL (
GETPANEPROP (PANEPROPS P) NEXTPANE))) (GO $$OUT))) by (OR (GETPANEPROP (PANEPROPS I.V.) PREVPANE) (GO 
$$OUT)))))
(PUTPROPS ALLBUTTONSUP MACRO (NIL (ZEROP (LOGAND 7 LASTMOUSEBUTTONS))))
(PUTPROP (QUOTE TEDIT-WINDOW) (QUOTE IMPORTDATE) (IDATE "26-Jul-2025 15:45:59"))
(PUTPROP (QUOTE TEDIT-BUTTONS) (QUOTE IMPORTDATE) (IDATE "30-Apr-2025 14:09:18"))
(RPAQQ PTSPERPICA 12)
(RPAQQ PTSPERINCH 72)
(RPAQQ PICASPERINCH 6)
(RPAQQ MICASPERINCH 2540)
(RPAQ PTSPERCM (FQUOTIENT PTSPERINCH 2.54))
(RPAQ PTSPERMICA (FQUOTIENT PTSPERINCH MICASPERINCH))
(RPAQ MICASPERPOINT (FQUOTIENT MICASPERINCH PTSPERINCH))
(CONSTANTS (PTSPERPICA 12) (PTSPERINCH 72) (PICASPERINCH 6) (MICASPERINCH 2540) (PTSPERCM (FQUOTIENT 
PTSPERINCH 2.54)) (PTSPERMICA (FQUOTIENT PTSPERINCH MICASPERINCH)) (MICASPERPOINT (FQUOTIENT 
MICASPERINCH PTSPERINCH)))
(PUTPROP (QUOTE TEDIT-MENU) (QUOTE IMPORTDATE) (IDATE "28-Jul-2025 23:26:01"))
(PUTPROP (QUOTE TEDIT-FIND) (QUOTE IMPORTDATE) (IDATE "21-Apr-2025 22:42:57"))
(RPAQQ \TEDIT.TTCCODES ((NONE 0) (CHARDELETE 1) (WORDDELETE 2) (DELETE 3) (FUNCTIONCALL 4) (REDO 5) (
UNDO 6) (CMD 7) (NEXT 8) (EXPAND 9) (CHARDELETE.FORWARD 10) (WORDDELETE.FORWARD 11) (PUNCT 20) (TEXT 
21) (WHITESPACE 22)))
(CONSTANTS \TEDIT.TTCCODES)
(PUTPROPS \TEDIT.TTC MACRO ((CLASS) (CONSTANT (CADR (ASSOC (QUOTE CLASS) \TEDIT.TTCCODES)))))
(PUTPROP (QUOTE TEDIT-FNKEYS) (QUOTE IMPORTDATE) (IDATE "29-May-2025 16:20:30"))
(PUTPROP (QUOTE TEDIT-HCPY) (QUOTE IMPORTDATE) (IDATE "21-Apr-2025 19:07:23"))
(DATATYPE TEDITHISTORYEVENT ((* ;; "Describes one event on the TEdit edit history list.") THACTION (* 
; "A keyword specifying what the event was") THPOINT (* ; "Was the selection to the left or right?") 
THLEN (* ; "The # of chars involved") THCH# (* ; "The starting ch#") THFIRSTPIECE (* ; 
"First piece involved") THOLDINFO (* ; "Old info, for undo") NIL (* ; 
"Was THAUXINFO: Auxiliary info about the event, primarily for redo") THDELETEDPIECES) (ACCESSFNS 
TEDITHISTORYEVENT ((THCHLIM (IPLUS (OR (fetch (TEDITHISTORYEVENT THCH#) of DATUM) 0) (OR (fetch (
TEDITHISTORYEVENT THLEN) of DATUM) 0))))) (INIT (DEFPRINT (QUOTE TEDITHISTORYEVENT) (FUNCTION 
\TEDIT.HISTORYEVENT.DEFPRINT))) THPOINT _ (QUOTE LEFT))
(DEFPRINT (QUOTE TEDITHISTORYEVENT) (FUNCTION \TEDIT.HISTORYEVENT.DEFPRINT))
(PUTPROPS \TEDIT.LASTEVENT MACRO ((TOBJ) (CAR (fetch (TEXTOBJ TXTHISTORY) of TOBJ))))
(PUTPROPS GETTH MACRO ((EVENT FIELD) (fetch (TEDITHISTORYEVENT FIELD) of EVENT)))
(PUTPROPS SETTH MACRO ((EVENT FIELD NEWVALUE) (replace (TEDITHISTORYEVENT FIELD) of EVENT with 
NEWVALUE)))
(PUTPROP (QUOTE TEDIT-HISTORY) (QUOTE IMPORTDATE) (IDATE " 1-Aug-2025 14:58:56"))
(RECORD PAGEFORMATTINGSTATE ((* ;; "Contains the state for a TEdit page-formatting job.") PAGE# (* ; 
"The current page number.  Counted from 1") FIRSTPAGE (* ;; 
"T if the current page is the 'first page' .  Is set initially, and can be set again by the user at will.  Gets reset after each page image is printed."
) MINPAGE# (* ; "The page # of the first page to be printed, or NIL") MAXPAGE# (* ; 
"The page # of the last page to be printed, or NIL") STATE (* ; "One of FORMATTING or SEARCHING.") 
REQUIREDREGIONTYPE (* ; 
"If STATE is SEARCHING, the kind of box we're looking for.  If STATE is :SEARCHING-FOR-EQUIVALENT-PAGE, this is the page count for the matching page."
) MAINSTREAM (* ; "The principal textobj/stream source") CHNO (* ; "Our position in that stream") 
PRESSREGION (* ; "The press code's REGION info.") PAGEHEADINGS (* ; 
"The list of current values to be printed, indexed by heading type") PAGE#GENERATOR (* ; 
"List of page numbers;  later, maybe, a function to generate page numbers.  Used to fill in PAGE#TEXT, below"
) PAGE#TEXT (* ; 
"If special page numbers are in use, this is the place to take them from.  PAGE# is still used for recto/verso decisions &c"
) PAGEISRECTO (* ; "T if this is a recto page, NIL if it's a VERSO page.") PAGEFOOTNOTELINES (* ; 
"A list of extant footnote lines that should appear at the next opportunity") PAGEFLOATINGTOPLINES (* 
; "A list of lines that should float to the top of the next available place") PAGECOUNT (* ; 
"The number of pages we've formatted so far.") PAGELINECACHE (* ; 
"A cache for pre-created LINEDESCRIPTOR/THISLINE sets, to avoid the overhead of re-allocating them all the time"
) NEWPAGELAYOUT (* ; 
"If we switch page layouts in mid-document, this is where the new layout gets cached until we get started again."
)) PAGECOUNT _ 0)
(DATATYPE PAGEREGION ((* ;; 
"Describe a part of a page for page formatting.  Can be made into compound descriptions.") 
REGIONFILLMETHOD (* ; "What kind of a region this is -- TEXT, FOLIO, PAGEHEADING, etc.") REGIONSPEC (*
 ; "The page-relative region this occupies") REGIONLOCALINFO (* ; "A PLIST for local information") (
REGIONPARENT FULLXPOINTER) (* ; "The parent node for this box, for sub-boxes") REGIONSUBBOXES (* ; 
"The sub-regions of this region") REGIONTYPE (* ; "A user-settable region type")))
(PUTPROPS GETPFS MACRO ((FS FIELD) (fetch (PAGEFORMATTINGSTATE FIELD) of FS)))
(PUTPROPS SETPFS MACRO ((FS FIELD NEWVALUE) (replace (PAGEFORMATTINGSTATE FIELD) of FS with NEWVALUE))
)
(PUTPROPS TEDIT.SETQS MACRO (ARGS (BQUOTE (LET (($$VALUES (\, (CADR ARGS)))) (DECLARE (LOCALVARS 
$$VALUES)) (PROG1 (CAR $$VALUES) (\,@ (FOR V IN (CAR ARGS) collect (COND (V (BQUOTE (SETQ (\, V) (POP 
$$VALUES)))) (T (BQUOTE (SETQ $$VALUES (CDR $$VALUES))))))))))))
(PUTPROPS TEDIT.VALUES MACRO (ARGS (BQUOTE (LIST (\,@ ARGS)))))
(PUTPROP (QUOTE TEDIT-PAGE) (QUOTE IMPORTDATE) (IDATE " 5-Jun-2025 08:24:12"))
(PUTPROP (QUOTE TEDIT-ABBREV) (QUOTE IMPORTDATE) (IDATE "24-Apr-2025 23:45:12"))
(PUTPROP (QUOTE TEDIT-TFBRAVO) (QUOTE IMPORTDATE) (IDATE "28-Jul-2025 23:34:14"))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL)))
STOP
