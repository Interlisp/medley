(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)(FILECREATED " 4-Jan-2021 23:21:42" {DSK}<home>larry>ilisp>medley>lispusers>COMPAREDIRECTORIES.;278 65555        changes to%:  (VARS MEDLEY-FIX-DIRS COMPAREDIRECTORIESCOMS FIX-MEDLY-DIRS)                    (FNS MEDLEY-FIX-DIRS COMPAREDIRECTORIES CDFILES COMPAREDIRECTORIES.INFOS                          MATCHNAME CDPRINT CDPRINT.LINE CDMAP CDENTRY CDSUBSET BINCOMP EOLTYPE                          FIND-UNCOMPILED-FILES FIND-UNSOURCED-FILES FIND-SOURCE-FILES                          FIND-COMPILED-FILES FIND-UNLOADED-FILES FIND-LOADED-FILES                          FIND-MULTICOMPILED-FILES CREATED-AS SOURCE-FOR-COMPILED-P                          COMPILE-SOURCE-DATE-DIFF FIX-DIRECTORY-DATES FIX-EQUIV-DATES                          COPY-COMPARED-FILES COPY-MISSING-FILES COMPILED-ON-SAME-SOURCE                          COMPARE-ENTRY-SOURCE-FILES)      previous date%: "31-Oct-2020 09:13:05" {DSK}<home>larry>ilisp>medley>lispusers>COMPAREDIRECTORIES.;275)(* ; "Copyright (c) 1985, 1986, 1987, 1988, 1990, 1994, 1998, 2018, 2020, 2021 by Venue & Xerox Corporation.  All rights reserved.")(PRETTYCOMPRINT COMPAREDIRECTORIESCOMS)(RPAQQ COMPAREDIRECTORIESCOMS       (        (* ;; "Compare the contents of two directories.")        (FNS COMPAREDIRECTORIES CDFILES COMPAREDIRECTORIES.INFOS MATCHNAME MEDLEY-FIX-DIRS)        (VARS MEDLEY-FIX-DIRS)        (FNS CDPRINT CDPRINT.LINE)        (FNS CDMAP CDENTRY CDSUBSET)        (FNS BINCOMP EOLTYPE)        (RECORDS CDENTRY CDINFO)                (* ;; "look for compiled files older than the sources")        (FNS FIND-UNCOMPILED-FILES FIND-UNSOURCED-FILES FIND-SOURCE-FILES FIND-COMPILED-FILES              FIND-UNLOADED-FILES FIND-LOADED-FILES FIND-MULTICOMPILED-FILES)        (FNS CREATED-AS SOURCE-FOR-COMPILED-P COMPILE-SOURCE-DATE-DIFF)        (FNS FIX-DIRECTORY-DATES FIX-EQUIV-DATES COPY-COMPARED-FILES COPY-MISSING-FILES              COMPILED-ON-SAME-SOURCE)        [VARS (ONESECOND (IDIFFERENCE (IDATE "1-Jan-2020 12:00:01")                                (IDATE "1-Jan-2020 12:00:00"]        (INITVARS (LASTCDENTRIES NIL))        (COMS (FNS COMPARE-ENTRY-SOURCE-FILES)              (FILES COMPARESOURCES))))(* ;; "Compare the contents of two directories.")(DEFINEQ(COMPAREDIRECTORIES  [LAMBDA (DIR1 DIR2 SELECT FILEPATTERNS EXTENSIONSTOAVOID USEDIRECTORYDATE OUTPUTFILE ALLVERSIONS)                                                             (* ;                                                            "Edited 14-Oct-2020 21:15 by rmk:")    (* ;; "Compare the contents of two directories, e.g., for change-control purposes.  Compares files matching FILEPATTERN (or *.*;) on DIR1 and DIR2, listing which is newer, or when one is not found on the other.  If SELECT is or contains SAME/=, BEFORE/<, AFTER/>, then files where DIR1 is the same as, earlier than, or later than DIR2 are selected. SELECT= NIL is the same as (<  >), T is the same as (< > =).  Also allows selection based on file-length criteria.")    (* ;; "")    (* ;; "Unless USEDIRECTORYDATE, comparison is with respect to the the LISP filecreated dates if evailable.")    (* ;; "")    (* ;; "If OUTPUTFILE is NIL, the list of compared entries is returned.  Otherwise the selected entries are printed on OUTPUTFILE (T for the display).")    [SETQ SELECT (SELECTQ SELECT                     (NIL '(< > -* *-))                     (T '(< > -* *- =))                     (for S in (MKLIST SELECT) collect (SELECTQ S                                                                       ((AFTER >)                                                                             '>)                                                                       ((BEFORE <)                                                                             '<)                                                                       ((SAME SAMEDATE =)                                                                             '=)                                                                       (AUTHOR 'AUTHOR)                                                                       (-* '-*)                                                                       (*- '*-)                                                                       (ERROR                                                                       "UNRECOGNIZED SELECT PARAMETER"                                                                              S]    (PROG (INFOS1 INFOS2 CANDIDATES SELECTED COMPAREDATE DEPTH1 DEPTH2)          [SETQ COMPAREDATE (INTERSECTION SELECT '(< > =]     (* ;; "DIRECTORYNAME here to get unrelativized specifications for header.")     (* ;; "Allow all subdirectories if a directory ends in *, but peel it off for the resolution")          (CL:WHEN (EQ '* (NTHCHAR DIR1 -1))              (SETQ DEPTH1 T)              (SETQ DIR1 (SUBSTRING DIR1 1 -2)))          (CL:WHEN (EQ '* (NTHCHAR DIR2 -1))              (SETQ DEPTH2 T)              (SETQ DIR2 (SUBSTRING DIR2 1 -2)))          (SETQ DIR1 (OR (DIRECTORYNAME (OR DIR1 T))                         (ERROR "DIRECTORY DOES NOT EXIST" DIR1)))          (SETQ DIR2 (OR (DIRECTORYNAME (OR DIR2 T))                         (ERROR "DIRECTORY DOES NOT EXIST" DIR2)))          (PRINTOUT T "Comparing " DIR1 6 "vs. " DIR2 T "as of " (DATE)                 " selecting " SELECT " ... ")          (SETQ INFOS1 (COMPAREDIRECTORIES.INFOS (CDFILES DIR1 FILEPATTERNS EXTENSIONSTOAVOID                                                            ALLVERSIONS DEPTH1)                              USEDIRECTORYDATE))          (SETQ INFOS2 (COMPAREDIRECTORIES.INFOS (CDFILES DIR2 FILEPATTERNS EXTENSIONSTOAVOID                                                            ALLVERSIONS DEPTH2)                              USEDIRECTORYDATE))          (CL:UNLESS (AND INFOS2 INFOS1)                 (RETURN))     (* ;; "At this point the CAR of each info is the atomic match-name. Peel it off to produce candidate entries.")     (* ;;    "Look through all of the I2's because multiple versions (if VERSIONS) have the same matchname")          [SETQ CANDIDATES (for I1 in INFOS1                              join (if ALLVERSIONS                                           then (OR (for I2 in INFOS2                                                           when (EQ (CAR I2)                                                                        (CAR I1))                                                           collect (LIST (CAR I1)                                                                             (CDR I1)                                                                             (CDR I2)))                                                        (CONS (LIST (CAR I1)                                                                    (CDR I1)                                                                    NIL)))                                         else (CONS (LIST (CAR I1)                                                              (CDR I1)                                                              (CDR (ASSOC (CAR I1)                                                                          INFOS2]     (* ;; "Could be some 2's without 1's")          (SORT [NCONC CANDIDATES (for I2 in INFOS2 unless (ASSOC (CAR I2)                                                                              CANDIDATES)                                     collect (LIST (CAR I2)                                                       NIL                                                       (CDR I2]                T)     (* ;; "CANDIDATES is now a sorted list of the form (matchname entry1 entry2) where an entry consists of (fullname date length author)")     (* ;; "Do the SELECT filtering and insert the date relation.")          [SETQ SELECTED           (for C MATCHNAME INFO1 INFO2 IDATE1 IDATE2 DATEREL BINCOMP in CANDIDATES              eachtime (SETQ MATCHNAME (pop C))                    (SETQ INFO1 (pop C))                    (SETQ INFO2 (pop C))                    (if (AND INFO1 INFO2)                        then (SETQ IDATE1 (IDATE (fetch DATE of INFO1)))                              (SETQ IDATE2 (IDATE (fetch DATE of INFO2)))                              (SETQ DATEREL (if (IGREATERP IDATE1 IDATE2)                                                then '>                                              elseif (ILESSP IDATE1 IDATE2)                                                then '<                                              else '=))                      else                             (* ;; "Just for printing--no comparison")                            (SETQ DATEREL '*))              when (if (AND INFO1 INFO2)                           then (OR (NULL COMPAREDATE)                                        (SELECTQ DATEREL                                            (> (MEMB '> SELECT))                                            (< (MEMB '< SELECT))                                            (= (MEMB '= SELECT))                                            (SHOULDNT)))                         elseif INFO1                           then                                  (* ;; "OK if INFO2 is missing?")                                 (MEMB '*- SELECT)                         else                                (* ;; "OK if INFO1 is missing?")                               (MEMB '-* SELECT))              collect (create CDENTRY                                 MATCHNAME _ MATCHNAME                                 INFO1 _ INFO1                                 DATEREL _ DATEREL                                 INFO2 _ INFO2                                 EQUIV _ (CL:UNLESS (EQ DATEREL '*)                                             (BINCOMP (fetch FULLNAME of INFO1)                                                    (fetch FULLNAME of INFO2)                                                    T                                                    (fetch EOL of INFO1)                                                    (fetch EOL of INFO2)))]          (PRINTOUT T (LENGTH SELECTED)                 " entries" T)          (push SELECTED (LIST DIR1 DIR2 SELECT (DATE)))          (SETQ LASTCDENTRIES SELECTED)          (CL:UNLESS OUTPUTFILE (RETURN SELECTED))          (RETURN (CDPRINT SELECTED OUTPUTFILE (MEMB 'AUTHOR SELECT SELECT])(CDFILES  [LAMBDA (DIR FILEPATTERNS EXTENSIONSTOAVOID ALLVERSIONS DEPTH)                                                             (* ;                                                            "Edited 16-Oct-2020 13:42 by rmk:")    (* ;; "Returns a list of fullnames for files that satisfy the criteria")    (* ;; "For each name returned by (DIRECTORY DIR), assumes that FILEPATTERNS applies to the suffix after the directory (i.e. after NAMEPOS).  That includes possibly subdirectories, dotted files in ultimate file names, and versions.")    (* ;; "     Exclude subdirectories unless FILEPATTERNS includes *>*")    (* ;; "     Exclude dotted files (.xxx) unless FILEPATTERNS includes .*")    (* ;; "     Exclude files with extensions in EXTENSIONSTOAVOID (*=NIL does no filtering)")    (* ;; "     Exclude older versions unless ALLVERSIONS=T")    (* ;; "  DEPTH is the number of subdirectories below the ones specified in DIR (NIL top-level of DIR only, T = any depth)")    (* ;; "Resolve relative directories, so we can suppress subdirectory matches.   ")    (SETQ EXTENSIONSTOAVOID (MKLIST (U-CASE EXTENSIONSTOAVOID)))    [SETQ FILEPATTERNS (MKLIST (OR FILEPATTERNS '*]    (for FP FN FPNAME FPEXT EXCLUDEDOTTED (TOPDIR _ (DIRECTORYNAME (OR DIR T))) in                                                                                          FILEPATTERNS       join [SETQ FPNAME (U-CASE (FILENAMEFIELD FP 'NAME]             [SETQ FPEXT (U-CASE (FILENAMEFIELD FP 'EXTENSION]             (CL:UNLESS FPNAME                 (if FPEXT                     then                            (* ;; ".XY")                           (SETQ FPNAME (PACK* "." FPEXT))                   else (SETQ FPNAME '*)))             (CL:UNLESS FPEXT                 (SETQ FPEXT '*))             (SETQ EXCLUDEDOTTED (NEQ (CHARCODE %.)                                      (CHCON1 FPNAME)))             (SETQ FN (PACKFILENAME.STRING 'VERSION (CL:IF ALLVERSIONS                                                        '*                                                        "")                             'DIRECTORY TOPDIR 'NAME '* 'EXTENSION '*))              (* ;; "DEPTH is the number of internal %">%"")             [if (EQ DEPTH T)                 then (SETQ DEPTH MAX.SMALLP)               elseif DEPTH               else (SETQ DEPTH (bind (CNT _ 0)                                           (POS _ 0)                                           (FNDIR _ (FILENAMEFIELD FN 'DIRECTORY))                                       while (SETQ POS (STRPOS ">" FNDIR (ADD1 POS)))                                       do (add CNT 1) finally (RETURN CNT]             (for FULLNAME NAME EXT THISDEPTH in (DIRECTORY FN)                eachtime [SETQ NAME (U-CASE (FILENAMEFIELD FULLNAME 'NAME]                      [SETQ EXT (U-CASE (FILENAMEFIELD FULLNAME 'EXTENSION]                      (CL:UNLESS NAME                          (if EXT                              then                                     (* ;; ".XY")                                    (SETQ NAME (PACK* "." EXT))                                    (SETQ EXT NIL)))                      (CL:WHEN (AND EXCLUDEDOTTED (EQ (CHARCODE %.)                                                      (CHCON1 NAME)))                             (GO $$ITERATE))                      (SETQ THISDEPTH (bind (CNT _ 0)                                             (POS _ 0)                                             (FNDIR _ (FILENAMEFIELD FULLNAME 'DIRECTORY))                                         while (SETQ POS (STRPOS ">" FNDIR (ADD1 POS)))                                         do (add CNT 1) finally (RETURN CNT)))                       (* ;; "An empty subdirectory may appear without name or extensions") when (AND (OR NAME EXT)               (OR (EQ FPNAME '*)                   (EQ FPNAME NAME))               (OR (EQ FPEXT '*)                   (EQ FPEXT EXT))) unless [OR (IGREATERP THISDEPTH DEPTH)                                                   (AND EXT (OR (MEMB '* EXTENSIONSTOAVOID)                                                                (MEMB EXT EXTENSIONSTOAVOID]                collect FULLNAME) finally (CL:UNLESS $$VAL (PRINTOUT T                                                                           "No relevant files in "                                                                           TOPDIR T])(COMPAREDIRECTORIES.INFOS  [LAMBDA (FILES USEDIRECTORYDATE)                           (* ;                                                            "Edited 13-Oct-2020 08:42 by rmk:")    (* ;; "Value is a list of CDINFOS with the match-name consed on to the front")    (for FULLNAME TYPE LDATE in FILES       collect              (* ;; "GDATE/IDATE in case Y2K")             (SETQ LDATE (FILEDATE FULLNAME))                (* ; "Is it a Lisp file?")             (CONS (MATCHNAME FULLNAME)                   (create CDINFO                          FULLNAME _ FULLNAME                          DATE _ [GDATE (IDATE (if USEDIRECTORYDATE                                                   then (GETFILEINFO FULLNAME 'CREATIONDATE)                                                 elseif (OR LDATE (GETFILEINFO FULLNAME                                                                             'CREATIONDATE]                          LENGTH _ (GETFILEINFO FULLNAME 'LENGTH)                          AUTHOR _ (GETFILEINFO FULLNAME 'AUTHOR)                          TYPE _ (if LDATE                                     then (CL:IF (MEMB (FILENAMEFIELD FULLNAME 'EXTENSION)                                                           *COMPILED-EXTENSIONS*)                                                  'COMPILED                                                  'SOURCE)                                   else (PRINTFILETYPE FULLNAME))                          EOL _ (EOLTYPE FULLNAME])(MATCHNAME  [LAMBDA (NAME)                                             (* ;                                                            "Edited  5-Sep-2020 13:41 by rmk:")    (* ;; "The NAME.DIR for matching related files")    (LET ((M (PACKFILENAME 'HOST NIL 'VERSION NIL 'DIRECTORY NIL 'BODY NAME)))         (* ;; "Strip off the nuisance period")         (CL:IF (EQ (CHARCODE %.)                    (NTHCHARCODE M -1))             (SUBATOM M 1 -2)             M)])(MEDLEY-FIX-DIRS  [LAMBDA NIL                                          (* ; "Edited  4-Jan-2021 15:42 by larry")    (for X in MEDLEY-FIX-DIRS join (FIX-DIRECTORY-DATES (MEDLEYDIR (PRINT X T]))(RPAQQ MEDLEY-FIX-DIRS ("sources" "library" "lispusers" "internal/library" "greetfiles"                                   "docs>Documentation Tools" "cltl2" "clos" "makesysout"))(DEFINEQ(CDPRINT  [LAMBDA (CDENTRIES FILE PRINTAUTHOR)                       (* ;                                                            "Edited 13-Oct-2020 08:38 by rmk:")    (* ;; "Typically CDENTRIES will have a header.  If not, we fake one up, at least for the directories and today's date.")    (CL:UNLESS CDENTRIES        (PRINTOUT T T "Note:  Using LASTCDENTRIES" T T)        (SETQ CDENTRIES LASTCDENTRIES))    (RESETLST        (LET (INFO1 TEXT STREAM DATE1POS ENDDATE1 DIR1 DIR2 (HEADER (CAR CDENTRIES))                    NCHARSDIR1)             (CL:UNLESS (STRINGP (CADR HEADER))                 (SETQ HEADER (LIST [for E in CDENTRIES when (fetch INFO1                                                                            of E)                                       do (RETURN (PACKFILENAME 'NAME NIL 'EXTENSION NIL                                                             'VERSION NIL 'BODY                                                             (fetch FULLNAME                                                                of (fetch INFO1 of E]                                    [for E in CDENTRIES when (fetch INFO2                                                                            of E)                                       do (RETURN (PACKFILENAME 'NAME NIL 'EXTENSION NIL                                                             'VERSION NIL 'BODY                                                             (fetch FULLNAME                                                                of (fetch INFO2 of E]                                    NIL                                    (DATE)))                 (push CDENTRIES HEADER))             (SETQ DIR1 (CAR HEADER))             (SETQ NCHARSDIR1 (NCHARS DIR1))             (SETQ DIR2 (CADR HEADER))             (CL:UNLESS (SETQ STREAM (GETSTREAM FILE 'OUTPUT T))                 [RESETSAVE (SETQ STREAM (OPENSTREAM (PACKFILENAME 'EXTENSION 'TXT 'BODY FILE)                                                'OUTPUT                                                'NEW))                        '(PROGN (CLOSEF? OLDVALUE])             (CL:WHEN DIR1                 (PRINTOUT STREAM "Comparing " DIR1 6 "vs. " DIR2 T "as of " (CADDDR HEADER))                 (CL:WHEN (CADDR HEADER)                     (PRINTOUT STREAM " selecting " (CADDR HEADER)))                 (PRINTOUT STREAM -2 (LENGTH (CDR CDENTRIES))                        " entries" T T))             (LINELENGTH 1000 STREAM)                        (* ; "Don't wrap")             (* ;; "DATE1POS is the position of the first character of INFO1's date, used for tabbing.  We have to measure the filename, date, size, and author if desired")             (if (CDR CDENTRIES)                 then (for E INFO1 (MAXDATE1WIDTH _ 0)                                 (SPACEWIDTH _ 1)                                 (PARENWIDTH _ 2) in (CDR CDENTRIES)                             when (SETQ INFO1 (fetch INFO1 of E))                             largest [SETQ MAXDATE1WIDTH (IMAX MAXDATE1WIDTH                                                                   (NCHARS (fetch DATE                                                                              of INFO1]                                   (IPLUS (- (NCHARS (fetch FULLNAME of INFO1))                                             NCHARSDIR1)                                          (NCHARS (fetch LENGTH of INFO1))                                          (CL:IF PRINTAUTHOR                                              (IPLUS SPACEWIDTH PARENWIDTH                                                     (NCHARS (fetch AUTHOR of INFO1)))                                              0)) finally                                                         (* ;;                             "First 4 for width of equiv.  $$EXTREME is NIL if there are no INFO1's")                                                        (SETQ DATE1POS (IPLUS (OR $$EXTREME 10)                                                                              4                                                                              (ITIMES 3 SPACEWIDTH)))                                                        (SETQ ENDDATE1 (IPLUS DATE1POS MAXDATE1WIDTH)                                                         ))                       (for E in (CDR CDENTRIES)                          do (CDPRINT.LINE STREAM E PRINTAUTHOR DATE1POS ENDDATE1 NCHARSDIR1                                        (NCHARS DIR2)))               else (PRINTOUT T "CDENTRIES is empty" T))             (AND STREAM (CLOSEF? STREAM))))])(CDPRINT.LINE  [LAMBDA (STREAM ENTRY PRINTAUTHOR DATE1POS ENDDATE1 NCHARSDIR1 NCHARSDIR2)                                                             (* ;                                                            "Edited 13-Oct-2020 08:51 by rmk:")    (* ;; "Format one line of the directory comparison listing.  If PRINTAUTHOR and AUTHOR1 or AUTHOR2 are non-NIL, list the author in parens; otherwise omit it.")    (LET ((INFO1 (fetch INFO1 of ENTRY))          (INFO2 (fetch INFO2 of ENTRY)))         (PRINTOUT STREAM (SELECTQ (fetch EQUIV of ENTRY)                              (T "==")                              (NIL "  ")                              (PROGN (SELECTQ (fetch EOL of INFO1)                                         (CR 'C)                                         (LF 'L)                                         (CRLF 2)                                         " ")                                     (SELECTQ (fetch EOL of INFO2)                                         (CR 'C)                                         (LF 'L)                                         (CRLF 2)                                         " ")))                " ")         (CL:WHEN INFO1             (PRINTOUT STREAM (SUBSTRING (fetch FULLNAME of INFO1)                                     (ADD1 NCHARSDIR1)                                     NIL                                     (CONSTANT (CONCAT)))                    " ")             (CL:WHEN PRINTAUTHOR                 (PRINTOUT STREAM "(" (fetch AUTHOR of INFO1)                        ") "))             (PRINTOUT STREAM (fetch LENGTH of INFO1)                    .TAB0 DATE1POS (fetch DATE of INFO1)))         (PRINTOUT STREAM .TAB0 ENDDATE1 "  " (fetch DATEREL of ENTRY)                "  ")         (CL:WHEN INFO2             (PRINTOUT STREAM (fetch DATE of INFO2)                    "   "                    (SUBSTRING (fetch FULLNAME of INFO2)                           (ADD1 NCHARSDIR2)                           NIL                           (CONSTANT (CONCAT)))                    " ")             (CL:WHEN PRINTAUTHOR                 (PRINTOUT STREAM "(" (fetch AUTHOR of INFO2)                        ") "))             (PRINTOUT STREAM (fetch LENGTH of INFO2)))         (TERPRI STREAM]))(DEFINEQ(CDMAP  [LAMBDA (CDENTRIES FN)                                     (* ;                                                            "Edited  6-Sep-2020 15:58 by rmk:")    (CL:UNLESS CDENTRIES        (PRINTOUT T T "Note:  Using LASTCDENTRIES" T T)        (SETQ CDENTRIES LASTCDENTRIES))    (for CDE MATCHNAME INFO1 DATEREL INFO2 EQUIV in (CDR CDENTRIES)       declare (SPECVARS MATCHNAME INFO1 DATEREL INFO2 EQUIV)       eachtime (SETQ MATCHNAME (fetch MATCHNAME of CDE))             (SETQ INFO1 (fetch INFO1 of CDE))             (SETQ DATEREL (fetch DATEREL of CDE))             (SETQ INFO2 (fetch INFO2 of CDE))             (SETQ EQUIV (fetch EQUIV of CDE)) do (APPLY* FN CDE])(CDENTRY  [LAMBDA (MATCHNAME CDENTRIES)                          (* ;                                                            "Edited  5-Sep-2020 21:09 by rmk:")    (ASSOC MATCHNAME (OR CDENTRIES LASTCDENTRIES])(CDSUBSET  [LAMBDA (CDENTRIES FN)                                     (* ;                                                            "Edited 15-Sep-2020 13:49 by rmk:")    (CL:UNLESS CDENTRIES        (PRINTOUT T T "Note:  Using LASTCDENTRIES" T T)        (SETQ CDENTRIES LASTCDENTRIES))    (CONS (CAR CDENTRIES)          (for CDE MATCHNAME INFO1 DATEREL INFO2 EQUIV in (CDR CDENTRIES)             declare (SPECVARS MATCHNAME INFO1 DATEREL INFO2 EQUIV)             eachtime (SETQ MATCHNAME (fetch MATCHNAME of CDE))                   (SETQ INFO1 (fetch INFO1 of CDE))                   (SETQ DATEREL (fetch DATEREL of CDE))                   (SETQ INFO2 (fetch INFO2 of CDE))                   (SETQ EQUIV (fetch EQUIV of CDE)) when (APPLY* FN CDE) collect                                                                                      CDE]))(DEFINEQ(BINCOMP  [LAMBDA (FILE1 FILE2 EOLDIFFOK EOL1 EOL2)                  (* ;                                                            "Edited 13-Oct-2020 08:53 by rmk:")    (* ;; "Returns T if FILE1 and FILE2 are byte-equivalent.  Returns EOLDIFF if they are byte equivalent except for CR/LF/CRLF exchanges.  ")    (* ;; "If EOLDIFFOK, return indicates that the files are the same except for EOL mappings.  If EOL1 and EOL2 are not provided, they are computed here.")    (if (IEQP (GETFILEINFO FILE1 'LENGTH)                  (GETFILEINFO FILE2 'LENGTH))        then [CL:WITH-OPEN-FILE                  (STREAM1 FILE1 :DIRECTION :INPUT)                  (CL:WITH-OPEN-FILE                   (STREAM2 FILE2 :DIRECTION :INPUT)                   (SETFILEINFO STREAM1 'ENDOFSTREAMOP (FUNCTION NILL))                   (* ;; "Simpler code to recompute eol's even if provided")                   (bind B1 B2 EOL1 EOL2 EOLDIFF while (SETQ B1 (\BIN STREAM1))                      unless (EQ B1 (SETQ B2 (\BIN STREAM2)))                      do (CL:UNLESS (AND EOLDIFFOK (SELCHARQ B1                                                            (CR (CL:WHEN (EQ EOL1 'LF)                                                                       (RETURN NIL))                                                                (SETQ EOL1 'CR)                                                                (SETQ EOL2 'LF)                                                                (EQ B2 (CHARCODE LF)))                                                            (LF (CL:WHEN (EQ EOL1 'CR)                                                                       (RETURN NIL))                                                                (SETQ EOL1 'LF)                                                                (SETQ EOL2 'CR)                                                                (EQ B2 (CHARCODE CR)))                                                            NIL))                                    (RETURN NIL))                            (CL:UNLESS EOLDIFF                                (SETQ EOLDIFF (LIST EOL1 EOL2))) finally (RETURN (OR EOLDIFF T]      elseif EOLDIFFOK        then               (* ;; "Lengths are different possibly because of CRLF to CR/LF substitutions.")              (* ;;         "More complex code could detect the EOLTYPE incrementally without separate passes, but ...")              (CL:UNLESS EOL1                  (SETQ EOL1 (EOLTYPE FILE1)))              (CL:UNLESS EOL2                  (SETQ EOL2 (EOLTYPE FILE2)))              (CL:WHEN (if [AND (EQ EOL1 'CRLF)                                    (MEMB EOL2 '(LF CR]                         elseif [AND (EQ EOL2 'CRLF)                                         (MEMB EOL1 '(LF CR]                           then (swap FILE1 FILE2))                  (* ;; "FILE1 is now CRLF, FILE2 is not.  If FILE1 isn't longer, it can't have a CRLF that corresponds to a CR or LF.")                  (CL:WHEN (IGREATERP (GETFILEINFO FILE1 'LENGTH)                                  (GETFILEINFO FILE2 'LENGTH))                      [CL:WITH-OPEN-FILE (STREAM1 FILE1 :DIRECTION :INPUT)                             (CL:WITH-OPEN-FILE (STREAM2 FILE2 :DIRECTION :INPUT)                                    (SETFILEINFO STREAM1 'ENDOFSTREAMOP (FUNCTION NILL))                                    (bind B1 B2 EOLDIFF while (SETQ B1 (\BIN STREAM1))                                       unless (EQ B1 (SETQ B2 (\BIN STREAM2)))                                       do (CL:UNLESS [AND (EQ (CHARCODE CR)                                                                  B1)                                                              (EQ (CHARCODE LF)                                                                  (\BIN STREAM1))                                                              (MEMB B2 (CHARCODE (CR LF]                                                     (RETURN NIL))                                             (CL:UNLESS EOLDIFF                                                 (SETQ EOLDIFF (LIST EOL1 EOL2)))                                       finally (RETURN (OR EOLDIFF T]))])(EOLTYPE  [LAMBDA (FILE)                                             (* ;                                                            "Edited  3-Sep-2020 17:05 by rmk:")    (* ;; "Returns the EOLCONVENTION of FILE if it only sees one kind, NIL if it can't decide.")    (CL:WITH-OPEN-FILE (STREAM FILE :DIRECTION :INPUT)           (SETFILEINFO STREAM 'ENDOFSTREAMOP (FUNCTION NILL))           (bind EOLTYPE              do (SELCHARQ (OR (\BIN STREAM)                                   (RETURN EOLTYPE))                          (CR (if (EQ (CHARCODE LF)                                          (\PEEKBIN STREAM T))                                  then (CL:WHEN (MEMB EOLTYPE '(LF CR))                                                  (RETURN NIL))                                        (\BIN STREAM)                                        (SETQ EOLTYPE 'CRLF)                                elseif (MEMB EOLTYPE '(LF CRLF))                                  then (RETURN NIL)                                else (SETQ EOLTYPE 'CR)))                          (LF (CL:WHEN (MEMB EOLTYPE '(CR CRLF))                                     (RETURN NIL))                              (SETQ EOLTYPE 'LF))                          NIL]))(DECLARE%: EVAL@COMPILE(RECORD CDENTRY (MATCHNAME INFO1 DATEREL INFO2 . EQUIV))(RECORD CDINFO (FULLNAME DATE LENGTH AUTHOR TYPE EOL)))(* ;; "look for compiled files older than the sources")(DEFINEQ(FIND-UNCOMPILED-FILES  [LAMBDA (FILES DFASLMARGIN COMPILEEXTS)                    (* ;                                                            "Edited 20-Sep-2020 23:04 by rmk:")                                                             (* ; "Edited  3-Nov-94 15:17 by jds")    (* ;; "Produces a list of the source files in FILES that have no corresponding compiled file")    (* ;; "This determines whether there is at least one compiled file.  If there are two or more, that's a problem")    (* ;; "We want the most recent version only")    (* ;; "Source files have a 2-element created-as with a non-NIL date")    (SETQ FILES (for F in (OR (LISTP FILES)                                      (FILDIR FILES)) unless (MEMB (SETQ F (PACKFILENAME                                                                                'VERSION NIL                                                                                'BODY F))                                                                       $$VAL) collect F))    (for F SCREATION FILES in FILES when (AND (CADR (SETQ SCREATION (CREATED-AS                                                                                 F)))                                                          (NOT (CDDR SCREATION)))       when [SETQ FILES                 (for CEXT CF in (OR COMPILEEXTS *COMPILED-EXTENSIONS*)                    when (SETQ CF (INFILEP (PACKFILENAME 'EXTENSION CEXT 'VERSION NIL                                                      'BODY F)))                    collect (CL:WHEN (SOURCE-FOR-COMPILED-P SCREATION CF DFASLMARGIN)                                       (RETURN NIL))                          CF                    finally                           (* ;; "If we found some compiled files, they weren't on this source.  If there weren't any compiled files to check, maybe there weren't any functions.")                          (* ;;       "NLSETQ because we don't want to stop if there is an error, typically from a package problem")                          (RETURN (OR $$VAL (LET [(FCOMS (CAR (NLSETQ (GETDEF (FILECOMS F)                                                                             'VARS F]                                                 (if (NULL FCOMS)                                                     then                                                            (* ;;                                                "GETDEF caused an error.  Maybe a package problem. ")                                                           (AND NIL 'NOCOMMANDS)                                                   elseif (INFILECOMS? NIL '(FUNCTIONS FNS)                                                                     FCOMS)                                                     then T]       collect (CONS F (SELECTQ FILES                               (T NIL)                               (NOCOMMANDS (CONS "No commands"))                               (for CF in FILES collect                                                         (* ;;            "Positive means that compiled is later than source, normal order but maybe by too much.")                                                              (* ;;                                             "Negative means that compiled came before source.  Odd")                                                              (LIST CF (COMPILE-SOURCE-DATE-DIFF                                                                        CF SCREATION])(FIND-UNSOURCED-FILES  [LAMBDA (FILES DFASLMARGIN COMPILEEXTS)                    (* ;                                                            "Edited 15-Sep-2020 15:32 by rmk:")                                                             (* ; "Edited  3-Nov-94 15:17 by jds")    (* ;;   "Produces a list of compiled FILES for which no source file can be found in the same directory.")    (* ;; "The source date in at least one DFASL was off by a second, maybe some sort of IDATE rounding?  So, give a margin.")    (* ;; "We want the most recent version only.  Check CREATED-AS to make sure it really is a compiled file.")    (* ;; "Sort to get lcoms and dfasls next to each other.")    (LET (CCREATEDS)         (SETQ CCREATEDS (for CEXT FOUND CCREATED inside (OR COMPILEEXTS                                                                      *COMPILED-EXTENSIONS*)                            join (for CF in [OR (LISTP FILES)                                                            (FILDIR (PACKFILENAME 'EXTENSION CEXT                                                                           'VERSION "" 'BODY                                                                           '*]                                        when (CDDR (SETQ CCREATED (CREATED-AS CF)))                                        unless (MEMBER CCREATED $$VAL) collect CCREATED)))         (* ;; "CCREATEDS is now a list of CREATED-AS items")         (for CC SF in CCREATEDS unless (AND [SETQ SF (INFILEP (PACKFILENAME 'EXTENSION                                                                                   NIL 'VERSION NIL                                                                                  'BODY                                                                                  (CAR CC]                                                         (SOURCE-FOR-COMPILED-P (SETQ SF                                                                                     (CREATED-AS                                                                                      SF))                                                                CC DFASLMARGIN))            collect [LIST (CAR CC)                              (AND SF (LIST (CAR SF)                                            (ROUND (COMPILE-SOURCE-DATE-DIFF CC SF]            finally (RETURN (SORT $$VAL (FUNCTION (LAMBDA (CF1 CF2)                                                        (ALPHORDER (FILENAMEFIELD (CAR CF1)                                                                          'NAME)                                                               (FILENAMEFIELD (CAR CF2)                                                                      'NAME])(FIND-SOURCE-FILES  [LAMBDA (CFILES SDIRS DFASLMARGIN)                         (* ;                                                            "Edited  9-Sep-2020 12:26 by rmk:")    (* ;; "Returns (CFILE . SFILES) pairs where CFILE is a Lisp compiled file in CFILES SFILES is a list of source files in SDIRS that CFILE was compiled on.")    (* ;; "This suggests that one of CFILES should be copied to the SFILE directory.")    (SETQ SDIRS (for SD inside (OR SDIRS T) collect (DIRECTORYNAME SD)))    (SORT (for CF SFILES CNAME CCREATED in (OR (LISTP CFILES)                                                       (FILDIR CFILES))             when (AND (SETQ CNAME (INFILEP CF))                           (CDDR (SETQ CCREATED (CREATED-AS CF)))                           (SETQ SFILES (for SD SF in SDIRS                                           when (AND (SETQ SF (INFILEP (PACKFILENAME                                                                            'NAME                                                                            (FILENAMEFIELD                                                                             CF                                                                             'NAME)                                                                            'BODY SD)))                                                         (SOURCE-FOR-COMPILED-P SF CCREATED                                                                 DFASLMARGIN)) collect SF)))             collect (CONS CNAME SFILES))          (FUNCTION (LAMBDA (P1 P2)                      (ALPHORDER (FILENAMEFIELD (CAR P1))                             (FILENAMEFIELD (CAR P2])(FIND-COMPILED-FILES  [LAMBDA (SFILES CDIRS DFASLMARGIN)                         (* ;                                                            "Edited  9-Sep-2020 12:26 by rmk:")    (* ;; "Returns (SFILE . CFILES) pairs where SFILE is a Lisp source file in SFILES CFILES is a list of compiled files in CDIRS that were compiled on SFILE.")    (* ;; "FILEDATE is true for source files and compiled files")    (* ;; "This suggests that one of CFILES should be copied to the SFILE directory.")    (SETQ CDIRS (for CD inside (OR CDIRS T) collect (DIRECTORYNAME CD)))    (SORT (for SF CFILES SNAME SCREATED in (OR (LISTP SFILES)                                                       (FILDIR SFILES))             when [AND (SETQ SNAME (INFILEP SF))                           (SETQ SCREATED (CREATED-AS SF))                           (NOT (CDDR SCREATED))                           (SETQ CFILES (for CEXT (ROOT _ (FILENAMEFIELD SNAME 'NAME))                                           in *COMPILED-EXTENSIONS*                                           join (for CD CF in CDIRS                                                       when (AND (SETQ CF                                                                      (INFILEP (PACKFILENAME                                                                                'NAME ROOT                                                                                'EXTENSION CEXT                                                                                'BODY CD)))                                                                     (SOURCE-FOR-COMPILED-P                                                                      SCREATED CF DFASLMARGIN))                                                       collect CF] collect (CONS SNAME CFILES                                                                                         ))          (FUNCTION (LAMBDA (P1 P2)                      (ALPHORDER (FILENAMEFIELD (CAR P1))                             (FILENAMEFIELD (CAR P2])(FIND-UNLOADED-FILES  [LAMBDA (FILES)                                            (* ;                                                            "Edited  9-Sep-2020 19:35 by rmk:")    (* ;; "Returns the files in FILES that don't have FILECREATED properties and presumably are therefore not loaded in the current sysout.")    (for F in (OR (LISTP FILES)                          (FILDIR FILES)) when (AND (SETQ F (INFILEP (CL:IF (LISTP F)                                                                             (CAR F)                                                                             F)))                                                        (FILEDATE F))       unless (GETP (FILENAMEFIELD F 'NAME)                        'FILEDATES) collect F])(FIND-LOADED-FILES  [LAMBDA (ROOTFILENAMES)                                    (* ;                                                            "Edited 19-Sep-2020 07:20 by rmk:")    (for RN inside ROOTFILENAMES when (GETP RN 'FILEDATES)       collect (CONS RN (for F in LOADEDFILELST when (EQ RN (FILENAMEFIELD                                                                             F                                                                             'NAME)) collect                                                                                     F])(FIND-MULTICOMPILED-FILES  [LAMBDA (FILES SHOWINFO)                                   (* ;                                                            "Edited 20-Sep-2020 20:57 by rmk:")    (* ;; "Returns a list of names for files in FILES that have multiple compilations")    (LET (SFILES)         (for F EXT NAME in (OR (LISTP FILES)                                        (FILDIR FILES)) when (MEMB (SETQ EXT (FILENAMEFIELD                                                                                  F                                                                                  'EXTENSION))                                                                       *COMPILED-EXTENSIONS*)            do (SETQ NAME (FILENAMEFIELD F 'NAME))                   (* ;; "PUSHNEW because we haven't filtered out versions")                  (pushnew [CDR (OR (ASSOC NAME SFILES)                                        (CAR (push SFILES (CONS NAME]                         EXT))         (for S in SFILES when (CDDR S)            collect (if SHOWINFO                            then `[,(CAR S)                                       ,(CADAR (FIND-LOADED-FILES (CAR S)))                                       ,(CREATED-AS (CAR S))                                       ,@(for EXT in (SORT (CDR S))                                            collect (CREATED-AS (PACKFILENAME 'EXTENSION EXT                                                                               'BODY                                                                               (CAR S]                          else (CAR S]))(DEFINEQ(CREATED-AS  [LAMBDA (FILE)                                             (* ;                                                            "Edited 20-Sep-2020 23:06 by rmk:")    (* ;; "For lisp source files, returns (filecreatename filecreateddate)")    (* ;; "For lisp compiled files, returns (cfilename cfiledate sfilecreatename sfilecreateddate)")    (* ;; "For other files, (fullfilename NIL)")    (* ;; "The cfilename is just the current directory name for DFASLs.")    (* ;; "So:  (CADR value) is non-NIL for Lisp files.  Of those, (CDDR value) is non-NIL for compiled files.")    (* ;; "We disable the package delimiter because the atoms in changes may have a packages that we don't know.")    (CL:WITH-OPEN-FILE     (STREAM FILE :DIRECTION :INPUT)     (LET      (FILEDATE FILENAME SOURCEDATE SOURCENAME LINE POS)      [if (EQ (CHARCODE %()                  (SKIPSEPRCODES STREAM))          then                                           (* ; "Managed source or LCOM")          (RESETLST              [LET (FORM SFORM (RDTBL (FIND-READTABLE "OLD-INTERLISP-FILE")))                   (SETQ POS (GETFILEPTR STREAM))                   (READCCODE STREAM)                   (if (EQ 'DEFINE-FILE-INFO (RATOM STREAM RDTBL))                       then                              (* ;; "Reading is package-safe")                             (SETFILEPTR STREAM POS)                             (SETQ FORM (READ STREAM RDTBL))                             (SETQ RDTBL (FIND-READTABLE (LISTGET (CDR FORM)                                                                :READTABLE)))                     else (SETFILEPTR STREAM POS))                   (CL:WHEN (EQ 'PACKAGEDELIM (GETSYNTAX '%: RDTBL))                       [RESETSAVE (SETSYNTAX '%: 'OTHER RDTBL)                              `(SETSYNTAX %: PACKAGEDELIM ,RDTBL])                   (* ;; "One way or the other, we're ready for the filecreated")                   (CL:WHEN (EQ (CHARCODE %()                                (SKIPSEPRCODES STREAM))                       (SETQ FORM (READ STREAM RDTBL))                       (CL:WHEN (MEMB (U-CASE (CAR FORM))                                      '(FILECREATED IL%:FILECREATED))                           (* ;; "IL%%:FILECREATED because we screwed the readtable.")                           (if [STREQUAL "compiled on " (CAR (LISTP (CADDR FORM]                               then                      (* ; "LCOM, get source info")                                     (if [AND (EQ (CHARCODE %()                                                      (SKIPSEPRCODES STREAM))                                                  (MEMB [U-CASE (CAR (SETQ SFORM (READ STREAM RDTBL]                                                        '(FILECREATED IL%:FILECREATED]                                         then (SETQ FILENAME (FULLNAME STREAM))                                               (SETQ FILEDATE (CADR FORM))                                               (SETQ SOURCENAME (CADDR SFORM))                                               (SETQ SOURCEDATE (CADR SFORM))                                       else (SETQ FILENAME (FULLNAME STREAM))                                             (SETQ FILEDATE (CADR FORM)))                             else (SETQ FILENAME (CADDR FORM))                                   (SETQ FILEDATE (CADR FORM)))))])        elseif (SETQ POS (STRPOS "XCL Compiler output for source file " (SETQ LINE (CL:READ-LINE                                                                                        STREAM))                                    1 NIL NIL T))          then                                           (* ; "DFASL compiled?")                (SETQ SOURCENAME (SUBATOM LINE POS))                (CL:WHEN (SETQ POS (STRPOS "Source file created " (SETQ LINE (CL:READ-LINE STREAM))                                          1 NIL NIL T))                    [SETQ SOURCEDATE (GDATE (IDATE (SUBSTRING LINE POS]                    (CL:WHEN (SETQ POS (STRPOS "FASL file created " (SETQ LINE (CL:READ-LINE STREAM))                                              1 NIL NIL T))                        [SETQ FILEDATE (GDATE (IDATE (SUBSTRING LINE POS]))]      (* ;; "Revert filenames to Interlisp package if needed:")      (CL:WHEN (STRPOS "IL:" FILENAME)          (SETQ FILENAME (SUBATOM FILENAME 4)))      (CL:WHEN (STRPOS "IL:" SOURCENAME)          (SETQ SOURCENAME (MKATOM SOURCENAME 4)))      (* ;; "Return DATE NIL if file is not a Lisp file")      `(,(OR FILENAME (FULLNAME STREAM))        ,(AND FILEDATE (GDATE (IDATE FILEDATE)))        ,@(CL:WHEN SOURCENAME              (LIST SOURCENAME (GDATE (IDATE SOURCEDATE))))])(SOURCE-FOR-COMPILED-P  [LAMBDA (SOURCE COMPILED DFASLMARGIN)                      (* ;                                                            "Edited 31-Oct-2020 09:12 by rmk:")    (* ;; "There seems to be some variation between the source dates in dfasl files and the filecreated date in the sources, they often don't match exactly.  But if they are within DFASLMARGIN, we assume a match.  We require exact date match for LCOMS")    (* ;; "This is needed for dfasl files created before they recorded the source filecreated name and date instead of the directory source name and date when compile took place.")    (* ;; "")    (* ;; "DFASLMARGIN is a pair (after before) where we assume a match if the compiled date is no more than after minutes after the source date and no more than before minuts before (the diff is negative then).")    (* ;; "A single positive integer x is interpreted as (x 0).  A single negative integer x is interpreted as (-x x) (before or after x).")    (* ;; "Default is (20 0).")    (* ;; "T is positive or negative infinity")    (CL:UNLESS (LISTP SOURCE)        (SETQ SOURCE (CREATED-AS SOURCE)))    (CL:UNLESS (LISTP COMPILED)        (SETQ COMPILED (CREATED-AS COMPILED)))    (SETQ DFASLMARGIN (if (NULL DFASLMARGIN)                          then                                 (* ;;                        "If compiled is later than source by less than 20 minutes, it's probably OK")                                '(20 0)                        elseif (EQ T DFASLMARGIN)                          then '(T 0)                        elseif (LISTP DFASLMARGIN)                        elseif (NOT (FIXP DFASLMARGIN))                          then (ERROR "ILLEGAL DFASLMARGIN" DFASLMARGIN)                        elseif (MINUSP DFASLMARGIN)                          then (LIST (MINUS DFASLMARGIN)                                         DFASLMARGIN)                        else (LIST DFASLMARGIN 0)))    (OR (EQUAL (CAR SOURCE)               (CADDR COMPILED))        (EQUAL (CADR SOURCE)               (CADDDR COMPILED))        (AND [EQ 'DFASL (U-CASE (FILENAMEFIELD (CAR COMPILED)                                       'EXTENSION]             (LET ((TIMEDIFF (COMPILE-SOURCE-DATE-DIFF COMPILED SOURCE)))                  (* ;; "If compiled was no more than 20 minutes later, it's probably OK.  Of no more than DFASLMARGIN earlier, if it is negative.")                  (AND (OR (EQ T (CAR DFASLMARGIN))                           (LEQ TIMEDIFF (CAR DFASLMARGIN)))                       (OR (EQ T (CADR DFASLMARGIN))                           (GEQ TIMEDIFF (CADR DFASLMARGIN])(COMPILE-SOURCE-DATE-DIFF  [LAMBDA (CFILE SFILE)                                      (* ;                                                            "Edited 20-Sep-2020 22:59 by rmk:")    (* ;; "Positive means that compiled is later than source, normal order but maybe by too much. Negative means that compiled came before source, i.e., compiled on a source that didn't yet exist.")    (* ;; "Value is in minutes")    (ROUND (FQUOTIENT [IDIFFERENCE [IDATE (CADDDR (OR (LISTP CFILE)                                                      (CREATED-AS CFILE]                             (IDATE (CADR (OR (LISTP SFILE)                                              (CREATED-AS SFILE]                  (TIMES 60 ONESECOND]))(DEFINEQ(FIX-DIRECTORY-DATES  [LAMBDA (FILES MARGIN)                                     (* ;                                                            "Edited 30-Oct-2020 22:01 by rmk:")    (* ;; "For Lisp source and compiled files, ensures that the directory file date corresponds to the  filecreated date. Returns the list of files whose dates were changed.")    (* ;; "This allows for the fact that directory dates that  are no later than, say, 30 seconds of the filecreated date are probably OK--the directory date may be set when the file is closed.")    (* ;; "Use IDATEs in case FDCDATE is not Y2K.")    (* ;; "Stop if directory date is more than 2 minutes earlier than the filecreated date.  Earlier could be because the dates are asserted at different points in the filing process.  But 2 minutes is worth thinking about.  Returning from HELP will get them aligned.")    (SETQ MARGIN (ITIMES (OR MARGIN 2)                        60 ONESECOND))    (for F DIDATE FCDATE in (OR (LISTP FILES)                                        (FILDIR FILES)) when (SETQ FCDATE (FILEDATE F))       unless (IEQP (SETQ DIDATE (GETFILEINFO F 'ICREATIONDATE))                        (SETQ FCDATE (IDATE FCDATE))) collect (CL:WHEN (IGREATERP (IDIFFERENCE                                                                                       FCDATE DIDATE)                                                                                  MARGIN)                                                                      (HELP                                                        "DIRECTORY DATE EARLIER THAN FILECREATED DATE"                                                                            (LIST F (GDATE DIDATE)                                                                                  (GDATE FCDATE))))                                                            (SETFILEINFO F 'ICREATIONDATE FCDATE)                                                            F])(FIX-EQUIV-DATES  [LAMBDA (CDENTRIES)                                        (* ;                                                            "Edited  1-Sep-2020 16:21 by rmk:")    (* ;; "For every entry whose files are EQUIVALENT and whose filedates are different, sets the directory of the file with the later date to be the date of the one with the earlier date.  This preumes that the later one must have been a copy. ")    (CL:UNLESS CDENTRIES        (PRINTOUT T "Note:  Using LASTCDENTRIES" T)        (SETQ CDENTRIES LASTCDENTRIES))    (for CDE EARLY LATE in (CDR CDENTRIES) when (fetch EQUIV of CDE)       unless (EQ '= (fetch DATEREL of CDE))       collect (SELECTQ (fetch DATEREL of CDE)                       (> (SETQ EARLY (fetch INFO2 of CDE))                          (SETQ LATE (fetch INFO1 of CDE)))                       (< (SETQ EARLY (fetch INFO1 of CDE))                          (SETQ LATE (fetch INFO2 of CDE)))                       (SHOULDNT))             (SETFILEINFO (fetch FULLNAME of LATE)                    'ICREATIONDATE                    (GETFILEINFO (fetch FULLNAME of EARLY)                           'ICREATIONDATE))             (fetch FULLNAME of LATE])(COPY-COMPARED-FILES  [LAMBDA (CDENTRIES TARGET MATCHNAMES)                      (* ;                                                            "Edited  1-Sep-2020 16:20 by rmk:")    (* ;; "Copies source files to target files whose matchname belongs to MATCHNAMES, if given.")    (* ;; "TARGET is 1 or 2, indicating which side of the CD entry is the target.  Value is the list of matchnames whose files have been copied.")    (* ;; "Directory filedates and other properties are preserved.")    (CL:UNLESS (MEMB TARGET '(1 2))           (ERROR "INVALID TARGET" TARGET))    (CL:UNLESS CDENTRIES        (PRINTOUT T "Note:  Using LASTCDENTRIES" T)        (SETQ CDENTRIES LASTCDENTRIES))    (SETQ MATCHNAMES (MKLIST MATCHNAMES))    (for CDE SINFO TINFO MATCHNAME in (CDR CDENTRIES) eachtime (SETQ SINFO                                                                            (fetch INFO1                                                                               of CDE))                                                                    (SETQ TINFO (fetch INFO2                                                                                   of CDE))                                                                    (CL:WHEN (EQ TARGET 1)                                                                           (swap SINFO TINFO))                                                                    (SETQ MATCHNAME                                                                     (fetch MATCHNAME                                                                        of CDE))       when (AND (fetch FULLNAME of SINFO)                     (fetch FULLNAME of TINFO)) unless (AND MATCHNAMES                                                                        (NOT (MEMB MATCHNAME                                                                                    MATCHNAMES)))       collect (COPYFILE (fetch FULLNAME of SINFO)                          (PACKFILENAME 'VERSION NIL 'BODY (fetch FULLNAME of TINFO)))             MATCHNAME])(COPY-MISSING-FILES  [LAMBDA (CDENTRIES TARGET MATCHNAMES)                      (* ;                                                            "Edited  1-Sep-2020 16:21 by rmk:")    (* ;; "Copies source files to target files whose matchname belongs to MATCHNAMES, if given.")    (* ;; "TARGET is 1 or 2, indicating which side of the CD entry is the target.  Value is the list of matchnames whose files have been copied.")    (* ;; "Directory filedates and other properties are preserved.")    (CL:UNLESS (MEMB TARGET '(1 2))           (ERROR "INVALID TARGET" TARGET))    (CL:UNLESS CDENTRIES        (PRINTOUT T "Note:  Using LASTCDENTRIES" T)        (SETQ CDENTRIES LASTCDENTRIES))    (CL:UNLESS (STRINGP (CADR (CAR CDENTRIES)))        (ERROR "(CAR CDENTRIES) IS NOT A VALID PARAMETER LIST" (CAR CDENTRIES)))    (SETQ MATCHNAMES (MKLIST MATCHNAMES))    (for CDE SINFO TINFO TDIR MATCHNAME (TDIR _ (CL:IF (EQ TARGET 1)                                                        (CAAR CDENTRIES)                                                        (CADAR CDENTRIES))) in (CDR CDENTRIES)       eachtime (SETQ MATCHNAME (fetch MATCHNAME of CDE))             (SETQ SINFO (fetch INFO1 of CDE))             (SETQ TINFO (fetch INFO2 of CDE))             (CL:WHEN (EQ TARGET 1)                    (swap SINFO TINFO)) when (AND (fetch FULLNAME of SINFO)                                                          (NOT (fetch FULLNAME of TINFO)))       unless (AND MATCHNAMES (NOT (MEMB MATCHNAME MATCHNAMES)))       collect              (* ;; "Using the source fullname in the target should preserve the version number")             (COPYFILE (fetch FULLNAME of SINFO)                    (PACKFILENAME 'BODY TDIR 'BODY (fetch FULLNAME of SINFO)))             MATCHNAME])(COMPILED-ON-SAME-SOURCE  [LAMBDA (CDENTRIES)                                        (* ;                                                            "Edited  9-Sep-2020 13:00 by rmk:")    (* ;; "Returms a subset of CDENTRIES consisting of files that are compiled on the same source (i.e. their source names or dates are the same). Preserves the header.")    (CDSUBSET CDENTRIES (FUNCTION (LAMBDA (CDE)                                        (DECLARE (USEDFREE INFO1 INFO2))                                        (LET (CREATED1 CREATED2)                                             (CL:WHEN [AND (EQ 'COMPILED (fetch TYPE of                                                                                         INFO1))                                                           (EQ 'COMPILED (fetch TYPE of                                                                                         INFO2))                                                           [CDDR (SETQ CREATED1                                                                  (CREATED-AS (fetch FULLNAME                                                                                     of INFO1]                                                           (CDDR (SETQ CREATED2                                                                  (CREATED-AS (fetch FULLNAME                                                                                     of INFO2]                                                 (OR (EQUAL (CADDR CREATED1)                                                            (CADDR CREATED2))                                                     (EQUAL (CADDDR CREATED1)                                                            (CADDDR CREATED2))))]))(RPAQ ONESECOND (IDIFFERENCE (IDATE "1-Jan-2020 12:00:01")                           (IDATE "1-Jan-2020 12:00:00")))(RPAQ? LASTCDENTRIES NIL)(DEFINEQ(COMPARE-ENTRY-SOURCE-FILES  [LAMBDA (CDENTRY LISTSTREAM EXAMINE DW?)               (* ;                                                            "Edited 30-Aug-2020 12:22 by rmk:")    (* ;; "Wrapper to call COMPARESOURCES on the Lisp source files of CDENTRY")    (CL:WHEN [AND (EQ 'SOURCE (fetch TYPE of (fetch INFO1 of CDENTRY)))                  (EQ 'SOURCE (fetch TYPE of (fetch INFO2 of CDENTRY]        (COMPARESOURCES (fetch FULLNAME of (fetch INFO1 of CDENTRY))               (fetch FULLNAME of (fetch INFO2 of CDENTRY))               EXAMINE DW? LISTSTREAM))]))(FILESLOAD COMPARESOURCES)(PUTPROPS COMPAREDIRECTORIES COPYRIGHT ("Venue & Xerox Corporation" 1985 1986 1987 1988 1990 1994 1998 2018 2020 2021))(DECLARE%: DONTCOPY  (FILEMAP (NIL (2361 17867 (COMPAREDIRECTORIES 2371 . 10922) (CDFILES 10924 . 15560) (COMPAREDIRECTORIES.INFOS 15562 . 17142) (MATCHNAME 17144 . 17642) (MEDLEY-FIX-DIRS 17644 . 17865)) (18053 25364 (CDPRINT 18063 . 22928) (CDPRINT.LINE 22930 . 25362)) (25365 27312 (CDMAP 25375 . 26136) (CDENTRY 26138 . 26371) (CDSUBSET 26373 . 27310)) (27313 32974 (BINCOMP 27323 . 31677) (EOLTYPE 31679 . 32972)) (33187 46849 (FIND-UNCOMPILED-FILES 33197 . 36905) (FIND-UNSOURCED-FILES 36907 . 39781) (FIND-SOURCE-FILES 39783 . 41552) (FIND-COMPILED-FILES 41554 . 43697) (FIND-UNLOADED-FILES 43699 . 44508) (FIND-LOADED-FILES 44510 . 45129) (FIND-MULTICOMPILED-FILES 45131 . 46847)) (46850 55247 (CREATED-AS 46860 . 51722) (SOURCE-FOR-COMPILED-P 51724 . 54487) (COMPILE-SOURCE-DATE-DIFF 54489 . 55245)) (55248 64552 (FIX-DIRECTORY-DATES 55258 . 57291) (FIX-EQUIV-DATES 57293 . 58618) (COPY-COMPARED-FILES 58620 . 60809) (COPY-MISSING-FILES 60811 . 62715) (COMPILED-ON-SAME-SOURCE 62717 . 64550)) (64707 65383 (COMPARE-ENTRY-SOURCE-FILES 64717 . 65381)))))STOP