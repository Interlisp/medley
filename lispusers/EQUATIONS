(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE "INTERLISP")
(FILECREATED " 3-Mar-88 13:51:10" {ERINYES}<LISPUSERS>LYRIC>EQUATIONS.;1 86057  

      changes to%:  (FNS EQIO.Put EQIO.Get)

      previous date%: "27-May-87 11:20:49" |{IE:PARC:XEROX}<LISP>LYRIC>LISPUSERS>EQUATIONS.;1|)


(* "
Copyright (c) 1986, 1987, 1988 by Xerox Corporation.  All rights reserved.
")

(PRETTYCOMPRINT EQUATIONSCOMS)

(RPAQQ EQUATIONSCOMS 
       (

(* ;;; "EQUATION module: Part 1 of 3")

                                                             (* ; "functions for image object")

        (FNS EQIO.CreateFns EQIO.Create EQIO.Imagebox EQIO.Display EQIO.ButtonEventIn EQIO.Copy 
             EQIO.CopyList EQIO.Get EQIO.Put EQIO.WhenDeleted EQIO.SelectRegion EQIO.Selection 
             EQIO.DefaultSelectFn EQIO.MakeSelectionMenu)
        

(* ;;; "functions to handle individual equation props and data")

        (FNS EQIO.EqnType EQIO.EqnDataList EQIO.SetDataList EQIO.EqnData EQIO.EqnProperty 
             EQIO.AllProps EQIO.Specify EQIO.GetInitialProps EQIO.NumPieces EQIO.NewStructure)
        

(* ;;; "functions to handle equation specification info")

        (FNS EQIO.AddType EQIO.GetInfo EQIO.SetInfo EQIO.TypeProp EQIO.ResetTypeProps EQIO.IsDefined 
             EQIO.GetBox EQIO.GetDataSpec EQIO.GetDataSpecList EQIO.GetDataPosition 
             EQIO.GetDataSelectRegion EQIO.MakeSpec EQIO.MakeDataSpec)
        

(* ;;; "variable specification")

        (GLOBALVARS EquationInfo EquationTypeMenu EquationImageFns UnknownEquationData 
               EquationDefaultSelectFn)
        (VARS (EquationImageFns NIL))
        (INITVARS EquationInfo (EquationDefaultSelectFn 'EQIO.DefaultSelectFn))
        [P (TEDIT.ADD.MENUITEM TEDIT.DEFAULT.MENU '(Equation 'EQN.Equation]
        (P                                                   (* ; 
                             "needed to force the getfn to be recognized before any new eqns defined")

           (SETQ EquationImageFns (EQIO.CreateFns)))
        (VARS UnknownEquationData)
        (PROP ARGNAMES EQIO.TypeProp EQIO.NumPieces EQIO.AllProps EQIO.EqnProperty)
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
               (ADDVARS (NLAMA)
                      (NLAML)
                      (LAMA EQN.ObjEditWindow EQN.ContinueFlg EQN.PieceNumber EQN.ResultObj 
                            EQN.ResultWindow EQN.EditWindow EQIO.TypeProp EQIO.NumPieces 
                            EQIO.AllProps EQIO.EqnProperty)))
        

(* ;;; "EQUATIONEDIT module: Part 2 of 3")

                                                             (* ; "functions to edit data pieces")

        (FNS EQN.AbortEdit EQN.StopEdit EQN.ContinueEdit EQN.FinishEdit EQN.MakeEditWindow 
             EQN.SetUpEdit EQN.StartEdit EQN.StartNextEdit EQN.UpdateEdit EQN.DefaultData 
             EQN.TypeMenu)
        

(* ;;; "hooks to control behavior of equation subeditor")

        (FNS EQN.Equation EQN.NextPiece EQN.FinishEqn EQN.NoUpdateAbort EQN.PreventUpdate EQN.CharFn 
             EQN.TEditSpecialChar EQN.SnuggleWindows EQN.SnuggleMainWindow)
        

(* ;;; "functions to handle equation fonts")

        (FNS EQN.EquationFontNumber EQN.EquationFont EQN.GetEqnFont EQN.MakeFS)
        

(* ;;; "utilities")

        (FNS EQN.AdjustWindow EQN.CheckWindowSize)
        (FNS EQN.SubEditorP EQN.WindowFromText EQN.EditWindow EQN.ResultWindow EQN.ResultObj 
             EQN.PieceNumber EQN.ContinueFlg EQN.ValidEditWindow EQN.ObjEditWindow)
        (FNS EQN.Make)
        (GLOBALVARS EquationFontSpecs)
        (VARS EquationFontSpecs)
        (PROP ARGNAMES EQN.ObjEditWindow EQN.ContinueFlg EQN.PieceNumber EQN.ResultObj 
              EQN.ResultWindow EQN.EditWindow)
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS
               (ADDVARS (NLAMA)
                      (NLAML)
                      (LAMA EQN.ObjEditWindow EQN.ContinueFlg EQN.PieceNumber EQN.ResultObj 
                            EQN.ResultWindow EQN.EditWindow)))
        

(* ;;; "FORMATSTRING module: Part 3 of 3")

        (FNS FS.Box FS.Copy FS.Display FS.Get FS.Put FS.ItemFont FS.ItemValue FS.ItemShift 
             FS.MakeItem FS.Extract FS.ExtractFont FS.ExtractShift FS.Insert FS.AllowedChar 
             FS.RealStringP)
        

(* ;;; "Now load EQUATIONFORMS")

        (FILES EQUATIONFORMS)))



(* ;;; "EQUATION module: Part 1 of 3")




(* ; "functions for image object")

(DEFINEQ

(EQIO.CreateFns
  [LAMBDA NIL                                                (* thh%: " 5-Dec-85 10:50")
    (IMAGEFNSCREATE (FUNCTION EQIO.Display)
           (FUNCTION EQIO.Imagebox)
           (FUNCTION EQIO.Put)
           (FUNCTION EQIO.Get)
           (FUNCTION EQIO.Copy)
           (FUNCTION EQIO.ButtonEventIn)
           (FUNCTION NILL)
           (FUNCTION NILL)
           (FUNCTION NILL)
           (FUNCTION EQIO.WhenDeleted)
           (FUNCTION NILL)
           (FUNCTION NILL)
           (FUNCTION NILL])

(EQIO.Create
  [LAMBDA (kind dataList fontSpec objectProps)               (* thh%: " 5-Dec-85 10:50")
          
          (* makes an equation image object of specified kind and data)
          
          (* fontSpec, if non-NIL, is used as fontSpec prop of eqn)
          
          (* objectProps specifies properties for this object --
          if NIL then default props for this kind will be used)

    (PROG [(obj (IMAGEOBJCREATE (CONS kind dataList)
                       (COND
                          ((AND (BOUNDP 'EquationImageFns)
                                (IMAGEFNSP EquationImageFns))
                           EquationImageFns)
                          (T (SETQ EquationImageFns (EQIO.CreateFns]
          [COND
             ((NOT objectProps)
              (SETQ objectProps (COPYALL (EQIO.GetInfo kind 'objProps]
          (EQIO.AllProps obj objectProps)
          [COND
             (fontSpec (EQIO.EqnProperty obj 'fontSpec (COND
                                                          ((NUMBERP fontSpec)
                                                           (EQN.GetEqnFont fontSpec))
                                                          (T fontSpec]
          (RETURN obj])

(EQIO.Imagebox
  [LAMBDA (eqnObj imageStream)                               (* THH "21-May-85 12:13")
                                                             (* determines size of equation)
    (PROG ((spec (EQIO.Specify eqnObj imageStream)))
          (RETURN (COND
                     (spec (EQIO.GetBox spec))
                     (T (FS.Box UnknownEquationData imageStream])

(EQIO.Display
  [LAMBDA (eqnObj imageStream)                               (* thh%: "31-May-85 09:30")
                                                             (* displays equation)
    (PROG [(curX (DSPXPOSITION NIL imageStream))
           (curY (DSPYPOSITION NIL imageStream))
           (spec (EQIO.Specify eqnObj imageStream T))
           (invertPiece (PROG ((editWindow (EQN.ObjEditWindow eqnObj)))
                              (RETURN (COND
                                         (editWindow (EQN.PieceNumber editWindow))
                                         (T NIL]
          (COND
             [spec (for i from 1 to (EQIO.NumPieces eqnObj) bind data pos (desc _ (fetch YDESC
                                                                                     of (EQIO.GetBox
                                                                                         spec)))
                      do (SETQ data (EQIO.EqnData eqnObj i))
                         (SETQ pos (EQIO.GetDataPosition (EQIO.GetDataSpec spec i)))
                         (COND
                            ((AND pos data)
                             (MOVETO (PLUS curX (fetch XCOORD of pos))
                                    (PLUS curY (fetch YCOORD of pos)
                                          (MINUS desc))
                                    imageStream)
                             (FS.Display data imageStream (EQ invertPiece i]
             (T (FS.Display UnknownEquationData imageStream invertPiece])

(EQIO.ButtonEventIn
  [LAMBDA (eqnObj windowStream selection relX relY window textStream button)
                                                             (* thh%: "19-Mar-86 09:23")
                                                             (* handles button press in equation)
    (PROG ((editWindow (EQN.EditWindow window))
           [CHOICEMENU (CONSTANT (create MENU
                                        CENTERFLG _ T
                                        ITEMS _ '((Select 'SELECT "Select the image object")
                                                  (Edit 'EDIT "Edit selected piece of the equation"]
           underEdit)
          [SETQ underEdit (AND editWindow (EQ eqnObj (EQN.ResultObj editWindow]
                                                             (* non-NIL if eqnObj is currently 
                                                             being edited)
          (RETURN (COND
                     ((OR (KEYDOWNP 'RSHIFT)
                          (KEYDOWNP 'LSHIFT)
                          (KEYDOWNP 'CTRL))
          
          (* note%: using COPYBUTTONEVENTIN fn instead of this test doesnt work since it 
          is never called)

                      (COND
                         (underEdit 
          
          (* abort sub edit when obj specially selected in main window)

                                (EQN.AbortEdit window)
                                'CHANGED)
                         (T NIL)))
                     (T (SPAWN.MOUSE)
                        (OR (COND
                               [(EQ button 'LEFT)            (* check for direct selection of piece 
                                                             within the equation)
                                (AND (EQ (MENU CHOICEMENU)
                                         'EDIT)
                                     (LET ((piece# (EQIO.Selection eqnObj windowStream relX relY)))
                                          (COND
                                             (piece# (EQN.StartEdit eqnObj window piece#)
                                                    'CHANGED)
                                             (T NIL]
                               [(EQ button 'MIDDLE)          (* use menu to allow selection of 
                                                             piece to edit)
                                (LET ((selectFn (EQIO.GetInfo (EQIO.EqnType eqnObj)
                                                       'specialSelectFn))
                                      piece#)
                                     (COND
                                        ((NOT selectFn)
                                         (SETQ selectFn EquationDefaultSelectFn)))
                                     (COND
                                        ((AND selectFn (SETQ piece# (APPLY* selectFn eqnObj)))
                                         (EQN.StartEdit eqnObj window piece#)
                                         'CHANGED)
                                        (T NIL]
                               (T NIL))
                            (LET [(wholeEditFn (EQIO.GetInfo (EQIO.EqnType eqnObj)
                                                      'wholeEditFn]
          
          (* treat as top level selection and check for edits of global properties)

                                 (COND
                                    (underEdit (EQN.AbortEdit window)))
                                 (COND
                                    ((AND wholeEditFn (APPLY* wholeEditFn eqnObj window button))
                                     'CHANGED)
                                    (underEdit 'CHANGED)
                                    (T NIL])

(EQIO.Copy
  [LAMBDA (eqnObj)                                           (* THH "12-Jul-85 10:40")
    (LET ((dataList (EQIO.EqnDataList eqnObj)))
         (EQIO.Create (COPY (EQIO.EqnType eqnObj))
                (for data in dataList collect (FS.Copy data))
                NIL
                (EQIO.CopyList (EQIO.AllProps eqnObj])

(EQIO.CopyList
  [LAMBDA (list)                                             (* THH "12-Jul-85 10:44")
          
          (* copies list down to atoms or strings but sets anything else to NIL)
          
          (* datatype values set to NIL -- allows caching such data only)

    (COND
       ((OR (ATOM list)
            (STRINGP list))
        list)
       ((LISTP list)
        (for item in list collect (EQIO.CopyList item)))
       (T                                                    (* set value to NIL)
          NIL])

(EQIO.Get
  [LAMBDA (fileStream)                                       (* ; "Edited  3-Mar-88 13:45 by thh:")
          
          (* ;; "specify readtable for input")

    (LET ((*READTABLE* (FIND-READTABLE "INTERLISP")))
         (PROG ((kind (READ fileStream))
                (dataList (FS.Get fileStream)))
               (RETURN (EQIO.Create kind dataList NIL (READ fileStream])

(EQIO.Put
  [LAMBDA (eqnObj fileStream)                                (* ; "Edited  3-Mar-88 13:43 by thh:")
          
          (* ;; "specify readtable for output and eliminate all non-atom/string props which PRIN2 won't handle correctly")

    (LET ((*READTABLE* (FIND-READTABLE "INTERLISP")))
         (PRIN2 (EQIO.EqnType eqnObj)
                fileStream)
         (FS.Put (EQIO.EqnDataList eqnObj)
                fileStream)
         (PRIN2 (EQIO.CopyList (EQIO.AllProps eqnObj))
                fileStream])

(EQIO.WhenDeleted
  [LAMBDA (eqnObj window)                                    (* thh%: "15-May-85 11:27")
          
          (* called when eqnObj is about to be deleted from edit window)
                                                             (* abort any sub edit of this object)
    (PROG ((editWindow (EQN.ValidEditWindow (EQN.EditWindow window)
                              eqnObj)))
          (COND
             (editWindow (EQN.AbortEdit window])

(EQIO.SelectRegion
  [LAMBDA (spec data piece# imageStream)                     (* THH "21-May-85 12:13")
                                                             (* determines selection region for 
                                                             piece in eqnObj)
    (PROG ((dataSpec (EQIO.GetDataSpec spec piece#)))
          (RETURN (COND
                     ((EQIO.GetDataSelectRegion dataSpec))
                     [data (PROG ((dataBox (FS.Box data imageStream))
                                  (pos (EQIO.GetDataPosition dataSpec)))
                                 (RETURN (create REGION
                                                LEFT _ (fetch XCOORD of pos)
                                                BOTTOM _ (DIFFERENCE (fetch YCOORD of pos)
                                                                (fetch YDESC of dataBox))
                                                WIDTH _ (fetch XSIZE of dataBox)
                                                HEIGHT _ (fetch YSIZE of dataBox]
                     (T NIL])

(EQIO.Selection
  [LAMBDA (eqnObj imageStream relX relY)                     (* thh%: "31-May-85 09:31")
          
          (* returns piece number of data within which selection was made, if any)
          
          (* note%: if slection region for a piece is zero size, then cannot select that 
          piece)
          
          (* new TEdit%: relY is measured from baseline of object so must adjust since 
          eqn forms measure regions w.r.t. l.l. corner of box)

    (PROG ((spec (EQIO.Specify eqnObj imageStream))
           piece#)
          (RETURN (COND
                     [spec (add relY (fetch YDESC of (EQIO.GetBox spec)))
                           (SETQ piece# (for i from 1 to (EQIO.NumPieces eqnObj) bind region
                                           do (SETQ region (EQIO.SelectRegion spec (EQIO.EqnData
                                                                                    eqnObj i)
                                                                  i imageStream))
                                              (COND
                                                 ((AND region (INSIDEP region relX relY))
                                                  (RETURN i]
                     (T                                      (* unknown equation --
                                                             not able to select)
                        NIL])

(EQIO.DefaultSelectFn
  [LAMBDA (eqnObj)                                           (* thh%: "31-May-85 08:34")
          
          (* provides a menu-based selection of a part of the equation --
          returns the piece# of the part selected or NIL if no part was selected)
          
          (* this is useful for selecting parts whose select region on the screen is zero 
          size)

    (PROG ((type (EQIO.EqnType eqnObj))
           menu)
          [COND
             [(EQIO.GetInfo type 'variable?)
              (SETQ menu (EQIO.EqnProperty eqnObj 'selectionMenu))
              (COND
                 ((NOT (type? MENU menu))
                  (SETQ menu (EQIO.MakeSelectionMenu type (EQIO.NumPieces eqnObj)))
                  (EQIO.EqnProperty eqnObj 'selectionMenu menu]
             (T (SETQ menu (EQIO.TypeProp type 'selectionMenu))
                (COND
                   ((NOT (type? MENU menu))
                    (SETQ menu (EQIO.MakeSelectionMenu type (EQIO.NumPieces eqnObj)))
                    (EQIO.TypeProp type 'selectionMenu menu]
          (RETURN (COND
                     (menu (MENU menu))
                     (T NIL])

(EQIO.MakeSelectionMenu
  [LAMBDA (type numPieces)                                   (* thh%: "19-Mar-86 09:30")
          
          (* creates a selection menu for the specified type of equation)
          
          (* numPieces may be NIL if this is an unknown type of equation)

    (COND
       [(AND (FIXP numPieces)
             (IGREATERP numPieces 0))
        (PROG [(pieceNames (EQIO.GetInfo type 'pieceNames]
              (RETURN (create MENU
                             CENTERFLG _ T
                             TITLE _ "Eqn piece?"
                             ITEMS _ (for i from 1 to numPieces bind name
                                        collect (SETQ name (CAR pieceNames))
                                              (COND
                                                 (name (SETQ pieceNames (CDR pieceNames))
                                                       (LIST name i))
                                                 (T i]
       (T NIL])
)



(* ;;; "functions to handle individual equation props and data")

(DEFINEQ

(EQIO.EqnType
  [LAMBDA (eqnObj)                                           (* THH " 2-May-85 12:59")
                                                             (* returns type of equation)
    (CAR (IMAGEOBJPROP eqnObj 'OBJECTDATUM])

(EQIO.EqnDataList
  [LAMBDA (eqnObj)                                           (* THH " 2-May-85 12:59")
                                                             (* returns list of data pieces in the 
                                                             equation)
    (CDR (IMAGEOBJPROP eqnObj 'OBJECTDATUM])

(EQIO.SetDataList
  [LAMBDA (eqnObj newDataList)                               (* thh%: " 3-Jun-85 08:34")
          
          (* replaces entire data list of eqn -- caller must make sure any props, e.g.
          numPieces, are suitably adjusted)

    (IMAGEOBJPROP eqnObj 'OBJECTDATUM (CONS (EQIO.EqnType eqnObj)
                                            newDataList])

(EQIO.EqnData
  [LAMBDA (eqnObj piece#)                                    (* THH " 2-May-85 13:52")
    (CAR (NTH (EQIO.EqnDataList eqnObj)
              piece#])

(EQIO.EqnProperty
  [LAMBDA eqn                                                (* THH " 8-May-85 08:48")
                                                             (* gets and sets individual eqn props)
                                                             (* eqn is of form (eqnObj prop 
                                                             {newValue}))
    (COND
       ((IEQP eqn 2)
        (LISTGET (IMAGEOBJPROP (ARG eqn 1)
                        'props)
               (ARG eqn 2)))
       ((IEQP eqn 3)
        (PROG [(props (IMAGEOBJPROP (ARG eqn 1)
                             'props]
              [COND
                 (props (LISTPUT props (ARG eqn 2)
                               (ARG eqn 3)))
                 (T (SETQ props (LIST (ARG eqn 2)
                                      (ARG eqn 3]
              (IMAGEOBJPROP (ARG eqn 1)
                     'props props])

(EQIO.AllProps
  [LAMBDA eqn                                                (* THH " 8-May-85 08:48")
                                                             (* gets and sets all props for eqnObj)
                                                             (* eqn is of form (eqnObj {newProps}))
    (COND
       ((IEQP eqn 1)
        (IMAGEOBJPROP (ARG eqn 1)
               'props))
       ((IEQP eqn 2)
        (IMAGEOBJPROP (ARG eqn 1)
               'props
               (ARG eqn 2])

(EQIO.Specify
  [LAMBDA (eqnObj imageStream draw?)                         (* THH " 2-May-85 13:45")
          
          (* returns specification for equation on imageStream, and if draw? is not NIL, 
          draws the non-data parts of the equation)

    (PROG [(formFn (EQIO.GetInfo (EQIO.EqnType eqnObj)
                          'formFn]
          (RETURN (COND
                     (formFn (APPLY* formFn eqnObj imageStream draw?))
                     (T NIL])

(EQIO.GetInitialProps
  [LAMBDA (type)                                             (* thh%: "31-May-85 09:02")
          
          (* gets initial prop list to use when new equation of specified type is created)

    (PROG ([props (COPY (EQIO.GetInfo type 'objectProps]
           (initialPropFn (EQIO.GetInfo type 'initialPropFn))
           newProps)
          [COND
             ((AND initialPropFn (SETQ newProps (APPLY* initialPropFn type)))
              (COND
                 [props (repeatwhile newProps do (LISTPUT props (CAR newProps)
                                                        (CADR newProps))
                                                 (SETQ newProps (CDDR newProps]
                 (T (SETQ props newProps]
          (COND
             ([AND props (LISTGET props 'numPieces)
                   (NOT (EQIO.GetInfo type 'variable?]
          
          (* this equation does not allow a variable number of pieces)

              (ERROR "EQIO.GetInitialProps: can't specify numPieces for fixed size eqn type = " type)
              ))
          (RETURN props])

(EQIO.NumPieces
  [LAMBDA eqn                                                (* thh%: "31-Jul-85 08:49")
          
          (* gets or sets current number of parts for eqn --
          args are (eqnObj {newValue}))

    (COND
       ((IGREATERP eqn 0)
        (PROG ((eqnObj (ARG eqn 1))
               type value)
              (SETQ type (EQIO.EqnType eqnObj))
              (RETURN (COND
                         [(IEQP eqn 1)
                          (COND
                             ([AND (EQIO.GetInfo type 'variable?)
                                   (FIXP (SETQ value (EQIO.EqnProperty eqnObj 'numPieces]
                              value)
                             (T                              (* not variable or different number of 
                                                             parts not specified)
                                (EQIO.GetInfo type 'numPieces]
                         ((EQIO.GetInfo type 'variable?)
                          (EQIO.EqnProperty eqnObj 'numPieces (ARG eqn 2))
                          (EQIO.NewStructure eqnObj))
                         (T (ERROR "EQIO.NumPieces: equation has fixed # of parts, type = " type])

(EQIO.NewStructure
  [LAMBDA (eqnObj)                                           (* thh%: " 3-Jun-85 09:21")
          
          (* called when eqn structure is changed --
          e.g. different number of parts -- to reset any saved menus, etc.)

    (EQIO.EqnProperty eqnObj 'selectionMenu NIL)
    (PROG [(changeFn (EQIO.GetInfo (EQIO.EqnType eqnObj)
                            'changeFn]
          (COND
             (changeFn (APPLY* changeFn eqnObj])
)



(* ;;; "functions to handle equation specification info")

(DEFINEQ

(EQIO.AddType
  [LAMBDA (type formFn numPieces PROPS)                      (* THH " 1-Jul-85 08:37")
                                                             (* creates info for new equation type)
    [PROG ((newValue (APPEND (LIST 'formFn formFn 'numPieces numPieces)
                            PROPS)))
          (PUTPROP type 'equationInfo newValue)
          (COND
             ((NOT (MEMB type EquationInfo))
              (push EquationInfo type]
    (EQIO.ResetTypeProps type])

(EQIO.GetInfo
  [LAMBDA (type info)                                        (* thh%: "28-Jun-85 15:17")
                                                             (* returns specified info for equation 
                                                             type)
    (LISTGET (GETPROP type 'equationInfo)
           info])

(EQIO.SetInfo
  [LAMBDA (type info newValue)                               (* thh%: "28-Jun-85 15:38")
          
          (* allows setting particular equation info items for previously defined 
          equation types)

    (COND
       ((EQIO.IsDefined type)
        (LET [(spec (GETPROP type 'equationInfo]
             (COND
                (spec (LISTPUT spec info newValue)
                      (PUTPROP type 'equationInfo spec)
                      (EQIO.ResetTypeProps type)
                      newValue)
                (T (ERROR "EQIO.SetInfo: warning -- no specifications for eqn type = " type])

(EQIO.TypeProp
  [LAMBDA type                                               (* thh%: "31-May-85 09:11")
          
          (* associates properties with equation types --
          e.g. can be used to store selection menus for equations with fixed number of 
          parts)
                                                             (* args are (type prop {newValue}))
    (COND
       ((IEQP type 2)
        (LISTGET (GETPROP (ARG type 1)
                        'equationProps)
               (ARG type 2)))
       ((IEQP type 3)
        (PROG [(list (GETPROP (ARG type 1)
                            'equationProps]
              [COND
                 (list (LISTPUT list (ARG type 2)
                              (ARG type 3)))
                 (T (SETQ list (LIST (ARG type 2)
                                     (ARG type 3]
              (PUTPROP (ARG type 1)
                     'equationProps list])

(EQIO.ResetTypeProps
  [LAMBDA (type)                                             (* THH " 1-Jul-85 08:36")
          
          (* removes all props associated with this equation type --
          called when type info redefined)

    (SETQ EquationTypeMenu NIL)
    (PUTPROP type 'equationProps NIL])

(EQIO.IsDefined
  [LAMBDA (type)                                             (* thh%: "28-Jun-85 15:27")
          
          (* returns type if it is a currently defined equation type, else NIL)

    (COND
       ((MEMB type EquationInfo)
        type)
       (T NIL])

(EQIO.GetBox
  [LAMBDA (specification)                                    (* THH " 2-May-85 13:22")
                                                             (* gets image box)
    (CAR specification])

(EQIO.GetDataSpec
  [LAMBDA (specification piece#)                             (* THH " 2-May-85 13:26")
                                                             (* gets data spec for corresponding 
                                                             piece)
    (CAR (NTH specification (ADD1 piece#])

(EQIO.GetDataSpecList
  [LAMBDA (specification)                                    (* THH "12-Jul-85 10:22")
    (CDR specification])

(EQIO.GetDataPosition
  [LAMBDA (dataSpec)                                         (* THH " 2-May-85 13:26")
    (CAR dataSpec])

(EQIO.GetDataSelectRegion
  [LAMBDA (dataSpec)                                         (* THH " 2-May-85 13:26")
    (CDR dataSpec])

(EQIO.MakeSpec
  [LAMBDA (box dataSpecList)                                 (* THH " 2-May-85 13:26")
                                                             (* constructs specification)
    (CONS box dataSpecList])

(EQIO.MakeDataSpec
  [LAMBDA (position selectRegion)                            (* THH " 2-May-85 13:26")
    (CONS position selectRegion])
)



(* ;;; "variable specification")

(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS EquationInfo EquationTypeMenu EquationImageFns UnknownEquationData 
       EquationDefaultSelectFn)
)

(RPAQQ EquationImageFns NIL)

(RPAQ? EquationInfo NIL)

(RPAQ? EquationDefaultSelectFn 'EQIO.DefaultSelectFn)
[TEDIT.ADD.MENUITEM TEDIT.DEFAULT.MENU '(Equation 'EQN.Equation]
                                                             (* ; 
                             "needed to force the getfn to be recognized before any new eqns defined")

(SETQ EquationImageFns (EQIO.CreateFns))

(RPAQQ UnknownEquationData (((Gacha 10)
                             "[unknown equation]")))

(PUTPROPS EQIO.TypeProp ARGNAMES (NIL (type prop {newValue})
                                      args))

(PUTPROPS EQIO.NumPieces ARGNAMES (NIL (eqnObj {newValue})
                                       args))

(PUTPROPS EQIO.AllProps ARGNAMES (NIL (eqnObj {newValue})
                                      args))

(PUTPROPS EQIO.EqnProperty ARGNAMES (NIL (eqnObj prop {newValue})
                                         args))
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA EQN.ObjEditWindow EQN.ContinueFlg EQN.PieceNumber EQN.ResultObj EQN.ResultWindow 
                     EQN.EditWindow EQIO.TypeProp EQIO.NumPieces EQIO.AllProps EQIO.EqnProperty)
)



(* ;;; "EQUATIONEDIT module: Part 2 of 3")




(* ; "functions to edit data pieces")

(DEFINEQ

(EQN.AbortEdit
  [LAMBDA (mainWindow)                                       (* thh%: " 3-May-85 11:17")
                                                             (* terminates any eqn edit without 
                                                             allowing any continuation)
    (PROG ((editWindow (EQN.EditWindow mainWindow)))
          (COND
             ((WINDOWP editWindow)
              (EQN.ContinueFlg editWindow NIL)
              (EQN.StopEdit mainWindow])

(EQN.StopEdit
  [LAMBDA (mainWindow)                                       (* thh%: " 3-May-85 10:31")
                                                             (* terminates any eqn edit)
    (PROG ((editWindow (EQN.EditWindow mainWindow)))
          (COND
             ((WINDOWP editWindow)
              (EQN.FinishEdit editWindow)
              (TEDIT.QUIT (TEXTSTREAM editWindow))
              (CLOSEW editWindow])

(EQN.ContinueEdit
  [LAMBDA (window)                                           (* thh%: "28-Jun-85 14:14")
          
          (* called after sub edit quits to see if eqn edit should continue with next 
          piece)
          
          (* continueFlg is NIL to stop, T to continue incrementing by 1, FIXP to 
          increment by that amount once, (FIXP . end) to increment up/down to end
          (end = NIL to contnue until no more)%, or a function to determine next piece 
          from current piece (NIL to end))
          
          (* selection is pending delete for selections that continue beyond current 
          piece)

    [PROG [(process (WINDOWPROP (EQN.ResultWindow window)
                           'PROCESS]                         (* return TTY process to result window)
          (COND
             (process (TTY.PROCESS process]
    (PROG ((continueFlg (EQN.ContinueFlg window))
           (newPiece# (EQN.PieceNumber window))
           increment end)
          (COND
             ((COND
                 ((EQ continueFlg T)
                  (add newPiece# 1)
                  T)
                 ((NULL continueFlg)
                  NIL)
                 [(FIXP continueFlg)                         (* treat pieces as circular list)
                  (LET [(oldPiece# newPiece#)
                        (numPieces (EQIO.NumPieces (EQN.ResultObj window]
                       (SETQ newPiece# (IMOD (PLUS oldPiece# continueFlg)
                                             numPieces))
                       (COND
                          ((ZEROP newPiece#)
                           (SETQ newPiece# numPieces)))
                       (SETQ continueFlg NIL)
          
          (* this is a one-shot continuation so continueFlg for new edit to NIL)

                       (NOT (IEQP newPiece# oldPiece#]
                 ((LISTP continueFlg)
                  (COND
                     [(AND (FIXP (SETQ increment (CAR continueFlg)))
                           (NOT (ZEROP increment))
                           (OR (FIXP (SETQ end (CDR continueFlg)))
                               (NULL end)))
                      (add newPiece# increment)
                      (COND
                         ((NULL end)                         (* always continue)
                          T)
                         ((MINUSP increment)
                          (IGEQ newPiece# end))
                         (T (ILEQ newPiece# end]
                     (T                                      (* bad format list --
                                                             don't continue)
                        NIL)))
                 ((LITATOM continueFlg)
                  (SETQ newPiece# (APPLY* continueFlg newPiece#))
                                                             (* continue if the function returned a 
                                                             valid piece number)
                  (FIXP newPiece#))
                 (T (ERROR "EQN.ContinueEdit: Invalid value for continueFlg = " continueFlg)
                    NIL))                                    (* continue with edit of newPiece#)
          
          (* * continuation of edit requested -- start new edit)

              (EQN.StartNextEdit (EQN.ResultObj window)
                     (EQN.ResultWindow window)
                     newPiece# continueFlg (COND
                                              (continueFlg 'PENDINGDEL)
                                              (T NIL])

(EQN.FinishEdit
  [LAMBDA (window)                                           (* thh%: " 5-Dec-85 11:06")
                                                             (* returns edited data to calling 
                                                             TEdit)
    (PROG ((mainWindow (EQN.ResultWindow window)))
          (EQN.ObjEditWindow (EQN.ResultObj window)
                 NIL)
          (EQN.AbortEdit window)                             (* abort any sub edits)
          (EQN.UpdateEdit mainWindow (WINDOWPROP window 'NOUPDATE))
          (EQN.EditWindow mainWindow NIL))
          
          (* return T to allow TEdit to quit without user confirmation)

    T])

(EQN.MakeEditWindow
  [LAMBDA (mainWindow XSIZE YSIZE)                           (* thh%: " 6-Dec-85 11:34")
                                                             (* creates window for subeditor)
    (LET ((editWindow (CREATEW (CREATEREGION 0 0 (fetch (REGION WIDTH) of (WINDOWPROP mainWindow
                                                                                 'REGION))
                                      (PLUS 10 (HEIGHTIFWINDOW (TIMES 2 YSIZE)
                                                      T)))
                             "Eqn edit" NIL T)))
         (ATTACHWINDOW editWindow mainWindow 'BOTTOM 'LEFT 'LOCALCLOSE)
          
          (* note%: edit window is justified -- later may automatically reshape it as new 
          text is entered)

         (WINDOWADDPROP editWindow 'CLOSEFN 'DETACHWINDOW)   (* edit window will be detached when 
                                                             closed)
          
          (* * allow main and edit windows to be independently reshaped)

         (WINDOWDELPROP editWindow 'PASSTOMAINCOMS 'SHAPEW)
         (WINDOWADDPROP editWindow 'REJECTMAINCOMS 'SHAPEW)
          
          (* * make windows snuggle after reshape)

         (WINDOWADDPROP editWindow 'RESHAPEFN 'EQN.SnuggleWindows)
         (WINDOWADDPROP mainWindow 'RESHAPEFN 'EQN.SnuggleWindows)
         editWindow])

(EQN.SetUpEdit
  [LAMBDA (editWindow mainWindow eqnObj continueFlg piece#)  (* thh%: " 5-Dec-85 10:59")
                                                             (* sets up props for sub edit)
    (EQN.ResultWindow editWindow mainWindow)
    (EQN.ResultObj editWindow eqnObj)
    (EQN.ContinueFlg editWindow continueFlg)
    (EQN.PieceNumber editWindow piece#)
    [WINDOWPROP editWindow 'TEDIT.MENU.COMMANDS '(Find Looks Substitute Character% Looks
                                                       (Equation 'EQN.Equation)
                                                       (Exit 'Quit "exit from equation editor"
                                                             (SUBITEMS (Next% Piece 'EQN.NextPiece)
                                                                    (Finish% Eqn 'EQN.FinishEqn)
                                                                    (Abort 'EQN.NoUpdateAbort 
                                                        "Terminates eqn editor without changing eqn."
                                                                           ]
    (EQN.ObjEditWindow eqnObj editWindow])

(EQN.StartEdit
  [LAMBDA (eqnObj mainWindow piece# continueFlg initialSEL)  (* thh%: " 6-Dec-85 11:21")
          
          (* Starts edit of specified piece of eqnObj which is currently in TEdit 
          mainWindow. Starts new edit only if piece exists.)
                                                             (* continueFlg determines action on 
                                                             normal exit)
                                                             (* initialSEL is initial selection or 
                                                             char number)
    (EQN.AbortEdit mainWindow)                               (* abort any previous eqn edit)
    (COND
       ((AND (IGREATERP piece# 0)
             (ILEQ piece# (EQIO.NumPieces eqnObj)))
        (PROG ((data (EQIO.EqnData eqnObj piece#))
               editWindow editStream box len)
              (SETQ box (FS.Box data (DECODE/WINDOW/OR/DISPLAYSTREAM mainWindow)))
              (SETQ editWindow (EQN.MakeEditWindow mainWindow (fetch XSIZE of box)
                                      (fetch YSIZE of box)))
              [TEDIT NIL editWindow NIL (APPEND '(QUITFN EQN.FinishEdit AFTERQUITFN EQN.ContinueEdit 
                                                        CHARFN EQN.CharFn)
                                               (LIST 'PROMPTWINDOW (OR (TEXTPROP (TEXTSTREAM 
                                                                                        mainWindow)
                                                                              'PROMPTWINDOW)
                                                                       (GETPROMPTWINDOW mainWindow]
                                                             (* sub edit uses same prompt window as 
                                                             main editor)
              (EQN.SetUpEdit editWindow mainWindow eqnObj continueFlg piece#)
              (SETQ editStream (TEXTSTREAM editWindow))
              (SETQ len (FS.Insert data editStream))
              (COND
                 ((EQ initialSEL 'PENDINGDEL)
                  (TEDIT.SETSEL editStream 1 len 'RIGHT T))
                 ((FIXP initialSEL)
                  (TEDIT.SETSEL editStream initialSEL 0 'RIGHT))
                 ((type? SELECTION initialSEL)
                  (TEDIT.SETSEL editStream initialSEL)))
              (EQN.EditWindow mainWindow editWindow)
              [COND
                 ((NOT (EQN.SubEditorP mainWindow))
          
          (* this is a main edit window -- make sure sub edits are aborted when main edit 
          is done (don't call EQN.FinishEdit since want QUITFN to return NIL to allow 
          user to confirm quit at top level))

                  (TEXTPROP (TEXTSTREAM mainWindow)
                         'QUITFN
                         'EQN.AbortEdit]                     (* old TEdit version%:
                                                             (WINDOWPROP mainWindow
                                                             (QUOTE TEDIT.QUITFN)
                                                             (QUOTE EQN.FinishEdit)))
          ])

(EQN.StartNextEdit
  [LAMBDA (eqnObj mainWindow newPiece# continueFlg initialSEL)
                                                             (* thh%: "29-May-85 10:10")
          
          (* if another piece of eqnObj exists, starts an edit of it)

    (EQN.StartEdit eqnObj mainWindow newPiece# continueFlg initialSEL)
          
          (* mark obj as changed to allow display indication of new piece being edited)

    (TEDIT.OBJECT.CHANGED (TEXTSTREAM mainWindow)
           eqnObj])

(EQN.UpdateEdit
  [LAMBDA (mainWindow noChangeFLG)                           (* thh%: " 6-Dec-85 09:52")
                                                             (* updates sub edit in mainWindow)
          
          (* noChangeFLG non-NIL means main eqn not changed, but still must notify TEdit 
          obj is changed to update display, e.g. uninvert edited piece)

    (PROG ((editWindow (EQN.EditWindow mainWindow))
           value datum eqnObj piece# ptr)
          (COND
             ((WINDOWP editWindow)
              (SETQ eqnObj (EQN.ResultObj editWindow))
              [COND
                 ((NOT noChangeFLG)
                  (EQN.UpdateEdit editWindow)                (* get updates of any sub edits)
                  (SETQ piece# (EQN.PieceNumber editWindow))
                  (SETQ value (FS.Extract (TEXTSTREAM editWindow)))
                  (SETQ datum (EQIO.EqnDataList eqnObj))
                  (SETQ ptr (NTH datum piece#))
                  (COND
                     (ptr (RPLACA ptr value))
                     (T                                      (* put value on end of datum)
                        (EQIO.SetDataList eqnObj (NCONC1 datum value]
              (EQN.CheckWindowSize mainWindow eqnObj)
              (TEDIT.OBJECT.CHANGED (TEXTSTREAM mainWindow)
                     eqnObj])

(EQN.DefaultData
  [LAMBDA (type fontSpec numPieces dataList)                 (* thh%: " 6-Dec-85 09:44")
          
          (* gets list of default data items to use for equation specified type)
                                                             (* currently just a single item --
                                                             blank)
          
          (* if dataList is specified its values are used as the default data --
          either directly if the item is a format string or with default font for the 
          piece if it is a string)

    [COND
       ((NOT numPieces)
        (SETQ numPieces (EQIO.GetInfo type 'numPieces]
    (PROG [(initialData (EQIO.GetInfo type 'initialData]
          (RETURN
           (COND
              ((AND initialData (LITATOM initialData))
               (APPLY* initialData fontSpec type numPieces dataList))
              (T
               (COND
                  ((NLISTP initialData)
                   (SETQ initialData NIL)))
               (PROG ((fontNumber (EQN.EquationFontNumber fontSpec)))
                     (RETURN
                      (COND
                         [numPieces
                          (for i from 1 to numPieces bind initial item
                             collect (SETQ initial (pop initialData))
                                   (SETQ item (pop dataList)) 
          
          (* each piece of the equation consists of a single-item format string
          (unless specified otherwise by value in dataList))

                                   (COND
                                      ((AND item (LISTP item))
                                       item)
                                      ((IMAGEOBJP item)
                                       (LIST item))
                                      (T (LIST (FS.MakeItem [EQN.EquationFont (PLUS fontNumber
                                                                                    (COND
                                                                                       ((FIXP initial
                                                                                              )
                                                                                        initial)
                                                                                       (T 0]
                                                      (COND
                                                         (item (MKSTRING item))
                                                         (T " "]
                         (T NIL])

(EQN.TypeMenu
  [LAMBDA NIL                                                (* THH " 1-Jul-85 08:42")
                                                             (* returns menu of equation types)
    (COND
       ((AND (BOUNDP 'EquationTypeMenu)
             (type? MENU EquationTypeMenu))
        EquationTypeMenu)
       (T                                                    (* compute menu from EquationInfo)
          (SETQ EquationTypeMenu (create MENU
                                        ITEMS _ (SORT (for item in EquationInfo bind label
                                                         collect (SETQ label (EQIO.GetInfo
                                                                              item
                                                                              'menuLabel))
                                                               (COND
                                                                  (label (LIST label (KWOTE item)))
                                                                  (T item)))
                                                      T)
                                        TITLE _ "Equation Types"])
)



(* ;;; "hooks to control behavior of equation subeditor")

(DEFINEQ

(EQN.Equation
  [LAMBDA (textStream)                                       (* thh%: "31-May-85 08:58")
          
          (* allows insertion of an equation at current selection in textStream)

    (PROG ((type (MENU (EQN.TypeMenu)))
           currentFont window eqnObj props)
          (COND
             (type (SETQ currentFont (FS.ExtractFont textStream))
                   (SETQ window (EQN.WindowFromText textStream))
                   (SETQ props (EQIO.GetInitialProps type))
                   (SETQ eqnObj (EQIO.Create type (EQN.DefaultData type currentFont
                                                         (LISTGET props 'numPieces))
                                       currentFont props))
                   (EQN.CheckWindowSize window eqnObj)
                   (TEDIT.INSERT.OBJECT eqnObj textStream)
                   (EQN.StartEdit eqnObj window 1 T 'PENDINGDEL)
          
          (* must mark obj changed to allow display to indicate obj is being edited)
          
          (* TEDIT.OBJECT.CHANGED can not be called directly from EQN.StartEdit because 
          that fcn is called by the button fcn)

                   (TEDIT.OBJECT.CHANGED textStream eqnObj])

(EQN.NextPiece
  [LAMBDA (textStream)                                       (* thh%: "29-May-85 10:11")
                                                             (* aborts edit and continues with next 
                                                             piece of eqn)
    (PROG ((editWindow (EQN.WindowFromText textStream))
           mainWindow)
          (SETQ mainWindow (EQN.ResultWindow editWindow))
          (COND
             ((WINDOWP mainWindow)
              (EQN.ContinueFlg editWindow (COND
                                             ((EQN.ContinueFlg editWindow))
                                             (T 1)))
              (EQN.StopEdit mainWindow])

(EQN.FinishEqn
  [LAMBDA (textStream)                                       (* thh%: " 3-May-85 11:53")
                                                             (* aborts edit without any 
                                                             continuation)
    (PROG ((editWindow (EQN.WindowFromText textStream))
           mainWindow)
          (SETQ mainWindow (EQN.ResultWindow editWindow))
          (COND
             ((WINDOWP mainWindow)
              (EQN.AbortEdit mainWindow])

(EQN.NoUpdateAbort
  [LAMBDA (textStream)                                       (* thh%: " 5-Dec-85 11:21")
                                                             (* aborts equation editor without 
                                                             updating eqn in main window)
    (EQN.PreventUpdate (EQN.WindowFromText textStream))
    (EQN.FinishEqn textStream])

(EQN.PreventUpdate
  [LAMBDA (window)                                           (* thh%: " 5-Dec-85 11:21")
                                                             (* prevents any update of this or any 
                                                             subeditors)
    (COND
       ((WINDOWP window)
        (WINDOWPROP window 'NOUPDATE T)
        (EQN.PreventUpdate (EQN.EditWindow window])

(EQN.CharFn
  [LAMBDA (textObj charcode)                                 (* thh%: "19-Aug-85 08:31")
                                                             (* prevents control chars from being 
                                                             inserted into the document)
          
          (* allows any char that can be used in a format string and a few special 
          editing chars%: backspace & delete)
                                                             (* allows NEXT syntax char to exit 
                                                             from editor)
    (LET ((syntax (EQN.TEditSpecialChar textObj charcode)))
         (COND
            ((EQ syntax 'NEXT)
          
          (* next syntax key pressed -- see if this should quit eqn editor)

             (COND
                ((TEDIT.FIND (TEXTSTREAM textObj)
                        ">>*<<" NIL NIL T)                   (* special char -- let TEdit advance 
                                                             to next slot)
                 T)
                (T                                           (* force exit)
                   (EQN.FinishEdit (EQN.WindowFromText textObj))
                                                             (* TEDIT.QUIT does not automatically 
                                                             call the QUITFN)
                   (TEDIT.QUIT (TEXTSTREAM textObj))
                   NIL)))
            (syntax                                          (* special character)
                   T)
            ((FS.AllowedChar charcode)                       (* this character can be in format 
                                                             strings)
             T)
            (T                                               (* don't allow this char to be 
                                                             inserted)
               (FLASHWINDOW (EQN.WindowFromText textObj))
               NIL])

(EQN.TEditSpecialChar
  [LAMBDA (textObj charcode)                                 (* thh%: "16-Aug-85 09:35")
          
          (* if charcode is a control character for edit specified by textObj returns its 
          syntax class, else NIL)
          
          (* this may not correspond exactly to the procedure TEdit uses to determine 
          syntax of a character -- need to also check terminal table??)

    (LET ((table (OR (READTABLEP (TEXTPROP textObj 'READTABLE))
                     TEDIT.READTABLE))
          syntax)
         (SETQ syntax (TEDIT.GETSYNTAX charcode table))
         (COND
            ((EQ syntax 'NONE)
             (SETQ syntax NIL)))
         syntax])

(EQN.SnuggleWindows
  [LAMBDA (window)                                           (* thh%: " 6-Dec-85 12:07")
                                                             (* reshape fn for independently 
                                                             reshapeable attached windows)
          
          (* * move attached windows)

    (REPOSITIONATTACHEDWINDOWS window)
          
          (* Does not work correctly when window itself has attached windows ??)
          
          (* * move main window)

    (EQN.SnuggleMainWindow window])

(EQN.SnuggleMainWindow
  [LAMBDA (window)                                           (* thh%: " 6-Dec-85 11:44")
                                                             (* moves all windows in main window 
                                                             chain)
    (LET ((mainW (MAINWINDOW window))
          region)
         (COND
            ((AND (WINDOWP mainW)
                  (NOT (EQ mainW window)))
             (SETQ region (WINDOWREGION window))             (* position main window above window)
          
          (* note that MOVEW must be rejected by window so that moving main window wont 
          also move attached window)

             [RESETLST (RESETSAVE (WINDOWADDPROP window 'REJECTMAINCOMS 'MOVEW)
                              `(WINDOWDELPROP %, window REJECTMAINCOMS MOVEW))
                    (MOVEW mainW (fetch (REGION LEFT) of region)
                           (PLUS (fetch (REGION BOTTOM) of region)
                                 (fetch (REGION HEIGHT) of region]
             (EQN.SnuggleMainWindow mainW])
)



(* ;;; "functions to handle equation fonts")

(DEFINEQ

(EQN.EquationFontNumber
  [LAMBDA (fontSpec)                                         (* thh%: "31-Jul-85 08:48")
          
          (* returns number of the font to use for normal size parts of the equation)
          
          (* fontSpec can be a number which then corresponds to the size of the font)

    (COND
       ((NOT fontSpec)
        (SETQ fontSpec DEFAULTFONT)))
    (PROG [(size (OR (NUMBERP fontSpec)
                     (FONTPROP fontSpec 'SIZE]
          (RETURN (for i from 1 to (ARRAYSIZE EquationFontSpecs)
                     smallest (ABS (DIFFERENCE (FONTPROP (ELT EquationFontSpecs i)
                                                      'SIZE)
                                          size])

(EQN.EquationFont
  [LAMBDA (n)                                                (* thh%: " 5-Dec-85 11:26")
                                                             (* returns equation font number n)
    (COPY (ELT EquationFontSpecs (MAX 1 (MIN (ARRAYSIZE EquationFontSpecs)
                                             n])

(EQN.GetEqnFont
  [LAMBDA (fontSpec)                                         (* thh%: "31-Jul-85 08:52")
    (EQN.EquationFont (EQN.EquationFontNumber fontSpec])

(EQN.MakeFS
  [LAMBDA (item fontSpec)                                    (* thh%: "31-Jul-85 08:58")
                                                             (* constructs a single element format 
                                                             string)
    (COND
       ((IMAGEOBJP item)
        (LIST item))
       ((LISTP item)
        item)
       (T (LIST (FS.MakeItem fontSpec (MKSTRING item])
)



(* ;;; "utilities")

(DEFINEQ

(EQN.AdjustWindow
  [LAMBDA (editWindow dWidth dHeight)                        (* thh%: " 6-Dec-85 12:09")
                                                             (* reshapes subeditor window to have 
                                                             extra width and height)
    (PROG ((region (WINDOWPROP editWindow 'REGION))
           (attachedWindows (ATTACHEDWINDOWS editWindow))
           newHeight howAttached)
          (SETQ newHeight (MAX (HEIGHTIFWINDOW 10 T)
                               (PLUS (fetch HEIGHT of region)
                                     dHeight)))
          
          (* want to shape this window only, not any attached windows --
          depends on correctly setting props when edit windows created)
                                                             (* SETQ howAttached (for window in 
                                                             attachedWindows collect
                                                             (DETACHWINDOW window)))
          (SHAPEW editWindow (create REGION
                                    LEFT _ (fetch LEFT of region)
                                    BOTTOM _ (DIFFERENCE (fetch BOTTOM of region)
                                                    (DIFFERENCE newHeight (fetch HEIGHT of region)))
                                    WIDTH _ (MAX (WIDTHIFWINDOW 10)
                                                 (PLUS (fetch WIDTH of region)
                                                       dWidth))
                                    HEIGHT _ newHeight))
          
          (* reattach the windows -- note that LOCALCLOSE is assumed for all windows)
          
          (* for window in attachedWindows as how in howAttached do
          (ATTACHWINDOW window editWindow (CAR how)
          (CDR how) (QUOTE LOCALCLOSE)))

      ])

(EQN.CheckWindowSize
  [LAMBDA (window eqnObj)                                    (* thh%: "29-May-85 08:52")
          
          (* makes sure window can contain new obj --
          currently only checks based on height of new obj, assuming YDESC not too large)

    (COND
       ((EQN.SubEditorP window)                              (* only adjust for subeditors
                                                             (They contain a single line of text))
        (PROG ((box (APPLY* (IMAGEOBJPROP eqnObj 'IMAGEBOXFN)
                           eqnObj
                           (DECODE/WINDOW/OR/DISPLAYSTREAM window)))
               (height (WINDOWPROP window 'HEIGHT))
               extraHeight)
              (SETQ extraHeight (DIFFERENCE (MIN 400 (TIMES 2 (fetch YSIZE of box)))
                                       height))
          
          (* for now require window to be twice as high as object so don't have to check 
          YDESC -- should work for most cases)

              (COND
                 ((IGREATERP extraHeight 0)
                  (EQN.AdjustWindow window 0 extraHeight])
)
(DEFINEQ

(EQN.SubEditorP
  [LAMBDA (window)                                           (* thh%: "28-May-85 09:27")
          
          (* non-NIL if window has a eqn subeditor running in it)

    (EQN.ResultWindow window])

(EQN.WindowFromText
  [LAMBDA (textObjORStream)                                  (* thh%: "28-Jun-85 14:32")
                                                             (* gets window corresponding to a text 
                                                             object or stream)
          
          (* note%: \WINDOW field actually is a list whose only element is the window)

    (LET [(w (fetch \WINDOW of (TEXTOBJ textObjORStream]
         (OR (WINDOWP w)
             (WINDOWP (CAR w))
             (ERROR "EQN.WindowFromText: unable to find window for textobj/stream = " textObjORStream
                    ])

(EQN.EditWindow
  [LAMBDA window                                             (* thh%: " 3-May-85 08:55")
                                                             (* returns or sets window of any sub 
                                                             edit)
    (COND
       [(IEQP window 1)
        (PROG [(w (WINDOWPROP (ARG window 1)
                         'EditWindow]                        (* test for valid window)
              (RETURN (COND
                         ((WINDOWP w)
                          (COND
                             ((AND (OPENWP w)
                                   (EQ (EQN.ResultWindow w)
                                       (ARG window 1)))
                              w)
                             (T (WINDOWPROP (ARG window 1)
                                       'EditWindow NIL)
                                NIL)))
                         (T NIL]
       ((IEQP window 2)
        (WINDOWPROP (ARG window 1)
               'EditWindow
               (ARG window 2)))
       (T NIL])

(EQN.ResultWindow
  [LAMBDA editWindow                                         (* THH " 2-May-85 16:20")
                                                             (* returns or sets main window for a 
                                                             sub edit)
    (COND
       ((IEQP editWindow 1)
        (WINDOWPROP (ARG editWindow 1)
               'ResultWindow))
       ((IEQP editWindow 2)
        (WINDOWPROP (ARG editWindow 1)
               'ResultWindow
               (ARG editWindow 2)))
       (T NIL])

(EQN.ResultObj
  [LAMBDA editWindow                                         (* THH " 2-May-85 16:25")
                                                             (* returns or sets object being edited)
    (COND
       ((IEQP editWindow 1)
        (WINDOWPROP (ARG editWindow 1)
               'ResultObj))
       ((IEQP editWindow 2)
        (WINDOWPROP (ARG editWindow 1)
               'ResultObj
               (ARG editWindow 2)))
       (T NIL])

(EQN.PieceNumber
  [LAMBDA editWindow                                         (* THH " 2-May-85 16:37")
                                                             (* returns or sets number of piece 
                                                             being edited)
    (COND
       ((IEQP editWindow 1)
        (WINDOWPROP (ARG editWindow 1)
               'PieceNumber))
       ((IEQP editWindow 2)
        (WINDOWPROP (ARG editWindow 1)
               'PieceNumber
               (ARG editWindow 2)))
       (T NIL])

(EQN.ContinueFlg
  [LAMBDA editWindow                                         (* THH " 2-May-85 16:25")
                                                             (* returns or sets continuation flag)
                                                             (* THH " 2-May-85 13:35")
    (COND
       ((IEQP editWindow 1)
        (WINDOWPROP (ARG editWindow 1)
               'ContinueFlg))
       ((IEQP editWindow 2)
        (WINDOWPROP (ARG editWindow 1)
               'ContinueFlg
               (ARG editWindow 2)))
       (T NIL])

(EQN.ValidEditWindow
  [LAMBDA (editWindow eqnObj)                                (* THH " 8-May-85 09:44")
          
          (* returns editWindow if it is a window currently being used to edit eqnObj, 
          else NIL)

    (COND
       ((AND (WINDOWP editWindow)
             (OPENWP editWindow)
             (EQ (EQN.ResultObj editWindow)
                 eqnObj))
        editWindow)
       (T NIL])

(EQN.ObjEditWindow
  [LAMBDA eqn                                                (* THH " 8-May-85 10:01")
                                                             (* gets or sets edit window for eqnObj)
                                                             (* eqn is of the form
                                                             (eqnObj {newEditWindow}))
    (PROG (editWindow eqnObj)
          (COND
             ((AND (IGREATERP eqn 0)
                   (SETQ eqnObj (ARG eqn 1))
                   (IMAGEOBJP eqnObj))
              (RETURN (COND
                         ((IEQP eqn 1)
                          (SETQ editWindow (IMAGEOBJPROP eqnObj 'editWindow))
                          (COND
                             ((EQN.ValidEditWindow editWindow eqnObj))
                             (editWindow                     (* remove invalid edit window prop)
                                    (IMAGEOBJPROP eqnObj 'editWindow NIL)
                                    NIL)
                             (T NIL)))
                         ((IEQP eqn 2)
                          (SETQ editWindow (EQN.ValidEditWindow (ARG eqn 2)
                                                  eqnObj))
                          (IMAGEOBJPROP eqnObj 'editWindow editWindow])
)
(DEFINEQ

(EQN.Make
  [LAMBDA (type dataList fontSpec PROPS)                     (* thh%: " 9-Jan-86 10:12")
          
          (* creates equation of specified type with given dataList --
          for variable piece eqns PROPS should include numPieces)

    (COND
       ((EQIO.IsDefined type)
        (LET [(numPieces (LISTGET PROPS 'numPieces]
             (EQIO.Create type (EQN.DefaultData type fontSpec (COND
                                                                 ((EQIO.GetInfo type 'variable?)
                                                                  numPieces)
                                                                 (numPieces (ERROR 
                                                                "Can't specify numPieces for type = " 
                                                                                   type))
                                                                 (T NIL))
                                      dataList)
                    fontSpec PROPS)))
       (T (ERROR "Unknown equation type = " type])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS EquationFontSpecs)
)

(RPAQ EquationFontSpecs (READARRAY-FROM-LIST 3 (QUOTE POINTER) 1 (QUOTE ((TimesRoman 8) (TimesRoman 10
) (TimesRoman 12) NIL))))


(PUTPROPS EQN.ObjEditWindow ARGNAMES (NIL (eqnObj {newEditWindow})
                                          args))

(PUTPROPS EQN.ContinueFlg ARGNAMES (NIL (editWindow {continueFlg})
                                        args))

(PUTPROPS EQN.PieceNumber ARGNAMES (NIL (editWindow {pieceNumber})
                                        args))

(PUTPROPS EQN.ResultObj ARGNAMES (NIL (editWindow {resultObj})
                                      args))

(PUTPROPS EQN.ResultWindow ARGNAMES (NIL (editWindow {resultWindow})
                                         args))

(PUTPROPS EQN.EditWindow ARGNAMES (NIL (window {editWindow})
                                       args))
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA EQN.ObjEditWindow EQN.ContinueFlg EQN.PieceNumber EQN.ResultObj EQN.ResultWindow 
                     EQN.EditWindow)
)



(* ;;; "FORMATSTRING module: Part 3 of 3")

(DEFINEQ

(FS.Box
  [LAMBDA (data imageStream)                                 (* thh%: "27-May-87 10:02")
          
          (* determines box within which data will be displayed on imageStream --
          data is a list whose elements are either image objs or lists of the form
          (FontSpec String Shift))
          
          (* added adjustment for shift -- assumes data still spans baseline)

    (for item in data bind (width _ 0)
                           (ascent _ 0)
                           (descent _ 0)
                           (scale _ (DSPSCALE NIL imageStream))
       do (PROG ((itemWidth 0)
                 (itemAscent 0)
                 (itemDescent 0)
                 fullFont imageBox shift)
                [COND
                   ((IMAGEOBJP item)
                    (SETQ imageBox (APPLY* (IMAGEOBJPROP item 'IMAGEBOXFN)
                                          item imageStream))
                    (SETQ itemWidth (fetch XSIZE of imageBox))
                    (SETQ itemAscent (DIFFERENCE (fetch YSIZE of imageBox)
                                            (fetch YDESC of imageBox)))
                    (SETQ itemDescent (fetch YDESC of imageBox)))
                   ((FS.RealStringP item)
                    (SETQ fullFont (FONTCREATE (FS.ItemFont item)
                                          NIL NIL NIL imageStream))
                    (SETQ shift (TIMES scale (FS.ItemShift item)))
                    (SETQ itemWidth (STRINGWIDTH (FS.ItemValue item)
                                           fullFont))
                    [SETQ itemAscent (PLUS shift (FONTPROP fullFont 'ASCENT]
                    (SETQ itemDescent (DIFFERENCE (FONTPROP fullFont 'DESCENT)
                                             shift]
                (add width itemWidth)
                (SETQ ascent (MAX ascent itemAscent))
                (SETQ descent (MAX descent itemDescent)))
       finally (RETURN (create IMAGEBOX
                              XSIZE _ width
                              YSIZE _ (PLUS ascent descent)
                              YDESC _ descent
                              XKERN _ 0])

(FS.Copy
  [LAMBDA (data)                                             (* THH "21-May-85 12:38")
          
          (* constructs a copy of data -- data is a list whose elements are either image 
          objs or lists of the form (FontSpec String))

    (for item in data collect (COND
                                 ((IMAGEOBJP item)
          
          (* note%: COPYALL doesn't call imageobj copyfn so it can't be used here)

                                  (APPLY* (IMAGEOBJPROP item 'COPYFN)
                                         item))
                                 (T (COPYALL item])

(FS.Display
  [LAMBDA (data imageStream invert?)                         (* thh%: "27-May-87 10:02")
          
          (* displays data on imageStream -- data is a list whose elements are either 
          image objs or lists of the form (FontSpec String Shift))
                                                             (* added shift)
    (PROG ((scale (DSPSCALE NIL imageStream))
           xStart yStart)
          [COND
             (invert? (SETQ xStart (DSPXPOSITION NIL imageStream))
                    (SETQ yStart (DSPYPOSITION NIL imageStream]
          [for item in data do (COND
                                  ((IMAGEOBJP item)
                                   (PROG ((xPos (DSPXPOSITION NIL imageStream))
                                          (yPos (DSPYPOSITION NIL imageStream)))
                                         (APPLY* (IMAGEOBJPROP item 'DISPLAYFN)
                                                item imageStream)
                                         (MOVETO (PLUS xPos (fetch XSIZE
                                                               of (APPLY* (IMAGEOBJPROP item
                                                                                 'IMAGEBOXFN)
                                                                         item imageStream)))
                                                yPos imageStream)))
                                  ((FS.RealStringP item)
                                   (PROG [(oldFont (DSPFONT NIL imageStream))
                                          (shift (TIMES scale (FS.ItemShift item]
                                         (DSPFONT (FS.ItemFont item)
                                                imageStream)
                                         (COND
                                            ((NOT (ZEROP shift))
                                             (RELMOVETO 0 shift imageStream)))
                                         (PRIN1 (FS.ItemValue item)
                                                imageStream)
                                         (DSPFONT oldFont imageStream)
                                         (COND
                                            ((NOT (ZEROP shift))
                                             (RELMOVETO 0 (MINUS shift)
                                                    imageStream]
          (COND
             (invert? (PROG ((box (FS.Box data imageStream)))
                            (DSPFILL (create REGION
                                            LEFT _ xStart
                                            BOTTOM _ (DIFFERENCE yStart (fetch YDESC of box))
                                            WIDTH _ (fetch XSIZE of box)
                                            HEIGHT _ (fetch YSIZE of box))
                                   BLACKSHADE
                                   'INVERT imageStream])

(FS.Get
  [LAMBDA (fileStream)                                       (* thh%: "13-Jun-85 09:17")
          
          (* reads data from fileStream -- data is a list whose elements are either image 
          objs or lists of the form (FontSpec String))
                                                             (* also reads a list of such data 
                                                             items)
    (HREAD fileStream])

(FS.Put
  [LAMBDA (data fileStream)                                  (* THH " 2-May-85 14:31")
          
          (* puts data on fileStream -- data is a list whose elements are either image 
          objs or lists of the form (FontSpec String))
                                                             (* also writes a list of such data 
                                                             items)
    (HPRINT data fileStream])

(FS.ItemFont
  [LAMBDA (dataItem)                                         (* thh%: "15-May-85 11:29")
                                                             (* returns font spec of single data 
                                                             item)
    (COND
       ((LISTP dataItem)
        (CAR dataItem))
       (T NIL])

(FS.ItemValue
  [LAMBDA (dataItem)                                         (* THH "21-May-85 12:28")
                                                             (* returns string of single data item 
                                                             or image object)
    (COND
       ((LISTP dataItem)
        (CADR dataItem))
       ((IMAGEOBJP dataItem)
        dataItem])

(FS.ItemShift
  [LAMBDA (dataItem)                                         (* thh%: "27-May-87 09:57")
                                                             (* shift is number of points to move 
                                                             up)
    (COND
       ((LISTP dataItem)
        (OR (CADDR dataItem)
            0))
       (T 0])

(FS.MakeItem
  [LAMBDA (fontSpec string shift)                            (* thh%: "27-May-87 09:48")
                                                             (* makes data item from fontSpec and 
                                                             string with shift)
    (COND
       ((AND shift (NOT (ZEROP shift)))
        (LIST fontSpec string shift))
       (T (LIST fontSpec string])

(FS.Extract
  [LAMBDA (stream)                                           (* thh%: "27-May-87 10:23")
                                                             (* extracts data from TEdit stream)
    (SETFILEPTR stream 0)                                    (* BIN gets imageObj or individual 
                                                             characters)
    (PROG ((EOFptr (GETEOFPTR stream))
           (CHcount 0)
           data result)
          [SETQ data (while (ILESSP CHcount EOFptr) collect (add CHcount 1)
                                                          (CONS CHcount (BIN stream]
                                                             (* data has (ch# . item))
                                                             (* now combine characters into strings 
                                                             and get font information)
          [SETQ data (for item in data collect item unless (AND (NUMBERP (CDR item))
                                                                (NOT (FS.AllowedChar (CDR item]
                                                             (* remove control characters, e.g.
                                                             CR, LF, tab...)
          [SETQ result (while data bind item fontSpec shift
                          collect (SETQ item (CAR data))
                                (SETQ data (CDR data)) 
          
          (* note that imageobjs are not copied so changes to returned obj will also 
          change original)

                                (COND
                                   ((IMAGEOBJP (CDR item)))
                                   (T (SETQ fontSpec (FS.ExtractFont stream (CAR item)))
                                      (SETQ shift (FS.ExtractShift stream (CAR item)))
                                      (PROG ([string (MKSTRING (CHARACTER (CDR item]
                                             (nextItem (CAR data)))
                                            (while [AND nextItem (NOT (IMAGEOBJP (CDR nextItem)))
                                                        (EQUAL fontSpec (FS.ExtractFont stream
                                                                               (CAR nextItem)))
                                                        (EQUAL shift (FS.ExtractShift stream
                                                                            (CAR nextItem]
                                               do [SETQ string (CONCAT string (CHARACTER (CDR 
                                                                                             nextItem
                                                                                              ]
                                                  (SETQ data (CDR data))
                                                  (SETQ nextItem (CAR data)))
                                            (RETURN (FS.MakeItem fontSpec string shift]
          (RETURN (COND
                     ((AND result (FS.RealStringP (CAR result)))
                                                             (* first item is a string)
                      result)
                     (T 
          
          (* preserve initial font by including a null string item at beginning of list)
                                                             (* this item has zero shift)
                        (CONS (FS.MakeItem (FS.ExtractFont stream (COND
                                                                     ((ZEROP EOFptr)
                                                                      NIL)
                                                                     (T 1)))
                                     "")
                              result])

(FS.ExtractFont
  [LAMBDA (stream selOrCh#)                                  (* thh%: "20-Feb-86 14:05")
                                                             (* gets font spec for specified 
                                                             selection)
    (PROG ((looks (TEDIT.GET.LOOKS stream selOrCh#)))
          (RETURN (LIST (LISTGET looks 'FAMILY)
                        (LISTGET looks 'SIZE)
                        (LIST (LISTGET looks 'WEIGHT)
                              (LISTGET looks 'SLOPE)
                              (LISTGET looks 'EXPANSION])

(FS.ExtractShift
  [LAMBDA (stream selOrCh#)                                  (* thh%: "27-May-87 10:26")
                                                             (* gets upward shift in points for 
                                                             specified selection)
    (LET ((looks (TEDIT.GET.LOOKS stream selOrCh#))
          shift)
         (COND
            ((SETQ shift (LISTGET looks 'SUPERSCRIPT))
             shift)
            ((SETQ shift (LISTGET looks 'SUBSCRIPT))
             (MINUS shift))
            (T 0])

(FS.Insert
  [LAMBDA (data stream)                                      (* thh%: "27-May-87 10:43")
                                                             (* inserts data list into TEdit stream)
    (for item in data bind (length _ 0)
                           shift do [COND
                                       ((IMAGEOBJP item)
                                        (add length 1)
                                        (TEDIT.INSERT.OBJECT item stream))
                                       [(FS.RealStringP item)
                                        (add length (NCHARS (FS.ItemValue item)))
                                        (SETQ shift (FS.ItemShift item))
                                        (COND
                                           [(ZEROP shift)
                                            (TEDIT.INSERT stream (FS.ItemValue item)
                                                   NIL
                                                   (FONTCREATE (FS.ItemFont item]
                                           [(MINUSP shift)
                                            (TEDIT.INSERT stream (FS.ItemValue item)
                                                   NIL
                                                   `(FONT ,(FS.ItemFont item) SUBSCRIPT
                                                          ,(MINUS shift]
                                           (T (TEDIT.INSERT stream (FS.ItemValue item)
                                                     NIL
                                                     `(FONT ,(FS.ItemFont item) SUPERSCRIPT
                                                            ,shift]
                                       (T                    (* null string -- preserve font info)
                                          (TEDIT.CARETLOOKS stream (FONTCREATE (FS.ItemFont item]
       finally (RETURN length])

(FS.AllowedChar
  [LAMBDA (charcode)                                         (* thh%: "19-Aug-85 08:29")
          
          (* returns T if charcode can be included in format strings)

    (IGEQ charcode (CHARCODE " "])

(FS.RealStringP
  [LAMBDA (item nullOk)                                      (* thh%: "31-Jul-85 08:11")
    (AND (LISTP item)
         (OR nullOk (NOT (EQUAL "" (FS.ItemValue item])
)



(* ;;; "Now load EQUATIONFORMS")

(FILESLOAD EQUATIONFORMS)
(PUTPROPS EQUATIONS COPYRIGHT ("Xerox Corporation" 1986 1987 1988))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (4524 19553 (EQIO.CreateFns 4534 . 5067) (EQIO.Create 5069 . 6335) (EQIO.Imagebox 6337
 . 6749) (EQIO.Display 6751 . 8362) (EQIO.ButtonEventIn 8364 . 12205) (EQIO.Copy 12207 . 12588) (
EQIO.CopyList 12590 . 13161) (EQIO.Get 13163 . 13571) (EQIO.Put 13573 . 14128) (EQIO.WhenDeleted 14130
 . 14624) (EQIO.SelectRegion 14626 . 15773) (EQIO.Selection 15775 . 17279) (EQIO.DefaultSelectFn 17281
 . 18519) (EQIO.MakeSelectionMenu 18521 . 19551)) (19627 25629 (EQIO.EqnType 19637 . 19888) (
EQIO.EqnDataList 19890 . 20230) (EQIO.SetDataList 20232 . 20629) (EQIO.EqnData 20631 . 20810) (
EQIO.EqnProperty 20812 . 21740) (EQIO.AllProps 21742 . 22257) (EQIO.Specify 22259 . 22756) (
EQIO.GetInitialProps 22758 . 23890) (EQIO.NumPieces 23892 . 25135) (EQIO.NewStructure 25137 . 25627)) 
(25696 30158 (EQIO.AddType 25706 . 26219) (EQIO.GetInfo 26221 . 26571) (EQIO.SetInfo 26573 . 27214) (
EQIO.TypeProp 27216 . 28162) (EQIO.ResetTypeProps 28164 . 28486) (EQIO.IsDefined 28488 . 28773) (
EQIO.GetBox 28775 . 28995) (EQIO.GetDataSpec 28997 . 29330) (EQIO.GetDataSpecList 29332 . 29477) (
EQIO.GetDataPosition 29479 . 29619) (EQIO.GetDataSelectRegion 29621 . 29765) (EQIO.MakeSpec 29767 . 
30003) (EQIO.MakeDataSpec 30005 . 30156)) (31711 48815 (EQN.AbortEdit 31721 . 32233) (EQN.StopEdit 
32235 . 32682) (EQN.ContinueEdit 32684 . 36336) (EQN.FinishEdit 36338 . 37071) (EQN.MakeEditWindow 
37073 . 38492) (EQN.SetUpEdit 38494 . 39671) (EQN.StartEdit 39673 . 42974) (EQN.StartNextEdit 42976 . 
43493) (EQN.UpdateEdit 43495 . 44892) (EQN.DefaultData 44894 . 47579) (EQN.TypeMenu 47581 . 48813)) (
48882 56790 (EQN.Equation 48892 . 50151) (EQN.NextPiece 50153 . 50878) (EQN.FinishEqn 50880 . 51409) (
EQN.NoUpdateAbort 51411 . 51824) (EQN.PreventUpdate 51826 . 52261) (EQN.CharFn 52263 . 54348) (
EQN.TEditSpecialChar 54350 . 55069) (EQN.SnuggleWindows 55071 . 55662) (EQN.SnuggleMainWindow 55664 . 
56788)) (56844 58583 (EQN.EquationFontNumber 56854 . 57613) (EQN.EquationFont 57615 . 57957) (
EQN.GetEqnFont 57959 . 58140) (EQN.MakeFS 58142 . 58581)) (58612 61753 (EQN.AdjustWindow 58622 . 60582
) (EQN.CheckWindowSize 60584 . 61751)) (61754 67638 (EQN.SubEditorP 61764 . 61997) (EQN.WindowFromText
 61999 . 62656) (EQN.EditWindow 62658 . 63736) (EQN.ResultWindow 63738 . 64288) (EQN.ResultObj 64290
 . 64758) (EQN.PieceNumber 64760 . 65309) (EQN.ContinueFlg 65311 . 65874) (EQN.ValidEditWindow 65876
 . 66310) (EQN.ObjEditWindow 66312 . 67636)) (67639 68756 (EQN.Make 67649 . 68754)) (69964 85899 (
FS.Box 69974 . 72220) (FS.Copy 72222 . 72862) (FS.Display 72864 . 75850) (FS.Get 75852 . 76321) (
FS.Put 76323 . 76794) (FS.ItemFont 76796 . 77157) (FS.ItemValue 77159 . 77565) (FS.ItemShift 77567 . 
77947) (FS.MakeItem 77949 . 78371) (FS.Extract 78373 . 82297) (FS.ExtractFont 82299 . 82902) (
FS.ExtractShift 82904 . 83467) (FS.Insert 83469 . 85458) (FS.AllowedChar 85460 . 85697) (
FS.RealStringP 85699 . 85897)))))
STOP
