(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "22-Dec-2021 10:37:46" 
{DSK}<Users>kaplan>Local>medley3.5>my-medley>lispusers>comparetext.;20 39405  

      :CHANGES-TO (FNS IMCOMPARE.COLLECT.HASH.CHUNKS COMPARETEXT)
                  (RECORDS IMCOMPARE.CHUNK)

      :PREVIOUS-DATE "19-Dec-2021 12:45:35" 
{DSK}<Users>kaplan>Local>medley3.5>my-medley>lispusers>comparetext.;19)


(* ; "
Copyright (c) 1984-1985, 1993, 1998 by Xerox Corporation.
")

(PRETTYCOMPRINT COMPARETEXTCOMS)

(RPAQQ COMPARETEXTCOMS
       ((FNS COMPARETEXT IMCOMPARE.BOXNODE IMCOMPARE.CHUNKS IMCOMPARE.COLLECT.HASH.CHUNKS 
             IMCOMPARE.DISPLAY.FILE.DIFFERENCE.GRAPH IMCOMPARE.FIND.TEDIT.TEXT.OBJECT IMCOMPARE.HASH
             IMCOMPARE.LEFTBUTTONFN IMCOMPARE.LENGTHEN.ATOM IMCOMPARE.MERGE.CONNECTED.CHUNKS 
             IMCOMPARE.MERGE.UNCONNECTED.CHUNKS IMCOMPARE.MIDDLEBUTTONFN IMCOMPARE.SHOW.DIST 
             IMCOMPARE.UPDATE.SYMBOL.TABLE)
        (P (MOVD 'COMPARETEXT 'IMCOMPARE))
        (INITVARS (IMCOMPARE.LAST.NODE NIL)
               (IMCOMPARE.LAST.GRAPH.WINDOW NIL))
        (RECORDS IMCOMPARE.CHUNK IMCOMPARE.SYMB)
        (FILES (SYSLOAD)
               GRAPHER)
        (DECLARE%: EVAL@COMPILE DONTCOPY (FILES (LOADCOMP)
                                                GRAPHER))))
(DEFINEQ

(COMPARETEXT
  [LAMBDA (NEWFILENAME OLDFILENAME HASH.TYPE GRAPH.REGION FILELABELS)
                                                             (* ; "Edited 22-Dec-2021 10:35 by rmk")
                                                             (* ; "Edited 15-Dec-2021 16:23 by rmk")
                                                             (* ; "Edited 13-Dec-2021 12:21 by rmk")
                                                             (* ; "Edited  8-Nov-2021 08:44 by rmk:")
                                                             (* mjs " 8-Jan-84 21:06")

    (* ;; "Compares the two files, and produces a graph showing their corresponding chunks.  The courseness of the 'chunking' is determined by HASH.TYPE, which may be PARA, LINE, or WORD.  HASH.TYPE = NIL defaults to PARA.  The file difference graph is displayed at GRAPHREGION.  If GRAPH.REGION = NIL, the user is asked to specify a region.  If GRAPH.REGION = T, a standard region is used.")

    (SELECTQ HASH.TYPE
        ((PARA LINE WORD))
        (NIL (SETQ HASH.TYPE 'PARA))
        (ERROR (CONCAT "Unrecognize HASHTYPE " HASH.TYPE)))
    (LET ((NEWFILE (FINDFILE NEWFILENAME T))
          (OLDFILE (FINDFILE OLDFILENAME T)))
         (CL:UNLESS (AND OLDFILE NEWFILE)
             (ERROR "Can't find both files" (LIST NEWFILENAME OLDFILENAME)))
         (IMCOMPARE.CHUNKS (create IMCOMPARE.CHUNK
                                  FILENAME _ NEWFILE
                                  FILEPTR _ 0)
                (create IMCOMPARE.CHUNK
                       FILENAME _ OLDFILE
                       FILEPTR _ 0)
                HASH.TYPE
                (if (EQ GRAPH.REGION T)
                    then (create REGION
                                LEFT _ 25
                                BOTTOM _ 25
                                WIDTH _ 500
                                HEIGHT _ 150)
                  elseif GRAPH.REGION
                  else (CLRPROMPT)
                       (printout PROMPTWINDOW "Please specify a window for the file difference graph"
                              T)
                       (GETREGION))
                FILELABELS])

(IMCOMPARE.BOXNODE
  [LAMBDA (NODE WINDOW)                                  (* rmk%: "14-Dec-84 13:40")
    (if IMCOMPARE.LAST.NODE
        then (RESET/NODE/BORDER IMCOMPARE.LAST.NODE 'INVERT IMCOMPARE.LAST.GRAPH.WINDOW)
              (SETQ IMCOMPARE.LAST.NODE NIL)
              (SETQ IMCOMPARE.LAST.GRAPH.WINDOW NIL))
    (if NODE
        then (RESET/NODE/BORDER NODE 'INVERT WINDOW)
              (SETQ IMCOMPARE.LAST.NODE NODE)
              (SETQ IMCOMPARE.LAST.GRAPH.WINDOW WINDOW])

(IMCOMPARE.CHUNKS
  [LAMBDA (NEWFILE.SPEC.CHUNK OLDFILE.SPEC.CHUNK HASH.TYPE GRAPH.REGION FILELABELS)
                                                             (* ; "Edited 18-Dec-2021 13:21 by rmk")
                                                             (* ; "Edited 15-Dec-2021 16:28 by rmk")
                                                             (* ; "Edited 13-Dec-2021 12:32 by rmk")
                                                             (* rmk%: " 8-Sep-84 00:06")

    (* ;; "This is the main text-comparison function.  It compares the text in the two chunks <which may be small pieces of files, or entire files> and produces a graph showing how the sub-chunks of the two main chunks are related.  The two main chunks may be in the same file, and the file may actually be an open Tedit textstream.  The main chunks are broken down according to HASH.TYPE, which may be PARA <chunk by paragraph>, LINE, WORD,  or  PARA.  The file difference graph is displayed at GRAPH.REGION.")

    (* ;; "This text comparison algorithm is originally from the article 'A Technique for Isolating Differences Between Files' by Paul Heckel, in CACM, V21, #4, April 1978 --- major difference is that I use lists instead of arrays")

    (* ;; "")

    (* ;; "Collect lists of chunks from each of the main chunks, dividing them according to HASH.TYPE.  We start with whole-file chunks to provide the interface that the")

    (LET ((CHUNK.SYMBOL.TABLE (HASHARRAY 500))
          (NEWFILE.CHUNK.LIST (IMCOMPARE.COLLECT.HASH.CHUNKS NEWFILE.SPEC.CHUNK HASH.TYPE))
          (OLDFILE.CHUNK.LIST (IMCOMPARE.COLLECT.HASH.CHUNKS OLDFILE.SPEC.CHUNK HASH.TYPE)))

         (* ;; "Update the chunk symbol table.  For each hash value, this table records the number of 'new' chunks with that hash value, the number of 'old' chunks with that value, and a pointer to the place in OLD.CHUNK.LIST <not to an OLD c hunk itself>.")

         (IMCOMPARE.UPDATE.SYMBOL.TABLE NEWFILE.CHUNK.LIST CHUNK.SYMBOL.TABLE NIL)
         (IMCOMPARE.UPDATE.SYMBOL.TABLE OLDFILE.CHUNK.LIST CHUNK.SYMBOL.TABLE T)

         (* ;; "For every new chunk whose hash value matches EXACTLY ONE old chunk's value, 'connect' it to the old chunk by setting the new chunk's OTHERCHUNK field to point to the appropriate place in the old chunk list <not the old chunk directly>.  Also, make sure that OTHERCHUNK of the matching old chunk is non-NIL, so that unconnected old chunks will be merged correctly.")

         (for NEW.CHUNK in NEWFILE.CHUNK.LIST bind SYMB
            do (SETQ SYMB (GETHASH (fetch (IMCOMPARE.CHUNK HASHVALUE) of NEW.CHUNK)
                                 CHUNK.SYMBOL.TABLE))
               (if (AND (EQ 1 (fetch (IMCOMPARE.SYMB NEWCOUNT) of SYMB))
                        (EQ 1 (fetch (IMCOMPARE.SYMB OLDCOUNT) of SYMB)))
                   then (replace (IMCOMPARE.CHUNK OTHERCHUNK) of NEW.CHUNK with (fetch (
                                                                                       IMCOMPARE.SYMB
                                                                                        OLDPTR)
                                                                                   of SYMB))
                        (replace (IMCOMPARE.CHUNK OTHERCHUNK) of (CAR (fetch (IMCOMPARE.SYMB OLDPTR)
                                                                         of SYMB)) with T)))

         (* ;; "Merge connected chunks forward")

         (IMCOMPARE.MERGE.CONNECTED.CHUNKS NEWFILE.CHUNK.LIST NIL)

         (* ;; "Merge connected chunks backwards")

         (SETQ NEWFILE.CHUNK.LIST (DREVERSE NEWFILE.CHUNK.LIST))
         (SETQ OLDFILE.CHUNK.LIST (DREVERSE OLDFILE.CHUNK.LIST))
         (IMCOMPARE.MERGE.CONNECTED.CHUNKS NEWFILE.CHUNK.LIST T)
         (SETQ NEWFILE.CHUNK.LIST (DREVERSE NEWFILE.CHUNK.LIST))
         (SETQ OLDFILE.CHUNK.LIST (DREVERSE OLDFILE.CHUNK.LIST))

         (* ;; "Merge unconnected chunks")

         (IMCOMPARE.MERGE.UNCONNECTED.CHUNKS NEWFILE.CHUNK.LIST)
         (IMCOMPARE.MERGE.UNCONNECTED.CHUNKS OLDFILE.CHUNK.LIST)

         (* ;; "The file comparison is complete.  Format and display the file difference graph")

         (IMCOMPARE.DISPLAY.FILE.DIFFERENCE.GRAPH NEWFILE.SPEC.CHUNK OLDFILE.SPEC.CHUNK HASH.TYPE 
                GRAPH.REGION NEWFILE.CHUNK.LIST OLDFILE.CHUNK.LIST FILELABELS])

(IMCOMPARE.COLLECT.HASH.CHUNKS
  [LAMBDA (CHUNK HASH.TYPE)                                  (* ; "Edited 22-Dec-2021 10:37 by rmk")
                                                             (* ; "Edited 13-Dec-2021 16:32 by rmk")
                                                             (* ; "Edited 23-Dec-98 16:54 by rmk:")
                                                             (* mjs " 8-Jan-84 20:57")

(* ;;; "Returns a list of the chunks inside CHUNK as hashed of type HASH.TYPE.  Presumably CHUNK is is higher on the ranking PARA > LINE >.  WORD.  The initial CHUNK covers the whole file, middle-mouse refinement-chunks cover only subsections.")

    (* ;; "It is overkill to open raw text streams as TEDIT stream.  So we open, test for TEDIT and if so, close and reoopen.  TEDIT may not yet honor external formats other than XCCS for rawtext files.")

    (BIND (FILENAME _ (fetch (IMCOMPARE.CHUNK FILENAME) of CHUNK))
          STREAM ENDPOS FIRST (SETQ STREAM (OPENSTREAM FILENAME 'INPUT 'OLD))
                              (CL:WHEN (\TEDIT.FORMATTEDP1 STREAM)
                                  (CLOSEF STREAM)            (* ; 
                                               "The OBJECTCHAR is produced in place of image objects")
                                  [SETQ STREAM (OPENTEXTSTREAM FILENAME NIL NIL NIL
                                                      `(OBJECTBYTE ,(CHARCODE NULL])
                              (SETFILEINFO STREAM 'EOL 'ANY)
                              (CL:UNLESS (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of CHUNK)

                                  (* ;; 
                         "For TEDIT files, the character length isn't known until after text-opening")

                                  (REPLACE (IMCOMPARE.CHUNK CHUNKLENGTH) of CHUNK
                                     WITH (GETFILEINFO STREAM 'LENGTH)))
                              (SETFILEPTR STREAM (fetch (IMCOMPARE.CHUNK FILEPTR) of CHUNK))
                              (SETQ ENDPOS (IPLUS (fetch (IMCOMPARE.CHUNK FILEPTR) of CHUNK)
                                                  (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of CHUNK)))
       WHILE (SETQ CHUNK (IMCOMPARE.HASH STREAM HASH.TYPE ENDPOS))
       COLLECT (REPLACE FILENAME OF CHUNK WITH FILENAME)
             CHUNK FINALLY (CLOSEF STREAM])

(IMCOMPARE.DISPLAY.FILE.DIFFERENCE.GRAPH
  [LAMBDA (NEWFILE.SPEC.CHUNK OLDFILE.SPEC.CHUNK HASH.TYPE GRAPH.REGION NEWFILE.CHUNK.LIST 
                 OLDFILE.CHUNK.LIST FILELABELS)              (* ; "Edited 18-Dec-2021 13:16 by rmk")
                                                             (* ; "Edited 16-Dec-2021 10:48 by rmk")
                                                             (* ; "Edited 13-Dec-2021 12:19 by rmk")
                                                             (* mjs "11-Jul-85 09:10")

(* ;;; "format and display the graph")

    (LET ((NEWFILENAME (fetch (IMCOMPARE.CHUNK FILENAME) of NEWFILE.SPEC.CHUNK))
          (OLDFILENAME (fetch (IMCOMPARE.CHUNK FILENAME) of OLDFILE.SPEC.CHUNK))
          NEWFILELABEL OLDFILELABEL (OLD.CHUNK.NODE.FROM.NODES NIL)
          (BORDERSIZE 1)
          GRAPH.WINDOW NEW.CHUNK.NODES OLD.CHUNK.NODES OLD.CHUNK.XCOORD NEW.CHUNK.XCOORD 
          YCOORD.INCREMENT DIFF.GRAPH)

(* ;;; "set up GRAPH.WINDOW.  This is done first so you can get the width and height of strings to be printed in the window.")

         (SETQ NEWFILELABEL (OR (CAR (LISTP FILELABELS))
                                NEWFILENAME))
         (SETQ OLDFILELABEL (OR (CADR (LISTP FILELABELS))
                                OLDFILENAME))
         [SETQ GRAPH.WINDOW (CREATEW GRAPH.REGION (CONCAT "Text File Differences, hashed by "
                                                         (SELECTQ HASH.TYPE
                                                             ((PARA NIL) 
                                                                  "Paragraph")
                                                             (LINE "Line")
                                                             (WORD "Word")
                                                             (SHOULDNT]
         (WINDOWPROP GRAPH.WINDOW 'IMPARE.HASH.TYPE HASH.TYPE)
         [WINDOWADDPROP GRAPH.WINDOW 'CLOSEFN (FUNCTION (LAMBDA (WINDOW)
                                                          (if (EQ WINDOW IMCOMPARE.LAST.GRAPH.WINDOW)
                                                              then (SETQ IMCOMPARE.LAST.GRAPH.WINDOW
                                                                    NIL)
                                                                   (SETQ IMCOMPARE.LAST.NODE NIL]
         (SETQ NEW.CHUNK.XCOORD (IQUOTIENT (STRINGWIDTH NEWFILELABEL GRAPH.WINDOW)
                                       2))
         [SETQ OLD.CHUNK.XCOORD (IPLUS NEW.CHUNK.XCOORD (IMAX 100 (IPLUS NEW.CHUNK.XCOORD
                                                                         (IQUOTIENT (STRINGWIDTH
                                                                                     OLDFILELABEL 
                                                                                     GRAPH.WINDOW)
                                                                                2)
                                                                         20]
         [SETQ YCOORD.INCREMENT (IMINUS (IPLUS 2 (ITIMES 2 BORDERSIZE)
                                               (fetch (REGION HEIGHT) of (STRINGREGION NEWFILELABEL 
                                                                                GRAPH.WINDOW]

(* ;;; "collect new-chunk graph nodes, while accumulating OLD.CHUNK.NODE.FROM.NODES, assoc list from old-chunks to new-chunks")

         (SETQ NEW.CHUNK.NODES (for NEW.CHUNK in NEWFILE.CHUNK.LIST as Y from YCOORD.INCREMENT
                                  by YCOORD.INCREMENT bind CORRESPONDING.OLD.CHUNK
                                  collect (SETQ CORRESPONDING.OLD.CHUNK (CAR (fetch (IMCOMPARE.CHUNK
                                                                                     OTHERCHUNK)
                                                                                of NEW.CHUNK)))
                                        (if CORRESPONDING.OLD.CHUNK
                                            then (SETQ OLD.CHUNK.NODE.FROM.NODES
                                                  (CONS (CONS CORRESPONDING.OLD.CHUNK NEW.CHUNK)
                                                        OLD.CHUNK.NODE.FROM.NODES))) 
                                                             (* ; 
                                           "Start out with 2 point white border, so we can invert it")
                                        (NODECREATE NEW.CHUNK (IMCOMPARE.LENGTHEN.ATOM
                                                               (PACK* (fetch (IMCOMPARE.CHUNK FILEPTR
                                                                                    ) of NEW.CHUNK)
                                                                      ":"
                                                                      (fetch (IMCOMPARE.CHUNK 
                                                                                    CHUNKLENGTH)
                                                                         of NEW.CHUNK))
                                                               12)
                                               (create POSITION
                                                      XCOORD _ NEW.CHUNK.XCOORD
                                                      YCOORD _ Y)
                                               (if CORRESPONDING.OLD.CHUNK
                                                   then (LIST CORRESPONDING.OLD.CHUNK)
                                                 else NIL)
                                               NIL DEFAULTFONT -2)))
         (SETQ OLD.CHUNK.NODES (for OLD.CHUNK in OLDFILE.CHUNK.LIST as Y from YCOORD.INCREMENT
                                  by YCOORD.INCREMENT bind CORRESPONDING.NEW.CHUNK
                                  collect (SETQ CORRESPONDING.NEW.CHUNK (CDR (ASSOC OLD.CHUNK 
                                                                            OLD.CHUNK.NODE.FROM.NODES
                                                                                    )))
                                        (NODECREATE OLD.CHUNK (IMCOMPARE.LENGTHEN.ATOM
                                                               (PACK* (fetch (IMCOMPARE.CHUNK FILEPTR
                                                                                    ) of OLD.CHUNK)
                                                                      ":"
                                                                      (fetch (IMCOMPARE.CHUNK 
                                                                                    CHUNKLENGTH)
                                                                         of OLD.CHUNK))
                                                               12 "-")
                                               (create POSITION
                                                      XCOORD _ OLD.CHUNK.XCOORD
                                                      YCOORD _ Y)
                                               NIL
                                               (if CORRESPONDING.NEW.CHUNK
                                                   then (LIST CORRESPONDING.NEW.CHUNK)
                                                 else NIL)
                                               DEFAULTFONT -2)))
         (SETQ DIFF.GRAPH (create GRAPH
                                 DIRECTEDFLG _ T
                                 SIDESFLG _ T
                                 GRAPHNODES _
                                 (NCONC (LIST (NODECREATE NEWFILENAME NEWFILELABEL
                                                     (create POSITION
                                                            XCOORD _ NEW.CHUNK.XCOORD
                                                            YCOORD _ 0)
                                                     NIL NIL DEFAULTFONT -2))
                                        NEW.CHUNK.NODES
                                        (LIST (NODECREATE OLDFILENAME OLDFILELABEL
                                                     (create POSITION
                                                            XCOORD _ OLD.CHUNK.XCOORD
                                                            YCOORD _ 0)
                                                     NIL NIL DEFAULTFONT -2))
                                        OLD.CHUNK.NODES)))
         (GRAPHERPROP DIFF.GRAPH 'FILELABELS (LIST NEWFILELABEL OLDFILELABEL))
                                                             (* ; 
                                                    "So Middle mouse graphs can get the right labels")
         (GRAPHERPROP DIFF.GRAPH 'HASH.TYPE HASH.TYPE)
         (SHOWGRAPH DIFF.GRAPH GRAPH.WINDOW (FUNCTION IMCOMPARE.LEFTBUTTONFN)
                (FUNCTION IMCOMPARE.MIDDLEBUTTONFN)
                T NIL])

(IMCOMPARE.FIND.TEDIT.TEXT.OBJECT
  [LAMBDA (FILE)                                             (* ; "Edited 16-Dec-2021 08:40 by rmk")
                                                             (* mjs " 2-Jan-84 16:19")

    (* ;; "returns the Tedit text object of the first Tedit window which is currently looking at FILE, if there is one.  Returns NIL if none is found.")

    (for W in (OPENWINDOWS) bind POSS.TOBJ when [AND (SETQ POSS.TOBJ (WINDOWPROP W 'TEXTOBJ))
                                                     (EQ FILE (FULLNAME (fetch (TEXTOBJ TXTFILE)
                                                                           of POSS.TOBJ]
       unless (TEDIT.STREAMCHANGEDP POSS.TOBJ) do (RETURN POSS.TOBJ])

(IMCOMPARE.HASH
  [LAMBDA (STREAM HASH.TYPE ENDPOS)                          (* ; "Edited 19-Dec-2021 09:07 by rmk")
                                                             (* ; "Edited 15-Dec-2021 15:58 by rmk")
                                                             (* ; "Edited 13-Dec-2021 16:35 by rmk")
                                                             (* ; "Edited 23-Dec-98 16:58 by rmk:")

    (* ;; "IMCOMPARE.HASH automatically stops before reading char number EOF.PTR.")

    (* ;; "Returns an IMCOMPARE.CHUNK containing the hash value, the file pointer of the beginning of the chunk, the length of the chunk, and the fullname of the stream")

    (* ;; "Note: Most of the time in COMPARETEXT is spent reading in and hashing chunks, so this function was optimizes for speed, at the expense of length")

    (LET ((STARTPOS (GETFILEPTR STREAM))
          (HASHNUM 0)
          C NBYTES)
         (DECLARE (SPECVARS NBYTES))
         (SETQ NBYTES (IDIFFERENCE ENDPOS STARTPOS))         (* ; 
                                            "\INCCODE counts down. We reach NBYTES only on the chunk")

         (* ;; "Don't hash on white space")

         (CL:WHEN (IGREATERP NBYTES 0)
             (SELECTQ HASH.TYPE
                 (PARA                                       (* ; 
                                                   "Paragraph chunks end with two consecutive EOL's.")
                       (BIND EOLSEEN WHILE (IGREATERP NBYTES 0)
                          DO (SELCHARQ (SETQ C (\INCCODE.EOLC STREAM NIL 'NBYTES NBYTES))
                                  (EOL (CL:WHEN EOLSEEN (RETURN))
                                       (SETQ EOLSEEN T)      (* ; "Skip the NIL SETQ below")
                                       (GO $$ITERATE))
                                  ((SPACE TAB))
                                  (SETQ HASHNUM (ROT (ROT (ROT (LOGXOR HASHNUM C)
                                                               1 16)
                                                          1 16)
                                                     1 16)))
                             (SETQ EOLSEEN NIL)))
                 (LINE                                       (* ; "Line chunks end on EOL.")
                       [WHILE (IGREATERP NBYTES 0)
                          DO (SELCHARQ (SETQ C (\INCCODE.EOLC STREAM NIL 'NBYTES NBYTES))
                                  (EOL (RETURN))
                                  ((SPACE TAB))
                                  (SETQ HASHNUM (ROT (ROT (ROT (LOGXOR HASHNUM C)
                                                               1 16)
                                                          1 16)
                                                     1 16])
                 (WORD                                       (* ; 
                                                             "word chunks end on any white space")
                       [WHILE (IGREATERP NBYTES 0)
                          DO (SELECTQ (SETQ C (\INCCODE.EOLC STREAM NIL 'NBYTES NBYTES))
                                 ((SPACE EOL TAB) 
                                      (RETURN))
                                 (SETQ HASHNUM (ROT (ROT (ROT (LOGXOR HASHNUM C)
                                                              1 16)
                                                         1 16)
                                                    1 16])
                 (SHOULDNT))                                 (* ; 
                                                            "flush all white space before next chunk")
             (WHILE (IGREATERP NBYTES 0) DO (SELCHARQ (\INCCODE.EOLC STREAM NIL 'NBYTES NBYTES)
                                                 ((EOL SPACE TAB))
                                                 (RETURN)))
             (CREATE IMCOMPARE.CHUNK
                    HASHVALUE _ HASHNUM
                    FILEPTR _ STARTPOS
                    CHUNKLENGTH _ (IDIFFERENCE (GETFILEPTR STREAM)
                                         STARTPOS)))])

(IMCOMPARE.LEFTBUTTONFN
  [LAMBDA (GNODE WINDOW)                                     (* ; "Edited 18-Dec-2021 13:02 by rmk")
                                                             (* mjs " 2-Apr-85 14:21")
    (if GNODE
        then (LET ((NODEID (fetch (GRAPHNODE NODEID) of GNODE)))
                  (IF (FIXP (CAR NODEID))
                      THEN (IMCOMPARE.BOXNODE GNODE WINDOW)
                           [LET ((FILEPTR 1)
                                 (CHUNKLENGTH 0)
                                 (TEDIT.TEXT.OBJECT NIL)
                                 FILE)
                                (SETQ FILE (fetch (IMCOMPARE.CHUNK FILENAME) of NODEID))
                                (SETQ FILEPTR (fetch (IMCOMPARE.CHUNK FILEPTR) of NODEID))
                                (SETQ CHUNKLENGTH (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of NODEID))
                                (SETQ TEDIT.TEXT.OBJECT (IMCOMPARE.FIND.TEDIT.TEXT.OBJECT FILE))
                                (if TEDIT.TEXT.OBJECT
                                    then (TEDIT.SETSEL TEDIT.TEXT.OBJECT (IMAX 1 (IDIFFERENCE FILEPTR
                                                                                        25))
                                                0
                                                'LEFT)
                                         (TEDIT.NORMALIZECARET TEDIT.TEXT.OBJECT)
                                         (TEDIT.SETSEL TEDIT.TEXT.OBJECT FILEPTR CHUNKLENGTH
                                                'LEFT)
                                         (TEDIT.NORMALIZECARET TEDIT.TEXT.OBJECT)
                                         (TTY.PROCESS (WINDOWPROP (CAR (fetch (TEXTOBJ \WINDOW)
                                                                          of TEDIT.TEXT.OBJECT))
                                                             'PROCESS))
                                  else (TEDIT FILE NIL NIL (LIST 'SEL (LIST FILEPTR CHUNKLENGTH]
                    ELSEIF (AND (LITATOM NODEID)
                                (INFILEP NODEID))
                      THEN 
                           (* ;; 
                           "A file name as a column header, do TEDIT on the whole file, no selection")

                           (TEDIT-SEE NODEID)
                    ELSE (SHOULDNT])

(IMCOMPARE.LENGTHEN.ATOM
  [LAMBDA (X MIN.LENGTH EXTENDER)                            (* ; "Edited 13-Dec-2021 21:18 by rmk")
                                                             (* mjs "30-Dec-83 15:11")

    (* ;; "makes sure that the atom X is at least MIN.LENGTH characters long, by concatenating the first character of EXTENDER (or space, if not given) to the front")

    (IF (ILESSP (NCHARS X)
               MIN.LENGTH)
        THEN (PACK* (ALLOCSTRING (IDIFFERENCE MIN.LENGTH (NCHARS X))
                           (CL:IF EXTENDER
                               (NTHCHAR EXTENDER 1)
                               " "))
                    X)
      ELSE X])

(IMCOMPARE.MERGE.CONNECTED.CHUNKS
  [LAMBDA (NEW.CHUNK.LIST BACKWARDS.FLG)                 (* mjs " 6-Jan-84 10:35")
    (while NEW.CHUNK.LIST bind NEW.CHUNK OLD.CHUNK.PTR
       do (SETQ NEW.CHUNK (CAR NEW.CHUNK.LIST))
             (SETQ OLD.CHUNK.PTR (fetch (IMCOMPARE.CHUNK OTHERCHUNK) of NEW.CHUNK))
             (if [OR (NULL (CDR NEW.CHUNK.LIST))
                         (NULL OLD.CHUNK.PTR)
                         (NULL (CDR OLD.CHUNK.PTR))
                         (NOT (EQP (fetch (IMCOMPARE.CHUNK HASHVALUE) of (CADR NEW.CHUNK.LIST
                                                                                       ))
                                   (fetch (IMCOMPARE.CHUNK HASHVALUE) of (CADR OLD.CHUNK.PTR]
                 then (SETQ NEW.CHUNK.LIST (CDR NEW.CHUNK.LIST))
               else 

         (* next chunks have same hash, so "murge" them into current chunks by adding 
       their chunk lengths to the current chunks, and splicing out the next chunks)

                     [replace (IMCOMPARE.CHUNK CHUNKLENGTH) of NEW.CHUNK
                        with (IPLUS (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of NEW.CHUNK)
                                        (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of (CADR 
                                                                                       NEW.CHUNK.LIST
                                                                                              ]
                     [replace (IMCOMPARE.CHUNK CHUNKLENGTH) of (CAR OLD.CHUNK.PTR)
                        with (IPLUS (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of (CAR 
                                                                                        OLD.CHUNK.PTR
                                                                                             ))
                                        (fetch (IMCOMPARE.CHUNK CHUNKLENGTH) of (CADR 
                                                                                        OLD.CHUNK.PTR
                                                                                              ]
                     [if BACKWARDS.FLG
                         then                            (* if the list is backwards, copy 
                                                           next fileptr)
                               (replace (IMCOMPARE.CHUNK FILEPTR) of NEW.CHUNK
                                  with (fetch (IMCOMPARE.CHUNK FILEPTR) of (CADR 
                                                                                       NEW.CHUNK.LIST
                                                                                             )))
                               (replace (IMCOMPARE.CHUNK FILEPTR) of (CAR OLD.CHUNK.PTR)
                                  with (fetch (IMCOMPARE.CHUNK FILEPTR) of (CADR 
                                                                                        OLD.CHUNK.PTR
                                                                                             ] 
                                                             (* splice chunks out of new and old 
                                                           list)
                     (RPLACD NEW.CHUNK.LIST (CDDR NEW.CHUNK.LIST))
                     (RPLACD OLD.CHUNK.PTR (CDDR OLD.CHUNK.PTR])

(IMCOMPARE.MERGE.UNCONNECTED.CHUNKS
  [LAMBDA (CHUNK.LST)                                    (* mjs " 5-JAN-84 13:58")
    (while CHUNK.LST bind CHUNK do (SETQ CHUNK (CAR CHUNK.LST))
                                              (if (OR (NULL (CDR CHUNK.LST))
                                                          (fetch (IMCOMPARE.CHUNK OTHERCHUNK)
                                                             of CHUNK)
                                                          (fetch (IMCOMPARE.CHUNK OTHERCHUNK)
                                                             of (CADR CHUNK.LST)))
                                                  then (SETQ CHUNK.LST (CDR CHUNK.LST))
                                                else     (* both current chunk and next chunk 
                                                           have no OTHERCHUNK, so merge them)
                                                      [replace (IMCOMPARE.CHUNK CHUNKLENGTH)
                                                         of CHUNK
                                                         with (IPLUS (fetch (IMCOMPARE.CHUNK
                                                                                     CHUNKLENGTH)
                                                                            of CHUNK)
                                                                         (fetch (IMCOMPARE.CHUNK
                                                                                     CHUNKLENGTH)
                                                                            of (CADR CHUNK.LST] 
                                                             (* splice chunks out of new and old 
                                                           list)
                                                      (RPLACD CHUNK.LST (CDDR CHUNK.LST])

(IMCOMPARE.MIDDLEBUTTONFN
  [LAMBDA (GNODE WINDOW)

    (* ;; "Edited 16-Dec-2021 10:55 by rmk: Remove previous HASH.TYPE from the middle mouse menu")
                                                             (* ; "Edited 16-Dec-2021 10:51 by rmk")
                                                             (* mjs " 6-Jan-84 11:37")

    (* ;; "This function is called if the MIDDLE mouse button is pressed over a graph node.  The selected node is IMCOMPARE-ed with the last node selected <which is boxed>.  The type of hashing used <PARA, LINE, or WORD> is selected from a pop-up menu.  If none of the hashing types is selected, the current node is boxed.  The pop-up menu is always located a little above the current cursor position, so a quick double-MIDDLE-click is an easy way to change the current boxed node.")

    (if GNODE
        then (PROG (INNER.HASH.TYPE)
                   (CLRPROMPT)
                   (printout PROMPTWINDOW "Please select the type of hashing you wish." T)
                   [SETQ INNER.HASH.TYPE (MENU (create MENU
                                                      ITEMS _ (REMOVE (GRAPHERPROP
                                                                       (WINDOWPROP WINDOW
                                                                              'GRAPH)
                                                                       'HASH.TYPE)
                                                                     '(PARA LINE WORD))
                                                      MENUOFFSET _
                                                      (create POSITION
                                                             XCOORD _ 20
                                                             YCOORD _ -20]
                   (if (NULL INNER.HASH.TYPE)
                       then                                  (* ; 
                                  "if no hash type is selected, just box the current node and return")
                            (IMCOMPARE.BOXNODE GNODE WINDOW)
                            (RETURN))
                   (if (NULL IMCOMPARE.LAST.NODE)
                       then (CLRPROMPT)
                            (PRIN1 "You must select another graph node first." PROMPTWINDOW)
                            (RETURN))
                   (printout PROMPTWINDOW "Comparing chunks by " INNER.HASH.TYPE T)
                   (IMCOMPARE.CHUNKS (fetch (GRAPHNODE NODEID) of IMCOMPARE.LAST.NODE)
                          (fetch (GRAPHNODE NODEID) of GNODE)
                          INNER.HASH.TYPE
                          (WINDOWPROP WINDOW 'REGION)
                          (GRAPHERPROP (WINDOWPROP WINDOW 'GRAPH)
                                 'FILELABELS])

(IMCOMPARE.SHOW.DIST
  [LAMBDA (LST MAX)                                      (* mjs "30-Dec-83 15:13")
    (PROG ((WINDOW (CREATEW))
           MAX.Y X MAX.X)
          (SETQ MAX.X (WINDOWPROP WINDOW 'WIDTH))
          (SETQ MAX.Y (WINDOWPROP WINDOW 'HEIGHT))
          (for SAMPLE in LST do (SETQ X (FTIMES MAX.X (FQUOTIENT SAMPLE MAX)))
                                           (DRAWLINE X 0 X MAX.Y 1 'PAINT WINDOW])

(IMCOMPARE.UPDATE.SYMBOL.TABLE
  [LAMBDA (CHUNK.LIST CHUNK.SYMBOL.TABLE OLD.CHUNK.FLG)  (* mjs " 8-Jan-84 21:01")

         (* * update the chunk symbol table. For each hash value, this table records the 
       number of "new" chunks with that hash value, the number of "old" chunks with 
       that value, and a pointer to the place in OLD.CHUNK.LIST <not to an OLD chunk 
       itself>.)

    (for CHUNK.PTR on CHUNK.LIST bind CHUNK SYMB
       do (SETQ CHUNK (CAR CHUNK.PTR))
             (SETQ SYMB (if (GETHASH (fetch (IMCOMPARE.CHUNK HASHVALUE) of CHUNK)
                                       CHUNK.SYMBOL.TABLE)
                          else (PUTHASH (fetch (IMCOMPARE.CHUNK HASHVALUE) of CHUNK)
                                          (create IMCOMPARE.SYMB
                                                 NEWCOUNT _ 0
                                                 OLDCOUNT _ 0
                                                 OLDPTR _ NIL)
                                          CHUNK.SYMBOL.TABLE)))
             (if OLD.CHUNK.FLG
                 then                                    (* increment old-chunk count)
                       (replace (IMCOMPARE.SYMB OLDCOUNT) of SYMB
                          with (ADD1 (fetch (IMCOMPARE.SYMB OLDCOUNT) of SYMB))) 

         (* smash old-chunk pointer. Note that it must point to the LIST of old-chunks, 
       rather than to the individual one)

                       (replace (IMCOMPARE.SYMB OLDPTR) of SYMB with CHUNK.PTR)
               else                                      (* increment new-chunk count)
                     (replace (IMCOMPARE.SYMB NEWCOUNT) of SYMB
                        with (ADD1 (fetch (IMCOMPARE.SYMB NEWCOUNT) of SYMB])
)

(MOVD 'COMPARETEXT 'IMCOMPARE)

(RPAQ? IMCOMPARE.LAST.NODE NIL)

(RPAQ? IMCOMPARE.LAST.GRAPH.WINDOW NIL)
(DECLARE%: EVAL@COMPILE

(RECORD IMCOMPARE.CHUNK (HASHVALUE FILEPTR CHUNKLENGTH FILENAME . OTHERCHUNK)
                        FILEPTR _ 1)

(RECORD IMCOMPARE.SYMB (NEWCOUNT OLDCOUNT . OLDPTR))
)

(FILESLOAD (SYSLOAD)
       GRAPHER)
(DECLARE%: EVAL@COMPILE DONTCOPY 

(FILESLOAD (LOADCOMP)
       GRAPHER)
)
(PUTPROPS COMPARETEXT COPYRIGHT ("Xerox Corporation" 1984 1985 1993 1998))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (1334 38876 (COMPARETEXT 1344 . 3554) (IMCOMPARE.BOXNODE 3556 . 4072) (IMCOMPARE.CHUNKS 
4074 . 8592) (IMCOMPARE.COLLECT.HASH.CHUNKS 8594 . 11053) (IMCOMPARE.DISPLAY.FILE.DIFFERENCE.GRAPH 
11055 . 20136) (IMCOMPARE.FIND.TEDIT.TEXT.OBJECT 20138 . 20912) (IMCOMPARE.HASH 20914 . 25101) (
IMCOMPARE.LEFTBUTTONFN 25103 . 27545) (IMCOMPARE.LENGTHEN.ATOM 27547 . 28249) (
IMCOMPARE.MERGE.CONNECTED.CHUNKS 28251 . 31747) (IMCOMPARE.MERGE.UNCONNECTED.CHUNKS 31749 . 33704) (
IMCOMPARE.MIDDLEBUTTONFN 33706 . 36541) (IMCOMPARE.SHOW.DIST 36543 . 36989) (
IMCOMPARE.UPDATE.SYMBOL.TABLE 36991 . 38874)))))
STOP
