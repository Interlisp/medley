(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "IŒeo£ΩhMø∫YØ5(tıè˙∑©—Uµ1˝£4Ë/4utwıªèÇ∂©¿ß¥ø˙∫èÊ·˙Ç·ˇ˚ª∫Q◊e7(≠≥ÇxÁæ§∏ıÁ˜ÙÁæµxç∏?ÙÁÉÙßıÁæ?ı?Á¢5˝£Ë£ΩtÔCßÁ˚—UıÇÇäÇÇ∫∫©©∫∫∫∫∫∫µıß¸Äxıä§ÙÒ∫∫¶u/hı¢5˝£Ë£ΩtÔ®¨†(µ©∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫∫¶qØhı|Oß/tÔ7†4((5<4µ©©∫∫∫∫∫∫z?Ùèµ§Äxı˛ıÉÙÙ·∫ª∫ø∂πè¥Êø∫èÇ·ˇÉÁ˚äª∫g7(-≥ÇxÁæ§∏ıÁ˜ÙÁæµxç∏?ÙÁÉÙßıÁæ?ı?Á¢5˝£Ë£ΩtÔCßÁè©∑©©©¶°∫Á∫ª©Øç?µ¸√ı¶øµ∫èøÊˇæ∫èøÊäæ∫èøÊÇæ∫èøÊãæ∫èøÊÉæ∫èøÊÊæ∫èøÊøæ∫èøø˙∫ªıÙßÄÙıÒ∫.Ù?ıØç?ıÉµß∫∫wı;µ¸Éxı;Ù8ÙèÙ˜ß©ª∑©©¶j/tC=®¨‡M/˝Ô (ODD2BITNIBBLES ODD2BIT2) of SBASE)))
                    (\PUTBASE DBASE 2 (\GETBASE MAPBASE (fetch (ODD2BITNIBBLES ODD2BIT3) of SBASE)))
                    (\PUTBASE DBASE 3 (\GETBASE MAPBASE (fetch (ODD2BITNIBBLES ODD2BIT4) of SBASE)))
                    (\PUTBASE DBASE 4 (\GETBASE MAPBASE (fetch (ODD2BITNIBBLES ODD2BIT5) of SBASE)))
                    (\PUTBASE DBASE 5 (\GETBASE MAPBASE (fetch (ODD2BITNIBBLES ODD2BIT6) of SBASE)))
                    (\PUTBASE DBASE 6 (\GETBASE MAPBASE (fetch (ODD2BITNIBBLES ODD2BIT7) of SBASE)))
                    (\PUTBASEBYTE DBASE 14 (COND
                                              ((ZEROP (fetch (ODD2BITNIBBLES BIT15) of SBASE))
                                               0COLOR)
                                              (T 1COLOR)))
                    (\PUTBASEBYTE DBASE 15 (COND
                                              ([ZEROP (fetch (ODD2BITNIBBLES BIT0)
                                                         of (SETQ SBASE (\ADDBASE SBASE 1]
                                               0COLOR)
                                              (T 1COLOR)))
                    (SETQ DBASE (\ADDBASE DBASE 8))
                    (SETQ WIDTH (IDIFFERENCE WIDTH BITSPERWORD)))
                   ((EQ WIDTH 0)
                    (RETURN))
                   ((EQ WIDTH 1)                             (* move last bit specially)
                    (\PUTBASEBYTE DBASE 0 (COND
                                             ((ZEROP (LOGAND (\GETBASE SBASE 0)
                                                            (\BITMASK SBITOFFSET)))
                                              0COLOR)
                                             (T 1COLOR)))
                    (RETURN))
                   ((EQ SBITOFFSET 15)
          
          (* case of moving one bit from each of two words in the slow case.)

                    (\PUTBASEBYTE DBASE 0 (COND
                                             ((ZEROP (fetch (ODD2BITNIBBLES BIT15) of SBASE))
                                              0COLOR)
                                             (T 1COLOR)))
                    (\PUTBASEBYTE DBASE (SETQ SBITOFFSET 1)
                           (COND
                              ([ZEROP (fetch (ODD2BITNIBBLES BIT0) of (SETQ SBASE (\ADDBASE SBASE 1]
                               0COLOR)
                              (T 1COLOR)))
                    (SETQ WIDTH (IDIFFERENCE WIDTH 2))
                    (SETQ DBASE (\ADDBASE DBASE 1)))
                   (T 
          
          (* move the rest of the first word or the rest of last word two at a time.)

                      (\PUTBASEBYTE DBASE 0 (COND
                                               ((ZEROP (LOGAND (\GETBASE SBASE 0)
                                                              (\BITMASK SBITOFFSET)))
                                                0COLOR)
                                               (T 1COLOR)))
                      (\PUTBASEBYTE DBASE 1 (COND
                                               ([ZEROP (LOGAND (\GETBASE SBASE 0)
                                                              (\BITMASK (ADD1 SBITOFFSET]
                                                0COLOR)
                                               (T 1COLOR)))
                      (SETQ SBITOFFSET (IPLUS SBITOFFSET 2))
                      (SETQ WIDTH (IDIFFERENCE WIDTH 2))
                      (SETQ DBASE (\ADDBASE DBASE 1]
                (GO LP])

(\24BITLINEBLT
  [LAMBDA (SBASE SLEFT DBASE DLEFT WIDTH 0COLOR 1COLOR)      (* kbr%: "15-Feb-86 10:56")
          
          (* moves one line of a black and white bitmap into a color bitmap using a 
          mapping table.)

    (PROG NIL
          (for SX from SLEFT to (IPLUS SLEFT WIDTH -1) as DX from DLEFT
             do (\PUTBASE24 DBASE DX (COND
                                        ([ZEROP (LOGAND (\GETBASE SBASE (FOLDLO SX BITSPERWORD))
                                                       (\BITMASK (LOGAND SX 15]
                                         0COLOR)
                                        (T 1COLOR])

(\GETBASE24
  [LAMBDA (X D)                                              (* kbr%: "13-Feb-86 21:07")
                                                             (* Get Dth 24bit pixel from packed X.
                                                             *)
    (PROG (DWORD ANSWER)
          (SETQ DWORD (FOLDLO (ITIMES 24 D)
                             BITSPERWORD))
          [SETQ ANSWER (SELECTQ (LOGAND D 1)
                           (0 
          
          (* Get nibbles 1 0 of DWORD and nibble 1 of following word.
          *)

                              (LOGOR (LLSH (\GETBASE X DWORD)
                                           8)
                                     (LRSH (\GETBASE X (ADD1 DWORD))
                                           8)))
                           (PROGN 
          
          (* Get nibble 0 of DWORD and nibbles 1 0 of following word.
          *)

                                  (LOGOR (LLSH (LOGAND (\GETBASE X DWORD)
                                                      (MASK.1'S 0 8))
                                               16)
                                         (\GETBASE X (ADD1 DWORD]
          (RETURN ANSWER])

(\PUTBASE24
  [LAMBDA (X D V)                                            (* kbr%: "13-Feb-86 21:19")
                                                             (* Set Dth 24bit pixel from packed X.
                                                             *)
    (PROG (DWORD)
          (SETQ DWORD (FOLDLO (ITIMES 24 D)
                             BITSPERWORD))
          (SELECTQ (LOGAND D 1)
              (0 
          
          (* Replace nibbles 1 0 of DWORD and nibble 1 of following word.
          *)

                 (\PUTBASE X DWORD (LRSH V 8))
                 [\PUTBASE X (ADD1 DWORD)
                        (LOGOR (LLSH (LOGAND V (MASK.1'S 0 8))
                                     8)
                               (LOGAND (\GETBASE X DWORD)
                                      (MASK.1'S 0 8])
              (PROGN 
          
          (* Replace nibble 0 of DWORD and nibbles 1 0 of following word.
          *)

                     (\PUTBASE X DWORD (LOGOR (LOGAND (\GETBASE X DWORD)
                                                     (LLSH (MASK.1'S 0 8)
                                                           8))
                                              (LRSH V 16)))
                     (\PUTBASE X (ADD1 DWORD)
                            (LOGAND V (MASK.1'S 0 16])

(COLORTEXTUREFROMCOLOR#
  [LAMBDA (COLOR# BITSPERPIXEL)                              (* kbr%: "27-Feb-86 16:48")
          
          (* returns a TEXTURE that is COLOR# tessellated in a pattern to put down 
          BITSPERPIXEL per pixel color)

    (PROG (TEXTURE)
          (COND
             ((type? BITMAP COLOR#)                          (* already is a texture.)
              (RETURN COLOR#)))
          (SETQ COLOR# (COLORNUMBERP COLOR# BITSPERPIXEL))
          (SETQ TEXTURE (SELECTQ BITSPERPIXEL
                            (4 (PROG (TEXTUREBITMAP BITPATTERN)
                                     (SETQ TEXTUREBITMAP (BITMAPCREATE 4 4 4))
                                     (SETQ BITPATTERN (LOGOR (LLSH COLOR# 12)
                                                 ˚;; "Open a BSP connection to a nearby, responsive mail server and returns it") (if (OPENCLOSESTSOCKET (\MAILSERVERSOCKETS ERRORFLG) \MAILSERVERPOLLINGSOC \MAILSERVERENQUIRYSOC NIL \MAILIOTIMEOUT) elseif ERRORFLG then (ERROR "Couldn't open connection for" \MAILSERVERNAME) NIL))
)

(\MAILSERVERSOCKETS
(LAMBDA (ERRORFLG) (* bvm%: "21-MAY-83 20:00") (PROG (SOCKETS) (RETURN (COND ((AND \MAILSERVERSOCKETC!ËΩtı¶πÏCı¶
Ω†t/t}˝/t7‰∫¶Øuoı†5˝£(tot/(¨®≠t®5ËΩ4µ∑∑∑∫¶Ôwoı†5˝£(tot/(¨®≠t®5Ëç4µ∑∫¶Jı¶/tMı†5˝£(to                          (SETQ BITPATTERN (LOGOR (LLSH COLOR# 8)
                                                             COLOR#))
                                     (for I from 0 to 3 do (\BITMAPWORD TEXTUREBITMAP I BITPATTERN))
                                     (RETURN TEXTUREBITMAP)))
                            (24 
          
          (* This isn't right, but at least it won't break you.
          *)

                                (PROG (TEXTUREBITMAP BITMAPBASE)
                                      (SETQ TEXTUREBITMAP (BITMAPCREATE 2 4 24))
                                      (SETQ BITMAPBASE (fetch (BITMAP BITMAPBASE) of TEXTUREBITMAP))
                                      (for I from 0 to 7 do (\PUTBASE24 BITMAPBASE I COLOR#))
                                      (RETURN TEXTUREBITMAP)))
                            (ERROR "Only 4, 8 and 24 bits per pixel implemented.")))
          (RETURN TEXTURE])

(\BITMAPWORD
  [LAMBDA (BM WORDN NEWBITS)                                 (* edited%: " 8-SEP-82 10:54")
          
          (* puts a words worth of bits into the WORDNth word of a bitmap.)

    (\PUTBASE (\ADDBASE (fetch (BITMAP BITMAPBASE) of BM)
                     WORDN)
           0
           (LOGAND NEWBITS WORDMASK])
)
(DEFINEQ

(COLORIZEBITMAP
  [LAMBDA (BITMAP 0COLOR 1COLOR BITSPERPIXEL)                (* kbr%: "15-Feb-86 10:13")
          
          (* creates a copy of BITMAP that is in color form allowing BITSPERPIXEL per 
          pixel. 0COLOR and 1COLOR are the color numbers that get translated from 0 and 1 
          respectively.)

    (PROG (COLORBITMAP)
          (SETQ COLORBITMAP (BITMAPCREATE (fetch (BITMAP BITMAPWIDTH) of BITMAP)
                                   (fetch (BITMAP BITMAPHEIGHT) of BITMAP)
                                   BITSPERPIXEL))
          (\BWTOCOLORBLT BITMAP 0 0 COLORBITMAP 0 0 (fetch (BITMAP BITMAPWIDTH) of BITMAP)
                 (fetch (BITMAP BITMAPHEIGHT) of BITMAP)
                 (COLORNUMBERP 0COLOR BITSPERPIXEL)
                 (COLORNUMBERP 1COLOR BITSPERPIXEL)
                 BITSPERPIXEL)
          (RETURN COLORBITMAP])

(UNCOLORIZEBITMAP
  [LAMBDA (BITMAP COLORMAP)                                  (* kbr%: " 2-Sep-85 19:21")
    (PROG (BITSPERPIXEL MAXCOLOR MAXX MAXY BWBITMAP TABLE RGB R G B BIT BASE BWBASE RASTERWIDTH 
                 BWRASTERWIDTH WORD)
          (SETQ MAXX (SUB1 (fetch (BITMAP BITMAPWIDTH) of BITMAP)))
          (SETQ MAXY (SUB1 (fetch (BITMAP BITMAPHEIGHT) of BITMAP)))
          (SETQ BITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of BITMAP))
          (SETQ COLORMAP (OR COLORMAP (COLORMAP BITSPERPIXEL)))
          (SETQ MAXCOLOR (MAXIMUMCOLOR BITSPERPIXEL))
          (SETQ BWBITMAP (BITMAPCREATE (ADD1 MAXX)
                                (ADD1 MAXY)
                                1))
          (SETQ TABLE (\ALLOCBLOCK (FOLDHI (ADD1 MAXCOLOR)
                                          2)))
          (for I from 0 to MAXCOLOR do (SETQ RGB (ELT COLORMAP I))
                                       (SETQ R (fetch (RGB RED) of RGB))
                                       (SETQ G (fetch (RGB GREEN) of RGB))
                                       (SETQ B (fetch (RGB BLUE) of RGB))
                                       (SETQ BIT (IDIFFERENCE 1 (IQUOTIENT (IPLUS R G B)
                                                                       384)))
                                       (\PUTBASE TABLE I BIT))
          (SETQ BASE (fetch (BITMAP BITMAPBASE) of BITMAP))
          (SETQ BWBASE (fetch (BITMAP BITMAPBASE) of BWBITMAP))
          (SETQ RASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of BITMAP))
          (SETQ BWRASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of BWBITMAP))
          (SELECTQ BITSPERPIXEL
              (4 [for Y from 0 to MAXY do (SETQ WORD 0)
                                          [for X from 0 to MAXX
                                             do [SETQ WORD (LOGOR (LLSH WORD 1)
                                                                  (\GETBASE TABLE (\GETBASENYBBLE
                                                                                   BASE X]
                                                (COND
                                                   ((EQ (LOGAND X 15)
                                                        15)
                                                    (\PUTBASE BWBASE (FOLDLO X 16)
                                                           WORD)
                                                    (SETQ WORD 0]
                                          (COND
                                             ((NOT (EQ (LOGAND MAXX 15)
                                                       15))
                                              [SETQ WORD (LLSH WORD (IDIFFERENCE 15 (LOGAND MAXX 15]
                                              (\PUTBASE BWBASE (FOLDLO MAXX 16)
                                                     WORD)))
                                          (COND
                                             ((NOT (EQ Y MAXY))
                                              (SETQ BASE (\ADDBASE BASE RASTERWIDTH))
                                              (SETQ BWBASE (\ADDBASE BWBASE BWRASTERWIDTH])
              (8 [for Y from 0 to MAXY do (SETQ WORD 0)
                                          [for X from 0 to MAXX
                                             do [SETQ WORD (LOGOR (LLSH WORD 1)
                                                                  (\GETBASE TABLE (\GETBASEBYTE
                                                                                   BASE X]
                                                (COND
                                                   ((EQ (LOGAND X 15)
                                                        15)
                                                    (\PUTBASE BWBASE (FOLDLO X 16)
                                                           WORD)
                                                    (SETQ WORD 0]
                                          (COND
                                             ((NOT (EQ (LOGAND MAXX 15)
                                                       15))
                                              [SETQ WORD (LLSH WORD (IDIFFERENCE 15 (LOGAND MAXX 15]
                                              (\PUTBASE BWBASE (FOLDLO MAXX 16)
                                                     WORD)))
                                          (COND
                                             ((NOT (EQ Y MAXY))
                                              (SETQ BASE (\ADDBASE BASE RASTERWIDTH))
                                              (SETQ BWBASE (\ADDBASE BWBASE BWRASTERWIDTH])
              NIL)
          (RETURN BWBITMAP])
)

(RPAQ? \1COLORMENU NIL)

(RPAQ? \4COLORMENU NIL)

(RPAQ? \8COLORMENU NIL)
(DEFINEQ

(COLORMENU
  [LAMBDA (BITSPERPIXEL)                                     (* kbr%: " 5-Jun-85 18:24")
                                                             (* Make a BITSPERPIXEL color menu.
                                                             *)
    (PROG (MENU ITEMS MENUCOLUMNS MENUROWS BITMAP)           (* Try to find old menu.
                                                            eam") (COPYBYTES INSTREAM *MSGOUTSTREAM* BYTELEN))) (OR (AND *GV-SHOW-POSTMARK* (SELECTC TYPE (\I.POSTMQRK (* ; "6 bytes: pueˆ˜∑∫äµ¥Ù∑∑∫äµ¥Ùµø∑∫¶/tMıwOΩ¨hCı¶˝ÔıˇØhC/45†µ∑∫¶/tMı
Ω†tı¶πË/4utı¶ Ïtı1˝}µ∑∑¶¶;ÙÕ∑ı∏Ùıæ¨owıˇı
Ω†tıÉ√ı¶˝ÔıˇØhC/45†µ∑∫¶;ÙÕ∑ı∏ÙıÆΩÏowıˇı
Ω†tıÉ√ı¶˝ÔıˇØhC/45†µ∑∫
µ∫¶˝ß/tÔ7toı¶/tMı/tÔ7toı¶N/4®4˝4hC/˝Ø|ıˇØhC/45‡ı¶˝ÔıˇØhC/45†µ∑∑∑∫π˝£µ∑∫¶äı´}t£tÔı˛ı¶´˝ÔıˇØhC/45†µ∑∑∑∫¶ØÏwı¶¶„wwMı´}t£tØµ∫¶°∫Á∫ª6ı√ı:ı˜˜ß¸ıªÉÙø∑∫¶´˝ÔıˇØhC/45†µ∑∑∫Òßı∑ı¶´h<t†u/ÌıˇØhC/45†µ∑∑©∑as SHADE in (LIST WHITESHADE BLACKSHADE)
                                collect (LIST (PROGN (SETQ BITMAP (BITMAPCREATE 32 32))
                                                     (BLTSHADE SHADE BITMAP)
                                                     BITMAP)
                                              COLOR)))
                          (4 (for COLOR from 0 to 15
                                collect (LIST (PROGN (SETQ BITMAP (BITMAPCREATE 16 16 4))
                                                     (BLTSHADE COLOR BITMAP)
                                                     BITMAP)
                                              COLOR)))
                          (8 (for COLOR from 0 to 255
                                collect (LIST (PROGN (SETQ BITMAP (BITMAPCREATE 8 8 8))
                                                     (BLTSHADE COLOR BITMAP)
                                                     BITMAP)
                                              COLOR)))
                          (SHOULDNT)))
          (SETQ MENUROWS (SELECTQ BITSPERPIXEL
                             (1 1)
                             (4 4)
                             (8 16)
                             (SHOULDNT)))
          (SETQ MENUCOLUMNS (SELECTQ BITSPERPIXEL
                                (1 2)
                                (4 4)
                                (8 16)
                                (SHOULDNT)))
          (SETQ MENU (create MENU
                  o mail servers for user " FULLNAME) NIL) (T (create LAFITEMODEDATA FULLUSERNAME _ FULLNAME UNPACKEDUSERNAME _ GVUSERNAME CREDENTIALS _ PASS SHORTUSERNAME _ FULLNAME FROMFIELD _ (AND LAFITE.GV.FROM.FIELD (LET ((PARSE (\GV.PARSERECIPIENTS1 LAFITE.GV.FROM.FIELD NIL T))) (* ;; "If the user's variable parses correctly into the authenticated user, then take it") (if (AND PARSE (NULL (CDR PARSE)) (STRING-EQUAL (CAAR PARSE) (CAR GVUSERNAME)) (STRING-EQUAL (CDAR PARSE) (CDR GVUSERNAME))) then LAFITE.GV.FROM.FIELD else (CL:FORMAT PROMPTWINDOW "~%%Can't use GV From field %"~A%" because it does not parse to current user %"~A%"" LAFITE.GV.FROM.FIELD FULLNAME) NIL))) MAILSERVERS _ (for MAILSERVER in MAILSERVERS bind SERVEROPS SERVERPORT SERVERDEF when (COND ((NULL (SETQ SERVEROPS (GETMAILSERVEROPS MAILSERVER))) NIL) ((NULL (SETQ SERVERPORT (CL:FUNCALL (fetch (MAILSERVEROPS SERVERPORTFROMNAME) of SERVEROPS) MAILSERVER))) (printout PROMPTWINDOW T "Can't find address of " MAILSERVER) NIL) (T (SETQ SERVERDEF (create MAILSERVER MAILPORT _ SERVERPORT MAILSERVERNAME _ MAILSERVER MAILSERVEROPS _ SERVEROPS)))) collect SERVERDEF))))))
)

(GETMAILSERVEROPS
(LAMBDA (MAILSERVER) (* bvm%: "12-Nov-84 17:52") (PROG ((SERVERTYPE (\GV.MAILSERVERTYPE MAILSERVER)) OPS) (RETURN (COND ((AND SERVERTYPE (SETQ OPS (OR (ASSOC SERVERTYPE MAILSERVERTYPES) (AND (EQ SERVERTYPE (QUOTE MTP)) (PROGN (FILESLOAD (SYSLOAD FROM VALUEOF LISPUSERSDIRECTORIES) MTP) (ASSOC SERVERTYPE MAILSERVERTYPES)))))) (CDR OPS)) (T (printout PROMPTWINDOW T "Lafite cannot retrieve mail from " MAILSERVER) NIL)))))
)

(\GV.MAILSERVERTYPE
(LAMBDA (MAILSERVERNAME) (* bvm%: " 9-Dec-85 17:03") (* ;;; "type is determined by the name currently") (COND ((STRING-EQUAL (SUBSTRING MAILSERVERNAME -3) ".MS") (QUOTE GV)) ((STRING-EQUAL MAILSERVERNAME "MAXC") (QUOTE MTP))))
)
)
(DEFINEQ

(\GV.SENDMESSAGE
  [LAMBDA (MSG PARSE EDITORWINDOW ABORTWINDOW)           (* ; "Edited 15-Jun-90 17:53 by jds")

(* ;;; "This is the real mail sender for the GrapeVine")

(* ;;; "MSG is the entire text of the message -- RECIPIENTS is a parsed list of recipients")

    (PROG ((PWINDOW (AND EDITORWINDOW (GETPROMPTWINDOW EDITORWINDOW)))
           (RECIPIENTS (fetch (GVMAILPARSE GVPRECIPIENTS) of PARSE))
           (FROMFIELD (fetch (GVMAILPARSE GVPFROM) of PARSE))
           (FORMATTING (fetch (GVMAILPARSE GVPFORMAT) of PARSE))
           (DATEFIELD (CONCAT "Date: " (DATE (DATEFORMAT NO.SECONDS TIME.ZONE SPACES))
                             LAFITEEOL))
           (FAILURECNT 0)
           (SENDER (fetch (LAFITEMODEDATA FULLUSERNAME) of *LAFITE-MODE-DATA*))
           (UNPACKEDSENDER (fetch (LAFITEMODEDATA UNPACKEDUSERNAME) of *LAFITE-MODE-DATA*))
           DATELEN SENDINGSOCKET RECIPIENTSCHECK SENDRESULT SENDERFIELD ABORTMENU)
          [COND
             ((NOT (TYPENAMEP MSG 'STREAM))
              (RETURN (\ILLEGAL.ARG MSG]
          (SETQ FORMATTING (SELECTQ FORMATTING
                               ((MULTIMEDIA TEDIT)           (* ; 
                                                "Send with TEdit formatting, assuming there is any")
                                    (AND (TEDIT.FORMATTEDFILEP MSG)
                                         T))
                               (TEXT NIL)
                               (\ILLEGAL.ARG FORMATTING)))
          [COND
             (PWINDOW (CLEARW PWINDOW)
                    (CL:FORMAT PWINDOW "Delivering ~:[~;formatted ~]to ~D recipient~:P" FORMATTING
                           (LENGTH RECIPIENTS]
          [SETQ SENDERFIELD
           (COND
              (FROMFIELD                                     (* ; 
 "Test for valid From field.  We waited til now to do this so we didn't hold up start of delivery.")
               (if (for ADDR in FROMFIELD bind REG unless (STRPOS "@"
                                                                                     (CAR ADDR))
                          do                             (* ; "assume arpa addresses are valid")
                                (if (NLISTP (GV.EXPAND (if (EQ (SETQ REG (CDR ADDR))
                                                                       'NOREGISTRY)
                                                               then 
                                                             (* ; "The address had no registry.  We do it this odd way so that we can distinguish %"Fred%" from %"Fred.PA%" in the test below.")
                                                                     (CONS (CAR ADDR)
                                                                           (SETQ REG (CDR 
                                                                                       UNPACKEDSENDER
                                                                                          )))
                                                             else ADDR)))
                                    then [COND
                                                (PWINDOW (CLEARW PWINDOW)
                                                       (CL:FORMAT PWINDOW 
                                                              "From field not valid address: ~A"
                                                              (CONCAT (CAR ADDR)
                                                                     "." REG]
                                          (RETURN T)))
                   then (RETURN NIL))
               (if (AND (NULL (CDR FROMFIELD))
                            (STRING-EQUAL (CONCAT (CAAR FROMFIELD)
                                                 "."
                                                 (CDAR FROMFIELD))
                                   SENDER))
                   then                                  (* ; "From field is just a fancy way of writing the real from field, so adding a Sender field would be redundant")
                         NIL
                 else (CONCAT "Sender: " SENDER LAFITEEOL)))
              (T (CONCAT "From: " (OR (fetch (LAFITEMODEDATA FROMFIELD) of *LAFITE-MODE-DATA*
                                             )
                                      SENDER)
                        LAFITEEOL]
          [COND
             (FORMATTING (TEDIT.INSERT MSG DATEFIELD 1 NIL T)
                    (SETQ DATELEN (NCHARS DATEFIELD))
                    (CL:WHEN SENDERFIELD
                        (TEDIT.INSERT MSG SENDERFIELD (ADD1 DATELEN)
                               NIL T))                       (* ; 
                                   "Do tedit conversion now, before we have the bsp stream tied up")
                    [SETQ MSG (PROG1 (COERCETEXTOBJ MSG 'SPLIT)
                                  (TEDIT.DELETE MSG 1 (if SENDERFIELD
                                                          then (+ DATELEN (NCHARS SENDERFIELD))
                                                        else DATELEN)))]
                    (SETQ FORMATTING (CDR MSG))
                    (SETQ MSG (CAR MSG)))
             ((AND (TEXTSTREAMP MSG)
                   (TEDIT.FORMATTEDFILEP MSG))               (* ; "Message has formatting, but caller asked to send it as plain text.  Carefully coerce it, since TEDIT ns chars and image objects don't pass thru COPYBYTES very well")
              (SETQ MSG (LAFITE.MAKE.PLAIN.TEXTSTREAM MSG]
      STARTSEND
          (as I to 3 until (SETQ SENDINGSOCKET (GV.STARTSEND UNPACKEDSENDER
                                                                  (fetch (LAFITEMODEDATA 
                                                                                    CREDENTIALS)
                                                                     of *LAFITE-MODE-DATA*)
                                                                  UNPACKEDSENDER T))
             do                                          (* ; 
                                                           "loop 3 times trying to start this send")
                   (DISMISS 1000))
          [COND
             ((NULL SENDINGSOCKET)
              (RETURN (\LAFITE.SEND.FAIL EDITORWINDOW "Couldn't connect to a maildrop"]
          (RESETSAVE NIL (LIST (FUNCTION GV.KILLSOCKET)
                               SENDINGSOCKET))
          (AND PWINDOW (printout PWINDOW '|...|))
          (COND
             ((AND ABORTWINDOW (WINDOWPROP ABORTWINDOW 'ABORT))
              (ERROR!)))
          (SELECTQ (SETQ RECIPIENTSCHECK (\GV.SENDRECIPIENTS SENDINGSOCKET RECIPIENTS 
                                                EDITORWINDOW))
              (NIL                                           (* ; 
            "MS didn't like the recipients list -- this was already reported by \GV.SENDRECIPIENTS")
                   (RETURN NIL))
              (?                                             (* ; "Something went wrong, try again")
                 (GO TRYAGAIN))
              NIL)                                           (* ; "Everything is OK")
          (COND
             ((AND ABORTWINDOW (WINDOWPROP ABORTWINDOW 'ABORT))
              (ERROR!)))                                     (* ; "send code to start sending text")
          (GV.STARTITEM SENDINGSOCKET)
          [COND
             ((NOT FORMATTING)
              (GV.ADDTOITEM SENDINGSOCKET DATEFIELD)
              (AND SENDERFIELD (GV.ADDTOITEM SENDINGSOCKET SENDERFIELD]
                                                             (* ; "send the message")
          (COND
             ((AND ABORTWINDOW (WINDOWPROP ABORTWINDOW 'ABORT))
              (ERROR!)))
          (GV.ADDTOITEM SENDINGSOCKET MSG)               (* ; 
                                                           "tell the grapevine to send the message")
          (COND
             (FORMATTING (COND
                            ((AND ABORTWINDOW (WINDOWPROP ABORTWINDOW 'ABORT))
                             (ERROR!)))
                    (GV.STARTITEM SENDINGSOCKET \I.TEDITFORMATTING)
                                                             (* ; "Send formatting info")
                    (GV.ADDTOITEM SENDINGSOCKET FORMATTING)))
          (COND
             ((NULL ABORTWINDOW))
             ((WINDOWPROP ABORTWINDOW 'ABORT)
              (ERROR!))
             (T                                              (* ; "Too late to abort now")
                (DELETEMENU [SETQ ABORTMENU (CAR (WINDOWPROP ABORTWINDOW 'MENU]
                       NIL ABORTWINDOW)))
          (COND
             ((EQ (SETQ SENDRESULT (GV.SEND SENDINGSOCKET))
                  T)
              (RETURN T)))
      TRYAGAIN
          [COND
             ((> (add FAILURECNT 1)
                 4)
              (RETURN (\LAFITE.SEND.FAIL EDITORWINDOW "Several unsuccessful attempts"]
          (AND PWINDOW (printout PWINDOW " problems, trying again."))
          (GV.KILLSOCKET SENDINGSOCKET)                      (* ; "Just in case it's still alive")
          (COND
             (ABORTMENU                                      (* ; 
                                                         "Restore the Abort menu that we took down")
                    (ADDMENU ABORTMENU ABORTWINDOW '(0 . 0))
                    (SETQ ABORTMENU)))
          (GO STARTSEND])

(\GV.SENDRECIPIENTS
(LAMBDA (SOCKET RECIPIENTS EDITORWINDOW) (* DECLARATIONS%: (RECORD (%#OFVALIDRECIPIENTS . INVALIDRECIPIENTS)) (RECORD INVALIDRECIPIENT (RECIPIENT# . RECIPIENTNAME))) (* bvm%: " 6-Nov-84 11:53") (PROG (REASON VALIDITYRESULT INVALID) (COND ((NLISTP RECIPIENTS) (SETQ REASON "No recipients supplied")) (T (for R in RECIPIENTS do (GV.ADDRECIPIENT SOCKET R)) (SETQ VALIDITYRESULT (GV.CHECKVALIDITY SOCKET)) (COND ((NLISTP VALIDITYRESULT) (RETURN (QUOTE ?))) ((NULL (SETQ INVALID (fetch INVALIDRECIPIENTS of VALIDITYRESULT))) (* ; "everything went OK") (RETURN VALIDITYRESULT)) (T (* ; "GV didn't like some recipients") (SETQ REASON (\LAFITE.INVALID.RECIPIENTS (for RECIPIENT in INVALID collect (fetch (INVALIDRECIPIENT RECIPIENTNAME) of RECIPIENT)))))))) FAILED (RETURN (\LAFITE.SEND.FAIL EDITORWINDOW REASON))))
)
)
(DEFINEQ

(\GV.SEND.PARSE
(LAMBDA (MSG EDITORWINDOW) (* ; "Edited  5-May-88 13:06 by bvm") (PROG ((REGISTRY (CDR (fetch (LAFITEMODEDATA UNPACKEDUSERNAME) of *LAFITE-MODE-DATA*))) RECIPIENTS MSGFIELDS FROMFIELD SENDINGFORMAT HEADEREOF REPLYTO SUBJECT) (OR (SETQ MSGFIELDS (\LAFITE.PREPARE.SEND MSG EDITORWINDOW)) (RETURN)) (COND ((EQ (CAAR MSGFIELDS) (QUOTE EOF)) (SETQ HEADEREOF (CADR (pop MSGFIELDS))))) (for PAIR in MSGFIELDS do (SELECTQ (CAR PAIR) (Date (\SENDMESSAGEFAIL EDITORWINDOW "User-supplied Date not allowed")) ((To cc) (SETQ RECIPIENTS (NCONC RECIPIENTS (\GV.PARSERECIPIENTS (CDR PAIR) REGISTRY T EDITORWINDOW)))) (From (SETQ FROMFIELD (\GV.PARSERECIPIENTS (CDR PAIR) (QUOTE NOREGISTRY) T EDITORWINDOW))) (Reply-to (SETQ REPLYTO (\GV.PARSERECIPIENTS (CDR PAIR) REGISTRY T EDITORWINDOW))) (Sender (\SENDMESSAGEFAIL EDITORWINDOW "User-supplied Sender not allowed")) (Format (SETQ SENDINGFORMAT (CADR PAIR))) (Subject (SETQ SUBJECT (CADR PAIR))) NIL)) (COND ((NULL RECIPIENTS) (\SENDMESSAGEFAIL EDITORWINDOW "No recipients!") (RETURN NIL)) ((FMEMB NIL RECIPIENTS) (* ;; "if there is a NIL in RECIPIENTS then \GV.PARSERECIPIENTS couldn't parse something {it already reported it} therefore just get out now") (RETURN NIL))) (COND ((NULL SENDINGFORMAT) (SETQ SENDINGFORMAT (OR (\LAFITE.CHOOSE.MSG.FORMAT MSG HEADEREOF EDITORWINDOW) (RETURN))))) (COND ((AND EDITORWINDOW (NULL REPLYTO) (for GVNAME in RECIPIENTS thereis (EQ (NTHCHARCODE (CAR GVNAME) -1) (CHARCODE ^)))) (OR (\LAFITE.CHOOSE.REPLYTO MSG HEADEREOF FROMFIELD EDITORWINDOW) (RETURN)))) (RETURN (create GVMAILPARSE GVPSUBJECT _ SUBJECT GVPFROM _ FROMFIELD GVPFORMAT _ SENDINGFORMAT GVPRECIPIENTS _ RECIPIENTS))))
)

(\GV.PARSERECIPIENTS
(LAMBDA (FIELD REGISTRY INTERNALFLG EDITWINDOW) (* ; "Edited  9-Sep-87 16:27 by bvm:") (SETQ FIELD (COND ((LISTP FIELD) (for PIECE in FIELD join (\GV.PARSERECIPIENTS1 PIECE REGISTRY INTERNALFLG EDITWINDOW))) (T (\GV.PARSERECIPIENTS1 FIELD REGISTRY INTERNALFLG EDITWINDOW)))) (COND (INTERNALFLG FIELD) (T (CL:REMOVE-DUPLICATES FIELD :TEST (QUOTE STRING-EQUAL)))))
)

(\GV.PARSERECIPIENTS1
(LAMBDA (LINE REGISTRY INTERNALFLG EDITWINDOW RECURSIVE-P) (* ; "Edited 13-Jun-88 12:21 by bvm") (* ;;; "INTERNALFLG = T means produce addresses to give Grapevine;  NIL means give human-readable addresses") (PROG ((I 0) NC NOPEN CH ADDRESSES ADDR FAILURE OPEN CLOSE DOT ATSIGN START COLON COMSTART COMMENTS PRETTY DLNAME) (COND ((NULL LINE) (RETURN NIL))) (SETQ NC (NCHARS LINE)) NEXTADDR (if (>= I NC) then (* ; "done") (if COLON then (* ; "Slight missing semi-colon") (SETQ FAILURE #\:) (GO FAIL)) (RETURN (REVERSE ADDRESSES))) (CASE (SETQ CH (CL:CHAR LINE I)) ((#\Space #\Tab #\Newline) (* ; "Ignore leading whitespace") (add I 1) (GO NEXTADDR))) (SETQ START I) (SETQ OPEN (SETQ CLOSE (SETQ DOT (SETQ ATSIGN (SETQ COMMENTS NIL))))) THISCHAR (CASE CH (#\" (GO INQUOTE)) (#\( (GO INCOMMENT)) (#\[ (GO INDOMAIN)) ((#\) #\]) (* ; "Unbalanced stuff") (SETQ FAILURE CH) (GO FAIL)) (#\< (* ; "Start of address spec") (if OPEN then (SETQ FAILURE #\<) (GO FAIL) else (SETQ OPEN I))) (#\> (* ; "End of address spec") (if OPEN then (SETQ CLOSE I) else (SETQ FAILURE #\>) (GO FAIL))) (#\. (if (NOT CLOSE) then (* ; "Note placement of periods.  Ignore if outside <> address.") (SETQ DOT I))) (#\@ (if (NOT CLOSE) then (* ; "Note arpa address separator") (SETQ ATSIGN I) (SETQ DOT NIL))) (#\: (if (OR OPEN ATSIGN COLON) then (SETQ FAILURE "Invalid use of colon") (GO FAIL) else (if (EQ (\GV.FIND.NON.SPACE LINE (+ I 1) NC) #\;) then (* ; "DL in the form %"dlname:;%" -- get recipients from file") (SETQ ADDR (\GV.HANDLE.DL (SETQ DLNAME (\GV.EXTRACT.FIELD LINE START I)) INTERNALFLG EDITWINDOW)) (if (EQ (CAR ADDR) :ERROR) then (SETQ FAILURE (CADR ADDR)) (GO FAIL) else (SETQ ADDRESSES (NCONC ADDR ADDRESSES)) (SETQ DLNAME NIL)) else (* ; "Random phrase naming the group, followed by the addresses--just parse them as they come along, and note that we expect a semi-colon at some point.")) (SETQ COLON I) (add I 1) (GO NEXTADDR))) ((NIL #\, #\;) (* ; "end of address") (if (CASE CH (#\; (if (NOT COLON) then (SETQ FAILURE #\;) else (CASE (\GV.FIND.NON.SPACE LINE (+ I 1) NC) ((NIL #\,) (* ; "good--semi is at end of address.  Consider it eaten") (SETQ COLON NIL)) (T (* ; "Stuff after the semicolon is bad syntax") (SETQ FAILURE "Semi-colon must be at end of group specification"))))) ((NIL) (* ; "end of everything, check that there's no outstanding colon") (if COLON then (SETQ FAILURE #\:)))) then (* ; "Problem with this semi-colon") (GO FAIL)) (if (NEQ START I) then (* ; "there is a name") (if (NOT OPEN) then (* ; "simple address") (SETQ ADDR (\GV.PARSE.SIMPLE.RECIPIENT LINE START I DOT ATSIGN COMMENTS REGISTRY INTERNALFLG)) (if (EQ (CAR ADDR) :ERROR) then (SETQ FAILURE (CADR ADDR)) (GO FAIL)) elseif (NOT CLOSE) then (SETQ FAILURE #\<) (GO FAIL) else (* ; "real address is inside the <>") (SETQ ADDR (\GV.PARSE.SIMPLE.RECIPIENT LINE (+ OPEN 1) CLOSE DOT ATSIGN COMMENTS REGISTRY INTERNALFLG)) (if (EQ (CAR ADDR) :ERROR) then (SETQ FAILURE (CADR ADDR)) (GO FAIL)) (CASE INTERNALFLG ((NIL :BOTH) (* ; "Want pretty address--stick the reparsed real address inside the template") (SETQ PRETTY (CL:FORMAT NIL "~@[~A ~]<~A>~@[ ~A~]" (\GV.EXTRACT.FIELD LINE START OPEN) (if INTERNALFLG then (CAR ADDR) else ADDR) (\GV.EXTRACT.FIELD LINE (+ CLOSE 1) I))) (SETQ ADDR (if INTERNALFLG then (* ; "Want (pretty . internal)") (CONS PRETTY (CDR ADDR)) else PRETTY))))) (push ADDRESSES ADDR)) (add I 1) (GO NEXTADDR))) NEXT-I (SETQ CH (AND (< (add I 1) NC) (CL:CHAR LINE I))) (GO THISCHAR) INQUOTE (* ;; "Parse a quoted string--skip to next quote") (while (< (add I 1) NC) do (CASE (CL:CHAR LINE I) (#\" (* ; "end of quoted text") (GO NEXT-I)) (#\\ (* ; "quotes next char") (add I 1)))) (* ;; "If we get here, we have an unbalanced quote") (SETQ FAILURE #\") (GO FAIL) INCOMMENT (* ;; "Parse a comment in parens. Parentheses may be nested.  Add to set of comments") (SETQ COMSTART I) (SETQ NOPEN 1) (while (< (add I 1) NC) do (CASE (CL:CHAR LINE I) (#\) (if (EQ (SETQ NOPEN (- NOPEN 1)) 0) then (* ; "end of comment--parens are now matched") (if INTERNALFLG then (* ; "We will need to know how to strip comments") (push COMMENTS (LIST COMSTART (+ I 1)))) (GO NEXT-I))) (#\( (* ; "nested comment") (add NOPEN 1)) (#\\ (* ; "quotes next char") (add I 1)))) (* ;; "If we get here, we have an unbalanced paren") (SETQ FAILURE #\() (GO FAIL) INDOMAIN (* ;; "Parse a domain literal--string in square brackets.  These may not be nested.") (while (< (add I 1) NC) do (CASE (CL:CHAR LINE I) (#\] (* ; "end of literal") (GO NEXT-I)) (#\[ (* ; "unmatched") (RETURN)) (#\\ (* ; "quotes next char") (add I 1)))) (* ;; "If we get here, we have an unbalanced bracket") (SETQ FAILURE #\[) (GO FAIL) FAIL (RETURN (COND (RECURSIVE-P (LIST :ERROR FAILURE)) ((NOT EDITWINDOW) (* ; "No interaction, just show failure by returning (NIL)") (LIST NIL)) ((CL:CHARACTERP FAILURE) (\SENDMESSAGEFAIL EDITWINDOW (CL:FORMAT NIL "Error~@[ in ~A~]: " DLNAME) (CASE FAILURE (#\" "Unmatched quotation mark") (#\: "Incorrect group syntax--colon without terminating semi-colon") (T (CL:FORMAT NIL "Unmatched %"~C%"" FAILURE))))) (DLNAME (\SENDMESSAGEFAIL EDITWINDOW (CONCAT "In " DLNAME ": ") FAILURE)) (T (\SENDMESSAGEFAIL EDITWINDOW FAILURE))))))
)

(\GV.FIND.NON.SPACE
(LAMBDA (STR START END) (* ; "Edited 10-Jun-88 17:11 by bvm") (* ;; "returns the next non-white-space char in str from position start to end.") (bind CH do (if (>= START END) then (RETURN NIL) else (CASE (SETQ CH (CL:CHAR STR START)) ((#\Space #\Tab #\Newline) (add START 1)) (T (RETURN CH))))))
)

(\GV.PARSE.SIMPLE.RECIPIENT
(LAMBDA (FIELD START END DOT ATSIGN COMMENTS REGISTRY INTERNALFLG) (* ; "Edited 10-Jun-88 17:11 by bvm") (* ;;; "Parses a single ADDRESS, a list, and returns a proper address as a string, or if INTERNALFLG, in the form Grapevine likes") (COND ((EQ INTERNALFLG :BOTH) (LET ((INTERNAL (\GV.PARSE.SIMPLE.RECIPIENT FIELD START END DOT ATSIGN COMMENTS REGISTRY T))) (AND INTERNAL (CONS (\GV.PARSE.SIMPLE.RECIPIENT FIELD START END DOT ATSIGN COMMENTS REGISTRY NIL) INTERNAL)))) (INTERNALFLG (LET (TMP) (if (NULL DOT) then (SETQ TMP (\GV.EXTRACT.FIELD FIELD START END COMMENTS)) (if (NULL ATSIGN) then (* ; "use default registry") (if REGISTRY then (CONS TMP REGISTRY) else (LIST :ERROR (CONCAT "No registry given for addressee " TMP))) elseif (OR (EQ (CL:CHAR TMP 0) #\@) (EQ (CL:CHAR TMP (- (NCHARS TMP) 1)) #\@)) then (* ; "@ but null name or domain?") (\GV.PARSE.FAILED TMP) else (* ; "Assume name is otherwise good, use default arpa registry") (CONS TMP ARPANETGATEWAY.REGISTRY)) else (* ; "Take the domain/registry that's there") (SETQ TMP (CONS (\GV.EXTRACT.FIELD FIELD START DOT COMMENTS) (\GV.EXTRACT.FIELD FIELD (+ DOT 1) END COMMENTS))) (if (NULL (CDR TMP)) then (* ; "no domain?") (\GV.PARSE.FAILED (CONCAT (CAR TMP) ".")) else (RPLACD TMP (MKATOM (U-CASE (CDR TMP)))) (* ; "Grapevine registry must be atom, sigh.") TMP)))) ((OR ATSIGN DOT) (* ; "have an ARPA Internet address, or Grapevine address with registry--nothing to add to make user-sensible address") (if (NULL (\GV.FIND.NON.SPACE FIELD (OR ATSIGN DOT) END)) then (* ; "no domain") (\GV.PARSE.FAILED (\GV.EXTRACT.FIELD FIELD START END)) else (\GV.EXTRACT.FIELD FIELD START END))) (REGISTRY (* ; "Address without registry, supply default") (CONCAT (\GV.EXTRACT.FIELD FIELD START END) "." REGISTRY)) (T (* ; "Not even a default registry?  Punt") (\GV.EXTRACT.FIELD FIELD START END))))
)

(\GV.EXTRACT.FIELD
(LAMBDA (STR START END COMMENTS) (* ; "Edited 10-Jun-88 17:11 by bvm") (if COMMENTS then (LET (TMP PIECES) (SETQ PIECES (for PAIR in (if (CDR COMMENTS) then (REVERSE COMMENTS) else COMMENTS) when (AND (<= START (CAR PAIR)) (< (CAR PAIR) END) (PROG1 (SETQ TMP (\GV.EXTRACT.FIELD STR START (CAR PAIR))) (SETQ START (CADR PAIR)))) join (LIST " " TMP))) (if (SETQ TMP (\GV.EXTRACT.FIELD STR START END)) then (SETQ PIECES (NCONC PIECES (LIST " " TMP)))) (CONCATLIST (CDR PIECES))) else (* ; "trim white space from edges") (while (AND (< START END) (CASE (CL:CHAR STR START) ((#\Space #\Tab #\Newline) T))) do (add START 1)) (while (AND (< START END) (CASE (CL:CHAR STR (- END 1)) ((#\Space #\Tab #\Newline) T))) do (add END -1)) (AND (< START END) (CL:SUBSEQ STR START END))))
)

(\GV.HANDLE.DL
(LAMBDA (DL INTERNALFLG EDITWINDOW) (* ; "Edited 13-Jun-88 14:17 by bvm") (CASE INTERNALFLG ((NIL :BOTH) (* ; "Don't want the actual addresses, just something to stick in a header.  We assume user of :BOTH is answer, or something that is mainly concerned with textual presentation to user.") (LET ((STR (CONCAT DL ":;"))) (LIST (if INTERNALFLG then (* ; "(pretty . internal)") (LIST* STR STR NIL) else STR)))) (T (LET ((FILENAME (PACKFILENAME.STRING (QUOTE BODY) (if (EQL (CL:CHAR DL 0) #\") then (* ; "quoted file name, take off the quotes first") (CL:SUBSEQ DL 1 (- (CL:LENGTH DL) 1)) else DL) (QUOTE EXTENSION) LAFITEDL.EXT)) STREAM) (if (NULL (SETQ FILENAME (if (OR (UNPACKFILENAME.STRING FILENAME (QUOTE HOST)) (UNPACKFILENAME.STRING FILENAME (QUOTE DIRECTORY))) then (INFILEP FILENAME) else (* ; "Search default directories") (FINDFILE FILENAME T (CONS LAFITEDEFAULTHOST&DIR LAFITEDLDIRECTORIES))))) then (LIST :ERROR "Can't find file by this name") elseif (NULL (SETQ STREAM (CAR (NLSETQ (OPENTEXTSTREAM (MKATOM FILENAME)))))) then (LIST :ERROR (CONCAT "Can't open " DL)) else (RESETLST (RESETSAVE NIL (LIST (QUOTE CLOSEF) STREAM)) (* ; "I hope this closes the file.  We used OPENTEXTSTREAM instead of OPEN so that file can contain tedit formatting.") (bind LINE SOME RESULT while (SETQ LINE (CL:READ-LINE STREAM NIL NIL)) when (SETQ SOME (\GV.PARSERECIPIENTS1 LINE NIL INTERNALFLG EDITWINDOW T)) do (* ; "Note that we parse with respect to NO registry--require that the file contain all complete addresses") (if (EQ (CAR SOME) :ERROR) then (RETURN SOME) else (SETQ RESULT (NCONC SOME RESULT))) finally (* ; "Whole file parsed ok, so return the result") (RETURN RESULT))))))))
)

(\GV.PARSE.FAILED
(LAMBDA (ADDRESS) (* ; "Edited 13-Oct-87 14:17 by bvm:") (LIST :ERROR (CONCAT "Bad addressee " ADDRESS)))
)

(\LAFITE.CHOOSE.REPLYTO
(LAMBDA (TEXTSTREAM HEADEREOF FROMFIELD EDITORWINDOW) (* ; "Edited  3-Nov-89 12:59 by bvm") (* ;;; "Invoked when sending to a distribution list.  Ask user for Reply-to: field, and if one is chosen, enter it into message") (COND ((NULL EDITORWINDOW) T) (T (SELECTQ (\SENDMESSAGE.MENUPROMPT EDITORWINDOW (OR LAFITEREPLYTOMENU (SETQ LAFITEREPLYTOMENU (\LAFITE.CREATE.MENU LAFITEREPLYTOMENUITEMS "Include a Reply-to field?" T))) "Message is addressed to a distribution list" (QUOTE LAFITEREPLYTOMENU)) (NO T) (SELF (\LAFITE.INSERT.REPLYTO TEXTSTREAM (COND (FROMFIELD (* ; "Message explicitly from someone other than logged-in user, so set accordingly") (CONCATLIST (CDR (for GVNAME in FROMFIELD join (CONS ", " (COND ((EQ (CDR GVNAME) ARPANETGATEWAY.REGISTRY) (LIST (CAR GVNAME))) (T (LIST (CAR GVNAME) "." (CDR GVNAME))))))))) (T (fetch (LAFITEMODEDATA FULLUSERNAME) of *LAFITE-MODE-DATA*))) NIL HEADEREOF) T) (OTHER (\LAFITE.INSERT.REPLYTO TEXTSTREAM ">>Address<<" T HEADEREOF) NIL) (ABORT NIL) NIL))))
)
)
(DEFINEQ

(\GV.MESSAGE.P
(LAMBDA (MSG) (* ; "Edited  6-May-88 13:58 by bvm") (* ;; "Test whether the specified message is a GV message.  We test for sender having gv format.  This may fail for msgs with malformed from, but that's too bad.") (LET* ((SENDER (fetch (LAFITEMSG FROM) of MSG)) (DOT (STRPOS "." SENDER))) (if (NULL DOT) then (* ; "No registry") NIL elseif (NULL (STRPOS ":" SENDER)) then (* ; "Registry and no colon, so believe it.  This is based on the assumption that all grapevine users are internal Xerox with only NS as competition.") T else (* ; "Subject it to the rigorous parser.") (NOT (FMEMB NIL (\GV.PARSERECIPIENTS1 SENDER))))))
)

(\GV.MESSAGE.FROM.SELF.P
(LAMBDA (MSG) (* ; "Edited  6-May-88 14:36 by bvm") (* ;; "True if message is from current user") (LET ((SENDER (fetch (LAFITEMSG FROM) of MSG)) (ME (fetch (LAFITEMODEDATA FULLUSERNAME) of *LAFITE-MODE-DATA*)) HIT) (AND (SETQ HIT (STRPOS ME SENDER NIL NIL NIL NIL UPPERCASEARRAY)) (if (EQ (SETQ HIT (SUB1 HIT)) 0) then (* ; "Matched at start--is the length right?") (EQ (NCHARS ME) (NCHARS SENDER)) elseif (EQ (CL:CHAR SENDER (SUB1 HIT)) #\<) then (* ; "Also recognize %"name <realname>%"") (AND (< (add HIT (NCHARS ME)) (NCHARS SENDER)) (EQ (CL:CHAR SENDER HIT) #\>))))))
)

(GV.MAKEANSWERFORM
(LAMBDA (MSGDESCRIPTORS MAILFOLDER) (* ; "Edited 10-Jun-88 17:27 by bvm") (LET ((MSGFIELDS (\LAFITE.PARSE.MESSAGE MAILFOLDER (OR (CAR (LISTP MSGDESCRIPTORS)) MSGDESCRIPTORS))) SUBJECT FROM DATE SENDER REPLYTO TO CC ORIGINALREGISTRY OLDFROM NEWTO NEWCC) (* ; "get the fields from the file") (for PAIR in MSGFIELDS do (SELECTQ (CAR PAIR) (Subject (SETQ SUBJECT (CADR PAIR))) (Sender (SETQ SENDER (CADR PAIR))) (From (SETQ FROM (CADR PAIR))) (Date (SETQ DATE (CADR PAIR))) (Reply-to (SETQ REPLYTO (CDR PAIR))) (To (SETQ TO (CDR PAIR))) (cc (SETQ CC (CDR PAIR))) NIL)) (* ;; "first parse the strings into recipients.  Need to find the sender's registry in order to get the registry defaults correct for its recipients.") (COND (SENDER (* ; "Sender is a mail address, and has the official registry") (SETQ OLDFROM (\GV.PARSERECIPIENTS SENDER NIL :BOTH)) (* ; "Elements are of the form (prettyname gvname . registry)") (if FROM then (* ; "Now that we have a source of official registry (we hope), parse the From field with reference to it.") (SETQ OLDFROM (\GV.PARSERECIPIENTS FROM (PROGN (* ; "Return first element that has a registry") (CL:SOME (QUOTE CDDR) OLDFROM)) :BOTH)))) (FROM (* ; "Have to parse the From field before we can get its registry") (SETQ OLDFROM (\GV.PARSERECIPIENTS FROM NIL :BOTH)))) (if (NULL OLDFROM) then (LAB.PROMPTPRINT MAILFOLDER T "Warning: message has no FROM field") else (SETQ ORIGINALREGISTRY (CL:SOME (QUOTE CDDR) OLDFROM)) (* ; "Choose first element that has a registry")) (AND TO (SETQ TO (\GV.PARSERECIPIENTS TO ORIGINALREGISTRY :BOTH))) (AND CC (SETQ CC (\GV.PARSERECIPIENTS CC ORIGINALREGISTRY :BOTH))) (SETQ NEWTO (OR (AND REPLYTO (SETQ REPLYTO (\GV.PARSERECIPIENTS REPLYTO ORIGINALREGISTRY :BOTH))) OLDFROM)) (SETQ NEWCC (\GV.DIFFERENCE (COND (REPLYTO (* ; "Reply goes only to this address, so the only cc is to self") (LIST (CONS (fetch (LAFITEMODEDATA FULLUSERNAME) of *LAFITE-MODE-DATA*) (fetch (LAFITEMODEDATA UNPACKEDUSERNAME) of *LAFITE-MODE-DATA*)))) (T (* ; "By default CC everyone who received the original message and to whom we are not directly replying already") (APPEND TO (\GV.DIFFERENCE CC TO)))) NEWTO)) (LAFITE.FILL.IN.ANSWER.FORM SUBJECT (if (AND (OR (NULL REPLYTO) (EQUAL REPLYTO OLDFROM)) (NULL (CDR NEWCC)) (OR (NULL NEWCC) (LET ((CC1 (CDAR NEWCC)) (CC2 (fetch (LAFITEMODEDATA UNPACKEDUSERNAME) of *LAFITE-MODE-DATA*))) (AND (STRING-EQUAL (CAR CC1) (CAR CC2)) (STRING-EQUAL (CDR CC1) (CDR CC2)))))) then (* ; "Replying only to sender (and maybe self), so just say %"your%" instead of %"Joe Bob Smith <JBSmith.pa>'s%"") NIL else FROM) DATE NEWTO NEWCC (FUNCTION (LAMBDA (NAMES STREAM) (* ;; "Print all the pretty names") (LA.PRINT.COMMA.LIST (MAPCAR NAMES (FUNCTION CAR)) STREAM))))))
)

(\GV.DIFFERENCE
(LAMBDA (A B) (* ; "Edited  6-Jun-88 13:49 by bvm") (* ;; "Return all the names in A that aren't in B.  Names are of the form (prettyname gvname . registry).  We can't eliminate all gvname duplicates, since sometimes the prettyname contains more information (yecch).") (for TRIPLE in A collect TRIPLE unless (for OTHER in B bind (GVNAME _ (CADR TRIPLE)) thereis (AND (STRING-EQUAL (CADR OTHER) GVNAME) (OR (PROGN (* ; "Identical pretty names") (STRING-EQUAL (CAR OTHER) (CAR TRIPLE))) (PROGN (* ; "Identical gv names, and TRIPLE has no interesting additional info, like a people name") (AND (STRING-EQUAL (CDDR OTHER) (CDDR TRIPLE)) (STRING-EQUAL (CAR TRIPLE) (CONCAT (CADR TRIPLE) "." (CDDR TRIPLE))))))))))
)
)

(ADDTOVAR MAILSERVERTYPES )

(ADDTOVAR LAFITEDLDIRECTORIES )

(ADDTOVAR LAFITE.PERSONAL.VARS LAFITE.GV.FROM.FIELD)

(RPAQ? ARPANETGATEWAY.REGISTRY 'AG)

(RPAQ? LAFITEREPLYTOMENU NIL)

(RPAQ? LAFITEDL.EXT "DL")

(RPAQ? LAFITE.GV.FROM.FIELD )

(ADDTOVAR LAFITESUPPORT (GV "LafiteSupport.pa"))

(ADDTOVAR LAFITEMENUVARS LAFITEREPLYTOMENU)

(RPAQQ LAFITEREPLYTOMENUITEMS (("Send message as is" 'NO)
                                   ("Reply-to: me" 'SELF 
                                "Insert a Reply-to: field instructing responder to reply only to you"
                                          )
                                   ("Reply-to: other" 'OTHER 
                                          "Edit your own Reply-to: field into the message")
                                   ("Abort" 'ABORT "Don't send the message")))

(PUTPROPS MAINTAIN FILEDEF MAINTAIN)
(DECLARE%: DOEVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE

(RECORD MAILPORT (HOST# . SOCKET#))

(RECORD GVMAILPARSE (GVPSUBJECT GVPFROM GVPFORMAT . GVPRECIPIENTS))
)


(RPAQQ MAILCLIENTCONSTANTCOMS
       ((COMS                                                (* ; "Mail retrieval opcodes")
              (CONSTANTS (\OP.ADDRECIPIENT 21)
                     (\OP.ADDTOITEM 24)
                     (\OP.CHECKVALIDITY 22)
                     (\OP.HUMANMESS 520)
                     (\OP.MSEXPAND 27)
                     (\OP.SEND 26)
                     (\OP.STARTITEM 23)
                     (\OP.STARTSEND 20))
              (CONSTANTS (\MAILSOCKETTIMEOUT 36000000)))
        (COMS                                                (* ; "Mail sender opcodes")
              (CONSTANTS (\OP.OPENINBOX 0)
                     (\OP.NEXTMESSAGE 1)
                     (\OP.READTOC 2)
                     (\OP.READMESSAGE 3)
                     (\OP.WRITETOC 4)
                     (\OP.DELETEMESSAGE 5)
                     (\OP.FLUSH 6)))
        (COMS                                                (* ; 
                                                      "return codes from 'start to send a message'")
              (CONSTANTS (\RC.SENDSTARTED 0)
                     (\RC.PASSWORDINVALID 1)
                     (\RC.SENDERNOTREGISTERED 2)
                     (\RC.RETURNTONOTREGISTERED 3)
                     (\RC.COMMUNICATIONFAILURE 4)))
        (COMS                                                (* ; 
                                                           "return codes from 'open mail box'")
              (CONSTANTS (\RC.NAMEISGROUP 1)
                     (\RC.NAMEANDPASSWORDVALID 2)
                     (\RC.NAMENOTREGISTERED 3)
                     (\RC.COMMUNICATIONFAILURE 4)
                     (\RC.INVALIDPASSWORD 5)))
        (COMS                                                (* ; "Message Item types")
              (CONSTANTS (\I.POSTMARK 8)
                     (\I.SENDER 16)
                     (\I.RETURNTO 24)
                     (\I.RECIPIENTS 32)
                     (\I.TEXT 520)
                     (\I.OLDTEDITFORMATTING '(560 561))
                     (\I.TEDITFORMATTING 562)
                     (\I.END 65535)))
        (CONSTANTS (\PT.LAURELCHECK 140)
               (\PT.NOMAILBOX 139)
               (\PT.NONEWMAIL 138)
               (\PT.NEWMAIL 137))))



(* ; "Mail retrieval opcodes")

(DECLARE%: EVAL@COMPILE 

(RPAQQ \OP.ADDRECIPIENT 21)

(RPAQQ \OP.ADDTOITEM 24)

(RPAQQ \OP.CHECKVALIDITY 22)

(RPAQQ \OP.HUMANMESS 520)

(RPAQQ \OP.MSEXPAND 27)

(RPAQQ \OP.SEND 26)

(RPAQQ \OP.STARTITEM 23)

(RPAQQ \OP.STARTSEND 20)


(CONSTANTS (\OP.ADDRECIPIENT 21)
       (\OP.ADDTOITEM 24)
       (\OP.CHECKVALIDITY 22)
       (\OP.HUMANMESS 520)
       (\OP.MSEXPAND 27)
       (\OP.SEND 26)
       (\OP.STARTITEM 23)
       (\OP.STARTSEND 20))
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ \MAILSOCKETTIMEOUT 36000000)


(CONSTANTS (\MAILSOCKETTIMEOUT 36000000))
)



(* ; "Mail sender opcodes")

(DECLARE%: EVAL@COMPILE 

(RPAQQ \OP.OPENINBOX 0)

(RPAQQ \OP.NEXTMESSAGE 1)

(RPAQQ \OP.READTOC 2)

(RPAQQ \OP.READMESSAGE 3)

(RPAQQ \OP.WRITETOC 4)

(RPAQQ \OP.DELETEMESSAGE 5)

(RPAQQ \OP.FLUSH 6)


(CONSTANTS (\OP.OPENINBOX 0)
       (\OP.NEXTMESSAGE 1)
       (\OP.READTOC 2)
       (\OP.READMESSAGE 3)
       (\OP.WRITETOC 4)
       (\OP.DELETEMESSAGE 5)
       (\OP.FLUSH 6))
)



(* ; "return codes from 'start to send a message'")

(DECLARE%: EVAL@COMPILE 

(RPAQQ \RC.SENDSTARTED 0)

(RPAQQ \RC.PASSWORDINVALID 1)

(RPAQQ \RC.SENDERNOTREGISTERED 2)

(RPAQQ \RC.RETURNTONOTREGISTERED 3)

(RPAQQ \RC.COMMUNICATIONFAILURE 4)


(CONSTANTS (\RC.SENDSTARTED 0)
       (\RC.PASSWORDINVALID 1)
       (\RC.SENDERNOTREGISTERED 2)
       (\RC.RETURNTONOTREGISTERED 3)
       (\RC.COMMUNICATIONFAILURE 4))
)



(* ; "return codes from 'open mail box'")

(DECLARE%: EVAL@COMPILE 

(RPAQQ \RC.NAMEISGROUP 1)

(RPAQQ \RC.NAMEANDPASSWORDVALID 2)

(RPAQQ \RC.NAMENOTREGISTERED 3)

(RPAQQ \RC.COMMUNICATIONFAILURE 4)

(RPAQQ \RC.INVALIDPASSWORD 5)


(CONSTANTS (\RC.NAMEISGROUP 1)
       (\RC.NAMEANDPASSWORDVALID 2)
       (\RC.NAMENOTREGISTERED 3)
       (\RC.COMMUNICATIONFAILURE 4)
       (\RC.INVALIDPASSWORD 5))
)



(* ; "Message Item types")

(DECLARE%: EVAL@COMPILE 

(RPAQQ \I.POSTMARK 8)

(RPAQQ \I.SENDER 16)

(RPAQQ \I.RETURNTO 24)

(RPAQQ \I.RECIPIENTS 32)

(RPAQQ \I.TEXT 520)

(RPAQQ \I.OLDTEDITFORMATTING (560 561))

(RPAQQ \I.TEDITFORMATTING 562)

(RPAQQ \I.END 65535)


(CONSTANTS (\I.POSTMARK 8)
       (\I.SENDER 16)
       (\I.RETURNTO 24)
       (\I.RECIPIENTS 32)
       (\I.TEXT 520)
       (\I.OLDTEDITFORMATTING '(560 561))
       (\I.TEDITFORMATTING 562)
       (\I.END 65535))
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ \PT.LAURELCHECK 140)

(RPAQQ \PT.NOMAILBOX 139)

(RPAQQ \PT.NONEWMAIL 138)

(RPAQQ \PT.NEWMAIL 137)


(CONSTANTS (\PT.LAURELCHECK 140)
       (\PT.NOMAILBOX 139)
       (\PT.NONEWMAIL 138)
       (\PT.NEWMAIL 137))
)


(CL:PROCLAIM '(GLOBAL MAILSERVERTYPES ARPANETGATEWAY.REGISTRY LAFITEREPLYTOMENUITEMS 
                     LAFITEREPLYTOMENU))

(CL:PROCLAIM '(CL:SPECIAL *MSGOUTSTREAM*))


(FILESLOAD (SOURCE)
       LAFITEDECLS)


(FILESLOAD (LOADCOMP)
       GRAPEVINE PUP BSP)

(DECLARE%: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(CL:PROCLAIM '(GLOBAL LAFITE.GV.FROM.FIELD LAFITEDL.EXT LAFITEDLDIRECTORIES))

(CL:PROCLAIM '(CL:SPECIAL *GV-SHOW-POSTMARK*))


(FILESLOAD GRAPEVINE)
)
(PUTPROPS MAILCLIENT COPYRIGHT ("Venue & Xerox Corporation" 1983 1984 1985 1986 1987 1988 1989 1990))
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (4636 7478 (GV.STARTSEND 4646 . 5324) (GV.ADDRECIPIENT 5326 . 5469) (GV.CHECKVALIDITY 
5471 . 5617) (GV.STARTITEM 5619 . 5820) (GV.ADDTOITEM 5822 . 7080) (GV.SEND 7082 . 7204) (MS.EXPAND 
7206 . 7476)) (7512 9991 (MS.SENDOPERATION 7522 . 8117) (\FINDMAILSERVER 8119 . 8472) (
\MAILSERVERSOCKETS 8474 . 8842) (\RECEIVEACK 8844 . 8999) (\RESPTOCHECKVAL 9001 . 9306) (\RESPTOEXPAND
 9308 . 9636) (\RESPTOSTARTSEND 9638 . 9989)) (10491 13022 (GV.PORTFROMNAME 10501 . 10648) (
GV.POLLNEWMAIL 10650 . 11462) (GV.OPENMAILBOX 11464 . 12116) (GV.NEXTMESSAGE 12118 . 12496) (
GV.RETRIEVEMESSAGE 12498 . 12739) (GV.CLOSEMAILBOX 12741 . 13020)) (13226 13684 (GV.READTOC 13236 . 
13375) (GV.WRITETOC 13377 . 13532) (GV.DELETEMESSAGE 13534 . 13682)) (13720 17357 (
MS.RETRIEVEOPERATION 13730 . 14190) (\CONNECTTOMAILSERVER 14192 . 14612) (\RESPTOOPENMAILBOX 14614 . 
14933) (\RESPTONEXTMESSAGE 14935 . 15087) (\RESPTORETRIEVEMESSAGE 15089 . 16896) (\RECEIVELONGWORD 
16898 . 17092) (\CACHED.HOST.NAME 17094 . 17355)) (17852 20265 (GV.INIT.MAIL.USER 17862 . 19562) (
GETMAILSERVEROPS 19564 . 20009) (\GV.MAILSERVERTYPE 20011 . 20263)) (20266 30747 (\GV.SENDMESSAGE 
20276 . 29910) (\GV.SENDRECIPIENTS 29912 . 30745)) (30748 43923 (\GV.SEND.PARSE 30758 . 32433) (
\GV.PARSERECIPIENTS 32435 . 32824) (\GV.PARSERECIPIENTS1 32826 . 38048) (\GV.FIND.NON.SPACE 38050 . 
38371) (\GV.PARSE.SIMPLE.RECIPIENT 38373 . 40254) (\GV.EXTRACT.FIELD 40256 . 41052) (\GV.HANDLE.DL 
41054 . 42758) (\GV.PARSE.FAILED 42760 . 42889) (\LAFITE.CHOOSE.REPLYTO 42891 . 43921)) (43924 48688 (
\GV.MESSAGE.P 43934 . 44581) (\GV.MESSAGE.FROM.SELF.P 44583 . 45186) (GV.MAKEANSWERFORM 45188 . 47954)
 (\GV.DIFFERENCE 47956 . 48686)))))
STOP
