(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "INTERLISP")
(FILECREATED "26-Oct-91 20:44:05" |{DSK}<usr>local>lde>lispcore>internal-library>UNIXMAIL.;5| 27661  

      |changes| |to:|  (FNS \\UNIXMAIL.SEND.PARSE \\UNIXMAIL.MAKEANSWERFORM) (VARS UNIXMAILCOMS)

      |previous| |date:| "15-Sep-91 11:45:45" 
|{DSK}<usr>local>lde>lispcore>internal-library>UNIXMAIL.;4|)


; Copyright (c) 1989, 1990, 1991 by ENVOS Corporation.  All rights reserved.

(PRETTYCOMPRINT UNIXMAILCOMS)

(RPAQQ UNIXMAILCOMS ((DECLARE\: DOEVAL@COMPILE DONTCOPY (FILES (SOURCE) LAFITEDECLS MAILCLIENT NSMAIL) (RECORDS UNIXMAILBOX UNIXMAILFILEINFO UNIXMAILPARSE)) (ALISTS (LAFITEMODELST UNIX)) (* |;;| "These variables control how mail is sent and received.  UNIXMAIL.SEND.MODE controls whether the SMTP stream is opened via process-stream (PROCESS) or TCP socket (TCP).  UNIXMAIL.RECEIVE.MODE controls whether mail is received through the Berkeley mailer (MAILER) or by reading the spool file directly (SPOOL).  PROCESS and MAILER can only be done under an emulator; TCP and SPOOL will also work on D-machines (but may need other library packages like TCP or NFS).") (INITVARS (UNIXMAIL.SEND.MODE (QUOTE PROCESS)) (UNIXMAIL.RECEIVE.MODE (QUOTE SPOOL))) (* |;;| "List used by \\UNIXMAIL.AUTHENTICATE to construct the MAILSERVEROPS list") (VARS UNIXMAIL.MSOPS.LIST) (* |;;| "These variables control filenames, hostnames, etc. They default to NIL, meaning they are not used or the mailer will try and figure them out itself") (INITVARS UNIXMAIL.SEND.HOST (UNIXMAIL.SEND.PROCESS "/usr/etc/mconnect") (UNIXMAIL.RECEIVE.PROCESS "/usr/ucb/mail -N") UNIXMAIL.SPOOL.FILE (UNIXMAIL.DONT.RECEIVE.STATUS "") (UNIXMAIL.WRAP.LINES T) (UNIXMAIL.WRAP-LIMIT 72) (UNIXMAIL.TABWIDTH 8)) (* |;;| "Functions used to receive mail") (FNS UNIX.POLLNEWMAIL UNIX.NEXTMESSAGE UNIXMAILER.OPENMAILBOX UNIXMAILER.RETRIEVEMESSAGE UNIXMAILER.CLOSEMAILBOX UNIXSPOOL.OPENMAILBOX UNIXSPOOL.RETRIEVEMESSAGE UNIXSPOOL.CLOSEMAILBOX) (* |;;| "Functions used to send mail") (FNS UNIX.FLUSH.STREAM UNIX.RETRIEVE.LINE \\UNIXMAIL.SEND \\UNIXMAIL.SEND.PARSE \\UNIXMAIL.SMTP \\UNIXMAIL.SMTP.FLUSH) (* |;;| "This returns multiple-values, so it's a CL:LAMBDA (what the heck).") (FUNCTIONS \\UNIXMAIL.SMTP.TCP.STREAMS) (* |;;| "Other functions Lafite uses and needs Unix equivalents for") (FNS \\UNIXMAIL.AUTHENTICATE \\UNIXMAIL.LOGIN \\UNIXMAIL.PARSENAMES \\UNIXMAIL.MAKEANSWERFORM \\UNIXMAIL.MESSAGE.FROM.SELF.P \\UNIXMAIL.MESSAGE.P) (* |;;| "This is a stub needed by the TEdit-uuencode strategy; if we ever decide on a reasonable way to do this and make it part of Lafite, this may go away") (P (MOVD? (QUOTE NILL) (QUOTE UNIX.UUDECODE.IF.NEEDED))) (PROP FILETYPE UNIXMAIL)))
(DECLARE\: DOEVAL@COMPILE DONTCOPY 

(FILESLOAD (SOURCE) LAFITEDECLS MAILCLIENT NSMAIL)

(DECLARE\: EVAL@COMPILE

(RECORD UNIXMAILBOX (UMSTREAM UMNUMBERS UMNEXT))

(RECORD UNIXMAILFILEINFO (UMFNAME UMFTIME))

(RECORD UNIXMAILPARSE (UNIXFROM UNIXTO UNIXOTHER FORMATTED? UNIXBODY))
)
)

(ADDTOVAR LAFITEMODELST (UNIX 3 \\UNIXMAIL.SEND.PARSE \\UNIXMAIL.SEND \\UNIXMAIL.MAKEANSWERFORM \\UNIXMAIL.AUTHENTICATE \\UNIXMAIL.MESSAGE.P \\UNIXMAIL.MESSAGE.FROM.SELF.P \\UNIXMAIL.LOGIN))



(* |;;| 
"These variables control how mail is sent and received.  UNIXMAIL.SEND.MODE controls whether the SMTP stream is opened via process-stream (PROCESS) or TCP socket (TCP).  UNIXMAIL.RECEIVE.MODE controls whether mail is received through the Berkeley mailer (MAILER) or by reading the spool file directly (SPOOL).  PROCESS and MAILER can only be done under an emulator; TCP and SPOOL will also work on D-machines (but may need other library packages like TCP or NFS)."
)


(RPAQ? UNIXMAIL.SEND.MODE (QUOTE PROCESS))

(RPAQ? UNIXMAIL.RECEIVE.MODE (QUOTE SPOOL))



(* |;;| "List used by \\UNIXMAIL.AUTHENTICATE to construct the MAILSERVEROPS list")


(RPAQQ UNIXMAIL.MSOPS.LIST ((MAILER UNIX.POLLNEWMAIL UNIXMAILER.OPENMAILBOX UNIX.NEXTMESSAGE UNIXMAILER.RETRIEVEMESSAGE UNIXMAILER.CLOSEMAILBOX) (SPOOL UNIX.POLLNEWMAIL UNIXSPOOL.OPENMAILBOX UNIX.NEXTMESSAGE UNIXSPOOL.RETRIEVEMESSAGE UNIXSPOOL.CLOSEMAILBOX)))



(* |;;| 
"These variables control filenames, hostnames, etc. They default to NIL, meaning they are not used or the mailer will try and figure them out itself"
)


(RPAQ? UNIXMAIL.SEND.HOST NIL)

(RPAQ? UNIXMAIL.SEND.PROCESS "/usr/etc/mconnect")

(RPAQ? UNIXMAIL.RECEIVE.PROCESS "/usr/ucb/mail -N")

(RPAQ? UNIXMAIL.SPOOL.FILE NIL)

(RPAQ? UNIXMAIL.DONT.RECEIVE.STATUS "")

(RPAQ? UNIXMAIL.WRAP.LINES T)

(RPAQ? UNIXMAIL.WRAP-LIMIT 72)

(RPAQ? UNIXMAIL.TABWIDTH 8)



(* |;;| "Functions used to receive mail")

(DEFINEQ

(UNIX.POLLNEWMAIL
(LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER) (* \; "Edited 24-Oct-90 00:04 by jrb:") (* |;;| "We have mail iff our mail spool file (either the value of UNIXMAIL.SPOOL.FILE or /usr/spool/mail/<SHORTUSERNAME>) exists and its date is later than the last time we got our Unix mail.  In relentlessly hackish use of the existing MAILSERVER structure, MAILPORT holds a UNIXMAILFILEINFO which remembers the name of our mail file and when we last looked at it.") (LET ((FILEINFO (OR (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER) (|replace| (MAILSERVER MAILPORT) |of| MAILSERVER |with| (|create| UNIXMAILFILEINFO UMFNAME _ (OR UNIXMAIL.SPOOL.FILE (CL:CONCATENATE (QUOTE STRING) "{UNIX}/usr/spool/mail/" (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) UMFTIME _ 0))))) (AND (CL:PROBE-FILE (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| FILEINFO)) (IGREATERP (GETFILEINFO (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| FILEINFO) (QUOTE LENGTH)) 0) (IGREATERP (GETFILEINFO (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| FILEINFO) (QUOTE IWRITEDATE)) (|fetch| (UNIXMAILFILEINFO UMFTIME) |of| FILEINFO)))))
)

(UNIX.NEXTMESSAGE
(LAMBDA (MAILBOX) (* \; "Edited  5-Jan-89 18:18 by bane") (CAR (|fetch| UMNEXT |of| MAILBOX))))

(UNIXMAILER.OPENMAILBOX
(LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER) (* \; "Edited 15-Oct-90 20:31 by jrb:") (* |;;| "A Unix \"mailbox\" is a process-stream talking to /usr/ucb/mail ") (|if| (OR (|fetch| (MAILSERVER NEWMAILP) |of| MAILSERVER) (UNIX.POLLNEWMAIL ADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER)) |then| (LET* ((MSTREAM (CREATE-PROCESS-STREAM UNIXMAIL.RECEIVE.PROCESS)) (UMBOX (|create| UNIXMAILBOX UMSTREAM _ MSTREAM UMNUMBERS _ NIL UMNEXT _ NIL)) NUMBERS) (* |;;| "Get it in condition to be talked to") (CL:FORMAT MSTREAM "set screen=10000~%set prompt= ~%") (BLOCK 1000) (UNIX.FLUSH.STREAM MSTREAM) (* |;;| "OK, get it to print the headers followed by a line with a strange character on it (char code 254)") (CL:FORMAT MSTREAM "h~%echo ") (PRINTCCODE 254 MSTREAM) (PRINTCCODE (CHARCODE NEWLINE) MSTREAM) (* |;;| "Before we really get rolling, scream if UNIXMAIL.DONT.RECEIVE.STATUS isn't a string") (OR (STRINGP UNIXMAIL.DONT.RECEIVE.STATUS) (ERROR "UNIXMAIL.DONT.RECEIVE.STATUS isn't a string" UNIXMAIL.DONT.RECEIVE.STATUS)) (* |;;| "Headers look like this:") (* |;;| "<space><status-char> other junk like size, subject...") (|until| (EQ (READCCODE MSTREAM) 254) |do| (|if| (NULL (STRPOS (CL:READ-CHAR MSTREAM) UNIXMAIL.DONT.RECEIVE.STATUS)) |then| (|push| NUMBERS (READ MSTREAM))) (UNIX.FLUSH.STREAM MSTREAM (CHARCODE NEWLINE)) |finally| (UNIX.FLUSH.STREAM MSTREAM (CHARCODE NEWLINE))) (|if| NUMBERS |then| (SETQ NUMBERS (DREVERSE NUMBERS)) (|replace| UMNUMBERS |of| UMBOX |with| NUMBERS) (|replace| UMNEXT |of| UMBOX |with| NUMBERS) (|create| OPENEDMAILBOX MAILBOX _ UMBOX PROPERTIES _ (LIST (QUOTE \#OFMESSAGES) (LENGTH NUMBERS))) |else| (CL:FORMAT MSTREAM "x~%") (* \; "Empty; close the mail process") (* \; "and remember that we've checked on the mailbox.") (* \; "HACK!  Depends on \\LAFITE.RETRIEVEMESSAGES binding of MAILSERVER") (|replace| (UNIXMAILFILEINFO UMFTIME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER) |with| (IDATE)) (QUOTE EMPTY))) |else| (QUOTE EMPTY)))
)

(UNIXMAILER.RETRIEVEMESSAGE
(LAMBDA (MAILBOX MSGOUTFILE) (* \; "Edited  5-Sep-90 22:58 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of| MAILBOX)) (OUTSTART (GETFILEPTR MSGOUTFILE))) (* |;;| "The UMCOUNT in the MAILBOX is the number of the message we're about to read in.  The echo command below makes the message text be followed by a line starting with the character 254; you'll never see that in a message that has gone over an SMTP channel (guaranteed 7-bit chars).") (CL:FORMAT MSTREAM "p ~d~%echo " (|pop| (|fetch| UMNEXT |of| MAILBOX))) (PRINTCCODE 254 MSTREAM) (PRINTCCODE (CHARCODE NEWLINE) MSTREAM) (UNIX.FLUSH.STREAM MSTREAM (CHARCODE NEWLINE)) (* \; "Throw away \"Message 1:\" line") (|while| (UNIX.RETRIEVE.LINE MSTREAM MSGOUTFILE) |do| NIL) (* |;;| "This could use a little error-handling, of course... perhaps a LOT of error handling.") (* |;;| "Check out the tail of the message and uudecode it if it's an encoded message") (UNIX.UUDECODE.IF.NEEDED MSGOUTFILE OUTSTART)))
)

(UNIXMAILER.CLOSEMAILBOX
(LAMBDA (MAILBOX FLUSH?) (* \; "Edited  5-Sep-90 23:01 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of| MAILBOX))) (* |;;| "If FLUSH?, first clean out the mailbox") (|if| FLUSH? |then| (CL:FORMAT MSTREAM "d~{ ~D~}~%" (|fetch| UMNUMBERS |of| MAILBOX))) (* |;;| "Then close it up") (CL:FORMAT MSTREAM "q~%") (CLOSEF MSTREAM) (* |;;| "Twiddle a second to let the mailer run, then remember what time we closed the mailbox") (BLOCK 1000) (* |;;| "HACK!  Depends on \\LAFITE.RETRIEVEMESSAGES binding of MAILSERVER") (|replace| (UNIXMAILFILEINFO UMFTIME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER) |with| (IDATE))))
)

(UNIXSPOOL.OPENMAILBOX
(LAMBDA (ADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER) (* \; "Edited 13-Sep-90 20:25 by jrb:") (* |;;| "A Unix \"mailbox\" is a stream open on the mail spool file") (|if| (OR (|fetch| (MAILSERVER NEWMAILP) |of| MAILSERVER) (UNIX.POLLNEWMAIL ADDRESS REGISTEREDNAME CREDENTIALS MAILSERVER)) |then| (LET* ((MSTREAM (OPENSTREAM (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER)) (QUOTE INPUT) NIL (QUOTE (EOL LF)))) (UMBOX (|create| UNIXMAILBOX UMSTREAM _ MSTREAM UMNUMBERS _ NIL UMNEXT _ NIL)) NUMBERS) (* |;;| "Merrily scan the spool file remembering where all the messages start; there had better be at least one.  All messages in Unix spool files start with the character sequence \"(OR beginning-of-file Newline)From \"; this sequence is guaranteed to occur nowhere else but at the start of messages.") (|if| (ZEROP (FILEPOS "From " MSTREAM)) |then| (|push| NUMBERS 0) (* |;;| "The (CONCAT...) stuff below is to avoid having a string with a LF character in it; the file package/reader/printer have been known to EOL-translate such characters in strings inappropriately.") (|bind| POS |while| (SETQ POS (FILEPOS (CONSTANT (CONCAT (CHARACTER (CHARCODE LF)) "From ")) MSTREAM)) |do| (|push| NUMBERS (ADD1 POS)) (READCCODE MSTREAM)) (SETQ NUMBERS (DREVERSE NUMBERS)) (|replace| UMNUMBERS |of| UMBOX |with| NUMBERS) (|replace| UMNEXT |of| UMBOX |with| NUMBERS) (SETFILEPTR MSTREAM 0) (|create| OPENEDMAILBOX MAILBOX _ UMBOX PROPERTIES _ (LIST (QUOTE \#OFMESSAGES) (LENGTH NUMBERS))) |else| (CLOSEF MSTREAM) (ERROR "Mail spool file is not in Unix format:" (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER))) (QUOTE EMPTY))) |else| (QUOTE EMPTY)))
)

(UNIXSPOOL.RETRIEVEMESSAGE
(LAMBDA (MAILBOX MSGOUTFILE) (* \; "Edited  5-Sep-90 22:59 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of| MAILBOX)) (OUTSTART (GETFILEPTR MSGOUTFILE))) (* |;;| "The numbers in the UMNEXT of the mailbox are file positions in the spool file of the start of each message, so to get a message, just COPYCHARS from the start of the current message to the start of the next one.") (LET ((MSTART (|pop| (|fetch| UMNEXT |of| MAILBOX))) (MEND (OR (CAR (|fetch| UMNEXT |of| MAILBOX)) (GETEOFPTR MSTREAM)))) (COPYCHARS MSTREAM MSGOUTFILE MSTART MEND)) (* |;;| "This could use a little error-handling, of course... perhaps a LOT of error handling.") (* |;;| "Check out the tail of the message and uudecode it if it's an encoded message") (UNIX.UUDECODE.IF.NEEDED MSGOUTFILE OUTSTART)))
)

(UNIXSPOOL.CLOSEMAILBOX
(LAMBDA (MAILBOX FLUSH?) (* \; "Edited 15-Oct-90 20:46 by jrb:") (LET ((MSTREAM (|fetch| UMSTREAM |of| MAILBOX))) (* |;;| "If FLUSH?, nuke the spool file") (|if| FLUSH? |then| (SETFILEINFO (|fetch| (UNIXMAILFILEINFO UMFNAME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER)) (QUOTE LENGTH) 0)) (* |;;| " In any event, close the mailbox stream") (CLOSEF MSTREAM) (* |;;| "HACK!  Depends on \\LAFITE.RETRIEVEMESSAGES binding of MAILSERVER") (|replace| (UNIXMAILFILEINFO UMFTIME) |of| (|fetch| (MAILSERVER MAILPORT) |of| MAILSERVER) |with| (IDATE))))
)
)



(* |;;| "Functions used to send mail")

(DEFINEQ

(UNIX.FLUSH.STREAM
(LAMBDA (STREAM CHAR) (* \; "Edited 13-Sep-90 15:58 by jrb:") (* |;;| "Just vacuum out the stream until you see CHAR (if it's NIL, read until EOF)") (* |;;| "If CHAR is supplied, stream must not be at EOF") (|if| CHAR |then| (|until| (OR (NOT (READP STREAM)) (EQ (READCCODE STREAM) CHAR)) |do| NIL) |else| (|until| (NOT (READP STREAM)) |do| (READCCODE STREAM))) STREAM)
)

(UNIX.RETRIEVE.LINE
(LAMBDA (MSTREAM MSGOUTFILE) (* \; "Edited 18-Sep-89 14:39 by jrb:") (* |;;| "Copies a line of text from MSTREAM to MSGOUTFILE except if that line starts with a strange character (charcode 254; see UNIX.RETRIEVEMESSAGE). Returns NIL on seeing such a line") (BLOCK) (* \; "This looks like a good place...") (LET ((CHAR (READCCODE MSTREAM))) (|if| (EQ CHAR 254) |then| (SETQ CHAR NIL)) (* |;;| "When we get here, if CHAR is non-NIL, it needs to be printed to MSGOUTFILE") (|if| CHAR |then| (PRINTCCODE CHAR MSGOUTFILE) (|until| (EQ CHAR (CHARCODE NEWLINE)) |do| (PRINTCCODE (SETQ CHAR (READCCODE MSTREAM)) MSGOUTFILE)) T)))
)

(\\UNIXMAIL.SEND
(LAMBDA (MSG PARSE EDITORWINDOW ABORTWINDOW) (* \; "Edited 20-Aug-91 23:23 by jrb:") (* |;;| "The strategy here is to talk to an SMTP server and throw the message at it.") (|if| (AND (TEDIT.FORMATTEDFILEP MSG) (EQ (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE) (QUOTE TEDIT))) |then| (\\LAFITE.SEND.FAIL EDITORWINDOW "UNIX mode can't send raw TEdit; try TEdit-UUencoded") |else| (CL:MULTIPLE-VALUE-BIND (SMIN SMOUT) (\\UNIXMAIL.SMTP.TCP.STREAMS) (LET ((PWINDOW (AND EDITORWINDOW (GETPROMPTWINDOW EDITORWINDOW))) RESULT) (|if| (NULL SMIN) |then| (\\LAFITE.SEND.FAIL EDITORWINDOW (CL:FORMAT NIL "Coundn't open SMTP stream because ~s" SMOUT))) (CL:FLET ((GIVE-UP-AND-DIE (&REST WHY) (* |;;| "Close up the SMTP streams, send up a flare for the user and return NIL") (IGNORE-ERRORS (CLOSEF SMIN) (CLOSEF SMOUT)) (\\LAFITE.SEND.FAIL EDITORWINDOW (CL:APPLY (CL:FUNCTION CL:FORMAT) NIL WHY)) NIL)) (* |;;| "Get the connection ready to talk to") (|for| I |from| 1 |to| 5 |while| (SETQ RESULT (\\UNIXMAIL.SMTP.FLUSH SMIN)) |do| NIL) (|if| RESULT |then| (GIVE-UP-AND-DIE "Coundn't open SMTP stream because ~a" RESULT) |else| (|if| PWINDOW |then| (CLEARW PWINDOW) (CL:FORMAT PWINDOW "Delivering ~:[~;formatted ~]to ~D recipient~:P" (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE) (LENGTH (|fetch| (UNIXMAILPARSE UNIXTO) |of| PARSE)))) (|if| (SETQ RESULT (CL:CATCH (QUOTE SMTP-LOST) (* |;;| "First handle who it's from") (\\UNIXMAIL.SMTP SMIN SMOUT (CL:FORMAT NIL "MAIL FROM: ~a~%" (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) (* |;;| "Then the recipients") (|for| R |in| (|fetch| (UNIXMAILPARSE UNIXTO) |of| PARSE) |do| (\\UNIXMAIL.SMTP SMIN SMOUT (CL:FORMAT NIL "RCPT TO: ~a~%" R))) (* |;;| "Print a '.' to show we're this far") (AND PWINDOW (|printout| PWINDOW (QUOTE \.))) (* |;;| "Then the message itself; the SMTP response here is a 300-range number meaning \"Lay it on me\"") (\\UNIXMAIL.SMTP SMIN SMOUT "DATA~%" 300 399) (* |;;| "First hose out the other fields") (|for| F |in| (|fetch| (UNIXMAILPARSE UNIXOTHER) |of| PARSE) |do| (CL:FORMAT SMOUT "~a: ~a~%" (CAR F) (CADR F)) |finally| (|if| (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE) |then| (CL:FORMAT SMOUT "Format: ~a~%" (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE))) (TERPRI SMOUT)) (* |;;| "Print a '.' to show we're this far") (AND PWINDOW (|printout| PWINDOW (QUOTE \.))) (* |;;| "SMTP-DUMP is here to handle the case of lines beginning with '.': the '.' must be doubled when talking to the SMTP server.") (CL:FLET ((SMTP-DUMP (INSTREAM OUTSTREAM) (|if| UNIXMAIL.WRAP.LINES |then| (LET ((BUF (CL:MAKE-ARRAY (IPLUS UNIXMAIL.WRAP-LIMIT 8) :ELEMENT-TYPE (QUOTE CL:CHARACTER))) (BPTR 0) (BLENGTH 0) (LASTWS NIL) C) (CL:FLET ((ADDCHAR (C) (CL:SETF (CL:CHAR BUF BPTR) C) (CL:INCF BPTR) (CL:INCF BLENGTH)) (DUMP-BUFFER NIL (CL:DOTIMES (I BPTR) (CL:WRITE-CHAR (CL:CHAR BUF I) OUTSTREAM)) (TERPRI OUTSTREAM) (SETQ BPTR 0 BLENGTH 0))) (|while| (SETQ C (CL:READ-CHAR INSTREAM NIL NIL)) |do| (CASE C (#\Newline (DUMP-BUFFER) (SETQ LASTWS NIL)) (#\. (|if| (EQ 0 BPTR) |then| (ADDCHAR C)) (ADDCHAR C)) (#\Space (SETQ LASTWS BPTR) (ADDCHAR C)) (#\Tab (CL:INCF BLENGTH (CL:1- UNIXMAIL.TABWIDTH)) (SETQ BLENGTH (ITIMES UNIXMAIL.TABWIDTH (CL:FLOOR BLENGTH UNIXMAIL.TABWIDTH))) (ADDCHAR C)) (CL:OTHERWISE (ADDCHAR C))) (|if| (IGREATERP BLENGTH UNIXMAIL.WRAP-LIMIT) |then| (|if| LASTWS |then| (SETQ C (IDIFFERENCE (IDIFFERENCE BPTR LASTWS) 1)) (SETQ BPTR LASTWS) (DUMP-BUFFER) (|if| (EQ (CL:CHAR BUF (CL:INCF LASTWS)) #\.) |then| (CL:SETF (CL:CHAR BUF (CL:DECF LASTWS)) #\.) (CL:INCF C)) (|for| I |from| 0 |to| (IDIFFERENCE C 1) |as| BPTR |from| LASTWS |do| (CL:SETF (CL:CHAR BUF I) (CL:CHAR BUF BPTR))) (SETQ BPTR C BLENGTH C LASTWS NIL) |else| (DUMP-BUFFER) (SETQ LASTWS NIL))) |finally| (DUMP-BUFFER)))) |else| (LET ((STARTC (GETFILEPTR INSTREAM)) ENDC) (WHILE (SETQ ENDC (FILEPOS (CONSTANT (CONCAT (CHARACTER (CHARCODE NEWLINE)) ".")) INSTREAM STARTC)) DO (COPYCHARS INSTREAM OUTSTREAM STARTC (ADD1 ENDC)) (PRIN1 ".." OUTSTREAM) (SETQ STARTC (IPLUS ENDC 2)) FINALLY (COPYCHARS INSTREAM OUTSTREAM STARTC (GETEOFPTR INSTREAM))))))) (|if| (TEDIT.FORMATTEDFILEP MSG) |then| (SELECTQ (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE) (TEDIT (GIVE-UP-AND-DIE "UNIX mode can't send raw TEdit; try TEdit-UUencoded")) (TEDIT-UUENCODE (* |;;| "Nuke the header in a copy of the msg") (SETQ MSG (COPYTEXTSTREAM MSG)) (TEDIT.DELETE MSG 1 (|fetch| (UNIXMAILPARSE UNIXBODY) |of| PARSE)) (UNIX.TEDIT-UUENCODE.MESSAGE MSG SMOUT)) (NIL (* |;;| "Strip TEdit formatting") (SMTP-DUMP (LAFITE.MAKE.PLAIN.TEXTSTREAM MSG (|fetch| (UNIXMAILPARSE UNIXBODY) |of| PARSE)) SMOUT)) (GIVE-UP-AND-DIE "Send failed due to strange Format: ~A" (|fetch| (UNIXMAILPARSE FORMATTED?) |of| PARSE))) |else| (SMTP-DUMP MSG SMOUT))) (|if| (OPENP SMOUT) |then| (\\UNIXMAIL.SMTP SMIN SMOUT "~%.~%") (* |;;| "Print a '.' to show we're this far") (AND PWINDOW (|printout| PWINDOW (QUOTE \.))) (\\UNIXMAIL.SMTP SMIN SMOUT "QUIT~%") NIL |else| (BLOCK 1000) 554))) |then| (GIVE-UP-AND-DIE "SMTP error is ~a" RESULT) |else| (IGNORE-ERRORS (CLOSEF SMIN) (CLOSEF SMOUT)) (LENGTH (|fetch| (UNIXMAILPARSE UNIXTO) |of| PARSE)))))))))
)

(\\UNIXMAIL.SEND.PARSE
(LAMBDA (MSG EDITORWINDOW) (* \; "Edited 20-Sep-91 16:59 by jrb:") (* |;;| "Do some obvious checks here and build a \\UNIXMAILPARSE for UNIXMAIL.SEND to munch on") (PROG ((MSGFIELDS (\\LAFITE.PREPARE.SEND MSG EDITORWINDOW)) SENDINGFORMAT HEADEREOF FROMFIELD RECIPIENTS OTHERSTUFF) (|if| MSGFIELDS |then| (|if| (EQ (CAAR MSGFIELDS) (QUOTE EOF)) |then| (SETQ HEADEREOF (CADR (|pop| MSGFIELDS)))) (|for| PAIR |in| MSGFIELDS |do| (SELECTQ (CAR PAIR) (|Date| (\\SENDMESSAGEFAIL EDITORWINDOW "User-supplied Date not allowed")) (|Sender| (\\SENDMESSAGEFAIL EDITORWINDOW "User-supplied Sender not allowed")) ((TO T\o |cc|) (SETQ RECIPIENTS (NCONC RECIPIENTS (\\UNIXMAIL.PARSENAMES (CDR PAIR)))) (|push| OTHERSTUFF PAIR)) (|From| (SETQ FROMFIELD (\\UNIXMAIL.PARSENAMES (CDR PAIR))) (|push| OTHERSTUFF PAIR)) (|Format| (SETQ SENDINGFORMAT (CADR PAIR))) (|push| OTHERSTUFF PAIR))) (|if| (NULL RECIPIENTS) |then| (\\SENDMESSAGEFAIL EDITORWINDOW "No recipients!") (RETURN NIL)) (|if| (NULL SENDINGFORMAT) |then| (SETQ SENDINGFORMAT (OR (\\LAFITE.CHOOSE.MSG.FORMAT MSG HEADEREOF EDITORWINDOW) (RETURN)))) (RETURN (|create| UNIXMAILPARSE UNIXFROM _ FROMFIELD UNIXTO _ RECIPIENTS UNIXOTHER _ OTHERSTUFF UNIXBODY _ HEADEREOF FORMATTED? _ (SELECTQ SENDINGFORMAT ((NIL TEXT) NIL) SENDINGFORMAT))))))
)

(\\UNIXMAIL.SMTP
(LAMBDA (SIN SOUT STRING LO HI) (* \; "Edited 13-Sep-90 16:11 by jrb:") (* |;;| "Very dumb protocol handler; shows STRING to STREAM and reads the response number, returning T or NIL depending on the range of the result.  Currently we only accept 200-range answers (completions)") (LET (RESULT) (CL:FORMAT SOUT STRING) (FORCEOUTPUT SOUT) (|if| (SETQ RESULT (\\UNIXMAIL.SMTP.FLUSH SIN LO HI)) |then| (CL:THROW (QUOTE SMTP-LOST) RESULT))))
)

(\\UNIXMAIL.SMTP.FLUSH
(LAMBDA (STREAM LO HI) (* \; "Edited 12-Oct-90 16:03 by jrb:") (* |;;| "STREAM is about to throw an SMTP exchange at us; get the number and shake hands appropriately") (LET ((RESULT (IGNORE-ERRORS (RATOM STREAM))) CHAR) (|if| (NOT (SMALLP RESULT)) |then| (UNIX.FLUSH.STREAM STREAM (CHARCODE NEWLINE)) (CL:FORMAT NIL "Not an SMTP number:~S" RESULT) |else| (|if| (OR (IGREATERP RESULT (OR HI 299)) (ILESSP RESULT (OR LO 200))) |then| (SETQ RESULT (CL:FORMAT NIL "~a: " RESULT)) (|until| (OR (NOT (READP STREAM)) (EQ (SETQ CHAR (READCCODE STREAM)) (CHARCODE NEWLINE))) |do| (SETQ RESULT (CONCAT RESULT (CHARACTER CHAR)))) RESULT |else| (UNIX.FLUSH.STREAM STREAM (CHARCODE NEWLINE)) NIL))))
)
)



(* |;;| "This returns multiple-values, so it's a CL:LAMBDA (what the heck).")


(CL:DEFUN \\UNIXMAIL.SMTP.TCP.STREAMS NIL (* |;;| "Opens two streams representing the input and output streams of an SMTP TCP connection.  On failure return NIL and a string describing the failure.") (SELECTQ UNIXMAIL.SEND.MODE (PROCESS (|if| (EQ (MACHINETYPE) (QUOTE MAIKO)) |then| (LET ((S (CREATE-PROCESS-STREAM UNIXMAIL.SEND.PROCESS))) (CL:VALUES S S)) |else| (CL:VALUES NIL "this MACHINETYPE can't do Unix process-streams; change UNIXMAIL.SEND.MODE"))) (SOCKET (|if| (EQ (MACHINETYPE) (QUOTE MAIKO)) |then| (LET ((S (OPENTCPSTREAM (OR UNIXMAIL.SEND.HOST (UNIX-GETPARM "HOSTNAME")) 25))) (CL:VALUES S S)) |else| (LET ((S (TCP.OPEN UNIXMAIL.SEND.HOST 25 NIL (QUOTE ACTIVE) (QUOTE INPUT) T))) (|if| S |then| (CL:VALUES S (TCP.OTHER.STREAM S)) |else| (CL:VALUES NIL "TCP.OPEN failed; check your Lisp TCP configuration"))))) (ERROR "Unrecognized UNIXMAIL.SEND.MODE:" UNIXMAIL.SEND.MODE)))



(* |;;| "Other functions Lafite uses and needs Unix equivalents for")

(DEFINEQ

(\\UNIXMAIL.AUTHENTICATE
(LAMBDA NIL (* \; "Edited  6-Sep-90 15:01 by jrb:") (* |;;| "No authentication really necessary (we're depending on underlying Unix to keep us from doing illegal things), so just return an appropriate LAFITEMODEDATA") (* |;;| "Unfortunately, all the various versions of the username have to be the short one, because Lafite insists they all be acceptable mailing addresses, in particular FULLUSERNAME... *sigh*...") (LET ((FULLNAME (UNIX-USERNAME))) (|create| LAFITEMODEDATA LAFITEOPS _ (FASSOC (QUOTE UNIX) LAFITEMODELST) FULLUSERNAME _ FULLNAME UNPACKEDUSERNAME _ FULLNAME SHORTUSERNAME _ FULLNAME MAILSERVERS _ (LIST (|create| MAILSERVER MAILSERVERNAME _ "Unix mail" MAILSERVEROPS _ (OR (CDR (FASSOC UNIXMAIL.RECEIVE.MODE UNIXMAIL.MSOPS.LIST)) (ERROR "Not a known Unix mail receive mode" UNIXMAIL.RECEIVE.MODE)))))))
)

(\\UNIXMAIL.LOGIN
(LAMBDA NIL (* \; "Edited  4-Jan-89 13:29 by bane") (|if| (EQ (MACHINETYPE) (QUOTE MAIKO)) |then| (\\LAFITE.GET.USER.DATA (QUOTE UNIX) NIL T) (\\LAFITE.WAKE.WATCHER) |else| (PROMPTPRINT "No Unix mode; this isn't Maiko")))
)

(\\UNIXMAIL.PARSENAMES
(LAMBDA (FIELD) (* \; "Edited  4-Jan-89 15:41 by bane") (* |;;| "Just returns a list of the comma-seperated fields in this string") (|if| (CL:CONSP FIELD) |then| (MAPCONC FIELD (CL:FUNCTION \\UNIXMAIL.PARSENAMES)) |else| (COND (FIELD (|bind| ADDR (START _ 1) COMMA |when| (PROGN (SETQ ADDR (SUBSTRING FIELD START (COND ((SETQ COMMA (STRPOS (QUOTE \,) FIELD START)) (SUB1 COMMA))))) (|do| (* \; "Strip leading blanks") (SELCHARQ (CHCON1 ADDR) ((SPACE TAB) (GNC ADDR)) (RETURN))) (|do| (* \; "Strip trailing blanks") (SELCHARQ (NTHCHARCODE ADDR -1) ((SPACE TAB) (GLC ADDR)) (RETURN))) (NEQ (NCHARS ADDR) 0)) |collect| ADDR |repeatwhile| (COND (COMMA (SETQ START (ADD1 COMMA)))))))))
)

(\\UNIXMAIL.MAKEANSWERFORM
(LAMBDA (MSGDESCRIPTORS MAILFOLDER) (* \; "Edited 11-Oct-91 09:13 by jrb:") (* |;;| " Code borrowed liberally from GV.MAKEANSWERFORM") (LET ((MSGFIELDS (\\LAFITE.PARSE.MESSAGE MAILFOLDER (OR (CAR (LISTP MSGDESCRIPTORS)) MSGDESCRIPTORS))) SUBJECT FROM DATE SENDER REPLYTO TO CC OLDFROM NEWTO NEWCC) (* \; "get the fields from the file") (|for| PAIR |in| MSGFIELDS |do| (SELECTQ (CAR PAIR) (|Subject| (SETQ SUBJECT (CADR PAIR))) (|Sender| (SETQ SENDER (CADR PAIR))) (|From| (SETQ FROM (CADR PAIR))) (|Date| (SETQ DATE (CADR PAIR))) (|Reply-to| (SETQ REPLYTO (CDR PAIR))) ((T\o TO) (SETQ TO (CDR PAIR))) (|cc| (SETQ CC (CDR PAIR))) NIL)) (* |;;| "first parse the strings into recipients.  Need to find the sender's registry in order to get the registry defaults correct for its recipients.") (COND (SENDER (* \; "Sender is a mail address, and has the official registry") (SETQ OLDFROM (\\UNIXMAIL.PARSENAMES SENDER)) (* \; "Elements are of the form (prettyname gvname . registry)") (|if| FROM |then| (* \; "Now that we have a source of official registry (we hope), parse the From field with reference to it.") (SETQ OLDFROM (\\UNIXMAIL.PARSENAMES FROM)))) (FROM (* \; "Have to parse the From field before we can get its registry") (SETQ OLDFROM (\\UNIXMAIL.PARSENAMES FROM)))) (|if| (NULL OLDFROM) |then| (LAB.PROMPTPRINT MAILFOLDER T "Warning: message has no FROM field")) (AND TO (SETQ TO (\\UNIXMAIL.PARSENAMES TO))) (AND CC (SETQ CC (\\UNIXMAIL.PARSENAMES CC))) (SETQ NEWTO (OR (AND REPLYTO (SETQ REPLYTO (\\UNIXMAIL.PARSENAMES REPLYTO))) OLDFROM)) (SETQ NEWCC (CL:SET-DIFFERENCE (COND (REPLYTO (* \; "Reply goes only to this address, so the only cc is to self") (MKLIST (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of| *LAFITE-MODE-DATA*))) (T (* \; "By default CC everyone who received the original message and to whom we are not directly replying already") (APPEND TO (CL:SET-DIFFERENCE CC TO :TEST (CL:FUNCTION STRING-EQUAL))))) NEWTO :TEST (CL:FUNCTION STRING-EQUAL))) (LAFITE.FILL.IN.ANSWER.FORM SUBJECT (|if| (AND (OR (NULL REPLYTO) (EQUAL REPLYTO OLDFROM)) (NULL (CDR NEWCC)) (OR (NULL NEWCC) (STRING-EQUAL (CAR NEWCC) (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of| *LAFITE-MODE-DATA*)))) |then| (* \; "Replying only to sender (and maybe self), so just say \"your\" instead of \"Joe Bob Smith <JBSmith.pa>'s\"") NIL |else| FROM) DATE NEWTO NEWCC (CL:FUNCTION LA.PRINT.COMMA.LIST))))
)

(\\UNIXMAIL.MESSAGE.FROM.SELF.P
(LAMBDA (MSG) (* \; "Edited  6-Dec-88 15:41 by bane") (* |;;| "For the moment, we send stuff with our SHORTUSERNAME only in the FROM field") (STRING-EQUAL (|fetch| (LAFITEMSG FROM) |of| MSG) (|fetch| (LAFITEMODEDATA SHORTUSERNAME) |of| *LAFITE-MODE-DATA*)))
)

(\\UNIXMAIL.MESSAGE.P
(LAMBDA (MSG) (* \; "Edited  6-Dec-88 15:39 by bane") (* |;;| "We're guessing here; basically if it doesn't look like an NS message, say maybe.") (AND (NOT (STRPOS ":" (|fetch| (LAFITEMSG FROM) |of| MSG))) (QUOTE ?)))
)
)



(* |;;| 
"This is a stub needed by the TEdit-uuencode strategy; if we ever decide on a reasonable way to do this and make it part of Lafite, this may go away"
)


(MOVD? (QUOTE NILL) (QUOTE UNIX.UUDECODE.IF.NEEDED))

(PUTPROPS UNIXMAIL FILETYPE :COMPILE-FILE)
(PUTPROPS UNIXMAIL COPYRIGHT ("ENVOS Corporation" 1989 1990 1991))
(DECLARE\: DONTCOPY
  (FILEMAP (NIL (4643 12706 (UNIX.POLLNEWMAIL 4653 . 5782) (UNIX.NEXTMESSAGE 5784 . 5901) (
UNIXMAILER.OPENMAILBOX 5903 . 7918) (UNIXMAILER.RETRIEVEMESSAGE 7920 . 8911) (UNIXMAILER.CLOSEMAILBOX 
8913 . 9561) (UNIXSPOOL.OPENMAILBOX 9563 . 11312) (UNIXSPOOL.RETRIEVEMESSAGE 11314 . 12121) (
UNIXSPOOL.CLOSEMAILBOX 12123 . 12704)) (12754 21465 (UNIX.FLUSH.STREAM 12764 . 13158) (
UNIX.RETRIEVE.LINE 13160 . 13807) (\\UNIXMAIL.SEND 13809 . 18974) (\\UNIXMAIL.SEND.PARSE 18976 . 20285
) (\\UNIXMAIL.SMTP 20287 . 20746) (\\UNIXMAIL.SMTP.FLUSH 20748 . 21463)) (22520 27304 (
\\UNIXMAIL.AUTHENTICATE 22530 . 23380) (\\UNIXMAIL.LOGIN 23382 . 23627) (\\UNIXMAIL.PARSENAMES 23629
 . 24338) (\\UNIXMAIL.MAKEANSWERFORM 24340 . 26758) (\\UNIXMAIL.MESSAGE.FROM.SELF.P 26760 . 27055) (
\\UNIXMAIL.MESSAGE.P 27057 . 27302)))))
STOP
