(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP")(FILECREATED "18-Feb-91 11:52:53" {DSK}<users>gadener>medley>work>PS>POSTSCRIPTSTREAM.;5 149573       changes to%:  (VARS POSTSCRIPTSTREAMCOMS)      previous date%: "15-Feb-91 16:35:41" {DSK}<users>gadener>medley>work>PS>POSTSCRIPTSTREAM.;4)(* ; "Copyright (c) 1989, 1990, 1991 by Savoir and Beckman.  All rights reserved.")(PRETTYCOMPRINT POSTSCRIPTSTREAMCOMS)(RPAQQ POSTSCRIPTSTREAMCOMS       [(RECORDS FONTID PSCFONT \POSTSCRIPTDATA)        (FNS CLOSEPOSTSCRIPTSTREAM OPENPOSTSCRIPTSTREAM POSTSCRIPT.BITMAPSCALE POSTSCRIPT.CLOSESTRING             POSTSCRIPT.ENDPAGE POSTSCRIPT.FONTCREATE POSTSCRIPT.FONTSAVAILABLE POSTSCRIPT.GETFONTID             POSTSCRIPT.HARDCOPYW POSTSCRIPT.INIT POSTSCRIPT.OUTSTR POSTSCRIPT.PUTBITMAPBYTES              POSTSCRIPT.PUTCOMMAND POSTSCRIPT.SHOWACCUM POSTSCRIPT.STARTPAGE POSTSCRIPT.TEDIT              POSTSCRIPT.TEXT POSTSCRIPTFILEP PSCFONT.READFONT PSCFONT.SPELLFILE PSCFONT.WRITEFONT              READ-AFM-FILE \BITBLT.PSC \BLTSHADE.PSC \CHARWIDTH.PSC \DRAWARC.PSC \DRAWCIRCLE.PSC              \DRAWCURVE.PSC \DRAWELLIPSE.PSC \DRAWLINE.PSC \DRAWPOINT.PSC \DRAWPOLYGON.PSC              \DSPBOTTOMMARGIN.PSC \DSPCLIPPINGREGION.PSC \DSPFONT.PSC \DSPLEFTMARGIN.PSC              \DSPLINEFEED.PSC \DSPRESET.PSC \DSPRIGHTMARGIN.PSC \DSPROTATE.PSC \DSPSCALE.PSC              \DSPSPACEFACTOR.PSC \DSPTOPMARGIN.PSC \DSPTRANSLATE.PSC \DSPXPOSITION.PSC              \DSPYPOSITION.PSC \FILLCIRCLE.PSC \FILLPOLYGON.PSC \FIXLINELENGTH.PSC \MOVETO.PSC              \NEWPAGE.PSC \POSTSCRIPTTAB \PS.BOUTFIXP \PS.SCALEHACK \PS.SCALEREGION \SCALEDBITBLT.PSC             \SETPOS.PSC \SETXFORM.PSC \STRINGWIDTH.PSC \SWITCHFONTS.PSC \TERPRI.PSC)        (FNS \POSTSCRIPT.OUTCHARFN \POSTSCRIPT.SYMBOLOUTCHAR)        (VARS (\POSTSCRIPT.ORIENTATION.MENU (create MENU ITEMS _ '(("Landscape" T                                             "Print this file/document/image in Landscape Orientation"                                                                          )                                                                   ("Portrait" 'NIL                                              "Print this file/document/image in Portrait Orientation"                                                                          ))                                                   TITLE _ "Orientation" CENTERFLG _ T MENUOFFSET _                                                   (create POSITION XCOORD _ -1 YCOORD _ 0)                                                   CHANGEOFFSETFLG _ 'Y))              (\POSTSCRIPT.ORIENTATION.OPTIONS.MENU (create MENU ITEMS _ '(("Ask" 'ASK                                    "Always ask whether to print in Landscape or Portrait Orientation"                                                                                  )                                                                           ("Landscape" T                                                           "Default printing to Landscape Orientation"                                                                                  )                                                                           ("Portrait" 'NIL                                                            "Default printing to Portrait Orientation"                                                                                  ))                                                           TITLE _ "Default Orientation" CENTERFLG _                                                           T))              PS.BITMAPARRAY \POSTSCRIPT.JOB.SETUP SlopeMenuItems WeightMenuItems)        [ADDVARS (BackgroundMenuCommands ("PS Orientation" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE                                                                  (MENU                                                                  \POSTSCRIPT.ORIENTATION.OPTIONS.MENU                                                                        ))                                                                                               "Select the default Orientation for PostScript output"                                                (SUBITEMS ("Ask" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE                                                                        'ASK)                                                                                                    "Always ask whether to print in Landscape or Portrait Orientation"                                                                 )                                                       ("Landscape" '(SETQ                                                                           POSTSCRIPT.PREFER.LANDSCAPE                                                                           T)                                                                                                                        "Default printing to Landscape Orientation"                                                              )                                                       ("Portrait" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE                                                                          NIL)                                                                                                                         "Default printing to Portrait Orientation"                                                              ]        (VARS (BackgroundMenu NIL))        (CONSTANTS (GOLDEN.RATIO 1.618034)               (\PS.SCALE0 100)               (\PS.TEMPARRAYLEN 20))        (INITVARS (POSTSCRIPT.BITMAP.SCALE 1)               (POSTSCRIPT.EOL 'CR)               (POSTSCRIPT.IMAGESIZEFACTOR 1)               (POSTSCRIPT.PREFER.LANDSCAPE NIL)               (POSTSCRIPT.TEXTFILE.LANDSCAPE NIL)               (POSTSCRIPT.DEFAULT.PAGEREGION '(4800 4800 52800 70800))               (POSTSCRIPT.TEXTURE.SCALE 4)               (POSTSCRIPTFONTDIRECTORIES (LIST (IF (EQL (MACHINETYPE)                                                         'MAIKO)                                                    then "{DSK}/usr/local/lde/fonts/postscript/" else                                                    "{DSK}<LISPFILES>FONTS>PSC>")))               (\POSTSCRIPT.MAX.WILD.FONTSIZE 72))        [ADDVARS (POSTSCRIPT.FONT.ALIST (HELVETICA . HELVETICA)                        (HELVETICAD . HELVETICA)                        (TIMESROMAN . TIMES)                        (TIMESROMAND . TIMES)                        (COURIER . COURIER)                        (GACHA . COURIER)                        (CLASSIC . TIMES)                        (MODERN . HELVETICA)                        (CREAM . HELVETICA)                        (TERMINAL . COURIER)                        (LOGO . HELVETICA)                        (TITAN . COURIER))               [PRINTERTYPES ((POSTSCRIPT)                              (CANPRINT (POSTSCRIPT))                              (STATUS TRUE)                              (PROPERTIES NILL)                              (SEND POSTSCRIPT.SEND)                              (BITMAPSCALE POSTSCRIPT.BITMAPSCALE)                              (BITMAPFILE (POSTSCRIPT.HARDCOPYW FILE BITMAP SCALEFACTOR REGION                                                  ROTATION TITLE]               [PRINTFILETYPES (POSTSCRIPT (TEST POSTSCRIPTFILEP)                                      (EXTENSION (PS PSC))                                      (CONVERSION (TEXT POSTSCRIPT.TEXT TEDIT POSTSCRIPT.TEDIT]               (IMAGESTREAMTYPES (POSTSCRIPT (OPENSTREAM OPENPOSTSCRIPTSTREAM)                                        (FONTCREATE POSTSCRIPT.FONTCREATE)                                        (FONTSAVAILABLE POSTSCRIPT.FONTSAVAILABLE)                                        (CREATECHARSET NILL]        (INITVARS (POSTSCRIPT.PAGETYPE 'LETTER))        [APPENDVARS (POSTSCRIPT.PAGEREGIONS (LETTER (0 0 8.5 11)                                                   (0.197 0.197 8.1 10.6))                           (LEGAL (0 0 8.5 14)                                  (0.89 0.5 6.72 13.0))                           (NOTE (0 0 8.5 11)                                 (0.405 0.42 7.69 10.16]        (GLOBALVARS DEFAULTPRINTINGHOST POSTSCRIPT.BITMAP.SCALE POSTSCRIPT.EOL POSTSCRIPT.FONT.ALIST               POSTSCRIPT.PREFER.LANDSCAPE POSTSCRIPT.TEXTFILE.LANDSCAPE POSTSCRIPT.TEXTURE.SCALE                POSTSCRIPTFONTDIRECTORIES \POSTSCRIPT.JOB.SETUP \POSTSCRIPT.MAX.WILD.FONTSIZE                \POSTSCRIPT.ORIENTATION.MENU \POSTSCRIPTIMAGEOPS POSTSCRIPT.PAGETYPE                POSTSCRIPT.PAGEREGIONS)        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (POSTSCRIPT.INIT)))        (PROP (FILETYPE MAKEFILE-ENVIRONMENT)              POSTSCRIPTSTREAM)        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)                                                                             (NLAML)                                                                             (LAMA                                                                                 POSTSCRIPT.PUTCOMMAND                                                                                   ])(DECLARE%: EVAL@COMPILE(RECORD FONTID (FONTIDNAME FONTXFACTOR FONTOBLIQUEFACTOR))(RECORD PSCFONT (FID IL-FONTID FIRSTCHAR LASTCHAR ASCENT DESCENT WIDTHS))(DATATYPE \POSTSCRIPTDATA           (POSTSCRIPTFONT                                    (* ;                                                            "The fontdescriptor of the current font")                 POSTSCRIPTX                                 (* ; "The current X")                 POSTSCRIPTY                                 (* ; "... and Y")                 POSTSCRIPTLEFTMARGIN                        (* ; "The margins")                 POSTSCRIPTRIGHTMARGIN POSTSCRIPTBOTTOMMARGIN POSTSCRIPTTOPMARGIN                  POSTSCRIPTLINESPACING                       (* ; "Line to line spacing")                 POSTSCRIPTCOLOR POSTSCRIPTSCALE             (* ; "Scale of the stream")                 POSTSCRIPTOPERATION                         (* ;                                                           "Default operation (PAINT, REPLACE, ...)")                 POSTSCRIPTCLIPPINGREGION                    (* ;                                                   "The current region available to be written into")                 POSTSCRIPTPAGENUM                           (* ; "Current page number")                 POSTSCRIPTHEADING                           (* ; "The heading")                 POSTSCRIPTHEADINGFONT                       (* ; "Font for the heading")                 POSTSCRIPTSPACEFACTOR                       (* ;                                                  "Expansion factor for spaces (see DSPSPACEFACTOR)")                 POSTSCRIPTSPACEWIDTH                        (* ;                                                          "The width of a space in the current font")                 POSTSCRIPTLANDSCAPE                         (* ;                                                            "non-NIL for paper in 'landscape' mode")                 POSTSCRIPTCHARSTOSHOW                       (* ;                  "non-NIL if the string (PostScript-type string) of chars has already been started")                 POSTSCRIPTFONTCHANGEDFLG                    (* ; "Font has changed")                 POSTSCRIPTMOVEFLG                           (* ; "Need to move")                 POSTSCRIPTWIDTHS                            (* ;                                                            "The widths vector of the current font")                 POSTSCRIPTTRANSX                            (* ; "Translation in X")                 POSTSCRIPTTRANSY                            (* ; "... and Y")                 POSTSCRIPTPENDINGXFORM                      (* ;                                                   "A userspace to devicespace transform is pending")                 POSTSCRIPTPAGEREGION                        (* ; "The whole page")                 POSTSCRIPTPAGEBLANK                         (* ; "This page is blank flag")                 POSTSCRIPTSCALEHACK                         (* ;                           "For \PS.SCALEHACK since DSPSCALE doesn't change the scale of the stream")                 POSTSCRIPTTEMPARRAY                         (* ;                                                      "For converting FIXP to string of digit chars")                 )          POSTSCRIPTX _ 0 POSTSCRIPTY _ 0 POSTSCRIPTTRANSX _ 0 POSTSCRIPTTRANSY _ 0           POSTSCRIPTSPACEFACTOR _ 1 POSTSCRIPTPAGENUM _ 0 POSTSCRIPTSCALEHACK _ 1 POSTSCRIPTTEMPARRAY          _ (ARRAY \PS.TEMPARRAYLEN 'BYTE 0 0)))(/DECLAREDATATYPE '\POSTSCRIPTDATA       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER                POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER                POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER)       '((\POSTSCRIPTDATA 0 POINTER)         (\POSTSCRIPTDATA 2 POINTER)         (\POSTSCRIPTDATA 4 POINTER)         (\POSTSCRIPTDATA 6 POINTER)         (\POSTSCRIPTDATA 8 POINTER)         (\POSTSCRIPTDATA 10 POINTER)         (\POSTSCRIPTDATA 12 POINTER)         (\POSTSCRIPTDATA 14 POINTER)         (\POSTSCRIPTDATA 16 POINTER)         (\POSTSCRIPTDATA 18 POINTER)         (\POSTSCRIPTDATA 20 POINTER)         (\POSTSCRIPTDATA 22 POINTER)         (\POSTSCRIPTDATA 24 POINTER)         (\POSTSCRIPTDATA 26 POINTER)         (\POSTSCRIPTDATA 28 POINTER)         (\POSTSCRIPTDATA 30 POINTER)         (\POSTSCRIPTDATA 32 POINTER)         (\POSTSCRIPTDATA 34 POINTER)         (\POSTSCRIPTDATA 36 POINTER)         (\POSTSCRIPTDATA 38 POINTER)         (\POSTSCRIPTDATA 40 POINTER)         (\POSTSCRIPTDATA 42 POINTER)         (\POSTSCRIPTDATA 44 POINTER)         (\POSTSCRIPTDATA 46 POINTER)         (\POSTSCRIPTDATA 48 POINTER)         (\POSTSCRIPTDATA 50 POINTER)         (\POSTSCRIPTDATA 52 POINTER)         (\POSTSCRIPTDATA 54 POINTER)         (\POSTSCRIPTDATA 56 POINTER))       '58)(DEFINEQ(CLOSEPOSTSCRIPTSTREAM  [LAMBDA (STREAM)                                (* ; "Edited 30-Mar-90 17:18 by Matt Heffron")    (POSTSCRIPT.ENDPAGE STREAM)    (POSTSCRIPT.PUTCOMMAND STREAM :EOL "%%%%Trailer" :EOL)    (BOUT STREAM (CHARCODE ^D])(OPENPOSTSCRIPTSTREAM  [LAMBDA (FILE OPTIONS)                          (* ; "Edited 30-Mar-90 17:02 by Matt Heffron")    (LET ([FP (OPENSTREAM FILE 'OUTPUT NIL `((EOL ,POSTSCRIPT.EOL)                                             (TYPE POSTSCRIPT)                                             (SEQUENTIAL T]          (IMAGEDATA (create \POSTSCRIPTDATA))          PAPER IMAGESIZEFACTOR CLIP REG)         (replace (STREAM OUTCHARFN) of FP with '\FILEOUTCHARFN)         (replace (STREAM IMAGEDATA) of FP with IMAGEDATA)         (replace (STREAM IMAGEOPS) of FP with \POSTSCRIPTIMAGEOPS)         (printout FP "%%!PS-Adobe-2.0" T "%%%%Title: " (MKSTRING (OR (LISTGET OPTIONS                                                                              'DOCUMENT.NAME)                                                                      FILE))                T                 "%%%%Creator: PostScript ImageStream Driver Copyright Beckman Instruments and Savoir"                T "%%%%CreationDate: " (DATE)                T "%%%%For: " (if (STRING-EQUAL INITIALS "Edited:")                                  then (MKSTRING USERNAME)                                else INITIALS)                T "%%%%EndComments" T)         (for X in \POSTSCRIPT.JOB.SETUP do (POSTSCRIPT.OUTSTR FP X)                                                       (\FILEOUTCHARFN FP (CHARCODE EOL)))         (SETQ PAPER (OR (CDR (FASSOC (SETQ PAPER (OR (LISTGET OPTIONS 'PAGETYPE)                                                      (LISTGET OPTIONS 'PAPERTYPE)                                                      POSTSCRIPT.PAGETYPE))                                     POSTSCRIPT.PAGEREGIONS))                         (ERROR "Unknown PostScript page type" PAPER)))         (if (NOT (AND [SETQ IMAGESIZEFACTOR (NUMBERP (LISTGET OPTIONS 'IMAGESIZEFACTOR]                           (CL:PLUSP IMAGESIZEFACTOR)))             then (SETQ IMAGESIZEFACTOR 1))         (if (AND (NUMBERP POSTSCRIPT.IMAGESIZEFACTOR)                      (CL:PLUSP POSTSCRIPT.IMAGESIZEFACTOR))             then (SETQ IMAGESIZEFACTOR (TIMES IMAGESIZEFACTOR POSTSCRIPT.IMAGESIZEFACTOR)))         (printout FP "/imagesizefactor " IMAGESIZEFACTOR " def" T)         (printout FP "%%%%EndSetup" T)         (replace POSTSCRIPTSCALE of IMAGEDATA with \PS.SCALE0)         (replace (STREAM OUTCHARFN) of FP with '\POSTSCRIPT.OUTCHARFN)         (replace POSTSCRIPTPAGEREGION of IMAGEDATA with (\PS.SCALEREGION                                                                      (/ (TIMES 72 \PS.SCALE0)                                                                         IMAGESIZEFACTOR)                                                                      (CAR PAPER)))         [replace POSTSCRIPTCLIPPINGREGION of IMAGEDATA            with (SETQ CLIP (\PS.SCALEREGION (/ (TIMES 72 \PS.SCALE0)                                                        IMAGESIZEFACTOR)                                       (CADR PAPER]         (* ;; "If a REGION parameter was supplied, it establishes the initial margins.")         (SETQ REG (OR (AND (SETQ REG (LISTGET OPTIONS 'REGION))                            (INTERSECTREGIONS REG CLIP))                       CLIP))         (replace POSTSCRIPTLEFTMARGIN of IMAGEDATA with (fetch LEFT of REG))         (replace POSTSCRIPTBOTTOMMARGIN of IMAGEDATA with (fetch BOTTOM of                                                                                         REG))         (replace POSTSCRIPTTOPMARGIN of IMAGEDATA with (PLUS (fetch BOTTOM                                                                             of REG)                                                                          (fetch HEIGHT                                                                             of REG)                                                                          -1))         (replace POSTSCRIPTRIGHTMARGIN of IMAGEDATA with (PLUS (fetch LEFT                                                                               of REG)                                                                            (fetch WIDTH                                                                               of REG)                                                                            -1))         (\DSPFONT.PSC FP (FONTCREATE (OR [CAR (MKLIST (LISTGET OPTIONS 'FONTS]                                              DEFAULTFONT)                                     NIL NIL NIL FP))         [if (replace POSTSCRIPTHEADING of IMAGEDATA with (LISTGET OPTIONS                                                                                 'HEADING))             then (replace POSTSCRIPTHEADINGFONT of IMAGEDATA                         with (if (LISTGET OPTIONS 'HEADINGFONT)                                      then (FONTCREATE (LISTGET OPTIONS 'HEADINGFONT)                                                      NIL NIL NIL FP)                                    else (fetch POSTSCRIPTFONT of IMAGEDATA]         (if (if (EQL (CL:GETF OPTIONS 'ROTATION 'DEFAULT)                              'DEFAULT)                     then (if (EQL POSTSCRIPT.PREFER.LANDSCAPE 'ASK)                                  then (MENU \POSTSCRIPT.ORIENTATION.MENU)                                else POSTSCRIPT.PREFER.LANDSCAPE)                   else (CL:GETF OPTIONS 'ROTATION))             then (\DSPROTATE.PSC FP 90))         (POSTSCRIPT.STARTPAGE FP)         FP])(POSTSCRIPT.BITMAPSCALE  [LAMBDA (WIDTH HEIGHT)                          (* ; "Edited 26-Jul-89 19:11 by Matt Heffron")    (LET* ([PAGEREGION (\PS.SCALEREGION (/ 72 POSTSCRIPT.BITMAP.SCALE)                              (CADDR (FASSOC POSTSCRIPT.PAGETYPE POSTSCRIPT.PAGEREGIONS]           (LONGEDGE (MAX (fetch WIDTH of PAGEREGION)                          (fetch HEIGHT of PAGEREGION)))           (SHORTEDGE (MIN (fetch WIDTH of PAGEREGION)                           (fetch HEIGHT of PAGEREGION)))           [MINDIMP (MIN (FQUOTIENT LONGEDGE (SETQ HEIGHT (TIMES HEIGHT POSTSCRIPT.BITMAP.SCALE)))                         (FQUOTIENT SHORTEDGE (SETQ WIDTH (TIMES WIDTH POSTSCRIPT.BITMAP.SCALE]           (MINDIML (MIN (FQUOTIENT SHORTEDGE HEIGHT)                         (FQUOTIENT LONGEDGE WIDTH)))           (PPL (if (EQ POSTSCRIPT.PREFER.LANDSCAPE 'ASK)                    then (MENU \POSTSCRIPT.ORIENTATION.MENU)                  else POSTSCRIPT.PREFER.LANDSCAPE))           MINDIM OTHERDIM SF1 SF2)          (if PPL              then (SETQ MINDIM MINDIML)                    (SETQ OTHERDIM MINDIMP)            else (SETQ MINDIM MINDIMP)                  (SETQ OTHERDIM MINDIML))          (SETQ SF1 (if (GREATERP MINDIM 1)                        then 1                      elseif (GREATERP MINDIM 0.75)                        then 0.75                      elseif (GREATERP MINDIM 0.5)                        then 0.5                      elseif (GREATERP MINDIM 0.25)                        then 0.25                      else MINDIM))          (SETQ SF2 (if (GREATERP OTHERDIM 1)                        then 1                      elseif (GREATERP OTHERDIM 0.75)                        then 0.75                      elseif (GREATERP OTHERDIM 0.5)                        then 0.5                      elseif (GREATERP OTHERDIM 0.25)                        then 0.25                      else OTHERDIM))          (if (AND (LESSP SF1 1)                       (LESSP SF1 SF2))              then (CONS SF2 (NOT PPL))            else (CONS SF1 PPL])(POSTSCRIPT.CLOSESTRING  [LAMBDA (STREAM)                                (* ; "Edited 12-Jan-88 12:33 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM)))         (if (fetch POSTSCRIPTCHARSTOSHOW of IMAGEDATA)             then (POSTSCRIPT.OUTSTR STREAM ") ")                   (replace POSTSCRIPTCHARSTOSHOW of IMAGEDATA with NIL)                   T           else NIL])(POSTSCRIPT.ENDPAGE  [LAMBDA (STREAM)                                (* ; "Edited 30-Mar-90 17:20 by Matt Heffron")    (LET ((IMAGEDATA (fetch (STREAM IMAGEDATA) of STREAM)))         (POSTSCRIPT.SHOWACCUM STREAM)         (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with NIL)         (if (NOT (PROG1 (fetch POSTSCRIPTPAGEBLANK of IMAGEDATA)                             (POSTSCRIPT.PUTCOMMAND STREAM "grestore savepage restore ")))             then (POSTSCRIPT.PUTCOMMAND STREAM "showpage" :EOL])(POSTSCRIPT.FONTCREATE  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)             (* ; "Edited 13-Jul-90 01:41 by jds")    (LET (UNITFONT FULLNAME SCALEFONTP PSCFD ASCENT DESCENT FIXPWIDTHS CHARSETINFO0 CHARSETINFO357                 WIDTHS357 WIDTHSBLOCK FD FACECHANGED (WEIGHT (CAR FACE))                (SLOPE (CADR FACE))                (EXPANSION (CADDR FACE)))         (* ;;   "Ignore rotations, it is **MUCH** easier to rotate the Postscript stream user space coordinates.")         [COND            [(EQ SIZE 1)             (* ;; "Since a 1 point font is rediculously small, and it is the standard size for Postscript font info, a 1 point font is presumed to be the unit size Postscript font info")             (COND                ((SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE FACE ROTATION DEVICE))                 (SETQ FACECHANGED NIL))                ((AND (NEQ EXPANSION 'REGULAR)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST WEIGHT SLOPE                                                                              'REGULAR)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (EQ SLOPE 'ITALIC)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST WEIGHT 'REGULAR                                                                               EXPANSION)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (NEQ EXPANSION 'REGULAR)                      (EQ SLOPE 'ITALIC)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST WEIGHT 'REGULAR                                                                              'REGULAR)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (NEQ WEIGHT 'MEDIUM)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST 'MEDIUM SLOPE EXPANSION                                                                              )                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (NEQ WEIGHT 'MEDIUM)                      (NEQ EXPANSION 'REGULAR)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST 'MEDIUM SLOPE                                                                              'REGULAR)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (NEQ WEIGHT 'MEDIUM)                      (EQ SLOPE 'ITALIC)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST 'MEDIUM 'REGULAR                                                                               EXPANSION)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T))                ((AND (NEQ WEIGHT 'MEDIUM)                      (NEQ EXPANSION 'REGULAR)                      (EQ SLOPE 'ITALIC)                      (SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE (LIST 'MEDIUM 'REGULAR                                                                              'REGULAR)                                            ROTATION DEVICE)))                 (SETQ FACECHANGED T)))             (COND                (FULLNAME (SETQ PSCFD (PSCFONT.READFONT FULLNAME))                       (SETQ ASCENT (FIXR (TIMES (fetch (PSCFONT ASCENT) of PSCFD)                                                 0.1)))                       (SETQ DESCENT (FIXR (TIMES (fetch (PSCFONT DESCENT) of PSCFD)                                                  0.1)))                       (COND                          (FACECHANGED (replace (PSCFONT IL-FONTID) of PSCFD                                          with (POSTSCRIPT.GETFONTID (fetch (PSCFONT                                                                                         FID)                                                                                of PSCFD)                                                          WEIGHT SLOPE EXPANSION]            ((SETQ UNITFONT (FONTCREATE FAMILY 1 FACE ROTATION DEVICE T))             (SETQ PSCFD (LISTGET (fetch (FONTDESCRIPTOR OTHERDEVICEFONTPROPS) of UNITFONT)                                'PSCFONT))             (* ;; "Scale the ASCENT and DESCENT")             (SETQ ASCENT (FIXR (TIMES SIZE (fetch (PSCFONT ASCENT) of PSCFD)                                       0.1)))             (SETQ DESCENT (FIXR (TIMES SIZE (fetch (PSCFONT DESCENT) of PSCFD)                                        0.1)))             (SETQ SCALEFONTP T))            (T                (* ;; "Here for fonts that only come in specific sizes.  Their info is not scaled like built-in Postscript fonts, it is already correct for this pointsize.")               (COND                  ((SETQ FULLNAME (PSCFONT.SPELLFILE FAMILY SIZE FACE ROTATION DEVICE))                   (SETQ PSCFD (PSCFONT.READFONT FULLNAME))                   (SETQ ASCENT (fetch (PSCFONT ASCENT) of PSCFD))                   (SETQ DESCENT (fetch (PSCFONT DESCENT) of PSCFD))                   (SETQ SCALEFONTP NIL]         (COND            (PSCFD (SETQ FIXPWIDTHS (fetch (PSCFONT WIDTHS) of PSCFD))                   (SETQ CHARSETINFO0 (create CHARSETINFO))                   (SETQ CHARSETINFO357 (create CHARSETINFO))                   (SETQ WIDTHSBLOCK (fetch (CHARSETINFO WIDTHS) of CHARSETINFO0))                   (SETQ FD                    (create FONTDESCRIPTOR                           OTHERDEVICEFONTPROPS _ (LIST 'PSCFONT PSCFD)                           FONTSCALE _ 100                           FONTDEVICE _ DEVICE                           FONTFAMILY _ FAMILY                           FONTSIZE _ SIZE                           FONTFACE _ FACE                           ROTATION _ 0                           \SFHeight _ (IPLUS ASCENT DESCENT)                           \SFAscent _ ASCENT                           \SFDescent _ DESCENT))                   (replace (CHARSETINFO IMAGEWIDTHS) of CHARSETINFO0 with WIDTHSBLOCK)                   (replace (CHARSETINFO CHARSETASCENT) of CHARSETINFO0 with ASCENT)                   (replace (CHARSETINFO CHARSETDESCENT) of CHARSETINFO0 with DESCENT)                   (replace (CHARSETINFO IMAGEWIDTHS) of CHARSETINFO357                      with (SETQ WIDTHS357 (fetch (CHARSETINFO WIDTHS) of CHARSETINFO357)                                ))                   (replace (CHARSETINFO CHARSETASCENT) of CHARSETINFO357 with ASCENT)                   (replace (CHARSETINFO CHARSETDESCENT) of CHARSETINFO357 with DESCENT)                   [COND                      [SCALEFONTP (for CH from 0 to 255                                     do (\FSETWIDTH WIDTHSBLOCK CH (FIXR (TIMES SIZE                                                                                    (ELT FIXPWIDTHS                                                                                          CH)                                                                                    0.1]                      (T (for CH from 0 to 255 do (\FSETWIDTH WIDTHSBLOCK CH                                                                         (ELT FIXPWIDTHS CH]                   [LET [(TMP (COND                                 (FULLNAME (\FONTINFOFROMFILENAME FULLNAME DEVICE))                                 (UNITFONT (fetch FONTDEVICESPEC of UNITFONT]                        (* ;; "If face got coerced (possibly in recursive call for unit font) then set FONTDEVICESPEC to describe what we really got")                        (COND                           ((AND TMP (NEQ FAMILY (CAR TMP)))                            (replace FONTDEVICESPEC of FD with (LIST (CAR TMP)                                                                                 SIZE                                                                                 (COPY FACE)                                                                                 0 DEVICE]                   (* ;; "Fill in character widths for known NS characters with PSC equivalents in CS0:  Bullet, M-dash, N-dash, dagger, and double-dagger, respectiely.")                   (for NSCHAR in '(36 37 48 49 102) as PSCCHAR                      in '(183 208 177 178 179) do (\FSETWIDTH WIDTHS357 NSCHAR                                                                  (ELT FIXPWIDTHS PSCCHAR)))                   [LET* [(SYMBOLFILE (PSCFONT.SPELLFILE 'SYMBOL 1 '(MEDIUM REGULAR REGULAR)                                             ROTATION DEVICE))                          (SYMBOLPS (AND SYMBOLFILE (PSCFONT.READFONT SYMBOLFILE)))                          (SYMWIDTHS (AND SYMBOLPS (SETQ FIXPWIDTHS (fetch (PSCFONT WIDTHS)                                                                       of SYMBOLPS]                         (AND SYMWIDTHS (for NSCHAR in '(210 211 212) as SYMCHAR                                           in '(226 227 228)                                           do (\FSETWIDTH WIDTHSBLOCK NSCHAR                                                         (FIXR (TIMES SIZE (ELT SYMWIDTHS SYMCHAR)                                                                      0.1]                   (\SETCHARSETINFO (fetch FONTCHARSETVECTOR of FD)                          0 CHARSETINFO0)                   (\SETCHARSETINFO (fetch FONTCHARSETVECTOR of FD)                          239 CHARSETINFO357)                   FD)            (T NIL])(POSTSCRIPT.FONTSAVAILABLE  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)      (* ; "Edited 12-Jan-88 13:04 by Matt Heffron")    (* ;; "the filtering code was borrowed from Richard Burton's \SEARCHINTERPRESSFONTS.  Note that without it [HELVETICA * (MEDIUM REGULAR REGULAR)]  would pick up [HELVETICA-NARROW * (MEDIUM REGULAR REGULAR)] as well.")    (LET     ((PATTERN (\FONTFILENAME (OR (CDR (ASSOC FAMILY POSTSCRIPT.FONT.ALIST))                                  FAMILY)                      SIZE FACE 'PSCFONT))      [INVERSE.ALIST (for PAIR in POSTSCRIPT.FONT.ALIST collect (CONS (CDR PAIR)                                                                                  (CAR PAIR]      FONTSAVAILABLE)     (SETQ FONTSAVAILABLE      (for FD in [for DIRECTORY in POSTSCRIPTFONTDIRECTORIES                            join (for FILE in (DIRECTORY (CONCAT DIRECTORY PATTERN))                                        collect (LET* ((RAWFD (\FONTINFOFROMFILENAME FILE DEVICE)                                                                  )                                                           (RAWNAME (CAR RAWFD)))                                                          (RPLACA RAWFD                                                                 (OR (CDR (ASSOC RAWNAME                                                                                  INVERSE.ALIST))                                                                     RAWNAME]         when (AND (OR (EQ FAMILY '*)                           (EQ FAMILY (CAR FD)))                       (OR (EQ SIZE '*)                           (EQ SIZE (CADR FD))                           (EQ (CADR FD)                               1))                       (OR (EQ FACE '*)                           (EQUAL FACE (CADDR FD))                           (EQUAL [CDR (ASSOC FACE '((MRR MEDIUM REGULAR REGULAR)                                                     (STANDARD MEDIUM REGULAR REGULAR)                                                     (MIR MEDIUM ITALIC REGULAR)                                                     (ITALIC MEDIUM ITALIC REGULAR)                                                     (BRR BOLD REGULAR REGULAR)                                                     (BOLD BOLD REGULAR REGULAR)                                                     (BIR BOLD ITALIC REGULAR)                                                     (BOLDITALIC BOLD ITALIC REGULAR]                                  (CADDR FD)))                       (NOT (MEMBER FD $$VAL))) collect FD))     (if (EQ SIZE '*)         then(* ;;; "If SIZE was wildcarded, then provide list of pointsizes for Postscript scaled fonts (those with a 1 point descriptor file)")         (for FD in FONTSAVAILABLE            join (if (EQ 1 (CADR FD))                         then (CONS FD (for NF                                              in (for S from 2 to                                                                         \POSTSCRIPT.MAX.WILD.FONTSIZE                                                        collect (LET ((NFD (COPY FD)))                                                                         (RPLACA (CDR NFD)                                                                                S)                                                                         NFD))                                              unless (MEMBER NF FONTSAVAILABLE) collect                                                                                    NF))                       else (LIST FD)))       else FONTSAVAILABLE])(POSTSCRIPT.GETFONTID  [LAMBDA (FID WEIGHT SLOPE EXPANSION)            (* ; "Edited 12-Jan-88 12:58 by Matt Heffron")    (LET (FONTID)         (SETQ FONTID (create FONTID                             FONTIDNAME _ (CAR FID)                             FONTXFACTOR _ 1.0                             FONTOBLIQUEFACTOR _ 0.0))         [if (AND (NEQ (CADDR FID)                           SLOPE)                      (EQ SLOPE 'ITALIC))             then (replace FONTOBLIQUEFACTOR of FONTID with (CONSTANT (TAN 7.0]         (if (AND (NEQ (CADR FID)                           WEIGHT)                      (EQ WEIGHT 'BOLD))             then                                        (* ; "Fake bold by slight expansion.")                   (replace FONTXFACTOR of FONTID with 1.1))         [if (NEQ EXPANSION 'REGULAR)             then (replace FONTXFACTOR of FONTID                         with (TIMES (fetch FONTXFACTOR of FONTID)                                         (if (EQ EXPANSION 'COMPRESSED)                                             then (CONSTANT (QUOTIENT 1.0 GOLDEN.RATIO))                                           else GOLDEN.RATIO]         FONTID])(POSTSCRIPT.HARDCOPYW  [LAMBDA (FILE BITMAP SCALEFACTOR REGION Landscape? TITLE)                                                      (* ; "Edited 30-Mar-90 17:07 by Matt Heffron")    (ALLOW.BUTTON.EVENTS)    (LET* ((STREAM (OPENPOSTSCRIPTSTREAM FILE (LIST 'DOCUMENT.NAME TITLE 'ROTATION Landscape?                                                        'IMAGESIZEFACTOR SCALEFACTOR)))           (IMAGEDATA (fetch IMAGEDATA of STREAM))           (SCLIP (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA))           SCALE)          [if REGION              then (SETQ REGION (COPY REGION))           (* ; "In case we need to change it.")                    [if (< (fetch BITMAPWIDTH of BITMAP)                               (+ (fetch (REGION LEFT) of REGION)                                  (fetch (REGION WIDTH) of REGION)))                        then (replace (REGION WIDTH) of REGION                                    with (- (fetch BITMAPWIDTH of BITMAP)                                                (fetch (REGION LEFT) of REGION]                    [if (< (fetch BITMAPHEIGHT of BITMAP)                               (+ (fetch (REGION BOTTOM) of REGION)                                  (fetch (REGION HEIGHT) of REGION)))                        then (replace (REGION HEIGHT) of REGION                                    with (- (fetch BITMAPHEIGHT of BITMAP)                                                (fetch (REGION BOTTOM) of REGION]            else (SETQ REGION (create REGION                                         LEFT _ 0                                         BOTTOM _ 0                                         WIDTH _ (fetch BITMAPWIDTH of BITMAP)                                         HEIGHT _ (fetch BITMAPHEIGHT of BITMAP]          (SETQ SCALE (TIMES POSTSCRIPT.BITMAP.SCALE (fetch POSTSCRIPTSCALE of IMAGEDATA)))          (BITBLT BITMAP (fetch (REGION LEFT) of REGION)                 (fetch (REGION BOTTOM) of REGION)                 STREAM                 (PLUS (fetch LEFT of SCLIP)                       (QUOTIENT (DIFFERENCE (fetch WIDTH of SCLIP)                                        (TIMES SCALE (fetch WIDTH of REGION)))                              2))                 (PLUS (fetch BOTTOM of SCLIP)                       (QUOTIENT (DIFFERENCE (fetch HEIGHT of SCLIP)                                        (TIMES SCALE (fetch HEIGHT of REGION)))                              2))                 (fetch WIDTH of REGION)                 (fetch HEIGHT of REGION)                 'INPUT                 'REPLACE)          (CLOSEF STREAM)          (FULLNAME STREAM])(POSTSCRIPT.INIT  [LAMBDA NIL                                            (* ; "Edited  7-Apr-89 15:36 by TAL")    (DECLARE (GLOBALVARS \POSTSCRIPT.CHARTYPE))    [MAPC     [CL:REMOVE-DUPLICATES (NCONC (for FD in FONTDEFS                                     join (for FP in (CDR (ASSOC 'FONTPROFILE                                                                             (CDR FD)))                                                 collect (CAR FP)))                                  '(FONT7 FONT6 FONT5 FONT4 FONT3 FONT2 FONT1 BOLDFONT LITTLEFONT                                           BIGFONT PRETTYCOMFONT COMMENTFONT USERFONT SYSTEMFONT                                           CLISPFONT LAMBDAFONT CHANGEFONT DEFAULTFONT]     (FUNCTION (LAMBDA (CLASS)                 (LET                  (COPYFD OLDPSCFD)                  (if (BOUNDP CLASS)                      then                      (SETQ CLASS (EVALV CLASS))                      (if (TYPEP CLASS 'FONTCLASS)                          then (SETQ COPYFD (OR (fetch (FONTCLASS PRESSFD) of CLASS)                                                    (fetch (FONTCLASS INTERPRESSFD) of CLASS)                                                    (fetch (FONTCLASS DISPLAYFD) of CLASS)))                                (if (SETQ OLDPSCFD (ASSOC 'POSTSCRIPT (fetch (FONTCLASS                                                                                      OTHERFDS)                                                                             of CLASS)))                                    then [if (NOT (CDR OLDPSCFD))                                                 then (RPLACD OLDPSCFD (if (LISTP COPYFD)                                                                               then COPYFD                                                                             else (FONTUNPARSE                                                                                       COPYFD]                                  else (push (fetch (FONTCLASS OTHERFDS) of CLASS)                                                  (CONS 'POSTSCRIPT (if (LISTP COPYFD)                                                                        then COPYFD                                                                      else (FONTUNPARSE COPYFD]    (SETQ \POSTSCRIPT.CHARTYPE (CL:MAKE-ARRAY 256 :INITIAL-ELEMENT T))    (* ;; "\POSTSCRIPT.OUTCHARFN uses this array to quickly determine whether a character needs any special processing -- T means yes")    (for x from (CHARCODE SP) to 126 unless (FMEMB x (CHARCODE (%( %) \)))       do (CL:SETF (CL:AREF \POSTSCRIPT.CHARTYPE x)                     NIL))    (SETQ \POSTSCRIPTIMAGEOPS (create IMAGEOPS                                     IMAGETYPE _ 'POSTSCRIPT                                     IMCLOSEFN _ (FUNCTION CLOSEPOSTSCRIPTSTREAM)                                     IMXPOSITION _ (FUNCTION \DSPXPOSITION.PSC)                                     IMYPOSITION _ (FUNCTION \DSPYPOSITION.PSC)                                     IMMOVETO _ (FUNCTION \MOVETO.PSC)                                     IMFONT _ (FUNCTION \DSPFONT.PSC)                                     IMLEFTMARGIN _ (FUNCTION \DSPLEFTMARGIN.PSC)                                     IMRIGHTMARGIN _ (FUNCTION \DSPRIGHTMARGIN.PSC)                                     IMLINEFEED _ (FUNCTION \DSPLINEFEED.PSC)                                     IMDRAWLINE _ (FUNCTION \DRAWLINE.PSC)                                     IMDRAWCURVE _ (FUNCTION \DRAWCURVE.PSC)                                     IMDRAWCIRCLE _ (FUNCTION \DRAWCIRCLE.PSC)                                     IMDRAWELLIPSE _ (FUNCTION \DRAWELLIPSE.PSC)                                     IMFILLCIRCLE _ (FUNCTION \FILLCIRCLE.PSC)                                     IMBLTSHADE _ (FUNCTION \BLTSHADE.PSC)                                     IMBITBLT _ (FUNCTION \BITBLT.PSC)                                     IMSCALEDBITBLT _ (FUNCTION \SCALEDBITBLT.PSC)                                     IMNEWPAGE _ (FUNCTION \NEWPAGE.PSC)                                     IMSCALE _ (FUNCTION \DSPSCALE.PSC)                                     IMTERPRI _ (FUNCTION \TERPRI.PSC)                                     IMTOPMARGIN _ (FUNCTION \DSPTOPMARGIN.PSC)                                     IMBOTTOMMARGIN _ (FUNCTION \DSPBOTTOMMARGIN.PSC)                                     IMSPACEFACTOR _ (FUNCTION \DSPSPACEFACTOR.PSC)                                     IMFONTCREATE _ 'POSTSCRIPT                                     IMCLIPPINGREGION _ (FUNCTION \DSPCLIPPINGREGION.PSC)                                     IMRESET _ (FUNCTION \DSPRESET.PSC)                                     IMDRAWPOLYGON _ (FUNCTION \DRAWPOLYGON.PSC)                                     IMFILLPOLYGON _ (FUNCTION \FILLPOLYGON.PSC)                                     IMSTRINGWIDTH _ (FUNCTION \STRINGWIDTH.PSC)                                     IMCHARWIDTH _ (FUNCTION \CHARWIDTH.PSC)                                     IMDRAWARC _ (FUNCTION \DRAWARC.PSC)                                     IMROTATE _ (FUNCTION \DSPROTATE.PSC)                                     IMTRANSLATE _ (FUNCTION \DSPTRANSLATE.PSC)                                     IMDRAWPOINT _ (FUNCTION \DRAWPOINT.PSC])(POSTSCRIPT.OUTSTR  [LAMBDA (STREAM X)                              (* ; "Edited 14-Jul-89 14:05 by Matt Heffron")    (DECLARE (LOCALVARS . T))    (if (FIXP X)        then                                             (* ; "Common case, speed helps")              (\PS.BOUTFIXP STREAM X)      elseif (STRINGP X)        then                                             (* ; "Other common case")              (if (ffetch (STRINGP FATSTRINGP) of X)                  then (for c infatstring X do (BOUT STREAM (\CHAR8CODE c)))                else (\BOUTS STREAM (ffetch (STRINGP BASE) of X)                                (ffetch (STRINGP OFFST) of X)                                (ffetch (STRINGP LENGTH) of X)))      elseif (LITATOM X)        then (for c inatom X do (BOUT STREAM (\CHAR8CODE c)))      elseif (ZEROP X)        then (BOUT STREAM (CHARCODE 0))      else (if (TYPEP X 'RATIO)                   then (SETQ X (FLOAT X)))            (for c in (CHCON X) do (BOUT STREAM (\CHAR8CODE c])(POSTSCRIPT.PUTBITMAPBYTES  [LAMBDA (STREAM BITMAP DELIMFLG)    (DECLARE (GLOBALVARS PS.BITMAPARRAY)           (LOCALVARS . T))                       (* ; "Edited 30-Mar-90 20:15 by Matt Heffron")    (LET*     ((WIDTH (fetch BITMAPWIDTH of BITMAP))      (HEIGHT (fetch BITMAPHEIGHT of BITMAP))      (BMBASE (fetch BITMAPBASE of BITMAP))      (BYTESPERROW (LRSH (IPLUS WIDTH 7)                         3))      (BYTEOFFSETPERROW (LSH (fetch BITMAPRASTERWIDTH of BITMAP)                             1))      (PS.BITMAPARRAYBASE (fetch (ARRAYP BASE) of PS.BITMAPARRAY)))     (if DELIMFLG         then (LET ((POS 0)                        BYTE)                       (\FILEOUTCHARFN STREAM (CHARCODE SPACE))                       (\FILEOUTCHARFN STREAM (CHARCODE <))                       (\FILEOUTCHARFN STREAM (CHARCODE EOL))                       (for R from (SUB1 HEIGHT) to 0 by -1 as ROWOFFSET                          from (ITIMES (SUB1 HEIGHT)                                          BYTEOFFSETPERROW) by (IMINUS BYTEOFFSETPERROW)                          do (for B from 1 to BYTESPERROW as BYTEOFFSET                                    from ROWOFFSET by 1                                    do (if (IGEQ POS 254)                                               then (\FILEOUTCHARFN STREAM (CHARCODE EOL))                                                     (SETQ POS 0))                                          (SETQ BYTE (\GETBASEBYTE BMBASE BYTEOFFSET))                                          [BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                              (LOGAND 15 (LRSH BYTE 4]                                          (BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                              (LOGAND 15 BYTE)))                                          (SETQ POS (IPLUS POS 2)))                                (\FILEOUTCHARFN STREAM (CHARCODE EOL))                                (SETQ POS 0))                       (\FILEOUTCHARFN STREAM (CHARCODE SPACE))                       (\FILEOUTCHARFN STREAM (CHARCODE >))                       (\FILEOUTCHARFN STREAM (CHARCODE EOL)))       else       (LET*        ((PRVBM (BITMAPCREATE WIDTH 1))         (PRVBASE (fetch BITMAPBASE of PRVBM)))        (for R from 0 to (SUB1 HEIGHT) as ROWOFFSET from (ITIMES (SUB1 HEIGHT)                                                                                    BYTEOFFSETPERROW)           by (IMINUS BYTEOFFSETPERROW)           do           (LET            ((POS 0)             (BYTEOFFSET ROWOFFSET)             (B 1)             (PRVO 0)             BYTE REPC)            [while (ILEQ B BYTESPERROW)               do               (SETQ REPC                (for BB from B to BYTESPERROW as BO from BYTEOFFSET by 1                   as PO from PRVO by 1 while (EQ (\GETBASEBYTE BMBASE BO)                                                                  (\GETBASEBYTE PRVBASE PO))                   count T))               (if (IGEQ REPC 3)                   then (SETQ B (IPLUS B REPC))                         (SETQ BYTEOFFSET (IPLUS BYTEOFFSET REPC))                         (SETQ PRVO (IPLUS PRVO REPC))                         (while (CL:PLUSP (SETQ REPC (IDIFFERENCE REPC 1)))                            do (if (IGEQ POS 251)                                       then (\FILEOUTCHARFN STREAM (CHARCODE EOL))                                             (SETQ POS 0))                                  (BOUT STREAM (CHARCODE B))                                  (BOUT STREAM (CHARCODE 3))                                  [if (IGEQ REPC 256)                                      then (BOUT STREAM (CHARCODE F))                                            (BOUT STREAM (CHARCODE F))                                    else [BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                                 (LOGAND 15 (LRSH REPC 4]                                          (BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                              (LOGAND 15 REPC]                                  (SETQ REPC (IDIFFERENCE REPC 256))                                  (SETQ POS (IPLUS POS 4)))                 else (SETQ BYTE (\GETBASEBYTE BMBASE BYTEOFFSET))                       (SETQ REPC (for BB from B to BYTESPERROW as BO from                                                                                            BYTEOFFSET                                     by 1 while (EQ (\GETBASEBYTE BMBASE BO)                                                            BYTE) count T))                       (if (IGEQ REPC 3)                           then (SETQ B (IPLUS B REPC))                                 (SETQ BYTEOFFSET (IPLUS BYTEOFFSET REPC))                                 (SETQ PRVO (IPLUS PRVO REPC))                                 (while (CL:PLUSP (SETQ REPC (IDIFFERENCE REPC 1)))                                    do (if (IGEQ POS 249)                                               then (\FILEOUTCHARFN STREAM (CHARCODE EOL))                                                     (SETQ POS 0))                                          (BOUT STREAM (CHARCODE B))                                          (BOUT STREAM (CHARCODE 2))                                          [if (IGEQ REPC 256)                                              then (BOUT STREAM (CHARCODE F))                                                    (BOUT STREAM (CHARCODE F))                                            else [BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                                         (LOGAND 15 (LRSH REPC 4]                                                  (BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                                      (LOGAND 15 REPC]                                          [BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                              (LOGAND 15 (LRSH BYTE 4]                                          (BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE                                                              (LOGAND 15 BYTE)))                                          (SETQ REPC (IDIFFERENCE REPC 256))                                          (SETQ POS (IPLUS POS 4)))                         else (SETQ BYTE (\GETBASEBYTE BMBASE BYTEOFFSET))                               (if (IGEQ POS 251)                                   then (\FILEOUTCHARFN STREAM (CHARCODE EOL))                                         (SETQ POS 0))                               (if (FMEMB BYTE '(178 179 180))                                   then                                          (* ;; "BYTE is B2, B3, or B4; quote it")                                         (BOUT STREAM (CHARCODE B))                                         (BOUT STREAM (CHARCODE 4))                                         (SETQ POS (IPLUS POS 2)))                               [BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE (LOGAND 15                                                                                    (LRSH BYTE 4]                               (BOUT STREAM (\GETBASEBYTE PS.BITMAPARRAYBASE (LOGAND 15 BYTE)))                               (SETQ B (IPLUS B 1))                               (SETQ BYTEOFFSET (IPLUS BYTEOFFSET 1))                               (SETQ PRVO (IPLUS PRVO 1))                               (SETQ POS (IPLUS POS 2]            (\FILEOUTCHARFN STREAM (CHARCODE EOL)))           (\MOVEBYTES BMBASE ROWOFFSET PRVBASE 0 BYTESPERROW])(POSTSCRIPT.PUTCOMMAND  [LAMBDA S.STRS                                  (* ; "Edited 30-Mar-90 17:37 by Matt Heffron")    (LET* ((STREAM (ARG S.STRS 1))           (IMAGEDATA (fetch IMAGEDATA of STREAM))           S#S)          (freplace POSTSCRIPTPAGEBLANK of IMAGEDATA with NIL)          (if (ffetch POSTSCRIPTCHARSTOSHOW of IMAGEDATA)              then (POSTSCRIPT.SHOWACCUM STREAM))          (if (ffetch POSTSCRIPTPENDINGXFORM of IMAGEDATA)              then (\SETXFORM.PSC STREAM IMAGEDATA))          (for STR# from 2 to S.STRS do (if (EQ (SETQ S#S (ARG S.STRS STR#))                                                                    :EOL)                                                            then (\FILEOUTCHARFN STREAM                                                                            (CHARCODE EOL))                                                          else (POSTSCRIPT.OUTSTR STREAM S#S])(POSTSCRIPT.SHOWACCUM  [LAMBDA (STREAM)                                (* ; "Edited 30-Mar-90 17:38 by Matt Heffron")    (LET ((IMAGEDATA (ffetch IMAGEDATA of STREAM)))         (if (fetch POSTSCRIPTCHARSTOSHOW of IMAGEDATA)             then [if (EQP (ffetch POSTSCRIPTSPACEFACTOR of IMAGEDATA)                                   1)                          then (POSTSCRIPT.OUTSTR STREAM ") S")                        else (POSTSCRIPT.OUTSTR STREAM ") ")                              [POSTSCRIPT.OUTSTR STREAM (DIFFERENCE (ffetch                                                                                POSTSCRIPTSPACEWIDTH                                                                           of IMAGEDATA)                                                                   (\FGETWIDTH (ffetch                                                                                      POSTSCRIPTWIDTHS                                                                                  of IMAGEDATA)                                                                          (CHARCODE SPACE]                              (POSTSCRIPT.OUTSTR STREAM (CONSTANT (CONCAT " 0 " (CHARCODE SPACE)                                                                             " 4 -1 roll widthshow"]                   (\FILEOUTCHARFN STREAM (CHARCODE EOL))                   (freplace POSTSCRIPTCHARSTOSHOW of IMAGEDATA with NIL])(POSTSCRIPT.STARTPAGE  [LAMBDA (STREAM)                                (* ; "Edited 30-Mar-90 17:41 by Matt Heffron")    (LET ((IMAGEDATA (fetch (STREAM IMAGEDATA) of STREAM)))         (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with NIL)                                                             (* ; "shouldnt need this")         (POSTSCRIPT.PUTCOMMAND STREAM :EOL "%%%%BeginPageSetup" :EOL "/savepage save def" :EOL                (FQUOTIENT 1 \PS.SCALE0)                " imagesizefactor mul dup scale" :EOL "%%%%EndPageSetup" :EOL "%%%%Page" :EOL)         (\SETXFORM.PSC STREAM IMAGEDATA T)         (* ;; "Lisp depends on the current font being carried over from page to page, but in postscript there is no current font at the beginning of a page, so force a setfont.")         (replace POSTSCRIPTFONTCHANGEDFLG of IMAGEDATA with T)         (replace POSTSCRIPTPAGEBLANK of IMAGEDATA with T)         (if (fetch POSTSCRIPTHEADING of IMAGEDATA)             then                    (* ;; "Here we handle headings.  This imitates the INTERPRESS code.")                   (LET [(FONT (\DSPFONT.PSC STREAM (fetch POSTSCRIPTHEADINGFONT of                                                                                         IMAGEDATA]                        (\DSPRESET.PSC STREAM)                        (PRIN3 (fetch POSTSCRIPTHEADING of IMAGEDATA)                               STREAM)                        (RELMOVETO (CONSTANT (TIMES 72 \PS.SCALE0))                               0 STREAM)                     (* ; "Skip an inch before page number")                        (PRIN3 "Page " STREAM)                        (PRIN3 (CL:INCF (fetch POSTSCRIPTPAGENUM of IMAGEDATA))                               STREAM)                        (\TERPRI.PSC STREAM)             (* ; "Skip 2 lines")                        (\TERPRI.PSC STREAM)                        (\DSPFONT.PSC STREAM FONT))           else (\DSPRESET.PSC STREAM])(POSTSCRIPT.TEDIT  [LAMBDA (FILE PFILE)                                 (* ; "Edited 15-Feb-91 16:34 by gadener")    [SETQ FILE (OPENTEXTSTREAM (OR (STREAMP FILE)                                   (MKATOM FILE]    (TEDIT.FORMAT.HARDCOPY FILE PFILE T NIL NIL NIL 'POSTSCRIPT)    (CLOSEF? FILE)    PFILE])(POSTSCRIPT.TEXT  [LAMBDA (FILE PSCFILE FONTS HEADING TABS)              (* ; "Edited 23-Apr-89 11:31 by TAL")    (TEXTTOIMAGEFILE FILE PSCFILE 'POSTSCRIPT FONTS HEADING TABS           `(REGION ,POSTSCRIPT.DEFAULT.PAGEREGION ROTATION ,(NOT (NOT POSTSCRIPT.TEXTFILE.LANDSCAPE])(POSTSCRIPTFILEP  [LAMBDA (FILE)                                         (* ; "Edited 27-Aug-90 23:59 by jds")    (OR (CL:MEMBER (UNPACKFILENAME.STRING FILE 'EXTENSION)               '("PS" "PSC")               :TEST               (FUNCTION STRING-EQUAL))        (PROGN (SETFILEPTR FILE 0)               (AND (EQ (BIN FILE)                        (CHARCODE %%))                    (EQ (BIN FILE)                        (CHARCODE !])(PSCFONT.READFONT  [LAMBDA (FONTFILENAME)                                 (* ; "Edited  1-Sep-89 10:55 by jds")    (* ;; "Read one of Matt Heffron's .PSC files, to get postscript font metrics.")    (LET ((PF (create PSCFONT))          [S (OPENSTREAM FONTFILENAME 'INPUT NIL '((SEQUENTIAL T]          FID W)         [replace (PSCFONT FID) of PF with (SETQ FID (READ S (FIND-READTABLE "INTERLISP"]         (* ;; "Read until we hit a 255 byte, marking the end of the font-id section.")         (CL:DO NIL                ((EQ (BIN S)                     255))             (* ;; "Body of the loop is empty, the test does all of the work")             )         (replace (PSCFONT IL-FONTID) of PF with (CAR FID))         (replace (PSCFONT FIRSTCHAR) of PF with (\WIN S))         (replace (PSCFONT LASTCHAR) of PF with (\WIN S))         (replace (PSCFONT ASCENT) of PF with (\WIN S))         (replace (PSCFONT DESCENT) of PF with (\WIN S))         (replace (PSCFONT WIDTHS) of PF with (SETQ W (ARRAY 256 'SMALLPOSP 0 0)))         (for C from 0 to 255 do (SETA W C (\WIN S)))         (CLOSEF S)         (* ;;      "PATCH JDS 9/1/89:  The afm font reader made fonts too tall.  This should fix things pro tem.")         (replace (PSCFONT ASCENT) of PF with (- 1000 (fetch (PSCFONT DESCENT)                                                                     OF PF)))         PF])(PSCFONT.SPELLFILE  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)             (* ; "Edited  3-Apr-89 13:30 by TAL")    (FINDFILE (\FONTFILENAME (OR (CDR (FASSOC FAMILY POSTSCRIPT.FONT.ALIST))                                 FAMILY)                     SIZE FACE '.PSCFONT)           NIL POSTSCRIPTFONTDIRECTORIES])(PSCFONT.WRITEFONT  [LAMBDA (FONTFILENAME PF)                       (* ; "Edited 15-Oct-87 11:12 by Matt Heffron")    (LET ([S (OPENSTREAM FONTFILENAME 'OUTPUT NIL '((TYPE BINARY)                                                    (SEQUENTIAL T]          (W (fetch (PSCFONT WIDTHS) of PF))          (*READTABLE* (FIND-READTABLE "INTERLISP")))         (PRIN3 (fetch (PSCFONT FID) of PF)                S)         (BOUT S 0)         (BOUT S 255)         (\WOUT S (fetch (PSCFONT FIRSTCHAR) of PF))         (\WOUT S (fetch (PSCFONT LASTCHAR) of PF))         (\WOUT S (fetch (PSCFONT ASCENT) of PF))         (\WOUT S (fetch (PSCFONT DESCENT) of PF))         (for C from 0 to 255 do (\WOUT S (ELT W C)))         (CLOSEF S)         FONTFILENAME])(READ-AFM-FILE  [LAMBDA (FILE)                                  (* ; "Edited 20-Jan-88 17:22 by Matt Heffron")    (LET ((IFILE (OPENSTREAM FILE 'INPUT))          (PSCFONT (create PSCFONT))          (FCHAR 1000)          (LCHAR 0)          (W (ARRAY 256 'SMALLPOSP 0 0))          TOKEN WEIGHT SLOPE CMCOUNT FBBOX)         (with PSCFONT PSCFONT (repeatuntil (STRING-EQUAL "FontName" (RSTRING IFILE))                                      do (READCCODE IFILE))                (repeatwhile (STRING-EQUAL "" (SETQ TOKEN (RSTRING IFILE)))                   do (READCCODE IFILE))                [if (NOT (AND (BOUNDP 'WeightMenu)                                  (type? MENU WeightMenu)))                    then (SETQ WeightMenu (create MENU                                                     ITEMS _ WeightMenuItems                                                     MENUFONT _ (FONTCREATE 'HELVETICA 12]                [if (NOT (AND (BOUNDP 'SlopeMenu)                                  (type? MENU SlopeMenu)))                    then (SETQ SlopeMenu (create MENU                                                    ITEMS _ SlopeMenuItems                                                    MENUFONT _ (FONTCREATE 'HELVETICA 12]                (printout T T "Font WEIGHT for " PSCFONT ": " (SETQ WEIGHT (MENU WeightMenu))                       T)                (printout T T "Font SLOPE for " PSCFONT ": " (SETQ SLOPE (MENU SlopeMenu))                       T)                (SETQ FID (LIST TOKEN WEIGHT SLOPE 'REGULAR))                [SETQ IL-FONTID (if (AND (EQ SLOPE 'REGULAR)                                             (EQ WEIGHT 'MEDIUM))                                    then TOKEN                                  else (POSTSCRIPT.GETFONTID FID WEIGHT SLOPE 'REGULAR]                (repeatuntil (STRING-EQUAL "StartCharMetrics" TOKEN)                   do (SETQ TOKEN (RSTRING IFILE))                         (if (STRING-EQUAL "FontBBox" TOKEN)                             then (SETQ FBBOX (LIST (READ IFILE)                                                        (READ IFILE)                                                        (READ IFILE)                                                        (READ IFILE)))                                    (* ;; "The Ascender and Descender properties from the AFM file are currently ignored, and the values from the FontBBox are used.")                                   (SETQ DESCENT (IABS (CADR FBBOX)))                                   (SETQ ASCENT (CADDDR FBBOX))                           else (READCCODE IFILE)))                (SETQ CMCOUNT (RATOM IFILE))                (repeatuntil (EQ (CHARCODE EOL)                                     (READCCODE IFILE)) do)                (SETQ WIDTHS W)                (for CC from 1 to CMCOUNT                   do (LET (CCODE)                               (repeatuntil (EQ 'C (RATOM IFILE)) do)                               (SETQ CCODE (READ IFILE))                               (if (CL:PLUSP CCODE)                                   then (if (ILESSP CCODE FCHAR)                                                then (SETQ FCHAR CCODE))                                         (if (IGREATERP CCODE LCHAR)                                             then (SETQ LCHAR CCODE))                                         (RATOMS 'WX IFILE)                                         (SETA W CCODE (READ IFILE)))                               (repeatuntil (EQ (CHARCODE EOL)                                                    (READCCODE IFILE)) do)))                (SETQ FIRSTCHAR FCHAR)                (SETQ LASTCHAR LCHAR))         (CLOSEF IFILE)         PSCFONT])(\BITBLT.PSC  [LAMBDA (SOURCEBITMAP SOURCELEFT SOURCEBOTTOM STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                 SOURCETYPE OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM)                                                             (* ; "Edited  7-Apr-89 19:53 by TAL")    (\SCALEDBITBLT.PSC SOURCEBITMAP SOURCELEFT SOURCEBOTTOM STREAM DESTINATIONLEFT            DESTINATIONBOTTOM WIDTH HEIGHT SOURCETYPE OPERATION TEXTURE CLIPPINGREGION            CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM 1])(\BLTSHADE.PSC  [LAMBDA (TEXTURE STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION)                                                      (* ; "Edited 30-Mar-90 17:44 by Matt Heffron")    (* ;; "Maybe we should do something with OPERATION")    (LET ((RGN (CREATEREGION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT))          (IMAGEDATA (fetch IMAGEDATA of STREAM))          TEXTUREBM TEXTUREWIDTH LEFT BOTTOM WIDTH HEIGHT)         [if CLIPPINGREGION             then (SETQ RGN (INTERSECTREGIONS RGN CLIPPINGREGION (fetch                                                                             POSTSCRIPTCLIPPINGREGION                                                                        of IMAGEDATA)))           else (SETQ RGN (INTERSECTREGIONS RGN (fetch POSTSCRIPTCLIPPINGREGION of                                                                                             IMAGEDATA                                                           ]         (if RGN             then (SETQ LEFT (fetch (REGION LEFT) of RGN))                   (SETQ BOTTOM (fetch (REGION BOTTOM) of RGN))                   (SETQ WIDTH (CL:1- (fetch (REGION WIDTH) of RGN)))                   (SETQ HEIGHT (CL:1- (fetch (REGION HEIGHT) of RGN)))                   (if (FIXP TEXTURE)                       then (SETQ TEXTURE (SELECT TEXTURE ((BLACKSHADE -1)                                                               0.0)                                                     (WHITESHADE 1.0)                                                     TEXTURE)))                   (if (AND (FLOATP TEXTURE)                                (<= 0.0 TEXTURE 1.0))                       then (POSTSCRIPT.PUTCOMMAND STREAM HEIGHT " " WIDTH " " LEFT " "                                        BOTTOM " " TEXTURE " R" :EOL)                     elseif (OR (TEXTUREP TEXTURE)                                    (NULL TEXTURE))                       then (SETQ TEXTUREBM (BITMAPCREATE 16 16 1))                             (SETQ TEXTUREWIDTH 16)                             (BLTSHADE TEXTURE TEXTUREBM)                     elseif (BITMAPP TEXTURE)                       then (SETQ TEXTUREWIDTH (MIN (fetch BITMAPWIDTH of TEXTUREBM)                                                        (fetch BITMAPHEIGHT of TEXTUREBM)))                             (SETQ TEXTUREBM (BITMAPCREATE TEXTUREWIDTH TEXTUREWIDTH 1))                             (BITBLT TEXTURE 0 0 TEXTUREBM 0 0 TEXTUREWIDTH TEXTUREWIDTH 'INPUT                                    'REPLACE))                   (if TEXTUREBM                       then (POSTSCRIPT.PUTCOMMAND STREAM "gsave newpath ")                             (POSTSCRIPT.PUTCOMMAND STREAM "100 100 scale " (QUOTIENT LEFT 100.0)                                    " "                                    (QUOTIENT BOTTOM 100.0)                                    " M "                                    (SETQ WIDTH (QUOTIENT WIDTH 100.0))                                    " 0 rlineto 0 "                                    (QUOTIENT HEIGHT 100.0)                                    " rlineto "                                    (MINUS WIDTH)                                    " 0 rlineto closepath" :EOL)                             (POSTSCRIPT.PUTBITMAPBYTES STREAM TEXTUREBM T)                             (POSTSCRIPT.PUTCOMMAND STREAM TEXTUREWIDTH " "                                    (LSH (fetch BITMAPRASTERWIDTH of TEXTUREBM)                                         1)                                    " 0 "                                    (TIMES 72 (QUOTIENT (DSPSCALE NIL STREAM)                                                     100.0))                                    " findresolution " TEXTUREWIDTH " div div ceiling "                                     POSTSCRIPT.TEXTURE.SCALE " mul setpattern eofill" :EOL "grestore"                                    :EOL))                   (\MOVETO.PSC STREAM DESTINATIONLEFT DESTINATIONBOTTOM)                   T           else NIL])(\CHARWIDTH.PSC  [LAMBDA (STREAM CHARCODE)                       (* ; "Edited 14-Jul-89 14:37 by Matt Heffron")    (* ;; "no NS character set treatment yet")    (LET ((IMAGEDATA (ffetch IMAGEDATA of STREAM)))         (if (EQ CHARCODE (CHARCODE SPACE))             then (fetch POSTSCRIPTSPACEWIDTH of IMAGEDATA)           else (\FGETWIDTH (fetch POSTSCRIPTWIDTHS of IMAGEDATA)                           (\CHAR8CODE CHARCODE])(\DRAWARC.PSC  [LAMBDA (STREAM CENTERX CENTERY RADIUS STARTANGLE NDEGREES BRUSH DASHING)                                                      (* ; "Edited 30-Mar-90 17:46 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          WIDTH COLOR)         (if (NUMBERP BRUSH)             then (SETQ WIDTH BRUSH)           elseif (LISTP BRUSH)             then (if (NEQ (fetch BRUSHSHAPE of BRUSH)                                   'ROUND)                          then (printout T T                               "[In \DRAWARC.PSC: Non-ROUND BRUSH not supported.][Using ROUND BRUSH]" T))                   (SETQ WIDTH (fetch BRUSHSIZE of BRUSH))                   (SETQ COLOR (fetch BRUSHCOLOR of BRUSH))           else                                          (* ;                                                            "If FUNCTIONAL BRUSH big trouble!")                 (printout T T                      "[In \DRAWARC.PSC: Functional BRUSH not supported.][Using ROUND 1 point BRUSH]" T)                 (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA)))         (if (NOT (ZEROP WIDTH))             then (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")                   (if (FLOATP COLOR)                       then (POSTSCRIPT.PUTCOMMAND STREAM COLOR " setgray ")                                                              (* ;                                                "COLOR is specified in POSTSCRIPT setgray notation.")                          )                   (if (LISTP DASHING)                       then (POSTSCRIPT.OUTSTR STREAM " [")                             (for D in DASHING do (POSTSCRIPT.PUTCOMMAND STREAM                                                                     (TIMES D WIDTH)                                                                     " "))                             (POSTSCRIPT.PUTCOMMAND STREAM "] 0 setdash" :EOL)                                                              (* ;          "Since Interlisp DASHING are in terms of BRUSH units, we must multiply by the brush size.")                          )                   (POSTSCRIPT.PUTCOMMAND STREAM WIDTH                           " setlinewidth 1 setlinecap 1 setlinejoin " CENTERX " " CENTERY " " RADIUS                          " " STARTANGLE " " (+ STARTANGLE NDEGREES)                          " arc stroke" :EOL "grestore" :EOL))         (\MOVETO.PSC STREAM CENTERX CENTERY])(\DRAWCIRCLE.PSC  [LAMBDA (STREAM CENTERX CENTERY RADIUS BRUSH DASHING)                                                      (* ; "Edited 30-Mar-90 17:48 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          WIDTH COLOR)         (if (NUMBERP BRUSH)             then (SETQ WIDTH BRUSH)           elseif (LISTP BRUSH)             then (if (NEQ (fetch BRUSHSHAPE of BRUSH)                                   'ROUND)                          then (printout T T                            "[In \DRAWCIRCLE.PSC: Non-ROUND BRUSH not supported.][Using ROUND BRUSH]" T))                   (SETQ WIDTH (fetch BRUSHSIZE of BRUSH))                   (SETQ COLOR (fetch BRUSHCOLOR of BRUSH))           else                                          (* ;                                                            "If FUNCTIONAL BRUSH big trouble!")                 (printout T T                       "[In \DRAWCIRCLE.PSC: Functional BRUSH not supported.][Using (ROUND 1) BRUSH]" T)                 (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA)))         (if (NOT (ZEROP WIDTH))             then (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")                   (if (FLOATP COLOR)                       then (POSTSCRIPT.PUTCOMMAND STREAM COLOR " setgray ")                                                              (* ;                                                "COLOR is specified in POSTSCRIPT setgray notation.")                          )                   (if (LISTP DASHING)                       then (POSTSCRIPT.OUTSTR STREAM " [")                             (for D in DASHING do (POSTSCRIPT.PUTCOMMAND STREAM                                                                     (TIMES D WIDTH)                                                                     " "))                             (POSTSCRIPT.PUTCOMMAND STREAM "] 0 setdash" :EOL)                                                              (* ;          "Since Interlisp DASHING are in terms of BRUSH units, we must multiply by the brush size.")                          )                   (POSTSCRIPT.PUTCOMMAND STREAM WIDTH                           " setlinewidth 1 setlinecap 1 setlinejoin " CENTERX " " CENTERY " " RADIUS                          " 0 360 arc stroke" :EOL "grestore" :EOL))         (\MOVETO.PSC STREAM CENTERX CENTERY])(\DRAWCURVE.PSC  [LAMBDA (STREAM KNOTS CLOSED BRUSH DASHING)     (* ; "Edited 30-Mar-90 20:12 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          WIDTH SHAPE COLOR PSPLINE XA YA DXA DYA N PREVX PREVY PREV-DX3 PREV-DY3)         (if (NUMBERP BRUSH)             then (SETQ WIDTH BRUSH)                   (SETQ SHAPE 'ROUND)           elseif (LISTP BRUSH)             then (SETQ WIDTH (fetch BRUSHSIZE of BRUSH))                   (SETQ SHAPE (fetch BRUSHSHAPE of BRUSH))                   (SETQ COLOR (fetch BRUSHCOLOR of BRUSH))           else                  (* ;; "If FUNCTIONAL BRUSH then BIG trouble!")                 (printout T T                        "[In \DRAWCURVE.PSC: Functional BRUSH not supported.][Using (ROUND 1) BRUSH]" T)                 (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA))                 (SETQ SHAPE 'ROUND))         (if (NOT (ZEROP WIDTH))             then (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")                   (if (FLOATP COLOR)                       then (POSTSCRIPT.PUTCOMMAND STREAM COLOR " setgray ")                              (* ;; "COLOR is specified in POSTSCRIPT setgray notation."))                   (if (LISTP DASHING)                       then (POSTSCRIPT.OUTSTR STREAM " [")                             (for D in DASHING do (POSTSCRIPT.PUTCOMMAND STREAM                                                                     (TIMES D WIDTH)                                                                     " ")                                                        (* ;;          "Since Interlisp DASHING are in terms of BRUSH units, we must multiply by the brush size."))                             (POSTSCRIPT.PUTCOMMAND STREAM "] 0 setdash" :EOL))                   (SETQ PSPLINE (PARAMETRICSPLINE KNOTS CLOSED NIL))                   (SETQ N (pop PSPLINE))                   (SETQ XA (pop PSPLINE))                   (SETQ YA (pop PSPLINE))                   (SETQ DXA (pop PSPLINE))                   (SETQ DYA (pop PSPLINE))                   (POSTSCRIPT.PUTCOMMAND STREAM (SELECTQ SHAPE                                                         (ROUND " 1 setlinecap 1 setlinejoin ")                                                         (SQUARE " 2 setlinecap 0 setlinejoin ")                                                         " 0 setlinecap 0 setlinejoin ")                          WIDTH " setlinewidth " (SETQ PREVX (ELT XA 1))                          " "                          (SETQ PREVY (ELT YA 1))                          " M" :EOL)                   (SETQ PREV-DX3 (FQUOTIENT (ELT DXA 1)                                         3.0))                   (SETQ PREV-DY3 (FQUOTIENT (ELT DYA 1)                                         3.0))                   (for C from 2 to N                      do (POSTSCRIPT.PUTCOMMAND STREAM (FPLUS PREVX PREV-DX3)                                    " "                                    (FPLUS PREVY PREV-DY3)                                    " "                                    (FDIFFERENCE (SETQ PREVX (ELT XA C))                                           (SETQ PREV-DX3 (FQUOTIENT (ELT DXA C)                                                                 3.0)))                                    " "                                    (FDIFFERENCE (SETQ PREVY (ELT YA C))                                           (SETQ PREV-DY3 (FQUOTIENT (ELT DYA C)                                                                 3.0)))                                    " " PREVX " " PREVY " curveto" :EOL))                   (POSTSCRIPT.PUTCOMMAND STREAM "stroke" :EOL "grestore" :EOL))         (\MOVETO.PSC STREAM PREVX PREVY))    NIL])(\DRAWELLIPSE.PSC  [LAMBDA (STREAM CENTERX CENTERY MINORRADIUS MAJORRADIUS ORIENTATION BRUSH DASHING)                                                      (* ; "Edited 30-Mar-90 17:51 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          WIDTH COLOR)         (if (NUMBERP BRUSH)             then (SETQ WIDTH BRUSH)           elseif (LISTP BRUSH)             then (if (NEQ (fetch BRUSHSHAPE of BRUSH)                                   'ROUND)                          then (printout T T                           "[In \DRAWELLIPSE.PSC: Non-ROUND BRUSH not supported.][Using ROUND BRUSH]" T))                   (SETQ WIDTH (fetch BRUSHSIZE of BRUSH))                   (SETQ COLOR (fetch BRUSHCOLOR of BRUSH))           else                                          (* ;                                                            "If FUNCTIONAL BRUSH, big trouble!")                 (printout T T                      "[In \DRAWELLIPSE.PSC: Functional BRUSH not supported.][Using (ROUND 1) BRUSH]" T)                 (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA)))         (if (NOT (ZEROP WIDTH))             then (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")                   (if (FLOATP COLOR)                       then (POSTSCRIPT.PUTCOMMAND STREAM COLOR " setgray ")                                                              (* ;                                                "COLOR is specified in POSTSCRIPT setgray notation.")                          )                   (if (LISTP DASHING)                       then (POSTSCRIPT.OUTSTR STREAM " [")                             (for D in DASHING do (POSTSCRIPT.PUTCOMMAND STREAM                                                                     (TIMES D WIDTH)                                                                     " ")                                                        (* ;;          "Since Interlisp DASHING are in terms of BRUSH units, we must multiply by the brush size."))                             (POSTSCRIPT.PUTCOMMAND STREAM "] 0 setdash" :EOL))                   (POSTSCRIPT.PUTCOMMAND STREAM WIDTH                           " setlinewidth 1 setlinecap 1 setlinejoin " CENTERX " " CENTERY " "                           MAJORRADIUS " " MINORRADIUS " " ORIENTATION " 0 360 ellipse stroke" :EOL                           "grestore" :EOL))         (\MOVETO.PSC STREAM CENTERX CENTERY])(\DRAWLINE.PSC  [LAMBDA (STREAM X1 Y1 X2 Y2 WIDTH OPERATION COLOR DASHING)                                                      (* ; "Edited 30-Mar-90 17:52 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM)))         (if (NOT (NUMBERP WIDTH))             then                    (* ;; "The WIDTH = NIL should have been handled before here, but just in case!")                   (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA)))         (if (NOT (ZEROP WIDTH))             then (if (NOT (OR (FLOATP COLOR)                                       (LISTP DASHING)))                          then                           (* ; "Simple case, no dash or gray")                                (POSTSCRIPT.PUTCOMMAND STREAM X2 " " Y2 " " X1 " " Y1 " " WIDTH                                        " L" :EOL)                        else                             (* ;                                                            "COLOR is interpreted as gray factor")                              (POSTSCRIPT.PUTCOMMAND STREAM X2 " " Y2 " " X1 " " Y1 " " WIDTH " "                                     (OR (FLOATP COLOR)                                         "0")                                     " [")                              (for D in (LISTP DASHING) do                                                              (* ;;                      "Interlisp DASHING is in terms of BRUSH units, so multiply by the brush size.")                                                                      (POSTSCRIPT.PUTCOMMAND                                                                       STREAM                                                                       (TIMES D WIDTH)                                                                       " "))                              (POSTSCRIPT.PUTCOMMAND STREAM "] L1" :EOL)))         (replace POSTSCRIPTX of IMAGEDATA with X2)         (freplace POSTSCRIPTY of IMAGEDATA with Y2)         (freplace POSTSCRIPTMOVEFLG of IMAGEDATA with NIL])(\DRAWPOINT.PSC  [LAMBDA (STREAM X Y BRUSH OPERATION)            (* ; "Edited 30-Mar-90 17:53 by Matt Heffron")    (* ;; "draw a point on the stream ")    (if (BITMAPP BRUSH)        then (LET ((WIDTH (fetch BITMAPWIDTH of BRUSH))                       (HEIGHT (fetch BITMAPHEIGHT of BRUSH)))                      (BITBLT BRUSH 0 0 STREAM (- X (IQUOTIENT WIDTH 2))                             (- Y (IQUOTIENT HEIGHT 2))                             WIDTH HEIGHT OPERATION))      else (\DRAWLINE.PSC STREAM X Y X Y BRUSH OPERATION])(\DRAWPOLYGON.PSC  [LAMBDA (STREAM POINTS CLOSED BRUSH DASHING)    (* ; "Edited 30-Mar-90 17:54 by Matt Heffron")    (LET ((LASTPOINT (CAR (LAST POINTS)))          (IMAGEDATA (fetch IMAGEDATA of STREAM))          WIDTH SHAPE COLOR)         (if (NUMBERP BRUSH)             then (SETQ WIDTH BRUSH)                   (SETQ SHAPE 'ROUND)           elseif (LISTP BRUSH)             then (SETQ WIDTH (fetch BRUSHSIZE of BRUSH))                   (SETQ SHAPE (fetch BRUSHSHAPE of BRUSH))                   (SETQ COLOR (fetch BRUSHCOLOR of BRUSH))           else                  (* ;; "If FUNCTIONAL BRUSH then BIG trouble!")                 (printout T T                      "[In \DRAWPOLYGON.PSC: Functional BRUSH not supported.][Using (ROUND 1) BRUSH]" T)                 (SETQ WIDTH (fetch POSTSCRIPTSCALE of IMAGEDATA))                 (SETQ SHAPE 'ROUND))         (if (NOT (ZEROP WIDTH))             then (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")                   (if (FLOATP COLOR)                       then (POSTSCRIPT.PUTCOMMAND STREAM COLOR " setgray ")                              (* ;; "COLOR is specified in POSTSCRIPT setgray notation."))                   (if (LISTP DASHING)                       then (POSTSCRIPT.OUTSTR STREAM " [")                             (for D in DASHING do (POSTSCRIPT.PUTCOMMAND STREAM                                                                     (TIMES D WIDTH)                                                                     " ")                                                        (* ;;          "Since Interlisp DASHING are in terms of BRUSH units, we must multiply by the brush size."))                             (POSTSCRIPT.PUTCOMMAND STREAM "] 0 setdash" :EOL))                   (POSTSCRIPT.PUTCOMMAND STREAM (SELECTQ SHAPE                                                         (ROUND " 1 setlinecap 1 setlinejoin ")                                                         (SQUARE " 2 setlinecap 0 setlinejoin ")                                                         " 0 setlinecap 0 setlinejoin ")                          WIDTH " setlinewidth " (fetch XCOORD of (CAR POINTS))                          " "                          (fetch YCOORD of (CAR POINTS))                          " M" :EOL)                   (for P in (CDR POINTS) do (POSTSCRIPT.PUTCOMMAND STREAM                                                                (fetch XCOORD of P)                                                                " "                                                                (fetch YCOORD of P)                                                                " lineto" :EOL))                   (if CLOSED                       then (POSTSCRIPT.PUTCOMMAND STREAM " closepath"))                   (POSTSCRIPT.PUTCOMMAND STREAM " stroke" :EOL "grestore" :EOL))         (\MOVETO.PSC STREAM (fetch XCOORD of LASTPOINT)                (fetch YCOORD of LASTPOINT])(\DSPBOTTOMMARGIN.PSC  [LAMBDA (STREAM YPOSITION)                      (* ; "Edited 12-Jan-88 13:14 by Matt Heffron")    (PROG1 (fetch POSTSCRIPTBOTTOMMARGIN of (fetch IMAGEDATA of STREAM))        (if YPOSITION            then (replace POSTSCRIPTBOTTOMMARGIN of (fetch IMAGEDATA of STREAM)                        with YPOSITION)))])(\DSPCLIPPINGREGION.PSC  [LAMBDA (STREAM REGION)                         (* ; "Edited 14-Jul-89 14:41 by Matt Heffron")    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (OLDCLIP (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA)))          (if [AND REGION (NOT (AND (EQP (fetch LEFT of OLDCLIP)                                             (fetch LEFT of REGION))                                        (EQP (fetch BOTTOM of OLDCLIP)                                             (fetch BOTTOM of REGION))                                        (EQP (fetch WIDTH of OLDCLIP)                                             (fetch WIDTH of REGION))                                        (EQP (fetch HEIGHT of OLDCLIP)                                             (fetch HEIGHT of REGION]              then (POSTSCRIPT.SHOWACCUM STREAM)                    (replace POSTSCRIPTCLIPPINGREGION of IMAGEDATA with REGION)                    (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with T)                    (\FIXLINELENGTH.PSC STREAM IMAGEDATA))          OLDCLIP])(\DSPFONT.PSC  [LAMBDA (STREAM FONT)                           (* ; "Edited 14-Jul-89 14:42 by Matt Heffron")    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (OLDFONT (fetch POSTSCRIPTFONT of IMAGEDATA))           NEWFONT)          (if (AND FONT (SETQ NEWFONT (OR (\COERCEFONTDESC FONT STREAM)                                              (FONTCOPY OLDFONT FONT)))                       (type? FONTDESCRIPTOR NEWFONT)                       (NEQ NEWFONT OLDFONT))              then (POSTSCRIPT.SHOWACCUM STREAM)                    (replace POSTSCRIPTFONT of IMAGEDATA with NEWFONT)                    (replace POSTSCRIPTWIDTHS of IMAGEDATA                       with (fetch (CHARSETINFO WIDTHS) of (\GETBASEPTR (fetch                                                                                     FONTCHARSETVECTOR                                                                                       of NEWFONT                                                                                           )                                                                              0)))                    [replace POSTSCRIPTSPACEWIDTH of IMAGEDATA                       with (FIXR (TIMES (fetch POSTSCRIPTSPACEFACTOR of IMAGEDATA)                                             (\FGETWIDTH (fetch POSTSCRIPTWIDTHS of IMAGEDATA                                                                )                                                    (CHARCODE SPACE]                    (replace POSTSCRIPTFONTCHANGEDFLG of IMAGEDATA with T)                    (\DSPLINEFEED.PSC STREAM (IMINUS (fetch (FONTDESCRIPTOR \SFHeight)                                                            of NEWFONT)))                    (\FIXLINELENGTH.PSC STREAM IMAGEDATA))          OLDFONT])(\DSPLEFTMARGIN.PSC  [LAMBDA (STREAM XPOSITION)                             (* ; "Edited  6-Apr-89 14:01 by TAL")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM)))         (PROG1 (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)             (COND                (XPOSITION (replace POSTSCRIPTLEFTMARGIN of IMAGEDATA with XPOSITION)                       (\FIXLINELENGTH.PSC STREAM IMAGEDATA))))])(\DSPLINEFEED.PSC  [LAMBDA (STREAM LINELEADING)                    (* ; "Edited 12-Jan-88 13:16 by Matt Heffron")    (PROG1 (fetch POSTSCRIPTLINESPACING of (fetch IMAGEDATA of STREAM))        (if LINELEADING            then (replace POSTSCRIPTLINESPACING of (fetch IMAGEDATA of STREAM)                        with LINELEADING)))])(\DSPRESET.PSC  [LAMBDA (STREAM)                                       (* ; "Edited  6-Apr-89 13:18 by TAL")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM)))         (replace (STREAM CHARPOSITION) of STREAM with 0)         (\MOVETO.PSC STREAM (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)                (DIFFERENCE (fetch POSTSCRIPTTOPMARGIN of IMAGEDATA)                       (FONTPROP (fetch POSTSCRIPTFONT of IMAGEDATA)                              'ASCENT])(\DSPRIGHTMARGIN.PSC  [LAMBDA (STREAM XPOSITION)                      (* ; "Edited 14-Jul-89 14:44 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM)))         (PROG1 (fetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)             (if XPOSITION                 then (replace POSTSCRIPTRIGHTMARGIN of IMAGEDATA with XPOSITION)                       (\FIXLINELENGTH.PSC STREAM IMAGEDATA)))])(\DSPROTATE.PSC  [LAMBDA (STREAM ROTATION)                       (* ; "Edited 27-Jul-89 18:03 by Matt Heffron")    (* ;; "rotate the postscript  stream by ROTATION")    (* ;;   "we only know 90 degrees of rotation for now (0 means portrait, anything else is landscape).")    (LET* ((IMAGEDATA (fetch (STREAM IMAGEDATA) of STREAM))           (OLAND (COND                     ((fetch POSTSCRIPTLANDSCAPE of IMAGEDATA)                      90)                     (T 0)))           LAND C0 P0 C P ML MB MR MT)          (if (AND ROTATION (NEQ (SETQ LAND (NOT (ZEROP ROTATION)))                                     (fetch POSTSCRIPTLANDSCAPE of IMAGEDATA)))              then (POSTSCRIPT.SHOWACCUM STREAM)                    (\DSPTRANSLATE.PSC STREAM 0 0)                    (SETQ C0 (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA))                    (SETQ P0 (fetch POSTSCRIPTPAGEREGION of IMAGEDATA))                    (SETQ C (create REGION                                   WIDTH _ (fetch HEIGHT of C0)                                   HEIGHT _ (fetch WIDTH of C0)))                    (SETQ P (create REGION                                   LEFT _ 0                                   BOTTOM _ 0                                   WIDTH _ (fetch HEIGHT of P0)                                   HEIGHT _ (fetch WIDTH of P0)))                    (if LAND                        then (replace LEFT of C with (fetch BOTTOM of C0))                              [replace BOTTOM of C with (- (fetch WIDTH of P0)                                                                       (+ (fetch LEFT                                                                             of C0)                                                                          (fetch WIDTH                                                                             of C0]                              (SETQ ML (fetch POSTSCRIPTBOTTOMMARGIN of IMAGEDATA))                              (SETQ MB (- (fetch WIDTH of P0)                                          (fetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)                                          1))                              (SETQ MR (fetch POSTSCRIPTTOPMARGIN of IMAGEDATA))                              (SETQ MT (- (fetch WIDTH of P0)                                          (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)                                          1))                      else [replace LEFT of C with (- (fetch HEIGHT of P0)                                                                      (+ (fetch BOTTOM                                                                            of C0)                                                                         (fetch HEIGHT                                                                            of C0]                            (replace BOTTOM of C with (fetch LEFT of C0))                            (SETQ ML (- (fetch HEIGHT of P0)                                        (fetch POSTSCRIPTTOPMARGIN of IMAGEDATA)                                        1))                            (SETQ MB (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA))                            (SETQ MR (- (fetch HEIGHT of P0)                                        (fetch POSTSCRIPTBOTTOMMARGIN of IMAGEDATA)                                        1))                            (SETQ MT (fetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)))                    (replace POSTSCRIPTCLIPPINGREGION of IMAGEDATA with C)                    (replace POSTSCRIPTPAGEREGION of IMAGEDATA with P)                    (replace POSTSCRIPTLEFTMARGIN of IMAGEDATA with ML)                    (replace POSTSCRIPTBOTTOMMARGIN of IMAGEDATA with MB)                    (replace POSTSCRIPTRIGHTMARGIN of IMAGEDATA with MR)                    (replace POSTSCRIPTTOPMARGIN of IMAGEDATA with MT)                    (replace POSTSCRIPTLANDSCAPE of IMAGEDATA with LAND)                    (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with T)                    (\DSPRESET.PSC STREAM))          OLAND])(\DSPSCALE.PSC  [LAMBDA (STREAM SCALE)                          (* ; "Edited 30-Mar-90 17:56 by Matt Heffron")    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (OSCALE (fetch POSTSCRIPTSCALE of IMAGEDATA))           NSCALE)          (if (AND NIL                        (* ;; "Changing SCALE is not implemented.  According to IRM.")                       (NUMBERP SCALE)                       (CL:PLUSP SCALE))              then (SETQ NSCALE (QUOTIENT SCALE OSCALE))                     (* ;;       "NSCALE is the adjustment for the fact that the scale operator takes RELATIVE scale changes.")                    (POSTSCRIPT.PUTCOMMAND STREAM " " NSCALE " " NSCALE " scale" :EOL)                    (replace POSTSCRIPTSCALE of IMAGEDATA with SCALE))          OSCALE])(\DSPSPACEFACTOR.PSC  [LAMBDA (STREAM FACTOR)                         (* ; "Edited 14-Jul-89 14:48 by Matt Heffron")    (DECLARE (LOCALVARS . T))    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (OLDFACTOR (fetch POSTSCRIPTSPACEFACTOR of IMAGEDATA)))          [if (AND (NUMBERP FACTOR)                       (NOT (EQUAL FACTOR OLDFACTOR)))              then (POSTSCRIPT.SHOWACCUM STREAM)                    (replace POSTSCRIPTSPACEFACTOR of IMAGEDATA with FACTOR)                    (replace POSTSCRIPTSPACEWIDTH of IMAGEDATA                       with (FIXR (TIMES FACTOR (\FGETWIDTH (fetch POSTSCRIPTWIDTHS                                                                   of IMAGEDATA)                                                           (CHARCODE SPACE]          OLDFACTOR])(\DSPTOPMARGIN.PSC  [LAMBDA (STREAM YPOSITION)                      (* ; "Edited 12-Jan-88 13:17 by Matt Heffron")    (PROG1 (fetch POSTSCRIPTTOPMARGIN of (fetch IMAGEDATA of STREAM))        (if YPOSITION            then (replace POSTSCRIPTTOPMARGIN of (fetch IMAGEDATA of STREAM)                        with YPOSITION)))])(\DSPTRANSLATE.PSC  [LAMBDA (STREAM TX TY)                          (* ; "Edited 14-Jul-89 14:58 by Matt Heffron")    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (MDX (DIFFERENCE (fetch POSTSCRIPTTRANSX of IMAGEDATA)                       TX))           (MDY (DIFFERENCE (fetch POSTSCRIPTTRANSY of IMAGEDATA)                       TY)))          (if (NOT (AND (ZEROP MDX)                            (ZEROP MDY)))              then (POSTSCRIPT.SHOWACCUM STREAM)                    (for REG in (LIST (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA)                                              (fetch POSTSCRIPTPAGEREGION of IMAGEDATA))                       do (CL:INCF (fetch LEFT of REG)                                     MDX)                             (CL:INCF (fetch BOTTOM of REG)                                    MDY))                    (CL:INCF (fetch POSTSCRIPTX of IMAGEDATA)                           MDX)                    (CL:INCF (fetch POSTSCRIPTY of IMAGEDATA)                           MDY)                    (CL:INCF (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)                           MDX)                    (CL:INCF (fetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)                           MDX)                    (CL:INCF (fetch POSTSCRIPTBOTTOMMARGIN of IMAGEDATA)                           MDY)                    (CL:INCF (fetch POSTSCRIPTTOPMARGIN of IMAGEDATA)                           MDY)                    (replace POSTSCRIPTTRANSX of IMAGEDATA with TX)                    (replace POSTSCRIPTTRANSY of IMAGEDATA with TY)                    (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with T])(\DSPXPOSITION.PSC  [LAMBDA (STREAM XPOSITION)                      (* ; "Edited  9-Sep-88 10:58 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          OLDX)         (PROG1 (SETQ OLDX (fetch POSTSCRIPTX of IMAGEDATA))             (if (AND XPOSITION (NOT (EQUAL XPOSITION OLDX)))                 then (\MOVETO.PSC STREAM XPOSITION (fetch POSTSCRIPTY of IMAGEDATA))                    ))])(\DSPYPOSITION.PSC  [LAMBDA (STREAM YPOSITION)                      (* ; "Edited  9-Sep-88 10:58 by Matt Heffron")    (LET ((IMAGEDATA (fetch IMAGEDATA of STREAM))          OLDY)         (PROG1 (SETQ OLDY (fetch POSTSCRIPTY of IMAGEDATA))             (if (AND YPOSITION (NOT (EQUAL YPOSITION OLDY)))                 then (\MOVETO.PSC STREAM (fetch POSTSCRIPTX of IMAGEDATA)                                 YPOSITION)))])(\FILLCIRCLE.PSC  [LAMBDA (STREAM CENTERX CENTERY RADIUS TEXTURE) (* ; "Edited 30-Mar-90 17:59 by Matt Heffron")    (LET (TEXTUREBM TEXTUREWIDTH)         (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")         (if (FIXP TEXTURE)             then (if (ZEROP TEXTURE)                          then (SETQ TEXTURE 1.0)        (* ; "The setgray version of white")                        elseif (OR (EQL TEXTURE 65535)                                       (EQL TEXTURE -1))                          then (SETQ TEXTURE 0.0)        (* ; "The setgray version of black")                             ))         (if (FLOATP TEXTURE)             then                    (* ;;                  "If TEXTURE is a FLOATP, then it is specified in PostScript setgray notation.")                   (POSTSCRIPT.PUTCOMMAND STREAM TEXTURE " setgray ")           elseif (OR (TEXTUREP TEXTURE)                          (NULL TEXTURE))             then (SETQ TEXTUREBM (BITMAPCREATE 16 16 1))                   (SETQ TEXTUREWIDTH 16)                   (BLTSHADE TEXTURE TEXTUREBM)           elseif (BITMAPP TEXTURE)             then (SETQ TEXTUREWIDTH (MIN (fetch BITMAPWIDTH of TEXTUREBM)                                              (fetch BITMAPHEIGHT of TEXTUREBM)))                   (SETQ TEXTUREBM (BITMAPCREATE TEXTUREWIDTH TEXTUREWIDTH 1))                   (BITBLT TEXTURE 0 0 TEXTUREBM 0 0 TEXTUREWIDTH TEXTUREWIDTH 'INPUT 'REPLACE))         (POSTSCRIPT.PUTCOMMAND STREAM " " CENTERX " " CENTERY " " RADIUS " 0 360 arc" :EOL)         (if TEXTUREBM             then (POSTSCRIPT.PUTCOMMAND STREAM "100 100 scale ")                   (POSTSCRIPT.PUTBITMAPBYTES STREAM TEXTUREBM T)                   (POSTSCRIPT.PUTCOMMAND STREAM TEXTUREWIDTH " " (LSH (fetch                                                                                   BITMAPRASTERWIDTH                                                                              of TEXTUREBM)                                                                           1)                          " 0 "                          (TIMES 72 (QUOTIENT (DSPSCALE NIL STREAM)                                           100.0))                          " findresolution " TEXTUREWIDTH " div div ceiling "                           POSTSCRIPT.TEXTURE.SCALE " mul setpattern eofill" :EOL "grestore" :EOL)           else (POSTSCRIPT.PUTCOMMAND STREAM " eofill" :EOL "grestore" :EOL))         (\MOVETO.PSC STREAM CENTERX CENTERY])(\FILLPOLYGON.PSC  [LAMBDA (STREAM KNOTS TEXTURE OPERATION WINDNUMBER)                                                      (* ; "Edited 30-Mar-90 18:01 by Matt Heffron")    (DECLARE (SPECVARS FILL.WRULE))    (* ;; "OPERATION is ignored here")    (LET ((LASTPOINT (CAR (LAST KNOTS)))          TEXTUREBM TEXTUREWIDTH)         (POSTSCRIPT.PUTCOMMAND STREAM :EOL "gsave newpath ")         (if (NOT (OR (ZEROP WINDNUMBER)                          (EQL WINDNUMBER 1)))             then (SETQ WINDNUMBER FILL.WRULE))         (if (FIXP TEXTURE)             then (if (ZEROP TEXTURE)                          then (SETQ TEXTURE 1.0)        (* ; "The setgray version of white")                        elseif (OR (EQL TEXTURE 65535)                                       (EQL TEXTURE -1))                          then (SETQ TEXTURE 0.0)        (* ; "The setgray version of black")                             ))         (if (FLOATP TEXTURE)             then                    (* ;;                  "If TEXTURE is a FLOATP, then it is specified in PostScript setgray notation.")                   (POSTSCRIPT.PUTCOMMAND STREAM TEXTURE " setgray ")           elseif (OR (TEXTUREP TEXTURE)                          (NULL TEXTURE))             then (SETQ TEXTUREBM (BITMAPCREATE 16 16 1))                   (SETQ TEXTUREWIDTH 16)                   (BLTSHADE TEXTURE TEXTUREBM)           elseif (BITMAPP TEXTURE)             then (SETQ TEXTUREWIDTH (MIN (fetch BITMAPWIDTH of TEXTUREBM)                                              (fetch BITMAPHEIGHT of TEXTUREBM)))                   (SETQ TEXTUREBM (BITMAPCREATE TEXTUREWIDTH TEXTUREWIDTH 1))                   (BITBLT TEXTURE 0 0 TEXTUREBM 0 0 TEXTUREWIDTH TEXTUREWIDTH 'INPUT 'REPLACE))         (POSTSCRIPT.PUTCOMMAND STREAM (fetch XCOORD of (CAR KNOTS))                " "                (fetch YCOORD of (CAR KNOTS))                " M" :EOL)         (for K in (CDR KNOTS) do (POSTSCRIPT.PUTCOMMAND STREAM (fetch XCOORD                                                                                   of K)                                                     " "                                                     (fetch YCOORD of K)                                                     " lineto" :EOL))         (POSTSCRIPT.PUTCOMMAND STREAM " closepath" :EOL)         (if TEXTUREBM             then (POSTSCRIPT.PUTCOMMAND STREAM "100 100 scale ")                   (POSTSCRIPT.PUTBITMAPBYTES STREAM TEXTUREBM T)                   (POSTSCRIPT.PUTCOMMAND STREAM TEXTUREWIDTH " " (LSH (fetch                                                                                   BITMAPRASTERWIDTH                                                                              of TEXTUREBM)                                                                           1)                          " 0 "                          (TIMES 72 (QUOTIENT (DSPSCALE NIL STREAM)                                           100.0))                          " findresolution " TEXTUREWIDTH " div div ceiling "                           POSTSCRIPT.TEXTURE.SCALE " mul setpattern"))         (POSTSCRIPT.PUTCOMMAND STREAM (if (ZEROP WINDNUMBER)                                               then " fill"                                             else " eofill")                :EOL "grestore" :EOL)         (\MOVETO.PSC STREAM (fetch XCOORD of LASTPOINT)                (fetch YCOORD of LASTPOINT])(\FIXLINELENGTH.PSC  [LAMBDA (STREAM IMAGEDATA)                      (* ; "Edited 27-Jul-89 17:59 by Matt Heffron")    (* ;; "Called by margin, font or rotation change to update the LINELENGTH field in the stream.")    (LET [(TMP (MIN MAX.SMALLP (FIX (QUOTIENT (DIFFERENCE (fetch POSTSCRIPTRIGHTMARGIN                                                             of IMAGEDATA)                                                     (ffetch POSTSCRIPTLEFTMARGIN of                                                                                             IMAGEDATA                                                            ))                                           (fetch FONTAVGCHARWIDTH of (ffetch                                                                                      POSTSCRIPTFONT                                                                                 of IMAGEDATA]         (replace (STREAM LINELENGTH) of STREAM with (if (GREATERP TMP 1)                                                                     then TMP                                                                   else 10])(\MOVETO.PSC  [LAMBDA (STREAM X Y)                            (* ; "Edited 14-Jul-89 14:49 by Matt Heffron")    (LET ((IMAGEDATA (ffetch IMAGEDATA of STREAM)))         (if [NOT (AND (EQP X (fetch POSTSCRIPTX of IMAGEDATA))                           (EQP Y (ffetch POSTSCRIPTY of IMAGEDATA]             then (POSTSCRIPT.SHOWACCUM STREAM)                   (freplace POSTSCRIPTX of IMAGEDATA with X)                   (freplace POSTSCRIPTY of IMAGEDATA with Y)                   (freplace POSTSCRIPTMOVEFLG of IMAGEDATA with T])(\NEWPAGE.PSC  [LAMBDA (STREAM)                                       (* ; "Edited  5-Apr-89 17:31 by TAL")    (POSTSCRIPT.ENDPAGE STREAM)    (POSTSCRIPT.STARTPAGE STREAM])(\POSTSCRIPTTAB  [LAMBDA (POSTSCRIPTDATA)                               (* ; "Edited  2-Apr-89 14:22 by TAL")    (LET [(TABSPACE (TIMES 8 (ffetch FONTAVGCHARWIDTH of (ffetch POSTSCRIPTFONT                                                                    of POSTSCRIPTDATA]         (IDIFFERENCE TABSPACE (IREMAINDER (IDIFFERENCE (ffetch POSTSCRIPTX of POSTSCRIPTDATA                                                               )                                                  (ffetch POSTSCRIPTLEFTMARGIN of                                                                                        POSTSCRIPTDATA                                                         ))                                      TABSPACE])(\PS.BOUTFIXP  [LAMBDA (STREAM N)                              (* ; "Edited 14-Jul-89 14:11 by Matt Heffron")    (* ;; "BOUT the decimal representation of N to STREAM using temp storage from the imagedata.  Done this way for speed.")    (DECLARE (LOCALVARS . T))    (if (MINUSP N)        then (BOUT STREAM (CHARCODE -))              (SETQ N (IMINUS N)))    (if (LESSP N 10)        then (BOUT STREAM (IPLUS N (CHARCODE 0)))      elseif (LESSP N 1000000000)        then (LET ([BASE (fetch (ARRAYP BASE) of (fetch POSTSCRIPTTEMPARRAY                                                                of (fetch (STREAM IMAGEDATA)                                                                          of STREAM]                       (i (SUB1 \PS.TEMPARRAYLEN)))                      [for old i by -1 do (\PUTBASEBYTE BASE i                                                                 (IPLUS (IREMAINDER N 10)                                                                        (CHARCODE 0)))                         repeatwhile (NEQ 0 (SETQ N (IQUOTIENT N 10]                      (\BOUTS STREAM BASE i (IDIFFERENCE \PS.TEMPARRAYLEN i)))      else                                               (* ; "Just in case we get a bignum")            (for c in (CHCON N) do (BOUT STREAM (\CHAR8CODE c])(\PS.SCALEHACK  [LAMBDA (STREAM SCALEFACTOR)                    (* ; "Edited 14-Jul-89 15:03 by Matt Heffron")    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (OLDSCALE (fetch POSTSCRIPTSCALEHACK of IMAGEDATA))           FACTOR)          (if (AND (NUMBERP SCALEFACTOR)                       (NOT (EQP OLDSCALE SCALEFACTOR)))              then (POSTSCRIPT.SHOWACCUM STREAM)                    (SETQ FACTOR (/ OLDSCALE SCALEFACTOR))                    [for REG in (LIST (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA)                                              (fetch POSTSCRIPTPAGEREGION of IMAGEDATA))                       do (change (fetch LEFT of REG)                                     (FIXR (CL:* DATUM FACTOR)))                             (change (fetch BOTTOM of REG)                                    (FIXR (CL:* DATUM FACTOR)))                             (change (fetch WIDTH of REG)                                    (FIXR (CL:* DATUM FACTOR)))                             (change (fetch HEIGHT of REG)                                    (FIXR (CL:* DATUM FACTOR]                    (change (fetch POSTSCRIPTX of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTY of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTBOTTOMMARGIN of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTTOPMARGIN of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTTRANSX of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (change (fetch POSTSCRIPTTRANSY of IMAGEDATA)                           (FIXR (CL:* DATUM FACTOR)))                    (replace POSTSCRIPTSCALEHACK of IMAGEDATA with SCALEFACTOR)                    (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with T))          OLDSCALE])(\PS.SCALEREGION  [LAMBDA (SCALE REGION)                                 (* ; "Edited  5-Apr-89 16:15 by TAL")                                                             (* ; "Scales a region")    (create REGION           LEFT _ (FIXR (TIMES SCALE (fetch (REGION LEFT) of REGION)))           BOTTOM _ (FIXR (TIMES SCALE (fetch (REGION BOTTOM) of REGION)))           WIDTH _ (FIXR (TIMES SCALE (fetch (REGION WIDTH) of REGION)))           HEIGHT _ (FIXR (TIMES SCALE (fetch (REGION HEIGHT) of REGION])(\SCALEDBITBLT.PSC  [LAMBDA (SOURCEBITMAP SOURCELEFT SOURCEBOTTOM STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                 SOURCETYPE OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM                  SCALE)                           (* ; "Edited 30-Mar-90 19:06 by Matt Heffron")    (* ;; "Postscript can only handle OPERATION REPLACE and PAINT.  SOURCETYPE = TEXTURE is converted to BLTSHADE before getting here (so the TEXTURE argument can be ignored).  If the destination region lies completely outside the clipping region we do nothing, otherwise we output the whole thing and let the printer clip.  Could be more clever.")    (OR (NUMBERP SCALE)        (SETQ SCALE 1))    (LET* ((IMAGEDATA (fetch IMAGEDATA of STREAM))           (SCALE1 (TIMES SCALE (fetch POSTSCRIPTSCALE of IMAGEDATA)))           (SCALE2 (TIMES SCALE1 (OR (NUMBERP POSTSCRIPT.BITMAP.SCALE)                                     1)))           DESTREGION           (BITMAPWIDTH (fetch BITMAPWIDTH of SOURCEBITMAP))           (BITMAPHEIGHT (fetch BITMAPHEIGHT of SOURCEBITMAP))           TEMPBM)          (if (NULL DESTINATIONLEFT)              then (SETQ DESTINATIONLEFT (fetch POSTSCRIPTX of IMAGEDATA)))          (if (NULL DESTINATIONBOTTOM)              then (SETQ DESTINATIONBOTTOM (fetch POSTSCRIPTY of IMAGEDATA)))          (if (OR (NULL WIDTH)                      (NULL HEIGHT))              then (SETQ WIDTH BITMAPWIDTH)                    (SETQ HEIGHT BITMAPHEIGHT)            elseif (OR (GREATERP WIDTH BITMAPWIDTH)                           (GREATERP HEIGHT BITMAPHEIGHT))              then (SETQ WIDTH (FIXR (QUOTIENT WIDTH SCALE1)))                    (SETQ HEIGHT (FIXR (QUOTIENT HEIGHT SCALE1)))                    (if (OR (GREATERP WIDTH BITMAPWIDTH)                                (GREATERP HEIGHT BITMAPHEIGHT))                        then (SETQ WIDTH BITMAPWIDTH)                              (SETQ HEIGHT BITMAPHEIGHT)))          [SETQ DESTREGION (INTERSECTREGIONS (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA)                                  (CREATEREGION DESTINATIONLEFT DESTINATIONBOTTOM (TIMES SCALE1 WIDTH                                                                                         )                                         (TIMES SCALE1 HEIGHT]          (if (AND DESTREGION (OR (NULL CLIPPINGREGION)                                      (REGIONSINTERSECTP DESTREGION CLIPPINGREGION)))              then (if (AND (EQ SOURCELEFT 0)                                    (EQ SOURCEBOTTOM 0)                                    (EQP WIDTH BITMAPWIDTH)                                    (EQP HEIGHT BITMAPHEIGHT))                           then                          (* ;                                                            "Avoid copy if sending entire bitmap")                                 (SETQ TEMPBM SOURCEBITMAP)                         else (SETQ TEMPBM (BITMAPCREATE WIDTH HEIGHT 1))                               (BITBLT SOURCEBITMAP SOURCELEFT SOURCEBOTTOM TEMPBM 0 0 WIDTH HEIGHT                                       SOURCETYPE 'REPLACE))                    (POSTSCRIPT.PUTCOMMAND STREAM "/bitbltsave save def " DESTINATIONLEFT " "                            DESTINATIONBOTTOM " translate " (TIMES SCALE2 WIDTH)                           " "                           (TIMES SCALE2 HEIGHT)                           " scale " WIDTH " " HEIGHT (if (EQ OPERATION 'PAINT)                                                          then " true"                                                        else " false")                           " thebitimage" :EOL)                    (POSTSCRIPT.PUTBITMAPBYTES STREAM TEMPBM NIL)                    (POSTSCRIPT.PUTCOMMAND STREAM :EOL "bitbltsave restore" :EOL)                    (\MOVETO.PSC STREAM DESTINATIONLEFT DESTINATIONBOTTOM)                    T            else NIL])(\SETPOS.PSC  [LAMBDA (STREAM IMAGEDATA)                             (* ; "Edited  3-Apr-89 18:09 by TAL")    (POSTSCRIPT.PUTCOMMAND STREAM (fetch POSTSCRIPTX of IMAGEDATA)           " "           (ffetch POSTSCRIPTY of IMAGEDATA)           " M ")    (freplace POSTSCRIPTMOVEFLG of IMAGEDATA with NIL])(\SETXFORM.PSC  [LAMBDA (STREAM IMAGEDATA NORESTORE)            (* ; "Edited  4-Apr-90 17:22 by Matt Heffron")    (LET ((CLIP (fetch POSTSCRIPTCLIPPINGREGION of IMAGEDATA)))         (replace POSTSCRIPTPENDINGXFORM of IMAGEDATA with NIL)         (if (NOT NORESTORE)             then (POSTSCRIPT.OUTSTR STREAM "grestore "))         (POSTSCRIPT.PUTCOMMAND STREAM "gsave" :EOL)         (if (NOT (EQP (fetch POSTSCRIPTSCALEHACK of IMAGEDATA)                           1))             then (POSTSCRIPT.PUTCOMMAND STREAM (fetch POSTSCRIPTSCALEHACK of                                                                                             IMAGEDATA                                                               )                             " dup scale" :EOL))         (if (fetch POSTSCRIPTLANDSCAPE of IMAGEDATA)             then (POSTSCRIPT.OUTSTR STREAM " 90 rotate "))         (if [NOT (AND (ZEROP (fetch POSTSCRIPTTRANSX of IMAGEDATA))                           (ZEROP (fetch POSTSCRIPTTRANSY of IMAGEDATA]             then (POSTSCRIPT.PUTCOMMAND STREAM (fetch POSTSCRIPTTRANSX of IMAGEDATA)                             " "                             (fetch POSTSCRIPTTRANSY of IMAGEDATA)                             " translate" :EOL))         (POSTSCRIPT.PUTCOMMAND STREAM (fetch HEIGHT of CLIP)                " "                (fetch WIDTH of CLIP)                " "                (fetch LEFT of CLIP)                " "                (fetch BOTTOM of CLIP)                " CLP" :EOL)         (replace POSTSCRIPTMOVEFLG of IMAGEDATA with T)         (replace POSTSCRIPTFONTCHANGEDFLG of IMAGEDATA with T])(\STRINGWIDTH.PSC  [LAMBDA (STREAM STR RDTBL)                             (* ; "Edited  2-Apr-89 18:13 by TAL")    (LET ((IMAGEDATA (ffetch (STREAM IMAGEDATA) of STREAM)))         (\STRINGWIDTH.GENERIC STR (fetch POSTSCRIPTFONT of IMAGEDATA)                RDTBL                (ffetch POSTSCRIPTSPACEWIDTH of IMAGEDATA])(\SWITCHFONTS.PSC  [LAMBDA (STREAM POSTSCRIPTDATA)                 (* ; "Edited 30-Mar-90 18:07 by Matt Heffron")    (LET* [(FONT (ffetch POSTSCRIPTFONT of POSTSCRIPTDATA))           (FONTID (fetch (PSCFONT IL-FONTID) of (LISTGET (fetch (FONTDESCRIPTOR                                                                                  OTHERDEVICEFONTPROPS                                                                                    ) of FONT)                                                                'PSCFONT]          (if (LISTP FONTID)              then (POSTSCRIPT.PUTCOMMAND STREAM "/" (fetch FONTIDNAME of FONTID)                              " findfont ["                              (TIMES (fetch FONTXFACTOR of FONTID)                                     (fetch (FONTDESCRIPTOR FONTSIZE) of FONT)                                     100)                              " 0 "                              (TIMES (fetch FONTOBLIQUEFACTOR of FONTID)                                     (fetch (FONTDESCRIPTOR FONTSIZE) of FONT)                                     100)                              " "                              (TIMES (fetch (FONTDESCRIPTOR FONTSIZE) of FONT)                                     100)                              " 0 0] makefont setfont" :EOL)            else (POSTSCRIPT.PUTCOMMAND STREAM (TIMES (fetch (FONTDESCRIPTOR FONTSIZE)                                                                 of FONT)                                                              100)                            " /" FONTID " F" :EOL))          (replace POSTSCRIPTFONTCHANGEDFLG of POSTSCRIPTDATA with NIL])(\TERPRI.PSC  [LAMBDA (STREAM)                                (* ; "Edited 30-Mar-90 18:08 by Matt Heffron")    (LET* [(IMAGEDATA (fetch IMAGEDATA of STREAM))           (NEWY (PLUS (ffetch POSTSCRIPTY of IMAGEDATA)                       (ffetch POSTSCRIPTLINESPACING of IMAGEDATA]          (if [LESSP NEWY (IPLUS (ffetch POSTSCRIPTBOTTOMMARGIN of IMAGEDATA)                                     (fetch (FONTDESCRIPTOR \SFDescent)                                        of (ffetch POSTSCRIPTFONT of IMAGEDATA]              then (\NEWPAGE.PSC STREAM)            else (replace (STREAM CHARPOSITION) of STREAM with 0)                  (\MOVETO.PSC STREAM (ffetch POSTSCRIPTLEFTMARGIN of IMAGEDATA)                         NEWY))          NIL]))(DEFINEQ(\POSTSCRIPT.OUTCHARFN  [LAMBDA (STREAM CHAR)                                  (* ; "Edited 12-Jul-90 12:22 by jds")(* ;;; "Output a character to be printed.   NS chars are not handled yet.")(* ;;; "Change font if necessary, do newline if at right margin, check for special chars and do appropriate thing, quote char and/or start postscript string if necessary.")(* ;;; "This is called a lot, so the code is unrolled for efficiancy.")(* ;;;; "")(* ;;;; "Need to inc CHARPOSITION of STREAM")    (DECLARE (GLOBALVARS \POSTSCRIPT.CHARTYPE)           (LOCALVARS . T))    (PROG* ((IMAGEDATA (fetch IMAGEDATA of STREAM))            (XPOS (fetch POSTSCRIPTX of IMAGEDATA))            (FONT (ffetch POSTSCRIPTFONT of IMAGEDATA))            [CHARWID (SELCHARQ CHAR                          (SPACE (ffetch POSTSCRIPTSPACEWIDTH of IMAGEDATA))                          (\FGETWIDTH (ffetch POSTSCRIPTWIDTHS of IMAGEDATA)                                 (\CHAR8CODE CHAR]            NEWXPOS)           [COND              ((AND (ILEQ CHAR 254)                    (NOT (CL:AREF \POSTSCRIPT.CHARTYPE CHAR)))                                                             (* ;                                                            "non-NIL if char is special in any way")               [COND                  ((IGREATERP (SETQ NEWXPOS (IPLUS XPOS CHARWID))                          (ffetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA))                   (\TERPRI.PSC STREAM)                   (SETQ NEWXPOS (IPLUS (ffetch POSTSCRIPTX of IMAGEDATA)                                        CHARWID]               (COND                  ((NOT (ffetch POSTSCRIPTCHARSTOSHOW of IMAGEDATA))                   (COND                      ((ffetch POSTSCRIPTPENDINGXFORM of IMAGEDATA)                       (\SETXFORM.PSC STREAM IMAGEDATA)))                   (COND                      ((ffetch POSTSCRIPTFONTCHANGEDFLG of IMAGEDATA)                                                             (* ;                                                   "If font was changed then switch before printing")                       (\SWITCHFONTS.PSC STREAM IMAGEDATA)))                   (COND                      ((ffetch POSTSCRIPTMOVEFLG of IMAGEDATA)                                                             (* ; "likewise for position")                       (\SETPOS.PSC STREAM IMAGEDATA)))                   (BOUT STREAM (CHARCODE %())                   (freplace POSTSCRIPTCHARSTOSHOW of IMAGEDATA with T)))               (BOUT STREAM CHAR)               (freplace POSTSCRIPTX of IMAGEDATA with NEWXPOS))              (T                                             (* ; "Special char")                 (SELCHARQ CHAR                      ((EOL LF)                            (\TERPRI.PSC STREAM))                      (FF (DSPNEWPAGE STREAM))                      (TAB (SETQ NEWXPOS (IPLUS XPOS (\POSTSCRIPTTAB IMAGEDATA)))                           [COND                              ((IGREATERP NEWXPOS (ffetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA)                                      )                               (\TERPRI.PSC STREAM)                               (SETQ NEWXPOS (IPLUS (ffetch POSTSCRIPTX of IMAGEDATA)                                                    (\POSTSCRIPTTAB IMAGEDATA]                           (\MOVETO.PSC STREAM NEWXPOS (ffetch POSTSCRIPTY of IMAGEDATA)))                      ("357,146"                             (* ; "Bullet")                                 (\POSTSCRIPT.OUTCHARFN STREAM (CHARCODE "0,267")))                      ("357,45"                              (* ; "M-Dash")                                (\POSTSCRIPT.OUTCHARFN STREAM (CHARCODE "0,320")))                      ("357,44"                              (* ; "N-dash")                                (\POSTSCRIPT.OUTCHARFN STREAM (CHARCODE "0,261")))                      ("357,60"                              (* ; "Dagger")                                (\POSTSCRIPT.OUTCHARFN STREAM (CHARCODE "0,262")))                      ("357,61"                              (* ; "Double dagger")                                (\POSTSCRIPT.OUTCHARFN STREAM (CHARCODE "0,263")))                      ("0,322"                               (* ; "R-circle is in Symbol")                               (\POSTSCRIPT.SYMBOLOUTCHAR STREAM (CHARCODE "0,342")))                      ("0,323"                               (* ; "C-circle is in Symbol")                               (\POSTSCRIPT.SYMBOLOUTCHAR STREAM (CHARCODE "0,343")))                      ("0,324"                               (* ; "TM is in Symbol")                               (\POSTSCRIPT.SYMBOLOUTCHAR STREAM (CHARCODE "0,344")))                      (PROGN (SETQ CHAR (\CHAR8CODE CHAR))                             [COND                                ((IGREATERP (SETQ NEWXPOS (IPLUS XPOS CHARWID))                                        (ffetch POSTSCRIPTRIGHTMARGIN of IMAGEDATA))                                 (\TERPRI.PSC STREAM)                                 (SETQ NEWXPOS (IPLUS (ffetch POSTSCRIPTX of IMAGEDATA)                                                      CHARWID]                             (COND                                ((NOT (ffetch POSTSCRIPTCHARSTOSHOW of IMAGEDATA))                                 (COND                                    ((ffetch POSTSCRIPTPENDINGXFORM of IMAGEDATA)                                     (\SETXFORM.PSC STREAM IMAGEDATA)))                                 (COND                                    ((ffetch POSTSCRIPTFONTCHANGEDFLG of IMAGEDATA)                                                             (* ;                                                   "If font was changed then switch before printing")                                     (\SWITCHFONTS.PSC STREAM IMAGEDATA)))                                 (COND                                    ((ffetch POSTSCRIPTMOVEFLG of IMAGEDATA)                                                             (* ; "likewise for position")                                     (\SETPOS.PSC STREAM IMAGEDATA)))                                 (BOUT STREAM (CHARCODE %())                                 (freplace POSTSCRIPTCHARSTOSHOW of IMAGEDATA with T)))                             (BOUT STREAM (CHARCODE \))                             [SELCHARQ CHAR                                  ((%( %) \)                                        (BOUT STREAM CHAR))                                  (PROGN [BOUT STREAM (IPLUS (CHARCODE 0)                                                             (LOGAND 3 (LRSH CHAR 6]                                         [BOUT STREAM (IPLUS (CHARCODE 0)                                                             (LOGAND 7 (LRSH CHAR 3]                                         (BOUT STREAM (IPLUS (CHARCODE 0)                                                             (LOGAND 7 CHAR]                             (freplace POSTSCRIPTX of IMAGEDATA with NEWXPOS]           (RETURN CHAR])(\POSTSCRIPT.SYMBOLOUTCHAR  [LAMBDA (STREAM CHARCODE)                              (* ; "Edited 12-Jul-90 12:20 by jds")    (* ;; "Print a character that's really in the Symbol font:  Change to Symbol, print the char, then change back.")    (LET* ((OLDFONT (DSPFONT NIL STREAM))           (SIZE (FETCH (FONTDESCRIPTOR FONTSIZE) OF OLDFONT)))          (DSPFONT (LIST 'SYMBOL SIZE)                 STREAM)          (\POSTSCRIPT.OUTCHARFN STREAM CHARCODE)          (DSPFONT OLDFONT STREAM]))(RPAQ \POSTSCRIPT.ORIENTATION.MENU      (create MENU ITEMS _ '(("Landscape" T "Print this file/document/image in Landscape Orientation"                                    )                             ("Portrait" 'NIL                                     "Print this file/document/image in Portrait Orientation"))             TITLE _ "Orientation" CENTERFLG _ T MENUOFFSET _             (create POSITION XCOORD _ -1 YCOORD _ 0)             CHANGEOFFSETFLG _ 'Y))(RPAQ \POSTSCRIPT.ORIENTATION.OPTIONS.MENU (create MENU ITEMS _ '(("Ask" 'ASK                                    "Always ask whether to print in Landscape or Portrait Orientation"                                                                             )                                                                      ("Landscape" T                                                           "Default printing to Landscape Orientation"                                                                             )                                                                      ("Portrait" 'NIL                                                            "Default printing to Portrait Orientation"                                                                             ))                                                      TITLE _ "Default Orientation" CENTERFLG _ T))(RPAQ PS.BITMAPARRAY (READARRAY-FROM-LIST 16 (QUOTE BYTE) 0 (QUOTE (48 49 50 51 52 53 54 55 56 57 65 66 67 68 69 70 NIL))))(RPAQQ \POSTSCRIPT.JOB.SETUP       ("/bdef {bind def} bind def" "/ldef {load def} bdef" "/S /show ldef" "/M /moveto ldef"               "/DR {transform round exch round exch itransform} bdef"               "/L {gsave newpath setlinewidth 0 setlinecap"               "  M lineto currentpoint stroke grestore M} bdef"               "/L1 {gsave newpath 0 setdash setgray setlinewidth 0 setlinecap"               "  M lineto currentpoint stroke grestore M} bdef"               "/F {findfont exch scalefont setfont} bdef"               "/CLP {newpath M dup 0 rlineto exch 0 exch rlineto"               "  neg 0 rlineto closepath clip newpath} bdef"               "/R {gsave setgray newpath M dup 0 rlineto exch 0 exch"               "  rlineto neg 0 rlineto closepath eofill grestore} bdef" "/ellipsedict 9 dict def"               "ellipsedict /mtrx matrix put" "/ellipse" " { ellipsedict begin" "  /endangle exch def"              "  /startangle exch def" "  /orientation exch def" "  /minorrad exch def"               "  /majorrad exch def" "  /y exch def" "  /x exch def"               "  /savematrix mtrx currentmatrix def" "  x y translate" "  orientation rotate"               "  majorrad minorrad scale" "  0 0 1 startangle endangle arc" "  savematrix setmatrix"              " end } bdef" "/concatprocs" " {/proc2 exch cvlit def" "  /proc1 exch cvlit def"               "  /newproc proc1 length proc2 length add array def" "  newproc 0 proc1 putinterval"               "  newproc proc1 length proc2 putinterval" "  newproc cvx" " } bdef"               "/resmatrix matrix def" "/findresolution" " {72 0 resmatrix defaultmatrix dtransform"               "  /yres exch def /xres exch def" "  xres dup mul yres dup mul add sqrt" " } bdef"               "/thebitimage" " {/maskp exch def" "  /bihgt exch def" "  /biwid exch def"               "  /byte 1 string def" "  /strbufl biwid 8 div ceiling cvi def"               "  /strbuf strbufl string def"               "  maskp not{{1 exch sub} currenttransfer concatprocs settransfer} if" "  biwid bihgt"              "  maskp { true } { 1 } ifelse" "  [biwid 0 0 bihgt 0 0]" "  {/col 0 def"               "   {currentfile byte readhexstring pop 0 get" "    dup 16#B2 eq {pop"               "    currentfile byte readhexstring pop 0 get 1 add"               "    currentfile byte readhexstring pop pop /nbyte byte 0 get def"               "    { strbuf col nbyte put /col col 1 add def} repeat}"               "   {dup 16#B3 eq {pop /col col" "    currentfile byte readhexstring pop"               "    0 get add 1 add def}" "    {16#B4 eq {currentfile byte readhexstring pop pop} if"              "     strbuf col byte 0 get put /col col 1 add def} ifelse" "   } ifelse"               "   col strbufl ge { exit } if } loop" "   strbuf }"               "  maskp { imagemask } { image } ifelse" " } bdef" "/setuserscreendict 22 dict def"               "setuserscreendict begin" " /tempctm matrix def" " /temprot matrix def"               " /tempscale matrix def" "end" "/setuserscreen" " {setuserscreendict begin"               "   /spotfunction exch def" "   /screenangle exch def" "   /cellsize exch def"               "   /m tempctm currentmatrix def" "   /rm screenangle temprot rotate def"               "   /sm cellsize dup tempscale scale def"               "   sm rm m m concatmatrix m concatmatrix pop"               "   1 0 m dtransform /y1 exch def /x1 exch def"               "   /veclength x1 dup mul y1 dup mul add sqrt def"               "   /frequency findresolution veclength div def" "   /newscreenangle y1 x1 atan def"               "   m 2 get m 1 get mul m 0 get m 3 get mul sub"               "   0 gt { { neg } /spotfunction load concatprocs"               "          /spotfunction exch def } if"               "   frequency newscreenangle /spotfunction load setscreen" "  end" " } bdef"               "/setpatterndict 18 dict def" "setpatterndict begin" " /bitison"               "  {/ybit exch def /xbit exch def"               "   /bytevalue bstring ybit bwidth mul xbit 8 idiv add get def"               "   /mask 1 7 xbit 8 mod sub bitshift def" "   bytevalue mask and 0 ne" "  } bdef"               "end" "/bitpatternspotfunction" " {setpatterndict begin" "   /y exch def /x exch def"               "   /xindex x 1 add 2 div bpside mul cvi def"               "   /yindex y 1 add 2 div bpside mul cvi def" "   xindex yindex bitison"               "    {/onbits onbits 1 add def 1}" "    {/offbits offbits 1 add def 0} ifelse" "  end"              " } bdef" "/setpattern" " {setpatterndict begin" "   /cellsz exch def"               "   /angle exch def" "   /bwidth exch def" "   /bpside exch def" "   /bstring exch def"              "   /onbits 0 def /offbits 0 def"               "   cellsz angle /bitpatternspotfunction load setuserscreen" "   {} settransfer"               "   offbits offbits onbits add div setgray" "  end" " } bdef" "%%%%EndProlog"               "%%%%BeginSetup"))(RPAQQ SlopeMenuItems ((Italic 'ITALIC "This is an Italic Slope font")                           (Regular 'REGULAR "This is a Regular Slope font")))(RPAQQ WeightMenuItems ((Bold 'BOLD "This is a Bold Weight font")                            (Medium 'MEDIUM "This is a Medium Weight font")                            (Light 'LIGHT "This is a Light Weight font")))(ADDTOVAR BackgroundMenuCommands          ("PS Orientation" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE (MENU                                                                  \POSTSCRIPT.ORIENTATION.OPTIONS.MENU                                                                     ))                 "Select the default Orientation for PostScript output"                 (SUBITEMS ("Ask" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE 'ASK)                                  "Always ask whether to print in Landscape or Portrait Orientation")                        ("Landscape" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE T)                               "Default printing to Landscape Orientation")                        ("Portrait" '(SETQ POSTSCRIPT.PREFER.LANDSCAPE NIL)                               "Default printing to Portrait Orientation"))))(RPAQQ BackgroundMenu NIL)(DECLARE%: EVAL@COMPILE (RPAQQ GOLDEN.RATIO 1.618034)(RPAQQ \PS.SCALE0 100)(RPAQQ \PS.TEMPARRAYLEN 20)(CONSTANTS (GOLDEN.RATIO 1.618034)       (\PS.SCALE0 100)       (\PS.TEMPARRAYLEN 20)))(RPAQ? POSTSCRIPT.BITMAP.SCALE 1)(RPAQ? POSTSCRIPT.EOL 'CR)(RPAQ? POSTSCRIPT.IMAGESIZEFACTOR 1)(RPAQ? POSTSCRIPT.PREFER.LANDSCAPE NIL)(RPAQ? POSTSCRIPT.TEXTFILE.LANDSCAPE NIL)(RPAQ? POSTSCRIPT.DEFAULT.PAGEREGION '(4800 4800 52800 70800))(RPAQ? POSTSCRIPT.TEXTURE.SCALE 4)(RPAQ? POSTSCRIPTFONTDIRECTORIES (LIST (IF (EQL (MACHINETYPE)                                                    'MAIKO)                                               then "{DSK}/usr/local/lde/fonts/postscript/" else                                                "{DSK}<LISPFILES>FONTS>PSC>")))(RPAQ? \POSTSCRIPT.MAX.WILD.FONTSIZE 72)(ADDTOVAR POSTSCRIPT.FONT.ALIST (HELVETICA . HELVETICA)                                    (HELVETICAD . HELVETICA)                                    (TIMESROMAN . TIMES)                                    (TIMESROMAND . TIMES)                                    (COURIER . COURIER)                                    (GACHA . COURIER)                                    (CLASSIC . TIMES)                                    (MODERN . HELVETICA)                                    (CREAM . HELVETICA)                                    (TERMINAL . COURIER)                                    (LOGO . HELVETICA)                                    (TITAN . COURIER))(ADDTOVAR PRINTERTYPES ((POSTSCRIPT)                            (CANPRINT (POSTSCRIPT))                            (STATUS TRUE)                            (PROPERTIES NILL)                            (SEND POSTSCRIPT.SEND)                            (BITMAPSCALE POSTSCRIPT.BITMAPSCALE)                            (BITMAPFILE (POSTSCRIPT.HARDCOPYW FILE BITMAP SCALEFACTOR REGION ROTATION                                               TITLE))))(ADDTOVAR PRINTFILETYPES (POSTSCRIPT (TEST POSTSCRIPTFILEP)                                    (EXTENSION (PS PSC))                                    (CONVERSION (TEXT POSTSCRIPT.TEXT TEDIT POSTSCRIPT.TEDIT))))(ADDTOVAR IMAGESTREAMTYPES (POSTSCRIPT (OPENSTREAM OPENPOSTSCRIPTSTREAM)                                      (FONTCREATE POSTSCRIPT.FONTCREATE)                                      (FONTSAVAILABLE POSTSCRIPT.FONTSAVAILABLE)                                      (CREATECHARSET NILL)))(RPAQ? POSTSCRIPT.PAGETYPE 'LETTER)(APPENDTOVAR POSTSCRIPT.PAGEREGIONS (LETTER (0 0 8.5 11)                                               (0.197 0.197 8.1 10.6))                                        (LEGAL (0 0 8.5 14)                                               (0.89 0.5 6.72 13.0))                                        (NOTE (0 0 8.5 11)                                              (0.405 0.42 7.69 10.16)))(DECLARE%: DOEVAL@COMPILE DONTCOPY(GLOBALVARS DEFAULTPRINTINGHOST POSTSCRIPT.BITMAP.SCALE POSTSCRIPT.EOL POSTSCRIPT.FONT.ALIST        POSTSCRIPT.PREFER.LANDSCAPE POSTSCRIPT.TEXTFILE.LANDSCAPE POSTSCRIPT.TEXTURE.SCALE        POSTSCRIPTFONTDIRECTORIES \POSTSCRIPT.JOB.SETUP \POSTSCRIPT.MAX.WILD.FONTSIZE        \POSTSCRIPT.ORIENTATION.MENU \POSTSCRIPTIMAGEOPS POSTSCRIPT.PAGETYPE POSTSCRIPT.PAGEREGIONS))(DECLARE%: DONTEVAL@LOAD DOCOPY (POSTSCRIPT.INIT))(PUTPROPS POSTSCRIPTSTREAM FILETYPE :TCOMPL)(PUTPROPS POSTSCRIPTSTREAM MAKEFILE-ENVIRONMENT (:PACKAGE "INTERLISP" :READTABLE "INTERLISP"))(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA POSTSCRIPT.PUTCOMMAND))(PUTPROPS POSTSCRIPTSTREAM COPYRIGHT ("Savoir and Beckman" 1989 1990 1991))(DECLARE%: DONTCOPY  (FILEMAP (NIL (14441 129927 (CLOSEPOSTSCRIPTSTREAM 14451 . 14713) (OPENPOSTSCRIPTSTREAM 14715 . 20560) (POSTSCRIPT.BITMAPSCALE 20562 . 22808) (POSTSCRIPT.CLOSESTRING 22810 . 23259) (POSTSCRIPT.ENDPAGE 23261 . 23823) (POSTSCRIPT.FONTCREATE 23825 . 33862) (POSTSCRIPT.FONTSAVAILABLE 33864 . 37630) (POSTSCRIPT.GETFONTID 37632 . 38912) (POSTSCRIPT.HARDCOPYW 38914 . 41832) (POSTSCRIPT.INIT 41834 . 47366) (POSTSCRIPT.OUTSTR 47368 . 48530) (POSTSCRIPT.PUTBITMAPBYTES 48532 . 56630) (POSTSCRIPT.PUTCOMMAND 56632 . 57666) (POSTSCRIPT.SHOWACCUM 57668 . 59202) (POSTSCRIPT.STARTPAGE 59204 . 61319) (POSTSCRIPT.TEDIT 61321 . 61642) (POSTSCRIPT.TEXT 61644 . 61935) (POSTSCRIPTFILEP 61937 . 62391) (PSCFONT.READFONT 62393 . 63951) (PSCFONT.SPELLFILE 63953 . 64281) (PSCFONT.WRITEFONT 64283 . 65115) (READ-AFM-FILE 65117 . 69013) (\BITBLT.PSC 69015 . 69568) (\BLTSHADE.PSC 69570 . 73845) (\CHARWIDTH.PSC 73847 . 74332) (\DRAWARC.PSC 74334 . 76962) (\DRAWCIRCLE.PSC 76964 . 79512) (\DRAWCURVE.PSC 79514 . 83477) (\DRAWELLIPSE.PSC 83479 . 86097) (\DRAWLINE.PSC 86099 . 88284) (\DRAWPOINT.PSC 88286 . 88874) (\DRAWPOLYGON.PSC 88876 . 92109) (\DSPBOTTOMMARGIN.PSC 92111 . 92504) (\DSPCLIPPINGREGION.PSC 92506 . 93715) (\DSPFONT.PSC 93717 . 95665) (\DSPLEFTMARGIN.PSC 95667 . 96105) (\DSPLINEFEED.PSC 96107 . 96498) (\DSPRESET.PSC 96500 . 97027) (\DSPRIGHTMARGIN.PSC 97029 . 97482) (\DSPROTATE.PSC 97484 . 102019) (\DSPSCALE.PSC 102021 . 102880) (\DSPSPACEFACTOR.PSC 102882 . 103766) (\DSPTOPMARGIN.PSC 103768 . 104152) (\DSPTRANSLATE.PSC 104154 . 105996) (\DSPXPOSITION.PSC 105998 . 106461) (\DSPYPOSITION.PSC 106463 . 106938) (\FILLCIRCLE.PSC 106940 . 109586) (\FILLPOLYGON.PSC 109588 . 113303) (\FIXLINELENGTH.PSC 113305 . 114512) (\MOVETO.PSC 114514 . 115132) (\NEWPAGE.PSC 115134 . 115329) (\POSTSCRIPTTAB 115331 . 116105) (\PS.BOUTFIXP 116107 . 117537) (\PS.SCALEHACK 117539 . 120034) (\PS.SCALEREGION 120036 . 120596) (\SCALEDBITBLT.PSC 120598 . 124712) (\SETPOS.PSC 124714 . 125066) (\SETXFORM.PSC 125068 . 126914) (\STRINGWIDTH.PSC 126916 . 127278) (\SWITCHFONTS.PSC 127280 . 129073) (\TERPRI.PSC 129075 . 129925)) (129928 137959 (\POSTSCRIPT.OUTCHARFN 129938 . 137430) (\POSTSCRIPT.SYMBOLOUTCHAR 137432 . 137957)))))STOP