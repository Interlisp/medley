(DEFINE-FILE-INFO READTABLE "INTERLISP" PACKAGE "INTERLISP")(FILECREATED " 3-Oct-91 20:16:54" |{PELE:MV:ENVOS}<LISPCORE>SOURCES>XMAS.;1| 160511       changes to%:  (RECORDS XSCREEN)                    (FNS CREATEXSCREEN)      previous date%: " 2-Oct-91 15:15:20" {DSK}<users>nilsson>xmas-split>XMAS.;3)(* ; "Copyright (c) 1991 by Venue.  All rights reserved.")(PRETTYCOMPRINT XMASCOMS)(RPAQQ XMASCOMS       [(RECORDS XSCREEN SCREENREGION)        (INITVARS XLIB::*DISPLAY* XLIB::*SCREEN* XLIB::*ROOT* XLIB::*BLACK* XLIB::*WHITE*                XLIB::*DEFAULTFONT* (XLIB::*DEFAULT-FONT-NAME* "FIXED")               XLIB::*GC* XLIB::*COLORMAP*)        (MACROS \XCURVESMOOTH)        (FNS XLIB::SETUP-CLX)        (FNS \XDISPLAYINIT CREATEXSCREEN BITSPERPIXEL BITMAPHEIGHT BITMAPWIDTH DSPDESTINATION              XDSPCREATE \DSPOPERATION.XDISPLAY \DSPRESET.XDISPLAY \BLTSHADE.XDISPLAY \BITBLT.XDISPLAY             \XBITBLTSUB \XBLTSHADE.PIXMAP \XBITBLT.PIXMAP \DRAWPOINT.XDISPLAY \DRAWLINE.XDISPLAY              \XLINEWITHBRUSH \DRAWCIRCLE.XDISPLAY \DRAWCURVE.XDISPLAY \XCURVE2 \XCURVE)        (FNS BITBLT)        (FNS XCREATEWFROMPIXMAP PIXMAPCREATE PIXMAPWIDTH PIXMAPHEIGHT)        (FNS XCREATEW ADVISEXWDS XOPENW \XOPENW1 XCLOSEW \XCLOSEW1 \XSFFixClippingRegion XSHOWWFRAME             XSHOWWTITLE \XCREATEBASEW \DSPCLIPPINGREGION.XDISPLAY)        (FNS \XDSPPRINTCHAR \XBLTCHAR \XDSPPRINTCR/LF)        (FNS OPENWINDOWS \INSURESCREEN DSPSOURCETYPE PUTWINDOWPROP RESHOWBORDER \XRESHOWBORDER1              \GETWINDOWHEIGHT)        (FNS XWHICHW)        (FNS TOTOPW)        (FNS XSHAPEW1 XMOVEW XMOVEW1 XMOVEORRESIZED.WINDOW XMOVED.WINDOW)        (INITVARS (\XSCREEN NIL))        [ADDVARS (\DISPLAYSTREAMTYPES XDISPLAY)               (IMAGESTREAMTYPES (XDISPLAY (OPENSTREAM NILL)                                        (FONTCREATE \CREATEXDISPLAYFONT)                                        (FONTSAVAILABLE NILL)                                        (CREATECHARSET NILL]        (FILES XLLKEY XLLBITMAP XLLCURSOR XLLMOUSE XLLFONT XSERVER XWATCHER)        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)                                                                             (NLAML)                                                                             (LAMA XLIB::SETUP-CLX])(DECLARE%: EVAL@COMPILE(DATATYPE XSCREEN (SCONOFF SCDESTINATION SCTOPW SCTOPWDS SCTITLEDS SCFDEV SCDS SCDATA                              (* ;; "Access fns and their caches.")                             \SCBITSPERPIXELCACHE            (* ; "The cache for pixeldepth.")                             \GETSCBITSPERPIXEL              (* ; "The access function for pixdepth. This function must return a number, larger than 0. This function is applied to the screen structure.")                             \SCWIDTHCACHE                   (* ; "The screenwidth cache. ")                             \GETSCWIDTH                     (* ; "The access function for screenwidth. This function must return a number, larger than 0. This function is applied to the screen structure.")                             \SCHEIGHTCACHE                  (* ; "The screenheigth cache. ")                             \GETSCHEIGHT                    (* ; "The access function for screenheigth. This function must return a number, larger than 0. This function is applied to the screen structure")                             CREATEWFN OPENWFN CLOSEWFN)                      SCONOFF _ 'OFF                       (* ;; "The function for getting the pixeldepth of the screen.")                      [ACCESSFNS ((SCBITSPERPIXEL (OR \SCBITSPERPIXELCACHE                                                      (replace (XSCREEN \SCBITSPERPIXELCACHE)                                                         of DATUM                                                         with (APPLY (fetch (XSCREEN                                                                                    \GETSCBITSPERPIXEL                                                                                           )                                                                            of DATUM)                                                                         (LIST DATUM)))                                                      (SHOULDNT "Pixel depth of screen is NIL"))                                         (replace (XSCREEN \SCBITSPERPIXELCACHE) of DATUM                                            with NEWVALUE))                                  (SCWIDTH (OR \SCWIDTHCACHE (replace (XSCREEN \SCWIDTHCACHE)                                                                of DATUM                                                                with (APPLY (fetch                                                                                 (XSCREEN \GETSCWIDTH                                                                                        )                                                                                   of DATUM)                                                                                (LIST DATUM)))                                               (SHOULDNT "Width of screen is NIL"))                                         (replace (XSCREEN \SCWIDTHCACHE) of DATUM                                            with NEWVALUE))                                  (SCHEIGHT (OR \SCHEIGHTCACHE (replace (XSCREEN \SCHEIGHTCACHE)                                                                  of DATUM                                                                  with (APPLY (fetch                                                                                   (XSCREEN                                                                                          \GETSCHEIGHT                                                                                          )                                                                                     of DATUM)                                                                                  (LIST DATUM)))                                                (SHOULDNT "Heigth of screen is NIL"))                                         (replace (XSCREEN \SCHEIGHTCACHE) of DATUM                                            with NEWVALUE))                                  (SCREGION (create REGION                                                   LEFT _ 0                                                   BOTTOM _ 0                                                              (* ; "Behold clever recursion.")                                                   WIDTH _ (fetch (XSCREEN SCWIDTH) of DATUM)                                                             (* ; "Dito.")                                                   HEIGHT _ (fetch (XSCREEN SCHEIGHT)                                                               of DATUM]                      (SYSTEM))(RECORD SCREENREGION (SCREEN . REGION)                         (SUBRECORD REGION)                         [TYPE? (AND (LISTP DATUM)                                         (type? SCREEN (CAR DATUM))                                         (type? REGION (CDR DATUM]                         (SYSTEM)))(/DECLAREDATATYPE 'XSCREEN       '(POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER POINTER                POINTER POINTER POINTER POINTER POINTER POINTER)       '((XSCREEN 0 POINTER)         (XSCREEN 2 POINTER)         (XSCREEN 4 POINTER)         (XSCREEN 6 POINTER)         (XSCREEN 8 POINTER)         (XSCREEN 10 POINTER)         (XSCREEN 12 POINTER)         (XSCREEN 14 POINTER)         (XSCREEN 16 POINTER)         (XSCREEN 18 POINTER)         (XSCREEN 20 POINTER)         (XSCREEN 22 POINTER)         (XSCREEN 24 POINTER)         (XSCREEN 26 POINTER)         (XSCREEN 28 POINTER)         (XSCREEN 30 POINTER)         (XSCREEN 32 POINTER))       '34)(RPAQ? XLIB::*DISPLAY* NIL)(RPAQ? XLIB::*SCREEN* NIL)(RPAQ? XLIB::*ROOT* NIL)(RPAQ? XLIB::*BLACK* NIL)(RPAQ? XLIB::*WHITE* NIL)(RPAQ? XLIB::*DEFAULTFONT* NIL)(RPAQ? XLIB::*DEFAULT-FONT-NAME* "FIXED")(RPAQ? XLIB::*GC* NIL)(RPAQ? XLIB::*COLORMAP* NIL)(DECLARE%: EVAL@COMPILE (PUTPROPS \XCURVESMOOTH MACRO (OPENLAMBDA                                       (NEWX NEWY USERFN DISPLAYSTREAM)                                       (PROG [(DX (IABS (IDIFFERENCE NEWX \OLDX)))                                              (DY (IABS (IDIFFERENCE NEWY \OLDY]                                             (COND                                                ((OR (IGREATERP DX 1)                                                     (IGREATERP DY 1))                                                 [COND                                                    ((NEQ [IPLUS (ADD1 (IDIFFERENCE \OLDX \OLDERX))                                                                 (ITIMES 3 (ADD1 (IDIFFERENCE \OLDY                                                                                         \OLDERY]                                                          4)                                                     [COND                                                        (DASHON (COND                                                                   (USERFN (APPLY* USERFN \OLDX \OLDY                                                                                  DISPLAYSTREAM))                                                                   (T (DRAWPOINT \OLDX \OLDY BRUSHBM                                                                             DISPLAYSTREAM]                                                     (COND                                                        (DASHTAIL (COND                                                                     ((EQ 0 (SETQ DASHCNT                                                                             (SUB1 DASHCNT)))                                                                      (SETQ DASHON (NOT DASHON))                                                                      (SETQ DASHTAIL                                                                       (OR (LISTP (CDR DASHTAIL))                                                                           DASHLST))                                                                      (SETQ DASHCNT (CAR DASHTAIL]                                                 (SETQ \OLDERX \OLDX)                                                 (SETQ \OLDERY \OLDY)                                                 (SETQ \OLDX \CURX)                                                 (SETQ \OLDY \CURY)))                                             (SETQ \CURX NEWX)                                             (SETQ \CURY NEWY)))))(DEFINEQ(XLIB::SETUP-CLX  [CL:LAMBDA (&OPTIONAL (XLIB:DISPLAY "unix:0.0"))       (* ; "Edited 11-Sep-91 19:29 by jn")         (CL:BLOCK XLIB::SETUP-CLX             (LET ((XLIB::HOST-PORT (XSERVERNAME XLIB:DISPLAY)))                  (CL:SETQ XLIB::*DISPLAY* (XLIB:OPEN-DISPLAY (CAR XLIB::HOST-PORT)                                                  :DISPLAY                                                  (CDR XLIB::HOST-PORT)))                  (CL:SETQ XLIB::*SCREEN* (XLIB:DISPLAY-DEFAULT-SCREEN XLIB::*DISPLAY*))                  (CL:SETQ XLIB::*BLACK* (XLIB:SCREEN-BLACK-PIXEL XLIB::*SCREEN*))                  (CL:SETQ XLIB::*WHITE* (XLIB:SCREEN-WHITE-PIXEL XLIB::*SCREEN*))                  (CL:SETQ XLIB::*COLORMAP* (XLIB:SCREEN-DEFAULT-COLORMAP XLIB::*SCREEN*))                  (CL:SETQ XLIB::*ROOT* (XLIB:SCREEN-ROOT XLIB::*SCREEN*))                  (CL:SETQ XLIB::*DEFAULTFONT* (XLIB:OPEN-FONT XLIB::*DISPLAY*                                                       XLIB::*DEFAULT-FONT-NAME*))                  (CL:SETQ XLIB::*GC* (XLIB:CREATE-GCONTEXT :DRAWABLE XLIB::*ROOT*))                  (CL:SETF (XLIB:DISPLAY-AFTER-FUNCTION XLIB::*DISPLAY*)                         #'XLIB:DISPLAY-FINISH-OUTPUT)))]))(DEFINEQ(\XDISPLAYINIT  [LAMBDA NIL    (DECLARE (GLOBALVARS XDisplayFDEV \XDISPLAYIMAGEOPS \XDisplayDeviceMethods                         \XDisplayDeviceData))          (* ; "Edited 16-Feb-91 15:03 by matsuda")    (SETQ \XDisplayDeviceMethods (create WSOPS))    (SETQ \XDisplayDeviceData     (create WSDATA            WSDESTINATION _ "Destination"            WSREGION _ (create REGION                              LEFT _ 0                              BOTTOM _ 0                              WIDTH _ 1024                              HEIGHT _ 808)))    (SETQ \XDISPLAYIMAGEOPS (create IMAGEOPS                                   IMAGETYPE _ 'XDISPLAY                                   IMFONT _ (FUNCTION \DSPFONT.XDISPLAY)                                   IMLEFTMARGIN _ (FUNCTION \DSPLEFTMARGIN.DISPLAY)                                   IMRIGHTMARGIN _ (FUNCTION \DSPRIGHTMARGIN.DISPLAY)                                   IMLINEFEED _ (FUNCTION \DSPLINEFEED.DISPLAY)                                   IMXPOSITION _ (FUNCTION \DSPXPOSITION.DISPLAY)                                   IMYPOSITION _ (FUNCTION \DSPYPOSITION.DISPLAY)                                   IMCLOSEFN _ (FUNCTION NILL)                                   IMDRAWCURVE _ (FUNCTION \DRAWCURVE.XDISPLAY)                                   IMFILLCIRCLE _ '\FILLCIRCLE.XDISPLAY                                   IMDRAWLINE _ (FUNCTION \DRAWLINE.XDISPLAY)                                   IMDRAWELLIPSE _ (FUNCTION \DRAWELLIPSE.XDISPLAY)                                   IMDRAWCIRCLE _ (FUNCTION \DRAWCIRCLE.XDISPLAY)                                   IMFILLPOLYGON _ (FUNCTION POLYSHADE.XDISPLAY)                                   IMBITBLT _ (FUNCTION \BITBLT.XDISPLAY)                                   IMSCALEDBITBLT _ (FUNCTION \SCALEDBITBLT.XDISPLAY)                                   IMBLTSHADE _ (FUNCTION \BLTSHADE.XDISPLAY)                                   IMNEWPAGE _ (FUNCTION \NEWPAGE.XDISPLAY)                                   IMSCALE _ [FUNCTION (LAMBDA NIL 1]                                   IMSPACEFACTOR _ (FUNCTION NILL)                                   IMFONTCREATE _ 'XDISPLAY                                   IMCOLOR _ (FUNCTION NILL)                                   IMBACKCOLOR _ (FUNCTION \BACKCOLOR.XDISPLAY)                                   IMOPERATION _ (FUNCTION \DSPOPERATION.XDISPLAY)                                   IMSTRINGWIDTH _ (FUNCTION \STRINGWIDTH.XDISPLAY)                                   IMCHARWIDTH _ (FUNCTION \CHARWIDTH.XDISPLAY)                                   IMCLIPPINGREGION _ (FUNCTION \DSPCLIPPINGREGION.XDISPLAY)                                   IMRESET _ (FUNCTION \DSPRESET.XDISPLAY)                                   IMDRAWARC _ (FUNCTION \DRAWARC.XDISPLAY)                                   IMDRAWPOLYGON _ (FUNCTION \DRAWPOLYGON.XDISPLAY)                                   IMDRAWPOINT _ (FUNCTION \DRAWPOINT.XDISPLAY)))    (SETQ XDisplayFDEV (create FDEV                              DEVICENAME _ 'XDISPLAY                              RESETABLE _ NIL                              RANDOMACCESSP _ NIL                              PAGEMAPPED _ NIL                              CLOSEFILE _ (FUNCTION NILL)                              DELETEFILE _ (FUNCTION NILL)                              GETFILEINFO _ (FUNCTION NILL)                              OPENFILE _ [FUNCTION (LAMBDA (NAME ACCESS RECOG OTHERINFO FDEV)                                                     NAME]                              READPAGES _ (FUNCTION \ILLEGAL.DEVICEOP)                              SETFILEINFO _ (FUNCTION NILL)                              GENERATEFILES _ (FUNCTION \GENERATENOFILES)                              TRUNCATEFILE _ (FUNCTION NILL)                              WRITEPAGES _ (FUNCTION \ILLEGAL.DEVICEOP)                              GETFILENAME _ [FUNCTION (LAMBDA (NAME RECOG FDEV)                                                        NAME]                              REOPENFILE _ [FUNCTION (LAMBDA (NAME)                                                       NAME]                              EVENTFN _ (FUNCTION \XDisplayEventFn)                              DIRECTORYNAMEP _ (FUNCTION NILL)                              HOSTNAMEP _ (FUNCTION NILL)                              BIN _ (FUNCTION \ILLEGAL.DEVICEOP)                              BOUT _ (FUNCTION \DSPPRINTCHAR)                              PEEKBIN _ (FUNCTION \ILLEGAL.DEVICEOP)                              BACKFILEPTR _ (FUNCTION \PAGEDBACKFILEPTR)                              BLOCKIN _ (FUNCTION \ILLEGAL.DEVICEOP)                              BLOCKOUT _ (FUNCTION \NONPAGEDBOUTS)                              WINDOWOPS _ \DisplayDeviceMethods                              WINDOWDATA _ \DisplayDeviceData                              DEVICEINFO _ (create DISPLAYSTATE)))    (\DEFINEDEVICE 'XDISPLAY XDisplayFDEV])(CREATEXSCREEN  [LAMBDA (DESTINATION)                                  (* ; "Edited  3-Oct-91 20:15 by jn")    (PROG (TITLEDS SCREEN)          (SETQ TITLEDS (XDSPCREATE DESTINATION))        (* ; "Create TITLEDS. ")          (DSPOPERATION 'INVERT TITLEDS)          (DSPFONT XWINDOWTITLEFONT TITLEDS)          (DSPRIGHTMARGIN MAX.SMALLP TITLEDS)                (* ;                                                        "Set right margin so title doesn't autoCR. ")     (* ;; "now create SCREEN. ")          [SETQ SCREEN (create XSCREEN                              SCONOFF _ 'OFF                              SCDESTINATION _ DESTINATION                              SCTOPW _ NIL                              SCTITLEDS _ TITLEDS                               (* ;; "Cached fns.")                              \GETSCWIDTH _ '[LAMBDA (DATUM)                                               (XLIB:DRAWABLE-WIDTH (fetch (XSCREEN SCDESTINATION                                                                                      ) of DATUM]                              \GETSCHEIGHT _ '[LAMBDA (DATUM)                                                (XLIB:DRAWABLE-HEIGHT (fetch (XSCREEN                                                                                         SCDESTINATION                                                                                        )                                                                         of DATUM]                              \GETSCBITSPERPIXEL _ '(LAMBDA (DATUM)                                                      (XLIB:DRAWABLE-DEPTH (fetch (XSCREEN                                                                                         SCDESTINATION                                                                                             )                                                                              of DATUM]          (RETURN SCREEN])(BITSPERPIXEL  [LAMBDA (BITMAP)                                     (* ; "Edited 31-Jan-91 14:24 by matsuda")    (* ;; "returns the height in pixels of a bitmap.")    (COND       ((type? BITMAP BITMAP)        (fetch (BITMAP BITMAPBITSPERPIXEL) of BITMAP))       ((XLIB:DRAWABLE-P BITMAP)        (XLIB:DRAWABLE-DEPTH BITMAP))       ((type? SCREEN BITMAP)        (BITSPERPIXEL (fetch (SCREEN SCDESTINATION) of BITMAP)))       ((type? XSCREEN BITMAP)        (BITSPERPIXEL (fetch (XSCREEN SCDESTINATION) of BITMAP)))       ((type? WINDOW BITMAP)        (BITSPERPIXEL (fetch (WINDOW SCREEN) of BITMAP)))       ((ARRAYP BITMAP)                                      (* ;                                                            "Consider array to be a colormap.")        (SELECTQ (ARRAYSIZE BITMAP)            (256 8)            (16 4)            (LISPERROR "ILLEGAL ARG" BITMAP)))       (T (LISPERROR "ILLEGAL ARG" BITMAP])(BITMAPHEIGHT  [LAMBDA (BITMAP)                                     (* ; "Edited 17-Jul-91 08:44 by matsuda")    (* ;; "returns the height in pixels of a bitmap.")    (COND       ((type? BITMAP BITMAP)        (fetch (BITMAP BITMAPHEIGHT) of BITMAP))       ((XLIB:DRAWABLE-P BITMAP)        (XLIB:DRAWABLE-HEIGHT BITMAP))       ((type? WINDOW BITMAP)        (WINDOWPROP BITMAP 'HEIGHT))       (T (\ILLEGAL.ARG BITMAP])(BITMAPWIDTH  [LAMBDA (BITMAP)                                     (* ; "Edited 17-Jul-91 08:42 by matsuda")    (* ;; "returns the width of a bitmap in pixels")    (COND       ((type? BITMAP BITMAP)        (ffetch (BITMAP BITMAPWIDTH) of BITMAP))       ((XLIB:DRAWABLE-P BITMAP)        (XLIB:DRAWABLE-WIDTH BITMAP))       ((type? WINDOW BITMAP)        (WINDOWPROP BITMAP 'WIDTH))       (T (\ILLEGAL.ARG BITMAP])(DSPDESTINATION  [LAMBDA (DESTINATION DISPLAYSTREAM)                  (* ; "Edited 31-Jan-91 14:46 by matsuda")    (DECLARE (GLOBALVARS \DISPLAYIMAGEOPS \4DISPLAYIMAGEOPS \8DISPLAYIMAGEOPS \24DISPLAYIMAGEOPS                        \XDISPLAYIMAGEOPS))    (PROG (DD)          (SETQ DD (\GETDISPLAYDATA DISPLAYSTREAM DISPLAYSTREAM))          (RETURN (PROG1 (ffetch (\DISPLAYDATA DDDestination) of DD)                      [COND                         (DESTINATION (COND                                         ((XLIB:DRAWABLE-P DESTINATION)                                                             (* ; "XDISPLAY case ")                                          (UNINTERRUPTABLY                                              (replace (STREAM DEVICE) of DISPLAYSTREAM                                                 with XDisplayFDEV)                                              (replace (STREAM IMAGEOPS) of DISPLAYSTREAM                                                 with \XDISPLAYIMAGEOPS)                                              (freplace (\DISPLAYDATA DDDestination) of                                                                                         DD                                                 with DESTINATION)))                                         (T                  (* ; "LFDISPLAY case")                                            (SETQ DESTINATION (\DTEST DESTINATION 'BITMAP))                                            (UNINTERRUPTABLY                                                (replace (STREAM DEVICE) of DISPLAYSTREAM                                                   with (SELECTQ (fetch (BITMAP                                                                                    BITMAPBITSPERPIXEL                                                                                       ) of                                                                                         DESTINATION)                                                                (1 DisplayFDEV)                                                                (4 \4DISPLAYFDEV)                                                                (8 \8DISPLAYFDEV)                                                                (24 \24DISPLAYFDEV)                                                                (SHOULDNT)))                                                (replace (STREAM IMAGEOPS) of DISPLAYSTREAM                                                   with (SELECTQ (fetch (BITMAP                                                                                    BITMAPBITSPERPIXEL                                                                                       ) of                                                                                         DESTINATION)                                                                (1 \DISPLAYIMAGEOPS)                                                                (4 \4DISPLAYIMAGEOPS)                                                                (8 \8DISPLAYIMAGEOPS)                                                                (24 \24DISPLAYIMAGEOPS)                                                                (SHOULDNT)))                                                (freplace (\DISPLAYDATA DDDestination)                                                   of DD with DESTINATION)                                                (\SFFixDestination DD DISPLAYSTREAM))])])(XDSPCREATE  [LAMBDA (DESTINATION)                                (* ; "Edited 15-Feb-91 18:29 by matsuda")    (LET (DSTRM GC)         (COND            ((XLIB:DRAWABLE-P DESTINATION)             (SETQ DSTRM (create STREAM                                USERCLOSEABLE _ NIL                                OUTCHARFN _ (FUNCTION \XDSPPRINTCHAR)                                IMAGEDATA _ (create \DISPLAYDATA)                                IMAGEOPS _ \XDISPLAYIMAGEOPS                                DEVICE _ XDisplayFDEV                                ACCESS _ 'OUTPUT))             (replace (\DISPLAYDATA DDPILOTBBT) of (fetch (STREAM IMAGEDATA) of                                                                                         DSTRM)                with (SETQ GC (XLIB:CREATE-GCONTEXT :DRAWABLE DESTINATION)))             (CL:SETF (XLIB:GCONTEXT-FOREGROUND GC)                    XLIB::*BLACK*)                           (* ; "temp foreground color ")             (CL:SETF (XLIB:GCONTEXT-BACKGROUND GC)                    XLIB::*WHITE*)                           (* ; "temp background color")             (DSPFONT XDEFAULTFONT DSTRM)             (DSPDESTINATION DESTINATION DSTRM)             (DSPRIGHTMARGIN (MAX SCREENWIDTH (XLIB:DRAWABLE-WIDTH DESTINATION))                    DSTRM)             (DSPSOURCETYPE 'INPUT DSTRM)             (DSPOPERATION 'REPLACE DSTRM)             DSTRM)            (T NIL])(\DSPOPERATION.XDISPLAY  [LAMBDA (DISPLAYSTREAM OPERATION)                    (* ; "Edited 15-Feb-91 12:32 by matsuda")    (* ;; "sets the operation field of a display stream")    (PROG ((DD (\GETDISPLAYDATA DISPLAYSTREAM)))          (RETURN (PROG1 (fetch DDOPERATION of DD)                      [COND                         (OPERATION (OR (FMEMB OPERATION '(PAINT REPLACE INVERT ERASE))                                        (LISPERROR "ILLEGAL ARG" OPERATION))                                (UNINTERRUPTABLY                                    (freplace DDOPERATION of DD with OPERATION)                                    (\SETGCFUNCTION (fetch DDPILOTBBT of DD)                                           (fetch DDSOURCETYPE of DD)                                           OPERATION))])])(\DSPRESET.XDISPLAY  [LAMBDA (DISPLAYSTREAM)    (DECLARE (GLOBALVARS \CURRENTDISPLAYLINE))     (* ; "Edited 22-Feb-91 17:41 by matsuda")    (LET [CREG FONT FONTASCENT (DD (\DTEST (fetch (STREAM IMAGEDATA) of (SETQ DISPLAYSTREAM                                                                                 (\OUTSTREAMARG                                                                                  DISPLAYSTREAM)))                                          '\DISPLAYDATA]         (SETQ CREG (ffetch (\DISPLAYDATA DDClippingRegion) of DD))         (SETQ FONT (fetch (\DISPLAYDATA DDFONT) of DD))         (SETQ FONTASCENT (FONTASCENT FONT))         (SELECTQ (fetch (FONTDESCRIPTOR ROTATION) of FONT)             (0 (\DSPXPOSITION.DISPLAY DISPLAYSTREAM (ffetch (\DISPLAYDATA DDLeftMargin)                                                        of DD))                (\DSPYPOSITION.DISPLAY DISPLAYSTREAM (ADD1 (IDIFFERENCE (fetch (REGION TOP)                                                                           of CREG)                                                                  FONTASCENT))))             (ERROR "only supported rotations are 0"))         (CL:SETF (XLIB:GCONTEXT-FOREGROUND XLIB::*GC*)                XLIB::*WHITE*)         (XLIB:DRAW-RECTANGLE (fetch (\DISPLAYDATA DDDestination) of DD)                XLIB::*GC*                (\DSPTRANSFORMX (fetch (REGION LEFT) of CREG)                       DD)                (\DSPTRANSFORMY (fetch (REGION BOTTOM) of CREG)                       DD)                (fetch (REGION WIDTH) of CREG)                (fetch (REGION HEIGHT) of CREG)                T)                                           (* ; "(BITBLT NIL NIL NIL DISPLAYSTREAM (fetch (REGION LEFT) of CREG) (fetch (REGION BOTTOM) of CREG) (fetch (REGION WIDTH) of CREG) (fetch (REGION HEIGHT) of CREG) 'TEXTURE 'REPLACE (ffetch (\DISPLAYDATA DDTexture) of DD))")         (* ;; "if this display stream is the tty display stream of a process, reset the # of lines in that process.")         (PROG ((X (WFROMDS DISPLAYSTREAM T)))               (COND                  ((AND X (SETQ X (WINDOWPROP X 'PROCESS))                        (EQ (PROCESS.TTY X)                            DISPLAYSTREAM))                   (PROCESS.EVAL X '(SETQ \CURRENTDISPLAYLINE 0])(\BLTSHADE.XDISPLAY  [LAMBDA (TEXTURE STREAM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION)                                                           (* ; "Edited 28-Feb-91 13:08 by matsuda")                                                             (* ; "BLTSHADE to a display stream")    (DECLARE (LOCALVARS . T))    (PROG (left top bottom right DESTINATIONBITMAP DESTDD DESTINATIONNBITS GC PIXMAP ORGFUNCTION)          (SETQ DESTDD (fetch (STREAM IMAGEDATA) of STREAM))          (SETQ GC (fetch (\DISPLAYDATA DDPILOTBBT) of DESTDD))          (SETQ DESTINATIONLEFT (\DSPTRANSFORMX DESTINATIONLEFT DESTDD))          (SETQ DESTINATIONBOTTOM (\DSPTRANSFORMY DESTINATIONBOTTOM DESTDD))          [PROGN                                             (* ;                                                         "compute limits based on clipping regions.")                 (SETQ left (fetch (\DISPLAYDATA DDClippingLeft) of DESTDD))                 (SETQ bottom (fetch (\DISPLAYDATA DDClippingBottom) of DESTDD))                 (SETQ right (fetch (\DISPLAYDATA DDClippingRight) of DESTDD))                 (SETQ top (fetch (\DISPLAYDATA DDClippingTop) of DESTDD))                 (COND                    (CLIPPINGREGION                          (* ;                       "hard case, two destination clipping regions: do calculations to merge them.")                           (PROG (CRLEFT CRBOTTOM)                                 [SETQ left (IMAX left (SETQ CRLEFT (\DSPTRANSFORMX                                                                     (fetch (REGION LEFT)                                                                        of CLIPPINGREGION)                                                                     DESTDD]                                 [SETQ bottom (IMAX bottom (SETQ CRBOTTOM (\DSPTRANSFORMY                                                                           (fetch (REGION BOTTOM)                                                                              of CLIPPINGREGION)                                                                           DESTDD]                                 [SETQ right (IMIN right (IPLUS CRLEFT (fetch (REGION WIDTH)                                                                          of CLIPPINGREGION]                                 (SETQ top (IMIN top (IPLUS CRBOTTOM (fetch (REGION HEIGHT)                                                                        of CLIPPINGREGION]          (SETQ DESTINATIONBITMAP (fetch (\DISPLAYDATA DDDestination) of DESTDD))          (SETQ DESTINATIONNBITS (BITSPERPIXEL DESTINATIONBITMAP))     (* ;; "left, right top and bottom are the limits in destination taking into account Clipping Regions.  Clip to region in the arguments of this call.")          [PROGN (SETQ left (IMAX DESTINATIONLEFT left))                 (SETQ bottom (IMAX DESTINATIONBOTTOM bottom))                 [COND                    (WIDTH                                   (* ; "WIDTH is optional")                           (SETQ right (IMIN (IPLUS DESTINATIONLEFT WIDTH)                                             right]                 (COND                    (HEIGHT                                  (* ; "HEIGHT is optional")                           (SETQ top (IMIN (IPLUS DESTINATIONBOTTOM HEIGHT)                                           top]          (COND             ((OR (ILEQ right left)                  (ILEQ top bottom))                         (* ; "there is nothing to move.")              (RETURN)))          (SETQ TEXTURE (SELECTQ (TYPENAME TEXTURE)                            (LITATOM (COND                                        ((NULL TEXTURE)      (* ;                                                 "NIL case.  default texture to background texture.")                                         (ffetch (\DISPLAYDATA DDTexture) of DESTDD))                                        (T (\ILLEGAL.ARG TEXTURE))))                            ((SMALLP FIXP)                                  (LOGAND TEXTURE 65535))                            (BITMAP TEXTURE)                            (\ILLEGAL.ARG TEXTURE)))          (SETQ PIXMAP (PIXMAPFROMTEXTURE TEXTURE))          (SETQ ORGFUNCTION (XLIB:GCONTEXT-FUNCTION GC))          (CL:SETF (XLIB:GCONTEXT-FUNCTION GC)                 (SELECTQ (OR OPERATION (ffetch (\DISPLAYDATA DDOPERATION) of DESTDD))                     (REPLACE CL:BOOLE-1)                     (PAINT CL:BOOLE-IOR)                     (INVERT CL:BOOLE-XOR)                     (ERASE CL:BOOLE-ANDC1)                     CL:BOOLE-1))          (CL:SETF (XLIB:GCONTEXT-TILE GC)                 PIXMAP)          (CL:SETF (XLIB:GCONTEXT-FILL-STYLE GC)                 :TILED)          (PROG (Y WIDTH HEIGHT)                (SETQ HEIGHT (IDIFFERENCE top bottom))                (SETQ WIDTH (IDIFFERENCE right left))                (SETQ Y (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DESTINATIONBITMAP)                               top))                (XLIB:DRAW-RECTANGLE DESTINATIONBITMAP GC left Y WIDTH HEIGHT :FILL-P T))          (CL:SETF (XLIB:GCONTEXT-FUNCTION GC)                 ORGFUNCTION)          (RETURN T])(\BITBLT.XDISPLAY  [LAMBDA (SOURCEBITMAP SOURCELEFT SOURCEBOTTOM DESTSTRM DESTINATIONLEFT DESTINATIONBOTTOM WIDTH                  HEIGHT SOURCETYPE OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT                  CLIPPEDSOURCEBOTTOM)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 17-Jul-91 10:37 by matsuda")    (PROG (stodx stody left top bottom right DESTDD DESTBITMAP DESTINATIONNBITS SOURCENBITS MAXSHADE)          (SETQ DESTDD (fetch (STREAM IMAGEDATA) of DESTSTRM))          (SETQ DESTBITMAP (fetch (\DISPLAYDATA DDDestination) of DESTDD))          (SETQ DESTINATIONLEFT (\DSPTRANSFORMX DESTINATIONLEFT DESTDD))          (SETQ DESTINATIONBOTTOM (\DSPTRANSFORMY DESTINATIONBOTTOM DESTDD))          [PROGN                                             (* ;                                                         "compute limits based on clipping regions.")                 (SETQ left (fetch (\DISPLAYDATA DDClippingLeft) of DESTDD))                 (SETQ bottom (fetch (\DISPLAYDATA DDClippingBottom) of DESTDD))                 (SETQ right (fetch (\DISPLAYDATA DDClippingRight) of DESTDD))                 (SETQ top (fetch (\DISPLAYDATA DDClippingTop) of DESTDD))                 (COND                    (CLIPPINGREGION                          (* ;                       "hard case, two destination clipping regions: do calculations to merge them.")                           (PROG (CRLEFT CRBOTTOM)                                 [SETQ left (IMAX left (SETQ CRLEFT (\DSPTRANSFORMX                                                                     (fetch (REGION LEFT)                                                                        of CLIPPINGREGION)                                                                     DESTDD]                                 [SETQ bottom (IMAX bottom (SETQ CRBOTTOM (\DSPTRANSFORMY                                                                           (fetch (REGION BOTTOM)                                                                              of CLIPPINGREGION)                                                                           DESTDD]                                 [SETQ right (IMIN right (IPLUS CRLEFT (fetch (REGION WIDTH)                                                                          of CLIPPINGREGION]                                 (SETQ top (IMIN top (IPLUS CRBOTTOM (fetch (REGION HEIGHT)                                                                        of CLIPPINGREGION]          [PROGN (SETQ left (IMAX DESTINATIONLEFT left))                 (SETQ bottom (IMAX DESTINATIONBOTTOM bottom))                 [COND                    (WIDTH                                   (* ; "WIDTH is optional")                           (SETQ right (IMIN (IPLUS DESTINATIONLEFT WIDTH)                                             right]                 (COND                    (HEIGHT                                  (* ; "HEIGHT is optional")                           (SETQ top (IMIN (IPLUS DESTINATIONBOTTOM HEIGHT)                                           top]              (* ; "Clip and translate coordinates.")          (SETQ stodx (IDIFFERENCE DESTINATIONLEFT SOURCELEFT))          (SETQ stody (IDIFFERENCE DESTINATIONBOTTOM SOURCEBOTTOM))          [PROGN                                             (* ; "compute left margin")                 (SETQ left (IMAX CLIPPEDSOURCELEFT (IDIFFERENCE left stodx)                                  0))                        (* ; "compute bottom margin")                 (SETQ bottom (IMAX CLIPPEDSOURCEBOTTOM (IDIFFERENCE bottom stody)                                    0))                      (* ; "compute right margin")                 (SETQ right (IMIN (BITMAPWIDTH SOURCEBITMAP)                                   (IDIFFERENCE right stodx)                                   (IPLUS CLIPPEDSOURCELEFT WIDTH)))                                                             (* ; "compute top margin")                 (SETQ top (IMIN (BITMAPHEIGHT SOURCEBITMAP)                                 (IDIFFERENCE top stody)                                 (IPLUS CLIPPEDSOURCEBOTTOM HEIGHT]          (COND             ((OR (ILEQ right left)                  (ILEQ top bottom))                         (* ; "there is nothing to move.")              (RETURN)))          (OR OPERATION (SETQ OPERATION (ffetch (\DISPLAYDATA DDOPERATION) of DESTDD)))          (PROG (GC HEIGHT WIDTH DTY DLX STY SLX)                (SETQ GC (fetch (\DISPLAYDATA DDPILOTBBT) of DESTDD))                (SETQ HEIGHT (IDIFFERENCE top bottom))                (SETQ WIDTH (IDIFFERENCE right left))                (SETQ DTY (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DESTBITMAP)                                 (IPLUS top stody)))                (SETQ DLX (IPLUS left stodx))                (SETQ STY (IDIFFERENCE (BITMAPWIDTH SOURCEBITMAP)                                 top))                (SETQ SLX left)                (\XBITBLTSUB GC SOURCEBITMAP SLX STY DESTBITMAP DLX DTY WIDTH HEIGHT SOURCETYPE                        OPERATION TEXTURE))          (RETURN T])(\XBITBLTSUB  [LAMBDA (GC SourceBitMap SLX STY DestinationDrawable DLX DTY WIDTH HEIGHT SourceType Operation               Texture WindowXOffset WindowYOffset)     (* ; "Edited 17-Jul-91 08:31 by matsuda")    (CL:SETF (XLIB:GCONTEXT-FUNCTION GC)           (SELECTQ SourceType               (INVERT (SELECTQ SourceType                           (PAINT CL:BOOLE-ORC1)                           (INVERT CL:BOOLE-EQV)                           (ERASE CL:BOOLE-AND)                           CL:BOOLE-C1))               (SELECTQ Operation                   (PAINT CL:BOOLE-IOR)                   (INVERT CL:BOOLE-XOR)                   (ERASE CL:BOOLE-ANDC1)                   CL:BOOLE-1)))    (SELECTQ (TYPENAME SourceBitMap)        (BITMAP [PROG (XIMAGE)                      (SETQ XIMAGE (XIMAGEFROMBITMAP SourceBitMap))                      (COND                         ((EQ (BITSPERPIXEL SourceBitMap)                              1)                          (XLIB:PUT-IMAGE DestinationDrawable GC XIMAGE :SRC-X SLX :SRC-Y STY :X DLX                                 :Y DTY :HEIGHT HEIGHT :WIDTH WIDTH :BITMAP-P T))                         (T (XLIB:PUT-IMAGE DestinationDrawable GC XIMAGE :SRC-X SLX :SRC-Y STY :X                                    DLX :Y DTY :HEIGHT HEIGHT :WIDTH WIDTH])        ((XLIB:WINDOW XLIB:PIXMAP)              (XLIB:COPY-AREA SourceBitMap GC SLX STY WIDTH HEIGHT DestinationDrawable DLX DTY))        NIL])(\XBLTSHADE.PIXMAP  [LAMBDA (TEXTURE DESTINATIONBITMAP DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT OPERATION                  CLIPPINGREGION)    (DECLARE (LOCALVARS . T))                      (* ; "Edited  6-Mar-91 17:09 by matsuda")    (PROG (left bottom top right PIXMAP)          (SETQ left 0)          (SETQ bottom 0)          (SETQ top (PIXMAPHEIGHT DESTINATIONBITMAP))          (SETQ right (PIXMAPWIDTH DESTINATIONBITMAP))          [COND             (CLIPPINGREGION                                 (* ; "adjust limits")                    (SETQ left (IMAX left (fetch (REGION LEFT) of CLIPPINGREGION)))                    (SETQ bottom (IMAX bottom (fetch (REGION BOTTOM) of CLIPPINGREGION)))                    [SETQ right (IMIN right (IPLUS (fetch (REGION WIDTH) of CLIPPINGREGION)                                                   (fetch (REGION LEFT) of CLIPPINGREGION]                    (SETQ top (IMIN top (IPLUS (fetch (REGION BOTTOM) of CLIPPINGREGION)                                               (fetch (REGION HEIGHT) of CLIPPINGREGION]          (OR DESTINATIONLEFT (SETQ DESTINATIONLEFT 0))          (OR DESTINATIONBOTTOM (SETQ DESTINATIONBOTTOM 0))          [PROGN (SETQ left (IMAX DESTINATIONLEFT left))                 (SETQ bottom (IMAX DESTINATIONBOTTOM bottom))                 [COND                    (WIDTH                                   (* ; "WIDTH is optional")                           (SETQ right (IMIN (IPLUS DESTINATIONLEFT WIDTH)                                             right]                 (COND                    (HEIGHT                                  (* ; "HEIGHT is optional")                           (SETQ top (IMIN (IPLUS DESTINATIONBOTTOM HEIGHT)                                           top]          (COND             ((OR (ILEQ right left)                  (ILEQ top bottom))                         (* ; "there is nothing to move.")              (RETURN)))          (SETQ TEXTURE (SELECTQ (TYPENAME TEXTURE)                            (LITATOM                         (* ; "includes NIL case")                                     (COND                                        ((NULL TEXTURE)                                         WHITESHADE)                                        (T (\ILLEGAL.ARG TEXTURE))))                            ((SMALLP FIXP)                                  (LOGAND TEXTURE BLACKSHADE))                            (BITMAP TEXTURE)                            (\ILLEGAL.ARG TEXTURE)))          (SETQ PIXMAP (PIXMAPFROMTEXTURE TEXTURE))          (CL:SETF (XLIB:GCONTEXT-FUNCTION XLIB::*GC*)                 (SELECTQ OPERATION                     (REPLACE CL:BOOLE-1)                     (PAINT CL:BOOLE-IOR)                     (INVERT CL:BOOLE-XOR)                     (ERASE CL:BOOLE-ANDC1)                     CL:BOOLE-1))          (CL:SETF (XLIB:GCONTEXT-TILE XLIB::*GC*)                 PIXMAP)          (CL:SETF (XLIB:GCONTEXT-FILL-STYLE XLIB::*GC*)                 :TILED)          (PROG (Y WIDTH HEIGHT)                (SETQ HEIGHT (IDIFFERENCE top bottom))                (SETQ WIDTH (IDIFFERENCE right left))                (SETQ Y (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DESTINATIONBITMAP)                               top))                (XLIB:DRAW-RECTANGLE DESTINATIONBITMAP XLIB::*GC* left Y WIDTH HEIGHT :FILL-P T))          (RETURN T])(\XBITBLT.PIXMAP  [LAMBDA (SOURCEBITMAP SOURCELEFT SOURCEBOTTOM DESTBITMAP DESTINATIONLEFT DESTINATIONBOTTOM WIDTH                  HEIGHT SOURCETYPE OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT                  CLIPPEDSOURCEBOTTOM)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 17-Jul-91 08:46 by matsuda")    (PROG (stodx stody right top DESTINATIONNBITS left bottom SOURCENBITS)          (SETQ top (PIXMAPHEIGHT DESTBITMAP))          (SETQ left 0)          (SETQ bottom 0)          (SETQ SOURCENBITS (BITSPERPIXEL SOURCEBITMAP))          (SETQ right (PIXMAPWIDTH DESTBITMAP))          [COND             (CLIPPINGREGION                                 (* ; "adjust limits")                    (SETQ left (IMAX left (fetch (REGION LEFT) of CLIPPINGREGION)))                    (SETQ bottom (IMAX bottom (fetch (REGION BOTTOM) of CLIPPINGREGION)))                    [SETQ right (IMIN right (IPLUS (fetch (REGION WIDTH) of CLIPPINGREGION)                                                   (fetch (REGION LEFT) of CLIPPINGREGION]                    (SETQ top (IMIN top (IPLUS (fetch (REGION BOTTOM) of CLIPPINGREGION)                                               (fetch (REGION HEIGHT) of CLIPPINGREGION]          [PROGN (SETQ left (IMAX DESTINATIONLEFT left))                 (SETQ bottom (IMAX DESTINATIONBOTTOM bottom))                 [COND                    (WIDTH                                   (* ; "WIDTH is optional")                           (SETQ right (IMIN (IPLUS DESTINATIONLEFT WIDTH)                                             right]                 (COND                    (HEIGHT                                  (* ; "HEIGHT is optional")                           (SETQ top (IMIN (IPLUS DESTINATIONBOTTOM HEIGHT)                                           top]              (* ; "Clip and translate coordinates.")          (SETQ stodx (IDIFFERENCE DESTINATIONLEFT SOURCELEFT))          (SETQ stody (IDIFFERENCE DESTINATIONBOTTOM SOURCEBOTTOM))          [PROGN                                             (* ; "compute left margin")                 (SETQ left (IMAX CLIPPEDSOURCELEFT 0 (IDIFFERENCE left stodx)))                                                             (* ; "compute bottom margin")                 (SETQ bottom (IMAX CLIPPEDSOURCEBOTTOM 0 (IDIFFERENCE bottom stody)))                                                             (* ; "compute right margin")                 (SETQ right (IMIN (BITMAPWIDTH SOURCEBITMAP)                                   (IDIFFERENCE right stodx)                                   (IPLUS CLIPPEDSOURCELEFT WIDTH)))                                                             (* ; "compute top margin")                 (SETQ top (IMIN (BITMAPHEIGHT SOURCEBITMAP)                                 (IDIFFERENCE top stody)                                 (IPLUS CLIPPEDSOURCEBOTTOM HEIGHT]          (COND             ((OR (ILEQ right left)                  (ILEQ top bottom))                         (* ; "there is nothing to move.")              (RETURN)))          (SELECTQ SOURCETYPE              (MERGE (\ILLEGAL.ARG TEXTURE))              NIL)          (COND             ((OR (XLIB:DRAWABLE-P SOURCEBITMAP)                  (EQ SOURCENBITS 1))              (PROG (HEIGHT WIDTH DTY DLX STY SLX)                    (SETQ HEIGHT (IDIFFERENCE top bottom))                    (SETQ WIDTH (IDIFFERENCE right left))                    (SETQ DTY (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DESTBITMAP)                                     (IPLUS top stody)))                    (SETQ DLX (IPLUS left stodx))                    (SETQ STY (\SFInvert SOURCEBITMAP top))                    (SETQ SLX left)                    (\XBITBLTSUB XLIB::*GC* SOURCEBITMAP SLX STY DESTBITMAP DLX DTY WIDTH HEIGHT                           SOURCETYPE OPERATION TEXTURE)))             (T (ERROR "Source bitmap should not color bitmaps." SOURCEBITMAP)))          (RETURN T])(\DRAWPOINT.XDISPLAY  [LAMBDA (DISPLAYSTREAM X Y BRUSH OPERATION)          (* ; "Edited 17-Jul-91 10:43 by matsuda")    (PROG ((BRUSHBM (XPIXMAPFROMBRUSH BRUSH)))          (RETURN (BITBLT BRUSHBM 0 0 DISPLAYSTREAM [IDIFFERENCE X (HALF (SUB1 (BITMAPWIDTH                                                                                    BRUSHBM]                         [IDIFFERENCE Y (HALF (SUB1 (BITMAPHEIGHT BRUSHBM]                         NIL NIL NIL (SELECTQ (OR OPERATION (DSPOPERATION NIL DISPLAYSTREAM))                                         (REPLACE 'PAINT)                                         OPERATION])(\DRAWLINE.XDISPLAY  [LAMBDA (DISPLAYSTREAM X1 Y1 X2 Y2 WIDTH OPERATION COLOR DASHING)                                                           (* ; "Edited 16-Jul-91 13:20 by matsuda")    [COND       [(OR DASHING (BRUSHP WIDTH))        (LET ((BRUSH (INSURE.BRUSH WIDTH)))             (if COLOR                 then (replace (BRUSH BRUSHCOLOR) of BRUSH with COLOR))             (\XLINEWITHBRUSH X1 Y1 X2 Y2 BRUSH (\GOOD.DASHLST DASHING BRUSH)                    DISPLAYSTREAM                    (SELECTQ OPERATION                        (NIL (ffetch DDOPERATION of (fetch IMAGEDATA of DISPLAYSTREAM                                                                   )))                        ((REPLACE PAINT INVERT ERASE)                              OPERATION)                        (\ILLEGAL.ARG OPERATION]       (T (PROG ((DD (fetch IMAGEDATA of DISPLAYSTREAM))                 X Y DRAWABLE GC)                (SETQ DRAWABLE (fetch (\DISPLAYDATA DDDestination) of DD))                (SETQ GC (fetch (\DISPLAYDATA DDPILOTBBT) of DD))                (SETQ X1 (\DSPTRANSFORMX (OR (FIXP X1)                                             (FIXR X1))                                DD))                (SETQ Y1 (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DRAWABLE)                                (\DSPTRANSFORMY (OR (FIXP Y1)                                                    (FIXR Y1))                                       DD)))                (SETQ X (\DSPTRANSFORMX (OR (FIXP X2)                                            (FIXR X2))                               DD))                (SETQ Y (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT DRAWABLE)                               (\DSPTRANSFORMY (OR (FIXP Y2)                                                   (FIXR Y2))                                      DD)))                (SETQ OPERATION (SELECTQ OPERATION                                    (NIL (ffetch DDOPERATION of DD))                                    ((REPLACE PAINT INVERT ERASE)                                          OPERATION)                                    (\ILLEGAL.ARG OPERATION)))                (CL:SETF (XLIB:GCONTEXT-FUNCTION GC)                       (SELECTQ OPERATION                           (REPLACE CL:BOOLE-1)                           (PAINT CL:BOOLE-IOR)                           (INVERT CL:BOOLE-XOR)                           (ERASE CL:BOOLE-ANDC1)                           CL:BOOLE-1))                [CL:SETF (XLIB:GCONTEXT-LINE-WIDTH GC)                       (COND                          ((NULL WIDTH)                           1)                          ((OR (FIXP WIDTH)                               (FIXR WIDTH]                (CL:SETF (XLIB:GCONTEXT-JOIN-STYLE GC)                       :ROUND)                (CL:SETF (XLIB:GCONTEXT-CAP-STYLE GC)                       :ROUND)                (XLIB:DRAW-LINE DRAWABLE GC X1 Y1 X Y]    (MOVETO X2 Y2 DISPLAYSTREAM])(\XLINEWITHBRUSH  [LAMBDA (X1 Y1 X2 Y2 BRUSH DASHLST DISPLAYSTREAM OPERATION)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 16-Jul-91 13:38 by matsuda")    (PROG (DestinationBitMap LEFT RIGHTPLUS1 TOP BOTTOM BRUSHWIDTH BRUSHHEIGHT LEFTMINUSBRUSH                  BOTTOMMINUSBRUSH TOPMINUSBRUSH BRUSHBM DESTINATIONBASE BRUSHBASE RASTERWIDTH                  BRUSHRASTERWIDTH NBITSRIGHTPLUS1 HEIGHTMINUS1 COLOR COLORBRUSHBASE NBITS                  HALFBRUSHWIDTH HALFBRUSHHEIGHT DX DY YINC CDL (DASHON T)                 (DASHTAIL DASHLST)                 (DASHCNT (CAR DASHLST))                 (DISPLAYDATA (fetch IMAGEDATA of DISPLAYSTREAM))                 (USERFN (AND (LITATOM BRUSH)                              BRUSH))                 (DISPLAYDATA (fetch IMAGEDATA of DISPLAYSTREAM)))                                                             (* ;                                                            "arrange things so that dx is positive.")          (COND             ((IGREATERP X1 X2)                              (* ; "switch points")              (swap X1 X2)              (swap Y1 Y2)))          (SETQ DX (ADD1 (IDIFFERENCE X2 X1)))          [SETQ DY (ADD1 (COND                            ((IGREATERP Y2 Y1)                             (SETQ YINC 1)                             (IDIFFERENCE Y2 Y1))                            (T (SETQ YINC -1)                               (IDIFFERENCE Y1 Y2]          [SETQ CDL (HALF (COND                             ((IGREATERP DX DY)              (* ;                                              "set up the bucket so that the ends will be the same.")                              (IREMAINDER DX DY))                             (T (IREMAINDER DY DX]          [COND             [USERFN                                         (* ;            "if user function is being called, don't bother bringing window to top uninterruptably.")                    (COND                       ((IGEQ DX DY)                         (* ; "X is the fastest mover.")                        (until (IGREATERP X1 X2)                           do                            (* ; "main loop")                                 (COND                                    (DASHON (APPLY* USERFN X1 Y1 DISPLAYSTREAM)))                                 [COND                                    (DASHTAIL                (* ; "do dashing.")                                           (COND                                              ((EQ 0 (SETQ DASHCNT (SUB1 DASHCNT)))                                               (SETQ DASHON (NOT DASHON))                                               (SETQ DASHTAIL (OR (LISTP (CDR DASHTAIL))                                                                  DASHLST))                                               (SETQ DASHCNT (CAR DASHTAIL]                                 [COND                                    ((NOT (IGREATERP DX (add CDL DY)))                                     (add Y1 YINC)                                     (COND                                        ((COND                                            ((EQ YINC -1)                                             (ILESSP Y1 Y2))                                            ((IGREATERP Y1 Y2)))                                         (RETURN)))                                     (SETQ CDL (IDIFFERENCE CDL DX]                                 (add X1 1)))                       (T                                    (* ; "Y is the fastest mover.")                          (until (COND                                        ((EQ YINC -1)                                         (ILESSP Y1 Y2))                                        ((IGREATERP Y1 Y2)))                             do                          (* ; "main loop")                                   (COND                                      (DASHON (APPLY* USERFN X1 Y1 DISPLAYSTREAM)))                                   [COND                                      (DASHTAIL              (* ; "do dashing.")                                             (COND                                                ((EQ 0 (SETQ DASHCNT (SUB1 DASHCNT)))                                                 (SETQ DASHON (NOT DASHON))                                                 (SETQ DASHTAIL (OR (LISTP (CDR DASHTAIL))                                                                    DASHLST))                                                 (SETQ DASHCNT (CAR DASHTAIL]                                   [COND                                      ([NOT (IGREATERP DY (SETQ CDL (IPLUS CDL DX]                                       (COND                                          ((IGREATERP (SETQ X1 (ADD1 X1))                                                  X2)                                           (RETURN)))                                       (SETQ CDL (IDIFFERENCE CDL DY]                                   (add Y1 YINC]             (T                                              (* ;                                               "when we put the points down make it uninterruptable")                (COND                   [(IGEQ DX DY)                             (* ; "X is the fastest mover.")                    (until (IGREATERP X1 X2)                       do                                (* ; "main loop")                             (COND                                (DASHON (DRAWPOINT X1 Y1 BRUSH DISPLAYSTREAM OPERATION)))                             [COND                                (DASHTAIL                    (* ; "do dashing.")                                       (COND                                          ((EQ 0 (SETQ DASHCNT (SUB1 DASHCNT)))                                           (SETQ DASHON (NOT DASHON))                                           (SETQ DASHTAIL (OR (LISTP (CDR DASHTAIL))                                                              DASHLST))                                           (SETQ DASHCNT (CAR DASHTAIL]                             [COND                                ([NOT (IGREATERP DX (SETQ CDL (IPLUS CDL DY]                                 (SETQ Y1 (IPLUS Y1 YINC))                                 (COND                                    ((COND                                        ((EQ YINC -1)                                         (ILESSP Y1 Y2))                                        ((IGREATERP Y1 Y2)))                                     (RETURN)))                                 (SETQ CDL (IDIFFERENCE CDL DX]                             (SETQ X1 (ADD1 X1]                   (T                                        (* ; "Y is the fastest mover.")                      (until (COND                                    ((EQ YINC -1)                                     (ILESSP Y1 Y2))                                    ((IGREATERP Y1 Y2)))                         do                              (* ; "main loop")                               (COND                                  (DASHON (DRAWPOINT X1 Y1 BRUSH DISPLAYSTREAM OPERATION)))                               [COND                                  (DASHTAIL                  (* ; "do dashing.")                                         (COND                                            ((EQ 0 (SETQ DASHCNT (SUB1 DASHCNT)))                                             (SETQ DASHON (NOT DASHON))                                             (SETQ DASHTAIL (OR (LISTP (CDR DASHTAIL))                                                                DASHLST))                                             (SETQ DASHCNT (CAR DASHTAIL]                               [COND                                  ([NOT (IGREATERP DY (SETQ CDL (IPLUS CDL DX]                                   (COND                                      ((IGREATERP (SETQ X1 (ADD1 X1))                                              X2)                                       (RETURN)))                                   (SETQ CDL (IDIFFERENCE CDL DY]                               (SETQ Y1 (IPLUS Y1 YINC]          (RETURN NIL])(\DRAWCIRCLE.XDISPLAY  [LAMBDA (DISPLAYSTREAM CENTERX CENTERY RADIUS BRUSH DASHING)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 16-Jul-91 14:59 by matsuda")    (COND       ((OR (NOT (NUMBERP RADIUS))            (ILESSP (SETQ RADIUS (FIXR RADIUS))                   0))        (\ILLEGAL.ARG RADIUS))       ((EQ RADIUS 0)        NIL)       (DASHING (DRAWCURVE (CDR (\COMPUTE.ARC.POINTS CENTERX CENTERY RADIUS 0 360))                       T BRUSH DASHING DISPLAYSTREAM))       (T (PROG (X Y D DestinationBitMap LEFT RIGHTPLUS1 TOP BOTTOM BRUSHWIDTH BRUSHHEIGHT                    LEFTMINUSBRUSH BOTTOMMINUSBRUSH TOPMINUSBRUSH BRUSHBM DESTINATIONBASE BRUSHBASE                    RASTERWIDTH BRUSHRASTERWIDTH NBITSRIGHTPLUS1 OPERATION HEIGHTMINUS1 CX CY BBT                    COLOR COLORBRUSHBASE NBITS DISPLAYDATA USERFN)                (SETQ X 0)                (SETQ Y RADIUS)                (SETQ D (ITIMES 2 (IDIFFERENCE 1 RADIUS)))                (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DISPLAYSTREAM))                (SETQ USERFN (AND (LITATOM BRUSH)                                  BRUSH))                (SETQ CX CENTERX)                (SETQ CY CENTERY)                [COND                   ((EQ RADIUS 1)                    (COND                       (USERFN (APPLY* USERFN CX CY DISPLAYSTREAM))                       (T (DRAWPOINT CX CY BRUSH DISPLAYSTREAM)))                    (RETURN))                   (T (COND                         (USERFN (APPLY* USERFN CX (IPLUS CY RADIUS)                                        DISPLAYSTREAM)                                (APPLY* USERFN CX (IDIFFERENCE CY RADIUS)                                       DISPLAYSTREAM))                         (T (DRAWPOINT CX (IPLUS CY RADIUS)                                   BRUSH DISPLAYSTREAM)                            (DRAWPOINT CX (IDIFFERENCE CY RADIUS)                                   BRUSH DISPLAYSTREAM]            LP  [COND                   [(IGREATERP 0 D)                    (SETQ X (ADD1 X))                    (COND                       ((IGREATERP (UNFOLD (IPLUS D Y)                                          2)                               1)                        (SETQ D (IPLUS D (UNFOLD (IDIFFERENCE X Y)                                                2)                                       4))                        (SETQ Y (SUB1 Y)))                       (T (SETQ D (IPLUS D (UNFOLD X 2)                                         1]                   ((OR (EQ 0 D)                        (IGREATERP X D))                    (SETQ X (ADD1 X))                    (SETQ D (IPLUS D (UNFOLD (IDIFFERENCE X Y)                                            2)                                   4))                    (SETQ Y (SUB1 Y)))                   (T (SETQ D (IPLUS (IDIFFERENCE D (UNFOLD Y 2))                                     3))                      (SETQ Y (SUB1 Y]                (COND                   [(EQ Y 0)                    (COND                       (USERFN (APPLY* USERFN (IPLUS CX X)                                      CY DISPLAYSTREAM)                              (APPLY* USERFN (IDIFFERENCE CX X)                                     CY DISPLAYSTREAM))                       (T (DRAWPOINT (IPLUS CX X)                                 CY BRUSH DISPLAYSTREAM)                          (DRAWPOINT (IDIFFERENCE CX X)                                 CY BRUSH DISPLAYSTREAM]                   (T (COND                         (USERFN (APPLY* USERFN (IPLUS CX X)                                        (IPLUS CY Y)                                        DISPLAYSTREAM)                                (APPLY* USERFN (IDIFFERENCE CX X)                                       (IPLUS CY Y)                                       DISPLAYSTREAM)                                (APPLY* USERFN (IPLUS CX X)                                       (IDIFFERENCE CY Y)                                       DISPLAYSTREAM)                                (APPLY* USERFN (IDIFFERENCE CX X)                                       (IDIFFERENCE CY Y)                                       DISPLAYSTREAM))                         (T (DRAWPOINT (IPLUS CX X)                                   (IPLUS CY Y)                                   BRUSH DISPLAYSTREAM)                            (DRAWPOINT (IDIFFERENCE CX X)                                   (IPLUS CY Y)                                   BRUSH DISPLAYSTREAM)                            (DRAWPOINT (IPLUS CX X)                                   (IDIFFERENCE CY Y)                                   BRUSH DISPLAYSTREAM)                            (DRAWPOINT (IDIFFERENCE CX X)                                   (IDIFFERENCE CY Y)                                   BRUSH DISPLAYSTREAM)))                      (GO LP)))                (MOVETO CENTERX CENTERY DISPLAYSTREAM)                (RETURN NIL])(\DRAWCURVE.XDISPLAY  [LAMBDA (DISPLAYSTREAM KNOTS CLOSED BRUSH DASHING)   (* ; "Edited 16-Jul-91 17:04 by matsuda")    (PROG ((DASHLST (\GOOD.DASHLST DASHING BRUSH)))          (SELECTQ (LENGTH KNOTS)              (0                                             (* ;                                                        "No knots => empty curve rather than error?")                 NIL)              (1                                             (* ;                                                            "only one knot, put down a brush shape")                 (OR (type? POSITION (CAR KNOTS))                     (ERROR "bad knot" (CAR KNOTS)))                 (\DRAWPOINT.DISPLAY DISPLAYSTREAM (fetch XCOORD of (CAR KNOTS))                        (fetch YCOORD of (CAR KNOTS))                        BRUSH))              (2 (OR (type? POSITION (CAR KNOTS))                     (ERROR "bad knot" (CAR KNOTS)))                 (OR (type? POSITION (CADR KNOTS))                     (ERROR "bad knot" (CADR KNOTS)))                 (\XLINEWITHBRUSH (fetch XCOORD of (CAR KNOTS))                        (fetch YCOORD of (CAR KNOTS))                        (fetch XCOORD of (CADR KNOTS))                        (fetch YCOORD of (CADR KNOTS))                        BRUSH DASHLST DISPLAYSTREAM))              (\XCURVE2 (PARAMETRICSPLINE KNOTS CLOSED)                     BRUSH DASHLST DISPLAYSTREAM))          (RETURN DISPLAYSTREAM])(\XCURVE2  [LAMBDA (SPLINE BRUSH DASHLST DISPLAYSTREAM)    (DECLARE (SPECVARS . T))                       (* ; "Edited 16-Jul-91 17:16 by matsuda")    (PROG (BRUSHBM DestinationBitMap OPERATION BRUSHWIDTH BRUSHHEIGHT BRUSHBASE BRUSHRASTERWIDTH LEFT                 RIGHTPLUS1 TOP BOTTOM DESTINATIONBASE LEFTMINUSBRUSH BOTTOMMINUSBRUSH TOPMINUSBRUSH                 RASTERWIDTH NBITSRIGHTPLUS1 HEIGHTMINUS1 COLOR COLORBRUSHBASE NBITS \CURX \CURY                  \OLDX \OLDY \OLDERX \OLDERY LKNOT (DASHON T)                 (DASHTAIL DASHLST)                 (DASHCNT (CAR DASHLST))                 NPOINTS NSEGS POINTSPERSEG DX D2X D3X DY D2Y D3Y D1 D2 D3 X0 Y0 X1 Y1 DX DDX DDDX DY                 DDY DDDY (XPOLY (create POLYNOMIAL))                 (X/PRIME/POLY (create POLYNOMIAL))                 (YPOLY (create POLYNOMIAL))                 (Y/PRIME/POLY (create POLYNOMIAL))                 (DISPLAYDATA (fetch IMAGEDATA of DISPLAYSTREAM))                 (USERFN (AND (LITATOM BRUSH)                              BRUSH)))          (SETQ BRUSHBM (\GETBRUSH BRUSH))          (\CURVESTART (ELT (fetch (SPLINE SPLINEX) of SPLINE)                            1)                 (ELT (fetch (SPLINE SPLINEY) of SPLINE)                      1))          [bind PERSEG for KNOT from 1 to (SUB1 (fetch %#KNOTS of SPLINE))             when (PROGN                              (* ;;                            "Loop thru the segments of the spline curve, drawing each in turn.")                             (SETQ X0 (ELT (fetch (SPLINE SPLINEX) of SPLINE)                                           KNOT))                             (SETQ Y0 (ELT (fetch (SPLINE SPLINEY) of SPLINE)                                           KNOT))                             (SETQ X1 (ELT (fetch (SPLINE SPLINEX) of SPLINE)                                           (ADD1 KNOT)))                             (SETQ Y1 (ELT (fetch (SPLINE SPLINEY) of SPLINE)                                           (ADD1 KNOT)))                             (SETQ DX (ELT (fetch (SPLINE SPLINEDX) of SPLINE)                                           KNOT))                             (SETQ DY (ELT (fetch (SPLINE SPLINEDY) of SPLINE)                                           KNOT))                             (SETQ DDX (ELT (fetch SPLINEDDX of SPLINE)                                            KNOT))                             (SETQ DDY (ELT (fetch SPLINEDDY of SPLINE)                                            KNOT))                             (SETQ DDDX (ELT (fetch SPLINEDDDX of SPLINE)                                             KNOT))                             (SETQ DDDY (ELT (fetch SPLINEDDDY of SPLINE)                                             KNOT))                             (SETQ NPOINTS (FOLDLO (ITIMES (IMAX (IABS (IDIFFERENCE X1 X0))                                                                 (IABS (IDIFFERENCE Y1 Y0)))                                                          3)                                                  2))                             (NOT (ZEROP NPOINTS)))             do [COND                       ((ILEQ NPOINTS 64)                        (SETQ NSEGS 1)                        (SETQ POINTSPERSEG NPOINTS))                       (T (SETQ NSEGS (FOLDLO NPOINTS 64))                          (SETQ POINTSPERSEG 64)                          (SETQ NPOINTS (UNFOLD NSEGS 64]                   (SETQ D1 (FQUOTIENT 1.0 NPOINTS))                   (SETQ D2 (FTIMES D1 D1))                   (SETQ D3 (FTIMES D2 D1))                   (SETQ D3X (FTIMES D3 DDDX))                   (SETQ D3Y (FTIMES D3 DDDY))                   (COND                      [(EQ NSEGS 1)                       [SETQ DX (FPLUS (FTIMES D1 DX)                                       (FTIMES DDX D2 0.5)                                       (FTIMES DDDX D3 (CONSTANT (FQUOTIENT 1.0 6.0]                       (SETQ D2X (FPLUS (FTIMES D2 DDX)                                        (FTIMES D3 DDDX)))                       [SETQ DY (FPLUS (FTIMES D1 DY)                                       (FTIMES D2 DDY 0.5)                                       (FTIMES D3 DDDY (CONSTANT (FQUOTIENT 1.0 6.0]                       (SETQ D2Y (FPLUS (FTIMES D2 DDY)                                        (FTIMES D3 DDDY)))                       (COND                          (USERFN (\XCURVE X0 Y0 X1 Y1 DX DY D2X D2Y D3X D3Y NPOINTS BRUSHBM                                          DISPLAYDATA NIL NIL USERFN DISPLAYSTREAM))                          (T (\XCURVE X0 Y0 X1 Y1 DX DY D2X D2Y D3X D3Y NPOINTS BRUSHBM                                     DISPLAYDATA NIL NIL NIL DISPLAYSTREAM]                      (T (SETQ PERSEG (FQUOTIENT 1.0 NSEGS))                         (LOADPOLY XPOLY X/PRIME/POLY DDDX DDX DX X0)                         (LOADPOLY YPOLY Y/PRIME/POLY DDDY DDY DY Y0)                         (bind (TT _ 0.0)                                (DDDX/PER/SEG _ (FTIMES DDDX PERSEG))                                (DDDY/PER/SEG _ (FTIMES DDDY PERSEG))                                [D3XFACTOR _ (FTIMES D3 DDDX (CONSTANT (FQUOTIENT 1.0 6.0]                                [D3YFACTOR _ (FTIMES D3 DDDY (CONSTANT (FQUOTIENT 1.0 6.0]                            for I from 0 to (SUB1 NSEGS)                            do (SETQ TT (FPLUS TT PERSEG))                                  (SETQ X1 (POLYEVAL TT XPOLY 3))                                  (SETQ Y1 (POLYEVAL TT YPOLY 3))                                  (SETQ DX (FPLUS (FTIMES D1 DX)                                                  (FTIMES D2 DDX 0.5)                                                  D3XFACTOR))                                  (SETQ D2X (FPLUS (FTIMES D2 DDX)                                                   (FTIMES D3 DDDX)))                                  (SETQ DY (FPLUS (FTIMES D1 DY)                                                  (FTIMES D2 DDY 0.5)                                                  D3YFACTOR))                                  (SETQ D2Y (FPLUS (FTIMES D2 DDY)                                                   (FTIMES D3 DDDY)))                                  (COND                                     (USERFN (\XCURVE X0 Y0 X1 Y1 DX DY D2X D2Y D3X D3Y 64                                                     BRUSHBM DISPLAYDATA NIL NIL USERFN DISPLAYSTREAM)                                            )                                     (T (\XCURVE X0 Y0 X1 Y1 DX DY D2X D2Y D3X D3Y 64 BRUSHBM                                                DISPLAYDATA NIL NIL NIL DISPLAYSTREAM)))                                  (SETQ X0 X1)                                  (SETQ Y0 Y1)                                  (SETQ DDX (FPLUS DDX DDDX/PER/SEG))                                  (SETQ DDY (FPLUS DDY DDDY/PER/SEG))                                  (SETQ DX (POLYEVAL TT X/PRIME/POLY 2))                                  (SETQ DY (POLYEVAL TT Y/PRIME/POLY 2]          (COND             (USERFN (\XCURVE 0 0 0 0 0 0 0 0 0 0 0 BRUSHBM DISPLAYDATA NIL T USERFN                             DISPLAYSTREAM))             (T (\XCURVE 0 0 0 0 0 0 0 0 0 0 0 BRUSHBM DISPLAYDATA NIL T NIL DISPLAYSTREAM])(\XCURVE  [LAMBDA (X0 Y0 X1 Y1 DX DY DDX DDY DDDX DDDY N BRUSHBM DISPLAYDATA BBT ENDING USERFN DISPLAYSTREAM)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 16-Jul-91 16:57 by matsuda")    (PROG (OLDX X Y OLDY DELTAX DELTAY DELTA TX TY OOLDX OOLDY)          [COND             ((NEQ N 0)              (SETQ OLDX X0)              (SETQ OLDY Y0)              (\XCURVESMOOTH OLDX OLDY USERFN DISPLAYSTREAM)              (SETQ X (\CONVERTTOFRACTION (FPLUS OLDX 0.49)))              (SETQ Y (\CONVERTTOFRACTION (FPLUS OLDY 0.49)))              (SETQ DX (\CONVERTTOFRACTION DX))              (SETQ DY (\CONVERTTOFRACTION DY))              (SETQ DDX (\CONVERTTOFRACTION DDX))              (SETQ DDY (\CONVERTTOFRACTION DDY))              (SETQ DDDX (\CONVERTTOFRACTION DDDX))              (SETQ DDDY (\CONVERTTOFRACTION DDDY))              [for I from 1 to N do (\BOXIPLUS X DX)                                                   (\BOXIPLUS DX DDX)                                                   (\BOXIPLUS DDX DDDX)                                                   (\BOXIPLUS Y DY)                                                   (\BOXIPLUS DY DDY)                                                   (\BOXIPLUS DDY DDDY)                                                   (SETQ OOLDX OLDX)                                                   (SETQ OOLDY OLDY)                                                   (SETQ DELTAX (IDIFFERENCE (SETQ OLDX (                                                                                      \GETINTEGERPART                                                                                         X))                                                                       OOLDX))                                                   (SETQ DELTAY (IDIFFERENCE (SETQ OLDY (                                                                                      \GETINTEGERPART                                                                                         Y))                                                                       OOLDY))                                                   (SETQ DELTA (IMAX (IABS DELTAX)                                                                     (IABS DELTAY)))                                                   (COND                                                      ((EQ DELTA 1)                                                       (\XCURVESMOOTH OLDX OLDY USERFN DISPLAYSTREAM)                                                       ))                                                   (COND                                                      ((IGREATERP DELTA 1)                                                       (SETQ DELTAX (\CONVERTTOFRACTION (FQUOTIENT                                                                                         DELTAX DELTA                                                                                         )))                                                       (SETQ DELTAY (\CONVERTTOFRACTION (FQUOTIENT                                                                                         DELTAY DELTA                                                                                         )))                                                       (SETQ TX (\CONVERTTOFRACTION OOLDX))                                                       (SETQ TY (\CONVERTTOFRACTION OOLDY))                                                       (for I from 0 to DELTA                                                          do (\XCURVESMOOTH (\GETINTEGERPART                                                                                 TX)                                                                        (\GETINTEGERPART TY)                                                                        USERFN DISPLAYSTREAM)                                                                (\BOXIPLUS TX DELTAX)                                                                (\BOXIPLUS TY DELTAY]              (COND                 (USERFN (\XCURVESMOOTH X1 Y1 USERFN DISPLAYSTREAM))                 (T (\XCURVESMOOTH X1 Y1 NIL DISPLAYSTREAM)))              (AND DISPLAYSTREAM (MOVETO X1 Y1 DISPLAYSTREAM]          (COND             (ENDING (\XCURVESMOOTH (IPLUS \CURX \CURX (IMINUS \OLDX))                            (IPLUS \CURY \CURY (IMINUS \OLDY))                            USERFN DISPLAYSTREAM)                    (\XCURVESMOOTH (IPLUS \CURX \CURX (IMINUS \OLDX))                           (IPLUS \CURY \CURY (IMINUS \OLDY))                           USERFN DISPLAYSTREAM)))          (RETURN NIL]))(DEFINEQ(BITBLT  [LAMBDA (SOURCE SOURCELEFT SOURCEBOTTOM DESTINATION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                 SOURCETYPE OPERATION TEXTURE CLIPPINGREGION)                                                           (* ; "Edited 17-Jul-91 08:49 by matsuda")    (DECLARE (LOCALVARS . T))    (* ;; "IRM defined defaults")    (OR DESTINATIONLEFT (SETQ DESTINATIONLEFT 0))    (OR DESTINATIONBOTTOM (SETQ DESTINATIONBOTTOM 0))    (COND       [(EQ SOURCETYPE 'TEXTURE)        (COND           ((type? BITMAP DESTINATION)            (\BLTSHADE.BITMAP TEXTURE DESTINATION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                    OPERATION CLIPPINGREGION))           ((XLIB:DRAWABLE-P DESTINATION)            (\XBLTSHADE.PIXMAP TEXTURE DESTINATION DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                   OPERATION CLIPPINGREGION))           (T (PROG ((STREAM (\OUTSTREAMARG DESTINATION)))                    (RETURN (IMAGEOP 'IMBLTSHADE STREAM TEXTURE STREAM DESTINATIONLEFT                                    DESTINATIONBOTTOM WIDTH HEIGHT OPERATION CLIPPINGREGION]       (T (PROG (SOURCEDD SOURCEBM CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM)                [COND                   [(OR (type? BITMAP SOURCE)                        (XLIB:DRAWABLE-P SOURCE))                    (OR SOURCELEFT (SETQ SOURCELEFT 0))                    (OR SOURCEBOTTOM (SETQ SOURCEBOTTOM 0))                    (SETQ SOURCEBM SOURCE)                    (SETQ CLIPPEDSOURCELEFT SOURCELEFT)                    (SETQ CLIPPEDSOURCEBOTTOM SOURCEBOTTOM)  (* ;                                                    "limit the WIDTH and HEIGHT to the source size.")                    [SETQ WIDTH (COND                                   (WIDTH (IMIN WIDTH (IDIFFERENCE (BITMAPWIDTH SOURCE)                                                             SOURCELEFT)))                                   (T (BITMAPWIDTH SOURCE]                    (SETQ HEIGHT (COND                                    (HEIGHT (IMIN HEIGHT (IDIFFERENCE (BITMAPHEIGHT SOURCE)                                                                SOURCEBOTTOM)))                                    (T (BITMAPHEIGHT SOURCE]                   ((SETQ SOURCEDD (\GETDISPLAYDATA SOURCE))                    [OR SOURCELEFT (SETQ SOURCELEFT (fetch (REGION LEFT)                                                       of (ffetch (\DISPLAYDATA                                                                                  DDClippingRegion)                                                                 of SOURCEDD]                    [OR SOURCEBOTTOM (SETQ SOURCEBOTTOM (fetch (REGION BOTTOM)                                                           of (ffetch (\DISPLAYDATA                                                                                      DDClippingRegion                                                                                     ) of                                                                                              SOURCEDD                                                                         ]                                                             (* ;                                                           "do transformations coming out of source")                    (SETQ SOURCEBM (fetch (\DISPLAYDATA DDDestination) of SOURCEDD))                    (SETQ CLIPPEDSOURCELEFT (IMAX (SETQ SOURCELEFT (\DSPTRANSFORMX SOURCELEFT                                                                           SOURCEDD))                                                  (fetch (\DISPLAYDATA DDClippingLeft)                                                     of SOURCEDD)))                    (SETQ CLIPPEDSOURCEBOTTOM (IMAX (SETQ SOURCEBOTTOM (\DSPTRANSFORMY SOURCEBOTTOM                                                                               SOURCEDD))                                                    (fetch (\DISPLAYDATA DDClippingBottom)                                                       of SOURCEDD)))                                                             (* ;                                              "limit the WIDTH and HEIGHT by the source dimensions.")                    [SETQ WIDTH (COND                                   (WIDTH (IMIN WIDTH (IDIFFERENCE (fetch (\DISPLAYDATA                                                                                      DDClippingRight)                                                                      of SOURCEDD)                                                             CLIPPEDSOURCELEFT)))                                   (T (IDIFFERENCE (fetch (\DISPLAYDATA DDClippingRight)                                                      of SOURCEDD)                                             CLIPPEDSOURCELEFT]                    [SETQ HEIGHT (COND                                    (HEIGHT (IMIN HEIGHT (IDIFFERENCE (fetch (\DISPLAYDATA                                                                                         DDClippingTop                                                                                        )                                                                         of SOURCEDD)                                                                CLIPPEDSOURCEBOTTOM)))                                    (T (IDIFFERENCE (fetch (\DISPLAYDATA DDClippingTop)                                                       of SOURCEDD)                                              CLIPPEDSOURCEBOTTOM]                                                             (* ;                                                "if texture is not given, use the display stream's.")                    (OR TEXTURE (SETQ TEXTURE (ffetch (\DISPLAYDATA DDTexture) of SOURCEDD]                (COND                   ((OR (IGEQ 0 WIDTH)                        (IGEQ 0 HEIGHT))                     (* ;                                                "if either width or height is 0, don't do anything.")                    (RETURN)))                (RETURN (COND                           [(type? BITMAP DESTINATION)                            (COND                               ((WINDOWP SOURCE)                                (* ;; "bring source window to the top.  Note: this doesn't work if the user passes in a display stream onto the screen instead of a window.")                                (.WHILE.TOP.DS. (\OUTSTREAMARG SOURCE)                                       (\BITBLT.BITMAP SOURCEBM SOURCELEFT SOURCEBOTTOM DESTINATION                                               DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT                                               SOURCETYPE OPERATION TEXTURE CLIPPINGREGION                                               CLIPPEDSOURCELEFT CLIPPEDSOURCEBOTTOM)))                               (T (\BITBLT.BITMAP SOURCEBM SOURCELEFT SOURCEBOTTOM DESTINATION                                          DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT SOURCETYPE                                          OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT                                          CLIPPEDSOURCEBOTTOM]                           ((XLIB:DRAWABLE-P DESTINATION)                            (\XBITBLT.PIXMAP SOURCEBM SOURCELEFT SOURCEBOTTOM DESTINATION                                    DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT SOURCETYPE                                    OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT                                    CLIPPEDSOURCEBOTTOM))                           (T (PROG (STREAM)                                    (SETQ STREAM (\OUTSTREAMARG DESTINATION))                                    (COND                                       ((AND (NEQ SOURCE DESTINATION)                                             (WINDOWP SOURCE))                                 (* ;; "both source and destination are windows, see if they overlap and use an intermediate bitmap.  Note: this doesn't work if the user passes in a display stream onto the screen instead of a window.")                                        [COND                                           ((WINDOWP DESTINATION)                                            (COND                                               ((WOVERLAPP SOURCE DESTINATION)                                                (RETURN (PROG (SCRATCHBM)                                                              (.WHILE.TOP.DS. (\OUTSTREAMARG SOURCE)                                                                     (BITBLT SOURCEBM SOURCELEFT                                                                            SOURCEBOTTOM                                                                            (SETQ SCRATCHBM                                                                             (BITMAPCREATE WIDTH                                                                                     HEIGHT))                                                                            0 0 WIDTH HEIGHT                                                                            'INPUT                                                                            'REPLACE))                                                              (RETURN (BITBLT SCRATCHBM 0 0                                                                              STREAM DESTINATIONLEFT                                                                              DESTINATIONBOTTOM WIDTH                                                                             HEIGHT SOURCETYPE                                                                              OPERATION TEXTURE                                                                              CLIPPINGREGION]                                                             (* ;     "bring the source to the top.  this should be done uninterruptably but is better than nothing.")                                        (TOTOPW SOURCE)))                                    (IMAGEOP 'IMBITBLT STREAM SOURCEBM SOURCELEFT SOURCEBOTTOM STREAM                                           DESTINATIONLEFT DESTINATIONBOTTOM WIDTH HEIGHT SOURCETYPE                                           OPERATION TEXTURE CLIPPINGREGION CLIPPEDSOURCELEFT                                            CLIPPEDSOURCEBOTTOM]))(DEFINEQ(XCREATEWFROMPIXMAP  [LAMBDA (PIXMAP SCREEN)                              (* ; "Edited  7-Mar-91 16:39 by matsuda")    (PROG (WINDOW WIDTH HEIGHT)          (SETQ WINDOW (XCREATEW (create SCREENREGION                                            SCREEN _ (\INSURESCREEN SCREEN)                                            LEFT _ 0                                            BOTTOM _ 0                                            WIDTH _ (SETQ WIDTH (PIXMAPWIDTH PIXMAP))                                            HEIGHT _ (SETQ HEIGHT (PIXMAPHEIGHT PIXMAP)))                              NIL 0 T))          (WINDOWPROP WINDOW 'MINSIZE (CONS (IMIN MinWindowWidth WIDTH)                                            (IMIN MinWindowWidth HEIGHT)))          (CL:SETF (XLIB:GCONTEXT-FUNCTION XLIB::*GC*)                 CL:BOOLE-1)          (XLIB:COPY-AREA PIXMAP XLIB::*GC* 0 0 WIDTH HEIGHT (fetch (WINDOW SAVE) of WINDOW)                 0 0)          (RETURN WINDOW])(PIXMAPCREATE  [LAMBDA (WIDTH HEIGHT BITSPERPIXEL)                  (* ; "Edited  6-Mar-91 17:25 by matsuda")    (PROG NIL          (SETQ BITSPERPIXEL (\INSUREBITSPERPIXEL BITSPERPIXEL))          (RETURN (XLIB:CREATE-PIXMAP :WIDTH WIDTH :HEIGHT HEIGHT :DEPTH BITSPERPIXEL :DRAWABLE                          XLIB::*ROOT*])(PIXMAPWIDTH  [LAMBDA (PIXMAP)                                     (* ; "Edited  6-Mar-91 16:34 by matsuda")    (COND       ((XLIB:DRAWABLE-P PIXMAP)        (XLIB:DRAWABLE-WIDTH PIXMAP))       ((type? WINDOW PIXMAP)        (WINDOWPROP PIXMAP 'WIDTH))       (T (\ILLEGAL.ARG PIXMAP])(PIXMAPHEIGHT  [LAMBDA (PIXMAP)                                     (* ; "Edited  6-Mar-91 16:37 by matsuda")    (COND       ((XLIB:DRAWABLE-P PIXMAP)        (XLIB:DRAWABLE-HEIGHT PIXMAP))       ((type? WINDOW PIXMAP)        (WINDOWPROP PIXMAP 'HEIGHT))       (T (\ILLEGAL.ARG PIXMAP]))(DEFINEQ(XCREATEW  [LAMBDA (REGION TITLE BORDERSIZE NOOPENFLG)          (* ; "Edited 10-Apr-91 14:02 by matsuda")    (* ;; "creates and returns a window.")    (PROG (SCREEN REG DSP DISPLAYDATA TITLEHEIGHT WINDOW WBORDER)          (SETQ WBORDER (COND                           ((NUMBERP BORDERSIZE)                            (ABS BORDERSIZE))                           ((NUMBERP WBorder)                            (ABS WBorder))                           (T 2)))          (COND             ((type? REGION REGION)              (SETQ SCREEN \XSCREEN)                         (* ;                                                    "Protect against user smashing REGION later on.")              (SETQ REG (COPY REGION)))             [(type? SCREENREGION REGION)              (SETQ SCREEN (fetch (SCREENREGION SCREEN) of REGION))              (SETQ REG (COPY (fetch (SCREENREGION REGION) of REGION]             (T (ERROR "Not a region" REG)))          [COND             ((NULL DSP)                                     (* ;                                           "Don't have a DSP yet.  User passed some kind of region.")              (SETQ DSP (XDSPCREATE (fetch (XSCREEN SCDESTINATION) of SCREEN)))              (SETQ DISPLAYDATA (fetch (STREAM IMAGEDATA) of DSP]          (COND             ((NOT (IGREATERP (IMIN (fetch (REGION WIDTH) of REG)                                    (fetch (REGION HEIGHT) of REG))                          (UNFOLD WBORDER 2)))              (ERROR "Region too small to use as a window" REG)))          (SETQ WINDOW           (create WINDOW                  DSP _ DSP                  REG _ REG                  SAVE _ NIL                  WTITLE _ TITLE                  WBORDER _ WBORDER                  NEXTW _ 'CLOSED                  SCREEN _ SCREEN                  BUTTONEVENTFN _ NIL))          (replace (\DISPLAYDATA XWINDOWHINT) of DISPLAYDATA with WINDOW)          (XSHOWWFRAME WINDOW)          (DSPDESTINATION (fetch (WINDOW SAVE) of WINDOW)                 DSP)          (ADVISEXWDS WINDOW)                            (* ;                                        "make the display stream and window agree about dimensions.")          (MOVETOUPPERLEFT WINDOW)          (AND TITLE (XLIB:SET-STANDARD-PROPERTIES (fetch (WINDOW SAVE) of WINDOW)                            :NAME TITLE))          (COND             ((NOT NOOPENFLG)              (XOPENW WINDOW)))          (RETURN WINDOW])(ADVISEXWDS  [LAMBDA (WINDOW OLDREG MOVEONLYFLG)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 25-Feb-91 18:26 by matsuda")    (PROG (R D WBORDERSIZE CLIPREG TWICEBORDER PROC OFFSET)          (SETQ R (fetch (WINDOW REG) of WINDOW))          (SETQ D (fetch (WINDOW DSP) of WINDOW))          (SETQ WBORDERSIZE (fetch (WINDOW WBORDER) of WINDOW))          (SETQ TWICEBORDER (UNFOLD WBORDERSIZE 2))          (COND             (OLDREG (OR MOVEONLYFLG (DSPCLIPPINGREGION                                      [create REGION                                             LEFT _ 0                                             BOTTOM _ 0                                             WIDTH _ (IDIFFERENCE (fetch (REGION WIDTH)                                                                     of R)                                                            TWICEBORDER)                                             HEIGHT _ (IPLUS (IDIFFERENCE (fetch (REGION HEIGHT)                                                                             of R)                                                                    TWICEBORDER)                                                             (COND                                                                [(fetch (WINDOW WTITLE)                                                                    of WINDOW)                                                                 (DSPLINEFEED                                                                  NIL                                                                  (fetch (XSCREEN SCTITLEDS)                                                                     of (fetch (WINDOW SCREEN                                                                                              )                                                                               of WINDOW]                                                                (T 0]                                      D)))             (T (SETQ OFFSET (IMAX (FOLDHI WBORDERSIZE 2)                                   (IDIFFERENCE WBORDERSIZE 2)))                (DSPXOFFSET OFFSET D)                (DSPYOFFSET OFFSET D)                (DSPCLIPPINGREGION [create REGION                                          LEFT _ 0                                          BOTTOM _ 0                                          WIDTH _ (IDIFFERENCE (fetch (REGION WIDTH) of                                                                                         R)                                                         TWICEBORDER)                                          HEIGHT _ (IPLUS (IDIFFERENCE (fetch (REGION HEIGHT)                                                                          of R)                                                                 TWICEBORDER)                                                          (COND                                                             [(fetch (WINDOW WTITLE) of                                                                                         WINDOW)                                                              (DSPLINEFEED NIL                                                                     (fetch (XSCREEN SCTITLEDS)                                                                        of (fetch                                                                                (WINDOW SCREEN)                                                                                  of WINDOW]                                                             (T 0]                       D)))          [COND             ((NULL MOVEONLYFLG)                             (* ;                                          "if the previous right margin was the default, change it.")              (AND (OR (NOT OLDREG)                       (EQ (DSPRIGHTMARGIN NIL D)                           (IDIFFERENCE (fetch (REGION WIDTH) of OLDREG)                                  TWICEBORDER)))                   (DSPRIGHTMARGIN (IDIFFERENCE (fetch (REGION WIDTH) of R)                                          TWICEBORDER)                          D))              (COND                 ((AND (SETQ PROC (WINDOWPROP WINDOW 'PROCESS))                       (EQ D (PROCESS.TTY PROC)))            (* ;                                              "if the window changing is a tty, set its linelength.")                  [PROCESS.EVAL PROC (LIST (FUNCTION PAGEHEIGHT)                                           (IQUOTIENT (fetch (REGION HEIGHT)                                                         of (SETQ CLIPREG (DSPCLIPPINGREGION                                                                               NIL D)))                                                  (IMINUS (DSPLINEFEED NIL D]                  (PROCESS.EVAL PROC '(SETLINELENGTH))                  (IF NIL                      THEN                               (* ; "try it without this.")                            (COND                               ((EQ (PROCESSPROP PROC 'NAME)                                    'EXEC)                                (* ;; "in the exec process, make sure the current position is inside the new shape.  reuse variables R and TWICEBORDER to save binding.")                                (COND                                   ((ILESSP (SETQ R (DSPYPOSITION NIL D))                                           (SETQ TWICEBORDER (fetch (REGION BOTTOM) of                                                                                               CLIPREG                                                                    )))                                    (DSPYPOSITION TWICEBORDER D))                                   ((IGREATERP R (SETQ TWICEBORDER (IPLUS (fetch (REGION HEIGHT)                                                                             of CLIPREG)                                                                          TWICEBORDER)))                                    (DSPYPOSITION (IDIFFERENCE TWICEBORDER (FONTPROP D 'ASCENT))                                           D]          (UPDATE/SCROLL/REG WINDOW))    WINDOW])(XOPENW  [LAMBDA (WINDOW)                                     (* ; "Edited 31-Jan-91 15:28 by matsuda")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (COND       ((OPENWP WINDOW)                                      (* ;                     "used to bring the window to top but doesn't since TOTOPW has been documented.")        NIL)       (T (PROG [(USEROPENFN (WINDOWPROP WINDOW 'OPENFN]                (COND                   ((\USERFNISDON'T USEROPENFN)              (* ; "one of the OPENFNs is DON'T")                    NIL)                   (T                                        (* ;                                             "open it by putting it on top and swapping its bits in")                                                             (* \OPENW1 WINDOW)                                                             (* ;                                                "call the openfns after the window has been opened.")                      (\XOPENW1 WINDOW)                      (DOUSERFNS USEROPENFN WINDOW)                      (RETURN WINDOW])(\XOPENW1  [LAMBDA (WINDOW)                                     (* ; "Edited  1-Feb-91 15:50 by matsuda")    (if (EQ (fetch (WINDOW NEXTW) of WINDOW)                'CLOSED)        then (PROG ((BASEW (WINDOWPROP WINDOW 'XBASEW))                        XWIN REG BORDER XTITLEW TOP (SCREEN (fetch (WINDOW SCREEN) of WINDOW)                                                           )                        DD)                       (if BASEW                           then (XLIB:MAP-WINDOW BASEW)                         else (WINDOWPROP WINDOW 'XBASEW (SETQ BASEW (\XCREATEBASEW WINDOW)))                               [AND (WINDOWPROP WINDOW 'TITLE)                                    (SETQ XTITLEW (WINDOWPROP WINDOW 'XTITLEW]                               (SETQ XWIN (fetch (WINDOW SAVE) of WINDOW))                               (SETQ BORDER (XLIB:DRAWABLE-BORDER-WIDTH XWIN))                               (SETQ TOP 0)                               [COND                                  (XTITLEW (XLIB:REPARENT-WINDOW XTITLEW BASEW 0 0)                                         (SETQ TOP (XLIB:DRAWABLE-HEIGHT XTITLEW]                               (XLIB:REPARENT-WINDOW XWIN BASEW 0 TOP)                               (XLIB:MAP-SUBWINDOWS BASEW)                               (XLIB:MAP-WINDOW BASEW))                       (UNINTERRUPTABLY                           (XLIB:MAP-WINDOW (fetch (WINDOW SAVE) of WINDOW))                           (replace (WINDOW NEXTW) of WINDOW with (fetch (XSCREEN                                                                                          SCTOPW)                                                                                 of SCREEN))                           (replace (XSCREEN SCTOPW) of SCREEN with WINDOW))])(XCLOSEW  [LAMBDA (WINDOW)                                     (* ; "Edited 31-Jan-91 16:12 by matsuda")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (COND       ((OPENWP WINDOW)        (COND           ((\OKTOCLOSEW WINDOW)            (AND (OPENWP WINDOW)                 (\XCLOSEW1 WINDOW))            T])(\XCLOSEW1  [LAMBDA (WINDOW)                                     (* ; "Edited  1-Feb-91 15:07 by matsuda")    (LET (SCREEN NEXTW SAVE)         (SETQ SCREEN (fetch (WINDOW SCREEN) of WINDOW))         (SETQ NEXTW (fetch (XSCREEN SCTOPW) of SCREEN))         (COND            ((NULL NEXTW)             NIL)            ((EQ NEXTW WINDOW)             (UNINTERRUPTABLY                 (XLIB:UNMAP-WINDOW (WINDOWPROP NEXTW 'XBASEW))                 (replace (XSCREEN SCTOPW) of SCREEN with (fetch (WINDOW NEXTW)                                                                         of NEXTW))                 (replace (WINDOW NEXTW) of WINDOW with 'CLOSED))             T)            (T (PROG NIL                     (SETQ SAVE NEXTW)                     (SETQ NEXTW (fetch (WINDOW NEXTW) of SAVE))                 LOOP                     (COND                        (NEXTW (COND                                  [(EQ NEXTW WINDOW)                                   (UNINTERRUPTABLY                                       (XLIB:UNMAP-WINDOW (WINDOWPROP NEXTW 'XBASEW))                                       (replace (WINDOW NEXTW) of SAVE                                          with (fetch (WINDOW NEXTW) of NEXTW))                                       (replace (WINDOW NEXTW) of NEXTW with 'CLOSED))]                                  (T (SETQ SAVE NEXTW)                                     (SETQ NEXTW (fetch (WINDOW NEXTW) of SAVE))                                     (GO LOOP])(\XSFFixClippingRegion  [LAMBDA (DISPLAYDATA)                                (* ; "Edited 25-Feb-91 18:43 by matsuda")    (* ;; "compute the top, bottom, left and right edges of the clipping region in destination coordinates to save computation every BltChar and coordinate transformation taking into account the size of the bit map as well as the clipping region.")    (PROG ((CLIPREG (ffetch (\DISPLAYDATA DDClippingRegion) of DISPLAYDATA))           (BM (ffetch (\DISPLAYDATA DDDestination) of DISPLAYDATA))           (GC (ffetch (\DISPLAYDATA DDPILOTBBT) of DISPLAYDATA)))          (freplace (\DISPLAYDATA DDClippingRight) of DISPLAYDATA             with (IMAX 0 (\DSPTRANSFORMX (IPLUS (ffetch (REGION LEFT) of CLIPREG)                                                     (ffetch (REGION WIDTH) of CLIPREG))                                     DISPLAYDATA)))          (freplace (\DISPLAYDATA DDClippingLeft) of DISPLAYDATA             with (IMIN (IMAX (\DSPTRANSFORMX (ffetch (REGION LEFT) of CLIPREG)                                         DISPLAYDATA)                                  0)                            MAX.SMALL.INTEGER))          (freplace (\DISPLAYDATA DDClippingTop) of DISPLAYDATA             with (IMAX 0 (\DSPTRANSFORMY (IPLUS (ffetch (REGION BOTTOM) of CLIPREG)                                                     (ffetch (REGION HEIGHT) of CLIPREG))                                     DISPLAYDATA)))          (freplace (\DISPLAYDATA DDClippingBottom) of DISPLAYDATA             with (IMIN (IMAX (\DSPTRANSFORMY (ffetch (REGION BOTTOM) of CLIPREG)                                         DISPLAYDATA)                                  0)                            MAX.SMALL.INTEGER))          (CL:SETF (XLIB:GCONTEXT-CLIP-MASK GC)                 (LIST (fetch (\DISPLAYDATA DDClippingLeft) of DISPLAYDATA)                       (IDIFFERENCE (XLIB:DRAWABLE-HEIGHT BM)                              (fetch (\DISPLAYDATA DDClippingTop) of DISPLAYDATA))                       (fetch (REGION WIDTH) of CLIPREG)                       (fetch (REGION HEIGHT) of CLIPREG])(XSHOWWFRAME  [LAMBDA (WIN)                                        (* ; "Edited 27-Feb-91 17:38 by matsuda")    (* ;; "Displays the border and title in the save image of a window")    [PROG ((TITLE (fetch (WINDOW WTITLE) of WIN))           (BORDER (fetch (WINDOW WBORDER) of WIN))           (SAVEIMAGE (fetch (WINDOW SAVE) of WIN))           (SCREEN (fetch (WINDOW SCREEN) of WIN))           (REG (fetch (WINDOW REG) of WIN))           BLACKPART           (TITLE-H 0))                                      (* ; "make most of the border black")          (SETQ BLACKPART (IMAX (FOLDHI BORDER 2)                                (IDIFFERENCE BORDER 2)))          (XSHOWWTITLE TITLE SAVEIMAGE BORDER NIL WIN)          [AND TITLE (SETQ TITLE-H (XLIB:DRAWABLE-HEIGHT (WINDOWPROP WIN 'XTITLEW]          (if SAVEIMAGE              then (CL:SETF (XLIB:DRAWABLE-Y SAVEIMAGE)                              TITLE-H)                    (CL:SETF (XLIB:DRAWABLE-X SAVEIMAGE)                           0)                    (CL:SETF (XLIB:DRAWABLE-WIDTH SAVEIMAGE)                           (IDIFFERENCE (fetch (REGION WIDTH) of REG)                                  (ITIMES BLACKPART 2)))                    [CL:SETF (XLIB:DRAWABLE-HEIGHT SAVEIMAGE)                           (IDIFFERENCE (fetch (REGION HEIGHT) of REG)                                  (IPLUS TITLE-H (ITIMES BLACKPART 2]            else (replace SAVE of WIN                        with (SETQ SAVEIMAGE (XLIB:CREATE-WINDOW                                                  :PARENT                                                  (fetch (XSCREEN SCDESTINATION) of SCREEN)                                                  :X                                                  (fetch (REGION LEFT) of REG)                                                  :Y                                                  (IDIFFERENCE (fetch (XSCREEN SCHEIGHT)                                                                  of SCREEN)                                                         (IDIFFERENCE (fetch (REGION TOP)                                                                         of REG)                                                                (IPLUS TITLE-H BLACKPART)))                                                  :WIDTH                                                  (IDIFFERENCE (fetch (REGION WIDTH) of                                                                                         REG)                                                         (ITIMES BLACKPART 2))                                                  :HEIGHT                                                  (IDIFFERENCE (fetch (REGION HEIGHT)                                                                  of REG)                                                         (IPLUS TITLE-H (ITIMES BLACKPART 2)))                                                  :BORDER-WIDTH BLACKPART :BACKGROUND XLIB::*WHITE*                                                   :BIT-GRAVITY :NORTH-WEST :BACKING-STORE :ALWAYS]    WIN])(XSHOWWTITLE  [LAMBDA (TITLE BM BORDER CENTERFLG WINDOW)           (* ; "Edited 27-Feb-91 16:51 by matsuda")    (PROG ((XTITLEW (WINDOWPROP WINDOW 'XTITLEW))           (XBASEW (WINDOWPROP WINDOW 'XBASEW))           FONT HEIGHT ASCENT (REG (fetch (WINDOW REG) of WINDOW)))          (if TITLE              then (SETQ HEIGHT (IPLUS (SETQ ASCENT (XLIB:FONT-ASCENT XLIB::*DEFAULTFONT*))                                           (XLIB:FONT-DESCENT XLIB::*DEFAULTFONT*)))                    (if XTITLEW                        then (CL:SETF (XLIB:DRAWABLE-WIDTH XTITLEW)                                        (fetch (REGION WIDTH) of REG))                      else (SETQ XTITLEW (XLIB:CREATE-WINDOW :PARENT (OR XBASEW XLIB::*ROOT*)                                                    :X 0 :Y 0 :WIDTH                                                    (IPLUS (fetch (REGION WIDTH) of REG)                                                           (IMAX (ITIMES (- BORDER 2)                                                                        2)                                                                 0))                                                    :HEIGHT                                                    (IPLUS HEIGHT 2)                                                    :BORDER-WIDTH 0 :BACKGROUND XLIB::*BLACK*                                                     :BACKING-STORE :ALWAYS :BIT-GRAVITY :NORTH-WEST))                           )                    (if XBASEW                        then (XLIB:MAP-WINDOW XTITLEW))                    (CL:SETF (XLIB:GCONTEXT-FONT XLIB::*GC*)                           XLIB::*DEFAULTFONT*)                    (CL:SETF (XLIB:GCONTEXT-FOREGROUND XLIB::*GC*)                           XLIB::*WHITE*)                    (CL:SETF (XLIB:GCONTEXT-BACKGROUND XLIB::*GC*)                           XLIB::*BLACK*)                    (CL:SETF (XLIB:GCONTEXT-FUNCTION XLIB::*GC*)                           CL:BOOLE-1)                    (XLIB:CLEAR-AREA XTITLEW)                    (XLIB:DRAW-IMAGE-GLYPHS XTITLEW XLIB::*GC* BORDER (ADD1 ASCENT)                           TITLE)            else (AND XTITLEW (XLIB:DESTROY-WINDOW XTITLEW))                  (SETQ XTITLEW NIL))          (WINDOWPROP WINDOW 'XTITLEW XTITLEW)          (RETURN XTITLEW])(\XCREATEBASEW  [LAMBDA (WINDOW)                                     (* ; "Edited 11-Jul-91 14:07 by matsuda")    (PROG ((XWIN (fetch (WINDOW SAVE) of WINDOW))           (XTITLEW (WINDOWPROP WINDOW 'XTITLEW))           (REG (fetch (WINDOW REG)                       WINDOW))           (XCURSOR (XCURSORFROMCURSOR DEFAULTCURSOR))           WIDTH HEIGHT XBORDER BASEW TITLE)          [SETQ WIDTH (IPLUS (XLIB:DRAWABLE-WIDTH XWIN)                             (SETQ XBORDER (ITIMES (XLIB:DRAWABLE-BORDER-WIDTH XWIN)                                                  2]          (SETQ HEIGHT (IPLUS (XLIB:DRAWABLE-HEIGHT XWIN)                              XBORDER))          [COND             (XTITLEW (SETQ HEIGHT (IPLUS HEIGHT (XLIB:DRAWABLE-HEIGHT XTITLEW]          (SETQ BASEW (XLIB:CREATE-WINDOW :PARENT XLIB::*ROOT* :X (fetch (REGION LEFT)                                                                     of REG)                             :Y                             (fetch (REGION TOP) of REG)                             :WIDTH WIDTH :HEIGHT HEIGHT :BORDER-WIDTH 0 :BACKGROUND XLIB::*WHITE*                              :GRAVITY :NORTH-WEST :CURSOR XCURSOR :EVENT-MASK                             (XLIB:MAKE-EVENT-MASK :STRUCTURE-NOTIFY :KEY-PRESS :KEY-RELEASE                                     :BUTTON-PRESS :BUTTON-RELEASE :POINTER-MOTION :ENTER-WINDOW                                     :LEAVE-WINDOW)))          (WINDOWPROP WINDOW 'XCURSOR XCURSOR)          (AND (SETQ TITLE (WINDOWPROP WINDOW 'TITLE))               (XLIB:SET-STANDARD-PROPERTIES BASEW :NAME TITLE :INPUT :ON))          (RETURN BASEW])(\DSPCLIPPINGREGION.XDISPLAY  [LAMBDA (DISPLAYSTREAM REGION)                       (* ; "Edited  1-Feb-91 10:01 by matsuda")    (* ;; "sets the clipping region of a display stream.")    (PROG ((DD (\GETDISPLAYDATA DISPLAYSTREAM)))          (RETURN (PROG1 (ffetch DDClippingRegion of DD)                      [COND                         (REGION (OR (type? REGION REGION)                                     (ERROR REGION " is not a REGION."))                                (UNINTERRUPTABLY                                    (freplace DDClippingRegion of DD with REGION)                                    (\XSFFixClippingRegion DD)                                    (\INVALIDATEDISPLAYCACHE DD))])]))(DEFINEQ(\XDSPPRINTCHAR  [LAMBDA (STREAM CHARCODE)                            (* ; "Edited 15-Feb-91 17:37 by matsuda")    (PROG ((DD (ffetch (STREAM IMAGEDATA) of STREAM)))                                                             (* \CHECKCARET STREAM)          (\MAYBE-DRIBBLE-CHAR STREAM CHARCODE)              (* ; "if dribbling, dribble.")          (SELECTC (ffetch (TERMCODE CCECHO) of (\SYNCODE \PRIMTERMSA CHARCODE))              (REAL.CCE                         (* ;; "All fat characters are defined as REAL according to \SYNCODE, so we don't have worry about any of the special cases")                        [COND                           ((IGREATERP CHARCODE (CONSTANT (IMAX (CHARCODE EOL)                                                                (CHARCODE CR)                                                                (CHARCODE LF)                                                                ERASECHARCODE)))                                                             (* ;                                     "This is for sure a printing character; take the fast way out.")                            (\XBLTCHAR CHARCODE STREAM DD)                            (add (ffetch (STREAM CHARPOSITION) of STREAM)                                   1))                           (T                                (* ; "Take the slow check.")                              (SELECTC CHARCODE                                  ((CHARCODE (EOL CR LF))                                        (\XDSPPRINTCR/LF CHARCODE STREAM)                                       (freplace (STREAM CHARPOSITION) of STREAM with                                                                                         0))                                  (ERASECHARCODE (DSPBACKUP (CHARWIDTH (CHARCODE A)                                                                   STREAM)                                                        STREAM)                                                             (* ;                        "line buffering routines have already taken care of backing up the position")                                                 0)                                  (PROGN (\XBLTCHAR CHARCODE STREAM DD)                                         (add (ffetch (STREAM CHARPOSITION) of STREAM)                                                1])              (INDICATE.CCE                                  (* ;      "Make sure that all the chars in the indicate-string fit on the line or wrap-around together.")                            (PROG (STR)                                  (SETQ STR (\INDICATESTRING CHARCODE))                                                             (* ; "This isn't right for rotated fonts.  But then there should probably be a separate rotated outcharfn")                                  [COND                                     ((IGREATERP (\STRINGWIDTH.DISPLAY STREAM STR)                                             (IDIFFERENCE (ffetch (\DISPLAYDATA DDRightMargin)                                                             of DD)                                                    (ffetch (\DISPLAYDATA DDXPOSITION)                                                       of DD)))                                      (\XDSPPRINTCR/LF (CHARCODE EOL)                                             STREAM)                                      (freplace (STREAM CHARPOSITION) of STREAM                                         with (NCHARS STR)))                                     (T (add (ffetch (STREAM CHARPOSITION) of STREAM)                                               (NCHARS STR]                                  (for I from 1 do (\XBLTCHAR (OR (NTHCHARCODE STR I)                                                                                  (RETURN))                                                                      STREAM DD))))              (SIMULATE.CCE (SELCHARQ CHARCODE                                 ((EOL CR LF)                                       (\XDSPPRINTCR/LF CHARCODE STREAM)                                      (freplace (STREAM CHARPOSITION) of STREAM with                                                                                        0))                                 (ESCAPE (\XBLTCHAR (CHARCODE $)                                                STREAM DD)                                         (add (ffetch (STREAM CHARPOSITION) of STREAM)                                                1))                                 (BELL                       (* ;                      "make switching of bits uninterruptable but allow interrupts between flashes.")                                       (SELECTC \MACHINETYPE                                           ((LIST \DANDELION \DAYBREAK \MAIKO)                                                 [PLAYTUNE '((880 . 2500])                                           (FLASHWINDOW (WFROMDS STREAM))))                                 (TAB (PROG (TABWIDTH (SPACEWIDTH (CHARWIDTH (CHARCODE SPACE)                                                                         STREAM)))                                            (SETQ TABWIDTH (UNFOLD SPACEWIDTH 8))                                            (COND                                               ((IGREATERP                                                 (\DISPLAYSTREAMINCRXPOSITION                                                  (SETQ TABWIDTH                                                   (IDIFFERENCE TABWIDTH                                                          (MOD (IDIFFERENCE (ffetch (\DISPLAYDATA                                                                                         DDXPOSITION)                                                                               of DD)                                                                      (ffetch (\DISPLAYDATA                                                                                   DDLeftMargin)                                                                         of DD))                                                               TABWIDTH)))                                                  DD)                                                 (ffetch (\DISPLAYDATA DDRightMargin)                                                    of DD))                                                             (* ;                                                            "tab was past rightmargin, force cr.")                                                (\XDSPPRINTCR/LF (CHARCODE EOL)                                                       STREAM)))                                                             (* ;                                                            "return the number of spaces taken.")                                            (add (ffetch (STREAM CHARPOSITION) of STREAM)                                                   (IQUOTIENT TABWIDTH SPACEWIDTH))))                                 (PROGN                      (* ;                                                            "this case was copied from \DSCCOUT.")                                        (\XBLTCHAR CHARCODE STREAM DD)                                        (add (ffetch (STREAM CHARPOSITION) of STREAM)                                               1))))              (IGNORE.CCE)              (SHOULDNT])(\XBLTCHAR  [LAMBDA (CHARCODE DISPLAYSTREAM DISPLAYDATA)    (DECLARE (LOCALVARS . T))                        (* ; "Edited  1-Oct-91 13:38 by jn")    (PROG (LOCAL1 RIGHT LEFT CURX CURY CHAR8CODE DESTINATION)          (SETQ CHAR8CODE (\CHAR8CODE CHARCODE))      CRLP          [COND             ((NOT (EQ (ffetch (\DISPLAYDATA DDCHARSET) of DISPLAYDATA)                       (\CHARSET CHARCODE)))              (\CHANGECHARSET.XDISPLAY DISPLAYDATA (\CHARSET CHARCODE]          (SETQ CURX (ffetch (\DISPLAYDATA DDXPOSITION) of DISPLAYDATA))          (SETQ RIGHT (IPLUS CURX (\DSPGETCHARWIDTH CHAR8CODE DISPLAYDATA)))          [COND             ((IGREATERP RIGHT (ffetch (\DISPLAYDATA DDRightMargin) of DISPLAYDATA))                                                             (* ;                                                            "would go past right margin, force a cr")              (COND                 ((IGREATERP CURX (ffetch (\DISPLAYDATA DDLeftMargin) of DISPLAYDATA))                                                             (* ;        "don't bother CR if position is at left margin anyway.  This also serves to break the loop.")                  (\XDSPPRINTCR/LF (CHARCODE EOL)                         DISPLAYSTREAM)                      (* ;                        "reuse the code in the test of this conditional rather than repeat it here.")                  (GO CRLP]                                  (* ;                                                            "update the display stream x position.")          (freplace (\DISPLAYDATA DDXPOSITION) of DISPLAYDATA with (IPLUS CURX                                                                                      (                                                                                     \DSPGETCHARWIDTH                                                                                       CHAR8CODE                                                                                        DISPLAYDATA)))                                                             (* ;                                       "transforms an x coordinate into the destination coordinate.")          (SETQ LOCAL1 (ffetch (\DISPLAYDATA DDXOFFSET) of DISPLAYDATA))          (SETQ CURX (IPLUS CURX LOCAL1))          (SETQ CURY (IPLUS (ffetch (\DISPLAYDATA DDYPOSITION) of DISPLAYDATA)                            (ffetch (\DISPLAYDATA DDXOFFSET) of DISPLAYDATA)))          (XLIB:DRAW-IMAGE-GLYPH (SETQ DESTINATION (fetch (\DISPLAYDATA DDDestination)                                                      of DISPLAYDATA))                 (fetch (\DISPLAYDATA DDPILOTBBT) of DISPLAYDATA)                 CURX                 (IDIFFERENCE (\GETWINDOWHEIGHT          (* ;       "No roundtrip needed BUT: we have to remember to keep the height in sync with reality. /jarl")                                     (WFROMDS DISPLAYSTREAM))                        CURY)                 CHAR8CODE)          (RETURN T])(\XDSPPRINTCR/LF  [LAMBDA (CHARCODE DISPLAY-STREAM)                    (* ; "Edited 28-Feb-91 12:05 by matsuda")    (COND       ((EQ DISPLAY-STREAM (TTYDISPLAYSTREAM))        (\STOPSCROLL?)                                       (* ;                                                         "\STOPSCROLL may have turned on the caret.")                                                             (* \CHECKCARET DISPLAY-STREAM)        ))    (PROG (BTM AMOUNT/BELOW Y ROTATION FONT (DD (fetch (STREAM IMAGEDATA) of DISPLAY-STREAM))               )          (COND             ((EQ CHARCODE (CHARCODE EOL))                   (* ; "on LF, no change in X")              (COND                 ((SETQ Y (fetch (\DISPLAYDATA DDEOLFN) of DD))                                                             (* ; "call the eol function for ds.")                  (APPLY* Y DISPLAY-STREAM)))              (DSPXPOSITION (ffetch (\DISPLAYDATA DDLeftMargin) of DD)                     DISPLAY-STREAM)))          (SETQ Y (IPLUS (ffetch (\DISPLAYDATA DDYPOSITION) of DD)                         (ffetch (\DISPLAYDATA DDLINEFEED) of DD)))          [COND             ((AND (fetch (\DISPLAYDATA DDScroll) of DD)                   (IGREATERP (SETQ AMOUNT/BELOW (IDIFFERENCE (IPLUS (SETQ BTM (fetch                                                                                (\DISPLAYDATA                                                                                      DDClippingBottom                                                                                       ) of                                                                                         DD))                                                                     (fetch (FONTDESCRIPTOR                                                                                 \SFDescent)                                                                        of (fetch                                                                                (\DISPLAYDATA DDFONT)                                                                                  of DD)))                                                        (\DSPTRANSFORMY Y DD)))                          0))              (* ;; "automatically scroll up enough to make the entire next character visible.  Descent check is so that the bottoms of characters will be printed also.")              [PROG (LFT WDTH BKGRND DBITMAP HGHT H)                    (SETQ LFT (fetch (\DISPLAYDATA DDClippingLeft) of DD))                    (SETQ DBITMAP (fetch (\DISPLAYDATA DDDestination) of DD))                    (SETQ HGHT (IDIFFERENCE (ffetch (\DISPLAYDATA DDClippingTop) of DD)                                      BTM))                    (SETQ WDTH (IDIFFERENCE (fetch (\DISPLAYDATA DDClippingRight) of DD)                                      LFT))                    (SETQ BKGRND (ffetch (\DISPLAYDATA DDTexture) of DD))                    (COND                       ((IGREATERP AMOUNT/BELOW HGHT)        (* ;                                        "scrolling more than the window size, use different method.")                                                             (* ;                                                            "clear the window with background.")                        (BLTSHADE BKGRND DISPLAY-STREAM LFT BTM WDTH HGHT 'REPLACE))                       (T (CL:SETF (XLIB:GCONTEXT-FUNCTION XLIB::*GC*)                                 CL:BOOLE-1)                          (XLIB:COPY-AREA DBITMAP XLIB::*GC* LFT [IDIFFERENCE (SETQ H (                                                                                 XLIB:DRAWABLE-HEIGHT                                                                                       DBITMAP))                                                                        (IPLUS BTM (SETQ HGHT                                                                                    (IDIFFERENCE                                                                                     HGHT                                                                                      AMOUNT/BELOW]                                 WDTH HGHT DBITMAP LFT (IDIFFERENCE H (IPLUS (IPLUS BTM AMOUNT/BELOW)                                                                             HGHT)))                          (BLTSHADE BKGRND DISPLAY-STREAM LFT BTM WDTH AMOUNT/BELOW 'REPLACE]              (SETQ Y (IPLUS Y AMOUNT/BELOW]          (DSPYPOSITION Y DISPLAY-STREAM]))(DEFINEQ(OPENWINDOWS  [LAMBDA (SCREEN)                                     (* ; "Edited 15-Feb-91 16:24 by matsuda")    (* ;; "returns a list of all open windows")    (PROG (WINDOW WINDOWS)          (COND             ((EQ SCREEN T)                                  (* ; "Return all open windows.")              (SETQ WINDOWS (for SCREEN in \SCREENS join (OPENWINDOWS SCREEN)))              (RETURN WINDOWS)))          (SETQ SCREEN (\INSURESCREEN SCREEN))          [SETQ WINDOW (COND                          ((type? SCREEN SCREEN)                           (fetch (SCREEN SCTOPW) of SCREEN))                          ((type? XSCREEN SCREEN)                           (fetch (XSCREEN SCTOPW) of SCREEN]          (while WINDOW do (SETQ WINDOWS (CONS WINDOW WINDOWS))                                  (SETQ WINDOW (fetch (WINDOW NEXTW) of WINDOW)))          (SETQ WINDOWS (DREVERSE WINDOWS))          (RETURN WINDOWS])(\INSURESCREEN  [LAMBDA (SCREEN)                                     (* ; "Edited 15-Feb-91 16:22 by matsuda")    (COND       ((type? SCREEN SCREEN)        SCREEN)       ((type? XSCREEN SCREEN)        SCREEN)       ((NULL SCREEN)        \CURSORSCREEN)       (T (\ILLEGAL.ARG SCREEN])(DSPSOURCETYPE  [LAMBDA (SOURCETYPE DISPLAYSTREAM)                   (* ; "Edited 15-Feb-91 13:02 by matsuda")    (* ;; "sets the operation field of a display stream")    (PROG ((DD (\GETDISPLAYDATA DISPLAYSTREAM))           PBT)          (RETURN (PROG1 (fetch DDSOURCETYPE of DD)                      [COND                         (SOURCETYPE (OR (FMEMB SOURCETYPE '(INPUT INVERT))                                         (LISPERROR "ILLEGAL ARG" SOURCETYPE))                                (UNINTERRUPTABLY                                    (freplace DDSOURCETYPE of DD with SOURCETYPE)                                                             (* ;                                                     "update other fields that depend on operation.")                                    [COND                                       ((type? PILOTBBT (SETQ PBT (fetch DDPILOTBBT                                                                         of DD)))                                        (\SETPBTFUNCTION PBT SOURCETYPE (fetch DDOPERATION                                                                           of DD)))                                       ((XLIB:GCONTEXT-P PBT)                                        (\SETGCFUNCTION PBT SOURCETYPE (fetch DDOPERATION                                                                              of DD])])])(PUTWINDOWPROP  [LAMBDA (WINDOW PROP VALUE)                          (* ; "Edited 27-Feb-91 16:46 by matsuda")    [OR (type? WINDOW WINDOW)        (COND           ((DISPLAYSTREAMP (\OUTSTREAMARG WINDOW))            (SETQ WINDOW (WFROMDS WINDOW)))           (T (\ILLEGAL.ARG WINDOW]    (SELECTQ PROP        (RIGHTBUTTONFN (PROG1 (fetch (WINDOW RIGHTBUTTONFN) of WINDOW)                           (replace (WINDOW RIGHTBUTTONFN) of WINDOW with VALUE)))        (BUTTONEVENTFN (PROG1 (fetch (WINDOW BUTTONEVENTFN) of WINDOW)                           (replace (WINDOW BUTTONEVENTFN) of WINDOW with VALUE)))        (CLOSEFN (PROG1 (fetch (WINDOW CLOSEFN) of WINDOW)                     (replace (WINDOW CLOSEFN) of WINDOW with VALUE)))        (MOVEFN (PROG1 (fetch (WINDOW MOVEFN) of WINDOW)                    (replace (WINDOW MOVEFN) of WINDOW with VALUE)))        (CURSORINFN (PROG1 (fetch (WINDOW CURSORINFN) of WINDOW)                        (replace (WINDOW CURSORINFN) of WINDOW with VALUE)))        (CURSOROUTFN (PROG1 (fetch (WINDOW CURSOROUTFN) of WINDOW)                         (replace (WINDOW CURSOROUTFN) of WINDOW with VALUE)))        (CURSORMOVEDFN (PROG1 (fetch (WINDOW CURSORMOVEDFN) of WINDOW)                           (replace (WINDOW CURSORMOVEDFN) of WINDOW with VALUE)))        (DSP (ERROR "Can't change DSP of a window" WINDOW))        (SCREEN (ERROR "Can't change SCREEN  of a window" WINDOW))        (RESHAPEFN (PROG1 (fetch (WINDOW RESHAPEFN) of WINDOW)                       (replace (WINDOW RESHAPEFN) of WINDOW with VALUE)))        (REPAINTFN (PROG1 (fetch (WINDOW REPAINTFN) of WINDOW)                       (replace (WINDOW REPAINTFN) of WINDOW with VALUE)))        (EXTENT (PROG1 (fetch (WINDOW EXTENT) of WINDOW)                    (OR (NULL VALUE)                        (REGIONP VALUE)                        (\ILLEGAL.ARG VALUE))                    (replace (WINDOW EXTENT) of WINDOW with VALUE)))        (SCROLLFN (PROG1 (fetch (WINDOW SCROLLFN) of WINDOW)                      (replace (WINDOW SCROLLFN) of WINDOW with VALUE)                      (UPDATE/SCROLL/REG WINDOW)))        (IMAGECOVERED (ERROR "Not implemented to change IMAGECOVERED property." WINDOW))        (HEIGHT (ERROR "Not implemented to change HEIGHT as property." WINDOW))        (WIDTH (ERROR "Not implemented to change WIDTH as property." WINDOW))        (REGION [PROG (CURREGION)                      (SETQ CURREGION (WINDOWPROP WINDOW 'REGION))                      (COND                         ((NOT (REGIONP VALUE))                          (\ILLEGAL.ARG VALUE)))                 (* ;; "there is no check for where the new region is nor how big it is;  this is left to MOVEW and RESHAPEW.")                      (COND                         ((AND (EQ (fetch (REGION WIDTH) of CURREGION)                                   (fetch (REGION WIDTH) of VALUE))                               (EQ (fetch (REGION HEIGHT) of CURREGION)                                   (fetch (REGION HEIGHT) of VALUE)))                                                             (* ;                                                    "width and height are the same, move the window")                          (MOVEW WINDOW (fetch (REGION LEFT) of VALUE)                                 (fetch (REGION BOTTOM) of VALUE)))                         (T                                  (* ; "dimensions changed, reshape it.")                            (SHAPEW WINDOW VALUE])        (NEWREGIONFN (PROG1 (fetch (WINDOW NEWREGIONFN) of WINDOW)                         (replace (WINDOW NEWREGIONFN) of WINDOW with VALUE)))        (TITLE (PROG1 (fetch (WINDOW WTITLE) of WINDOW)                   (COND                      ((type? SCREEN (fetch (WINDOW SCREEN) of WINDOW))                       (RESHOWTITLE VALUE WINDOW))                      ((type? XSCREEN (fetch (WINDOW SCREEN) of WINDOW))                       (replace (WINDOW WTITLE) of WINDOW with VALUE)                       (XSHOWWTITLE VALUE NIL (fetch (WINDOW WBORDER) of WINDOW)                              NIL WINDOW)))))        (BORDER (PROG1 (fetch (WINDOW WBORDER) of WINDOW)                    (COND                       ((NUMBERP VALUE)                        (RESHOWBORDER VALUE WINDOW))                       (T (\ILLEGAL.ARG VALUE)))))        (PROCESS (PROG1 (fetch (WINDOW PROCESS) of WINDOW)                     (replace (WINDOW PROCESS) of WINDOW with VALUE)))        (WINDOWENTRYFN (PROG1 (fetch (WINDOW WINDOWENTRYFN) of WINDOW)                           (replace (WINDOW WINDOWENTRYFN) of WINDOW with VALUE)))        (PROG (OLDDATA OLDVALUE)              (SETQ OLDDATA (fetch (WINDOW USERDATA) of WINDOW))              (RETURN (PROG1 (COND                                (OLDDATA (SETQ OLDVALUE (LISTGET OLDDATA PROP))                                       [COND                                          (VALUE (LISTPUT OLDDATA PROP VALUE))                                          (OLDVALUE          (* Remove the property)                                                 (COND                                                    ((EQ (CAR OLDDATA)                                                         PROP)                                                     (replace (WINDOW USERDATA) of WINDOW                                                        with (CDDR OLDDATA)))                                                    (T (for TAIL on (CDR OLDDATA)                                                          by (CDDR TAIL)                                                          when (EQ (CADR TAIL)                                                                       PROP)                                                          do (FRPLACD TAIL (CDDDR TAIL))                                                                (RETURN]                                       OLDVALUE)                                (VALUE (replace (WINDOW USERDATA) of WINDOW                                          with (LIST PROP VALUE))                                                             (* know old value is NIL)                                       NIL))                          (COND                             ((AND (fetch (WINDOW WTITLE) of WINDOW)                                   (EQ PROP 'WINDOWTITLESHADE))                                                             (* change windowtitleshade.)                              (RESHOWTITLE (fetch (WINDOW WTITLE) of WINDOW)                                     WINDOW T))))])(RESHOWBORDER  [LAMBDA (BORDER WINDOW)                              (* ; "Edited 27-Feb-91 17:15 by matsuda")    (* ;; "updates a windows display with a new border")                                                             (* ;                                                 "if the border is the same, don't change anything.")    (OR (EQ BORDER (fetch (WINDOW WBORDER) of WINDOW))        (COND           ((type? SCREEN (fetch (WINDOW SCREEN) of WINDOW))            (\RESHOWBORDER1 BORDER (fetch (WINDOW WBORDER) of WINDOW)                   WINDOW))           ((type? XSCREEN (fetch (WINDOW SCREEN) of WINDOW))            (\XRESHOWBORDER1 BORDER (fetch (WINDOW WBORDER) of WINDOW)                   WINDOW])(\XRESHOWBORDER1  [LAMBDA (NEWBORDER OLDBORDER WINDOW)                 (* ; "Edited 27-Feb-91 17:45 by matsuda")    (PROG ((REGION (fetch (WINDOW REG) of WINDOW))           (OLDSAVE (fetch (WINDOW SAVE) of WINDOW))           DELTA NUWIDTH NUHEIGHT XBASEW)          (SETQ DELTA (IDIFFERENCE NEWBORDER OLDBORDER))          (SETQ NUWIDTH (IPLUS (fetch (REGION WIDTH) of REGION)                               (ITIMES DELTA 2)))          [SETQ NUHEIGHT (IDIFFERENCE (IPLUS (fetch (REGION HEIGHT)                                                of (DSPCLIPPINGREGION NIL (fetch (WINDOW                                                                                          DSP)                                                                                 of WINDOW)))                                             (ITIMES NEWBORDER 2))                                (COND                                   [(fetch (WINDOW WTITLE) of WINDOW)                                    (DSPLINEFEED NIL (fetch (XSCREEN SCTITLEDS)                                                        of (fetch (WINDOW SCREEN)                                                                  of WINDOW]                                   (T 0]          (replace (WINDOW WBORDER) of WINDOW with NEWBORDER)          (CL:SETF (XLIB:DRAWABLE-BORDER-WIDTH OLDSAVE)                 (IMAX (FOLDHI NEWBORDER 2)                       (IDIFFERENCE NEWBORDER 2)))          (replace (WINDOW REG) of WINDOW with (create REGION                                                                  LEFT _ (IDIFFERENCE                                                                          (fetch (REGION LEFT)                                                                             of REGION)                                                                          DELTA)                                                                  BOTTOM _ (IDIFFERENCE                                                                            (fetch (REGION BOTTOM                                                                                              )                                                                               of REGION)                                                                            DELTA)                                                                  WIDTH _ NUWIDTH                                                                  HEIGHT _ NUHEIGHT))          (SETQ XBASEW (WINDOWPROP WINDOW 'XBASEW))          (if (SETQ XBASEW (WINDOWPROP WINDOW 'XBASEW))              then (CL:SETF (XLIB:DRAWABLE-WIDTH XBASEW)                              NUWIDTH)                    (CL:SETF (XLIB:DRAWABLE-HEIGHT XBASEW)                           NUHEIGHT))          (UPDATE/SCROLL/REG WINDOW)          (XSHOWWFRAME WINDOW])(\GETWINDOWHEIGHT  [LAMBDA (WINDOW)                                     (* ; "Edited 27-Feb-91 16:24 by matsuda")    (* ;; "calculate the height from the REGION in case user has changed the clipping region.  This won't work if the height of the title display stream has changed.")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (DIFFERENCE (fetch (REGION HEIGHT) of (fetch (WINDOW REG) of WINDOW))           (DIFFERENCE (ITIMES 2 (fetch (WINDOW WBORDER) of WINDOW))                  (COND                     [(fetch (WINDOW WTITLE) of WINDOW)                      (DSPLINEFEED NIL (COND                                          ((type? SCREEN (fetch (WINDOW SCREEN) of WINDOW                                                                    ))                                           (fetch (SCREEN SCTITLEDS) of (fetch                                                                                 (WINDOW SCREEN)                                                                                   of WINDOW)))                                          ((TYPE? XSCREEN (fetch (WINDOW SCREEN) of                                                                                         WINDOW))                                           (fetch (XSCREEN SCTITLEDS) of (fetch                                                                                  (WINDOW SCREEN)                                                                                    of WINDOW]                     (T 0]))(DEFINEQ(XWHICHW  [LAMBDA NIL                                          (* ; "Edited 10-Apr-91 14:11 by matsuda")    XLASTWINDOW]))(DEFINEQ(TOTOPW  [LAMBDA (WINDOW NOCALLTOTOPFNFLG)                      (* ; "Edited  2-Oct-91 15:13 by jn")    (* ;; "user entry to bring a window to the top.  Unless NOCALLTOTOPFNFLG is non-NIL, it will call the windows TOTOPFN")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (COND       [(type? XSCREEN (fetch (WINDOW SCREEN) of WINDOW))        (XLIB:CIRCULATE-WINDOW-UP (WINDOWPROP WINDOW 'XBASEW]       ((EQ WINDOW (fetch (SCREEN SCTOPW) of (fetch (WINDOW SCREEN) of WINDOW)))        (PROGN                                               (* (SETQ \TOPWDS (fetch                                                           (WINDOW DSP) of WINDOW)))               NIL))       ((OPENWP WINDOW)        (OR NOCALLTOTOPFNFLG (DOUSERFNS (WINDOWPROP WINDOW 'TOTOPFN)                                    WINDOW))        (\INTERNALTOTOPW WINDOW))       ((OPENW WINDOW)                                       (* ;                                              "if it is not open, open it and then call the TOTOPFN")        (OR NOCALLTOTOPFNFLG (DOUSERFNS (WINDOWPROP WINDOW 'TOTOPFN)                                    WINDOW)))       (T                                                    (* ;                                                "window won't open probably because of DON'T OPENFN")          (ERROR "Window won't open; Can't be brought to top." WINDOW)))    WINDOW]))(DEFINEQ(XSHAPEW1  [LAMBDA (WINDOW REGION)    (DECLARE (LOCALVARS . T))                      (* ; "Edited 16-Feb-91 16:14 by matsuda")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (OR (REGIONP REGION)        (\ILLEGAL.ARG REGION))    (PROG ((OLDREGION (fetch (WINDOW REG) of WINDOW))           (OLDCLIPREG (DSPCLIPPINGREGION NIL (fetch (WINDOW DSP) of WINDOW)))           (WBORDER (fetch (WINDOW WBORDER) of WINDOW))           SCREEN NUSAV NOWOPEN?)          (SETQ SCREEN (fetch (WINDOW SCREEN) of WINDOW))          (UNINTERRUPTABLY                                                             (* ; "Save window image")              (replace (WINDOW REG) of WINDOW with REGION)              (ADVISEXWDS WINDOW OLDREGION)              (XSHOWWFRAME WINDOW))                      (* ; " (DOUSERFNS2 (OR (fetch (WINDOW RESHAPEFN) of WINDOW) (FUNCTION RESHAPEBYREPAINTFN)) WINDOW NUSAV (create REGION LEFT _ WBORDER BOTTOM _ WBORDER WIDTH _ (fetch (REGION WIDTH) of OLDCLIPREG) HEIGHT _ (fetch (REGION HEIGHT) of OLDCLIPREG)) OLDREGION)")          (RETURN WINDOW])(XMOVEW  [LAMBDA (WINDOW POSorX Y)                            (* ; "Edited  7-Mar-91 14:24 by matsuda")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (PROG ((OLDREGION (fetch (WINDOW REG) of WINDOW))           (USERMOVEFN (fetch (WINDOW MOVEFN) of WINDOW))           POS NEWREGION OLDLEFT OLDBOTTOM OLDWIDTH OLDHEIGHT XBASEW)          (COND             ([COND                 ((LISTP USERMOVEFN)                  (FMEMB 'DON'T USERMOVEFN))                 (T (EQ USERMOVEFN 'DON'T]              (PROMPTPRINT "This window cannot be moved.")              (RETURN)))          (SETQ OLDLEFT (fetch (REGION LEFT) of OLDREGION))          (SETQ OLDBOTTOM (ffetch (REGION BOTTOM) of OLDREGION))          (SETQ OLDWIDTH (ffetch (REGION WIDTH) of OLDREGION))          (SETQ OLDHEIGHT (ffetch (REGION HEIGHT) of OLDREGION))          (COND             [(AND POSorX (SETQ POS (COND                                       ((POSITIONP POSorX)                                        POSorX)                                       [(NUMBERP POSorX)                                        (COND                                           ((NUMBERP Y)                                            (create POSITION                                                   XCOORD _ POSorX                                                   YCOORD _ Y))                                           (T (\ILLEGAL.ARG Y]                                       ((REGIONP POSorX)                                        (create POSITION                                               XCOORD _ (fetch (REGION LEFT) of POSorX)                                               YCOORD _ (fetch (REGION BOTTOM) of POSorX)))                                       (T (\ILLEGAL.ARG POSorX]             (T (\ILLEGAL.ARG POSorX)))          [COND             ((AND (LISTP USERMOVEFN)                   (NOT (FMEMB (CAR USERMOVEFN)                               LAMBDASPLST)))              (AND (EQ [for MFN in USERMOVEFN do (SETQ NEWREGION (APPLY* MFN WINDOW POS))                                                            (COND                                                               ((EQ NEWREGION 'DON'T)                                                                (RETURN 'DON'T))                                                               ((POSITIONP NEWREGION)                                                                (SETQ POS NEWREGION]                       'DON'T)                   (RETURN)))             (USERMOVEFN (SETQ NEWREGION (APPLY* USERMOVEFN WINDOW POS))                    (COND                       ((EQ NEWREGION 'DON'T)                        (RETURN))                       ((POSITIONP NEWREGION)                        (SETQ POS NEWREGION]          (COND             ((OR (NOT (EQ (fetch (POSITION XCOORD) of POS)                           OLDLEFT))                  (NOT (EQ (fetch (POSITION YCOORD) of POS)                           OLDBOTTOM)))              (SETQ NEWREGION (create REGION                                     LEFT _ (ffetch (POSITION XCOORD) of POS)                                     BOTTOM _ (ffetch (POSITION YCOORD) of POS)                                     WIDTH _ OLDWIDTH                                     HEIGHT _ OLDHEIGHT))              (UNINTERRUPTABLY                  [COND                     ((SETQ XBASEW (WINDOWPROP WINDOW 'XBASEW))                      (XLIB:WITH-STATE (XBASEW)                             (CL:SETF (XLIB:DRAWABLE-Y XBASEW)                                    (IDIFFERENCE (fetch (XSCREEN SCHEIGHT) of \XSCREEN)                                           (fetch (REGION TOP) of NEWREGION)))                             (CL:SETF (XLIB:DRAWABLE-X XBASEW)                                    (fetch (REGION LEFT) of NEWREGION]                  (replace (WINDOW REG) of WINDOW with NEWREGION)                  (ADVISEXWDS WINDOW OLDREGION T))              (DOUSERFNS (WINDOWPROP WINDOW 'AFTERMOVEFN)                     WINDOW)))          (RETURN POS])(XMOVEW1  [LAMBDA (WINDOW POSorX Y)                            (* ; "Edited 16-Feb-91 18:04 by matsuda")    (SETQ WINDOW (\INSUREWINDOW WINDOW))    (PROG ((OLDREGION (fetch (WINDOW REG) of WINDOW))           OLDLEFT OLDBOTTOM OLDWIDTH OLDHEIGHT POS NEWREGION REG)          (SETQ OLDLEFT (fetch (REGION LEFT) of OLDREGION))          (SETQ OLDBOTTOM (ffetch (REGION BOTTOM) of OLDREGION))          (SETQ OLDWIDTH (ffetch (REGION WIDTH) of OLDREGION))          (SETQ OLDHEIGHT (ffetch (REGION HEIGHT) of OLDREGION))          [AND POSorX (SETQ POS (COND                                   ((POSITIONP POSorX)                                    POSorX)                                   [(NUMBERP POSorX)                                    (COND                                       ((NUMBERP Y)                                        (create POSITION                                               XCOORD _ POSorX                                               YCOORD _ Y))                                       (T (\ILLEGAL.ARG Y]                                   ((REGIONP POSorX)                                    (create POSITION                                           XCOORD _ (fetch (REGION LEFT) of POSorX)                                           YCOORD _ (fetch (REGION BOTTOM) of POSorX)))                                   (T (\ILLEGAL.ARG POSorX]          (COND             ((OR (NOT (EQ (fetch (POSITION XCOORD) of POS)                           OLDLEFT))                  (NOT (EQ (ffetch (POSITION YCOORD) of POS)                           OLDBOTTOM)))              (SETQ NEWREGION (create REGION                                     LEFT _ (ffetch (POSITION XCOORD) of POS)                                     BOTTOM _ (ffetch (POSITION YCOORD) of POS)                                     WIDTH _ OLDWIDTH                                     HEIGHT _ OLDHEIGHT))              (UNINTERRUPTABLY                  (replace (WINDOW REG) of WINDOW with NEWREGION)                  (ADVISEXWDS WINDOW OLDREGION T))              (DOUSERFNS (WINDOWPROP WINDOW 'AFTERMOVEFN)                     WINDOW])(XMOVEORRESIZED.WINDOW  [LAMBDA (WINDOW X Y WIDTH HEIGHT)                    (* ; "Edited 11-Apr-91 09:37 by matsuda")    (PROG ((NEXTW (fetch (XSCREEN SCTOPW) of \XSCREEN))           XBASEW OLDREG NEWREG)      LOOP          (COND             (NEXTW (SETQ XBASEW (WINDOWPROP NEXTW 'XBASEW))                    (COND                       [(EQ WINDOW XBASEW)                        (SETQ OLDREG (fetch (WINDOW REG)                                            NEXTW))                        (SETQ NEWREG (create REGION                                            LEFT _ X                                            BOTTOM _ (IDIFFERENCE (fetch (XSCREEN SCHEIGHT)                                                                     of \XSCREEN)                                                            (IPLUS Y HEIGHT))                                            WIDTH _ WIDTH                                            HEIGHT _ HEIGHT))                        (COND                           ((AND (EQ (fetch (REGION WIDTH) of OLDREG)                                     WIDTH)                                 (EQ (fetch (REGION HEIGHT) of OLDREG)                                     HEIGHT))                            (XMOVEW1 NEXTW (fetch (REGION LEFT) of NEWREG)                                   (fetch (REGION BOTTOM) of NEWREG)))                           (T (XSHAPEW1 NEXTW NEWREG]                       (T (SETQ NEXTW (fetch (WINDOW NEXTW) of NEXTW))                          (GO LOOP])(XMOVED.WINDOW  [LAMBDA (WINDOW)                                     (* ; "Edited  1-Feb-91 16:48 by matsuda")    NIL]))(RPAQ? \XSCREEN NIL)(ADDTOVAR \DISPLAYSTREAMTYPES XDISPLAY)(ADDTOVAR IMAGESTREAMTYPES (XDISPLAY (OPENSTREAM NILL)                                      (FONTCREATE \CREATEXDISPLAYFONT)                                      (FONTSAVAILABLE NILL)                                      (CREATECHARSET NILL)))(FILESLOAD XLLKEY XLLBITMAP XLLCURSOR XLLMOUSE XLLFONT XSERVER XWATCHER)(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDTOVAR NLAMA )(ADDTOVAR NLAML )(ADDTOVAR LAMA XLIB::SETUP-CLX))(PUTPROPS XMAS COPYRIGHT ("Venue" 1991))(DECLARE%: DONTCOPY  (FILEMAP (NIL (11150 12401 (XLIB::SETUP-CLX 11160 . 12399)) (12402 80675 (\XDISPLAYINIT 12412 . 17445) (CREATEXSCREEN 17447 . 19460) (BITSPERPIXEL 19462 . 20487) (BITMAPHEIGHT 20489 . 20949) (BITMAPWIDTH 20951 . 21406) (DSPDESTINATION 21408 . 25038) (XDSPCREATE 25040 . 26540) (\DSPOPERATION.XDISPLAY 26542 . 27406) (\DSPRESET.XDISPLAY 27408 . 29848) (\BLTSHADE.XDISPLAY 29850 . 35267) (\BITBLT.XDISPLAY 35269 . 40602) (\XBITBLTSUB 40604 . 42083) (\XBLTSHADE.PIXMAP 42085 . 45581) (\XBITBLT.PIXMAP 45583 . 49709) (\DRAWPOINT.XDISPLAY 49711 . 50368) (\DRAWLINE.XDISPLAY 50370 . 53414) (\XLINEWITHBRUSH 53416 . 61792) (\DRAWCIRCLE.XDISPLAY 61794 . 66819) (\DRAWCURVE.XDISPLAY 66821 . 68378) (\XCURVE2 68380 . 75910) (\XCURVE 75912 . 80673)) (80676 91382 (BITBLT 80686 . 91380)) (91383 93367 (XCREATEWFROMPIXMAP 91393 . 92408) (PIXMAPCREATE 92410 . 92748) (PIXMAPWIDTH 92750 . 93055) (PIXMAPHEIGHT 93057 . 93365)) (93368 117849 (XCREATEW 93378 . 95995) (ADVISEXWDS 95997 . 102452) (XOPENW 102454 . 103586) (\XOPENW1 103588 . 105484) (XCLOSEW 105486 . 105815) (\XCLOSEW1 105817 . 107434) (\XSFFixClippingRegion 107436 . 109725) (XSHOWWFRAME 109727 . 112983) (XSHOWWTITLE 112985 . 115389) (\XCREATEBASEW 115391 . 117085) (\DSPCLIPPINGREGION.XDISPLAY 117087 . 117847)) (117850 133562 (\XDSPPRINTCHAR 117860 . 125664) (\XBLTCHAR 125666 . 128836) (\XDSPPRINTCR/LF 128838 . 133560)) (133563 148886 (OPENWINDOWS 133573 . 134579) (\INSURESCREEN 134581 . 134893) (DSPSOURCETYPE 134895 . 136365) (PUTWINDOWPROP 136367 . 143483) (RESHOWBORDER 143485 . 144286) (\XRESHOWBORDER1 144288 . 147269) (\GETWINDOWHEIGHT 147271 . 148884)) (148887 149034 (XWHICHW 148897 . 149032)) (149035 150494 (TOTOPW 149045 . 150492)) (150495 159902 (XSHAPEW1 150505 . 151645) (XMOVEW 151647 . 155883) (XMOVEW1 155885 . 158159) (XMOVEORRESIZED.WINDOW 158161 . 159765) (XMOVED.WINDOW 159767 . 159900)))))STOP