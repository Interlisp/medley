(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "SYSTEM")(IL:FILECREATED "16-May-90 12:12:42" IL:|{DSK}<usr>local>lde>lispcore>sources>BREAK-AND-TRACE.;2| 38319        IL:|changes| IL:|to:|  (IL:VARS IL:BREAK-AND-TRACECOMS)      IL:|previous| IL:|date:| "12-Jul-88 18:49:08" IL:|{DSK}<usr>local>lde>lispcore>sources>BREAK-AND-TRACE.;1|); Copyright (c) 1987, 1988, 1990 by Venue & Xerox Corporation.  All rights reserved.(IL:PRETTYCOMPRINT IL:BREAK-AND-TRACECOMS)(IL:RPAQQ IL:BREAK-AND-TRACECOMS          ((IL:* IL:|;;;| "Support for tracing.")           (IL:VARIABLES XCL:*TRACE-DEPTH* XCL::*TRACED-FNS* IL:TRACEREGION)           (IL:FUNCTIONS XCL:CREATE-TRACE-WINDOW)           (IL:FUNCTIONS CREATE-TRACED-DEFINITION CONSTRUCT-ENTRY-PRINTING-CODE                   PRINT-TRACE-ENTRY-INFO PRINT-TRACE-EXIT-INFO PRINT-TRACED-ARGUMENT                   PRINT-TRACED-CL-ARGLIST)           (IL:VARIABLES XCL:*TRACE-LEVEL* XCL:*TRACE-LENGTH* XCL:*TRACE-VERBOSE* *TRACE-OUTPUT*)           (IL:FNS TRACE UNTRACE)           (IL:FUNCTIONS XCL:TRACE-FUNCTION)           (IL:* IL:|;;;| "Support for breaking.")           (IL:FUNCTIONS XCL:BREAK-FUNCTION XCL:UNBREAK-FUNCTION XCL:REBREAK-FUNCTION                   CREATE-BROKEN-DEFINITION UNBREAK-FROM-RESTORE-CALLS FINISH-UNBREAKING)           (IL:VARIABLES IL:BROKENFNS XCL::*BREAK-HASH-TABLE* XCL::*UNBROKEN-FNS*)           (IL:PROP IL:PROPTYPE IL:BROKEN)                      (IL:* IL:|;;| "The old Interlisp interface to breaking.")           (IL:FNS IL:BREAK IL:BREAK0 IL:REBREAK XCL:UNBREAK IL:UNBREAK0)           (IL:FNS IL:BREAK1)           (IL:SPECIAL-FORMS IL:BREAK1)           (XCL:OPTIMIZERS IL:BREAK1)                      (IL:* IL:|;;| "Arrange for the proper compiler and package")           (IL:PROP (IL:FILETYPE IL:MAKEFILE-ENVIRONMENT)                  IL:BREAK-AND-TRACE)           (IL:DECLARE\: IL:DONTEVAL@LOAD IL:DOEVAL@COMPILE IL:DONTCOPY IL:COMPILERVARS                  (IL:ADDVARS (IL:NLAMA XCL:UNBREAK IL:REBREAK IL:BREAK UNTRACE TRACE)                         (IL:NLAML IL:BREAK1)                         (IL:LAMA)))))(IL:* IL:|;;;| "Support for tracing.")(DEFVAR XCL:*TRACE-DEPTH* 0)(DEFVAR XCL::*TRACED-FNS* NIL(IL:* IL:|;;;| "A subset of the entries on IL:BROKENFNS, being those that resulted from calls to TRACE as opposed to calls to BREAK-FUNCTION.")   )(DEFVAR IL:TRACEREGION (IL:|create| IL:REGION                                  IL:LEFT IL:_ 8                                  IL:BOTTOM IL:_ 3                                  IL:WIDTH IL:_ 547                                  IL:HEIGHT IL:_ 310))(DEFUN XCL:CREATE-TRACE-WINDOW (&KEY (XCL::REGION IL:TRACEREGION)                                         (XCL::OPEN? NIL)                                         (XCL::TITLE "*Trace-Output*"))(IL:* IL:|;;;| "Create and return a window suitable for use as the value of *TRACE-OUTPUT*.")(IL:* IL:|;;;| "REGION is the initial region of the window.  It defaults to the value of IL:TRACEREGION.")(IL:* IL:|;;;| "OPEN? is true if the newly-created window should be opened on the screen immediately.  If false, the window will open the first time any output is sent to it.")   (LET ((XCL::WINDOW (IL:CREATEW XCL::REGION XCL::TITLE NIL (NOT XCL::OPEN?))))        (IL:DSPSCROLL 'IL:ON XCL::WINDOW)        XCL::WINDOW))(DEFUN CREATE-TRACED-DEFINITION (TRACED-FN IN-FN FN-TO-CALL)   (MULTIPLE-VALUE-BIND    (LAMBDA-CAR ARG-LIST CALLING-FORM)    (FUNCTION-WRAPPER-INFO TRACED-FN FN-TO-CALL)    `(,LAMBDA-CAR ,(IF (EQ LAMBDA-CAR 'LAMBDA)                       '(&REST XCL:ARGLIST)                       ARG-LIST)            ,@(AND ARG-LIST (MEMBER LAMBDA-CAR '(IL:LAMBDA IL:NLAMBDA))                   `((DECLARE (SPECIAL ,@(IF (SYMBOLP ARG-LIST)                                                 (LIST ARG-LIST)                                                 ARG-LIST)))))            (IL:\\CALLME '(:TRACED ,(IF (NULL IN-FN)                                        TRACED-FN                                        `(,TRACED-FN :IN ,IN-FN))))            (LET* (($THE-REAL-TRACE-OUTPUT$ (XCL:FOLLOW-SYNONYM-STREAMS (IL:\\GETSTREAM                                                                                *TRACE-OUTPUT*)))                   ($IMAGE-STREAM?$ (IL:IMAGESTREAMP $THE-REAL-TRACE-OUTPUT$)))                  (LET ((*STANDARD-OUTPUT* $THE-REAL-TRACE-OUTPUT$)                        (IL:FONTCHANGEFLG $IMAGE-STREAM?$))                       (DECLARE (SPECIAL IL:FONTCHANGEFLG))                       ,@(CONSTRUCT-ENTRY-PRINTING-CODE TRACED-FN IN-FN LAMBDA-CAR ARG-LIST))                  (LET (($TRACED-FN-VALUES$ (MULTIPLE-VALUE-LIST (LET ((XCL:*TRACE-DEPTH*                                                                        (1+ XCL:*TRACE-DEPTH*)))                                                                      ,CALLING-FORM))))                       (LET ((*STANDARD-OUTPUT* $THE-REAL-TRACE-OUTPUT$)                             (IL:FONTCHANGEFLG $IMAGE-STREAM?$))                            (DECLARE (SPECIAL IL:FONTCHANGEFLG))                            (PRINT-TRACE-EXIT-INFO ',TRACED-FN ',IN-FN $TRACED-FN-VALUES$))                       (VALUES-LIST $TRACED-FN-VALUES$))))))(DEFUN CONSTRUCT-ENTRY-PRINTING-CODE (TRACED-FN IN-FN LAMBDA-CAR ARG-LIST)   `((PRINT-TRACE-ENTRY-INFO ',TRACED-FN ',IN-FN)     (LET      ((*PRINT-LEVEL* XCL:*TRACE-LEVEL*)       (*PRINT-LENGTH* XCL:*TRACE-LENGTH*))      ,@(CASE LAMBDA-CAR            ((IL:LAMBDA IL:NLAMBDA)                (IL:IF (LISTP ARG-LIST)                   IL:THEN                          (IL:* IL:|;;|                   "Interlisp spread function.  The ARG-LIST is, in fact, a list of argument names.")                         `((LET (($$INDENT$$ (+ 10 (* XCL:*TRACE-DEPTH* 4))))                                ,@(IL:FOR VAR IL:IN ARG-LIST                                     IL:COLLECT `(PRINT-TRACED-ARGUMENT ',VAR ,VAR $$INDENT$$))))                 IL:ELSEIF (EQ LAMBDA-CAR 'IL:LAMBDA)                   IL:THEN                          (IL:* IL:|;;|                 "Interlisp Lambda no-spread function.  Print out at most *TRACE-LENGTH* arguments.")                         `((IL:BIND ($$INDENT$$ IL:_ (+ 10 (* XCL:*TRACE-DEPTH* 4))) IL:FOR                                                                                                                                                                                 $ARG-COUNTER$                              IL:FROM 1 IL:TO (IF (NULL XCL:*TRACE-LENGTH*)                                                          ,ARG-LIST                                                          (MIN XCL:*TRACE-LENGTH* ,ARG-LIST))                              IL:DO (PRINT-TRACED-ARGUMENT $ARG-COUNTER$ (IL:ARG ,ARG-LIST                                                                                     $ARG-COUNTER$)                                               $$INDENT$$)))                 IL:ELSE                        (IL:* IL:|;;| "Interlisp NLambda no-spread function.  Print out at most *TRACE-LENGTH* arguments.  Also, be careful to check that the argument list is really a list.")                       `((LET (($$INDENT$$ (+ 10 (* XCL:*TRACE-DEPTH* 4))))                              (IF (LISTP ,ARG-LIST)                                  (IL:FOR $ARGUMENT$ IL:IN ,ARG-LIST IL:AS $ARG-COUNTER$                                     IL:FROM 1 IL:WHILE (OR (NULL XCL:*TRACE-LENGTH*)                                                                    (<= $ARG-COUNTER$                                                                         XCL:*TRACE-LENGTH*))                                     IL:DO (PRINT-TRACED-ARGUMENT $ARG-COUNTER$ $ARGUMENT$                                                       $$INDENT$$))                                  (PRINT-TRACED-ARGUMENT ',ARG-LIST ,ARG-LIST $$INDENT$$))))))            ((LAMBDA)                (IL:* IL:|;;| "A Common Lisp function.")               (MULTIPLE-VALUE-BIND (REQUIRED OPTIONAL REST KEY KEY-APPEARED? ALLOW-OTHER-KEYS)                      (PARSE-CL-ARGLIST ARG-LIST)                      `((PRINT-TRACED-CL-ARGLIST XCL:ARGLIST ',REQUIRED ',OPTIONAL                               ',REST                               ',KEY                               ,KEY-APPEARED?                               ,ALLOW-OTHER-KEYS                               (+ 8 (* XCL:*TRACE-DEPTH* 4))                               XCL:*TRACE-VERBOSE*))))))))(DEFUN PRINT-TRACE-ENTRY-INFO (TRACED-FN IN-FN)   (DECLARE (SPECIAL IL:BOLDFONT IL:DEFAULTFONT))   (IL:SPACES (* XCL:*TRACE-DEPTH* 4))   (PRINC (1+ XCL:*TRACE-DEPTH*))   (PRINC " - Enter ")   (IL:CHANGEFONT IL:BOLDFONT)   (PRIN1 TRACED-FN)   (IL:CHANGEFONT IL:DEFAULTFONT)   (WHEN (NOT (NULL IN-FN))       (PRINC " in ")       (IL:CHANGEFONT IL:BOLDFONT)       (PRIN1 IN-FN)       (IL:CHANGEFONT IL:DEFAULTFONT))   (PRINC ":")   (TERPRI))(DEFUN PRINT-TRACE-EXIT-INFO (TRACED-FN IN-FN FN-VALUES)   (DECLARE (SPECIAL IL:BOLDFONT IL:DEFAULTFONT))   (IL:SPACES (* XCL:*TRACE-DEPTH* 4))   (PRINC (1+ XCL:*TRACE-DEPTH*))   (PRINC " - Exit ")   (IL:CHANGEFONT IL:BOLDFONT)   (PRIN1 TRACED-FN)   (IL:CHANGEFONT IL:DEFAULTFONT)   (WHEN (NOT (NULL IN-FN))       (PRINC " in ")       (IL:CHANGEFONT IL:BOLDFONT)       (PRIN1 IN-FN)       (IL:CHANGEFONT IL:DEFAULTFONT))   (PRINC " =>")   (TERPRI)   (IL:FOR VALUE IL:IN FN-VALUES IL:DO (IL:SPACES (+ 10 (* XCL:*TRACE-DEPTH* 4)))                                               (PRIN1 VALUE)                                               (TERPRI)))(DEFUN PRINT-TRACED-ARGUMENT (NAME VALUE INDENT &OPTIONAL PRIN1-THE-NAME?)   (IL:SPACES INDENT)   (WHEN (TYPEP NAME 'FIXNUM)         (PRINC "Arg "))   (IF PRIN1-THE-NAME?       (PRIN1 NAME)       (PRINC NAME))   (PRINC " = ")   (PRIN1 VALUE)   (TERPRI))(DEFUN PRINT-TRACED-CL-ARGLIST (ARGS REQUIRED OPTIONAL REST KEY KEY-APPEARED? ALLOW-OTHER-KEYS                                          SMALL-INDENT VERBOSE?)   (DECLARE (SPECIAL IL:BOLDFONT IL:DEFAULTFONT))   (LET* ((INDENT (+ SMALL-INDENT 2)))         (WHEN REQUIRED             (IL:FOR VAR IL:IN REQUIRED IL:DO (COND                                                             ((NULL ARGS)                                                              (IL:SPACES INDENT)                                                              (PRINC VAR)                                                              (IL:CHANGEFONT IL:BOLDFONT)                                                              (PRINC " ** NOT SUPPLIED **")                                                              (IL:CHANGEFONT IL:DEFAULTFONT)                                                              (TERPRI))                                                             (T (PRINT-TRACED-ARGUMENT VAR                                                                       (POP ARGS)                                                                       INDENT)))))         (WHEN OPTIONAL             (WHEN VERBOSE?                 (IL:SPACES SMALL-INDENT)                 (PRINC '&OPTIONAL)                 (TERPRI))             (IL:FOR VAR IL:IN OPTIONAL IL:DO (IF (NULL ARGS)                                                              (WHEN VERBOSE?                                                                  (IL:SPACES INDENT)                                                                  (PRINC VAR)                                                                  (PRINC " not supplied")                                                                  (TERPRI))                                                              (PRINT-TRACED-ARGUMENT VAR (POP ARGS)                                                                     INDENT))))         (WHEN REST             (WHEN VERBOSE?                 (IL:SPACES SMALL-INDENT)                 (PRINC '&REST)                 (TERPRI))             (PRINT-TRACED-ARGUMENT REST ARGS INDENT))         (WHEN KEY             (WHEN VERBOSE?                 (IL:SPACES SMALL-INDENT)                 (PRINC '&KEY)                 (TERPRI))             (IL:FOR VAR IL:IN KEY IL:DO (IL:FOR TAIL IL:ON ARGS IL:BY CDDR                                                        IL:DO (WHEN (EQ VAR (CAR TAIL))                                                                      (PRINT-TRACED-ARGUMENT                                                                       VAR                                                                       (CADR TAIL)                                                                       INDENT T)                                                                      (RETURN)))))         (WHEN KEY-APPEARED?             (LET (TEMP)                  (COND                     ((ODDP (LENGTH ARGS))                      (IL:SPACES SMALL-INDENT)                      (IL:CHANGEFONT IL:BOLDFONT)                      (PRINC "** Odd-length &KEY argument list: **")                      (IL:CHANGEFONT IL:DEFAULTFONT)                      (TERPRI)                      (IL:SPACES INDENT)                      (PRIN1 ARGS)                      (TERPRI))                     ((SETQ TEMP (IL:FIND KEYWORD IL:IN ARGS IL:BY (CDDR KEYWORD)                                    IL:SUCHTHAT (IF ALLOW-OTHER-KEYS                                                        (NOT (KEYWORDP KEYWORD))                                                        (NOT (MEMBER KEYWORD KEY :TEST 'EQ)))))                      (IL:SPACES SMALL-INDENT)                      (IL:CHANGEFONT IL:BOLDFONT)                      (PRINC "** Illegal &KEY argument: **")                      (IL:CHANGEFONT IL:DEFAULTFONT)                      (TERPRI)                      (IL:SPACES INDENT)                      (PRIN1 TEMP)                      (TERPRI)))))         (WHEN (AND (NOT REST)                    (NOT KEY-APPEARED?)                    (NOT (NULL ARGS)))             (IL:SPACES SMALL-INDENT)             (IL:CHANGEFONT IL:BOLDFONT)             (PRINC "** Extra arguments: **")             (IL:CHANGEFONT IL:DEFAULTFONT)             (TERPRI)             (IL:SPACES INDENT)             (PRIN1 ARGS)             (TERPRI))))(DEFVAR XCL:*TRACE-LEVEL* NIL(IL:* IL:|;;;| "What to bind *PRINT-LEVEL* to when printing argument values in TRACE output.")   )(DEFVAR XCL:*TRACE-LENGTH* NIL(IL:* IL:|;;;| "What to bind *PRINT-LENGTH* to during the printing of argument values in TRACE output.  Also controls the number of arguments to no-spread functions that will be printed.")   )(DEFVAR XCL:*TRACE-VERBOSE* T(IL:* IL:|;;;| "Controls whether or not various parts of TRACE output are printed:")   (IL:* IL:|;;| "The lambda-list keywords &OPTIONAL, &REST, and &KEY.")   (IL:* IL:|;;| "Trailing unsupplied &OPTIONAL arguments.")   )(DEFVAR *TRACE-OUTPUT* (XCL:CREATE-TRACE-WINDOW))(IL:DEFINEQ(trace  (il:nlambda cl::fns                                 (il:* il:\; "Edited  2-Apr-87 16:10 by Pavel")    (setq cl::fns (il:nlambda.args cl::fns))    (if (null cl::fns)        xcl::*traced-fns*        (il:for cl::fn il:in cl::fns il:join (if (consp cl::fn)                                                 (xcl:trace-function (first cl::fn)                                                        :in                                                        (third cl::fn))                                                 (xcl:trace-function cl::fn))))))(untrace  (il:nlambda cl::fns                                 (il:* il:\; "Edited  2-Apr-87 16:39 by Pavel")    (setq cl::fns (il:nlambda.args cl::fns))    (flet ((cl::untrace-entry (cl::entry)                  (if (consp cl::entry)                      (xcl:unbreak-function (first cl::entry)                             :in                             (second cl::entry))                      (xcl:unbreak-function cl::entry))))          (cond             ((null cl::fns)              (il:for cl::entry il:in (reverse xcl::*traced-fns*) il:join (cl::untrace-entry                                                                                  cl::entry)))             ((equal cl::fns '(t))              (when xcl::*traced-fns* (cl::untrace-entry (car xcl::*traced-fns*))))             (t (il:for cl::fn il:in cl::fns il:join (if (consp cl::fn)                                                         (xcl:unbreak-function (first cl::fn)                                                                :in                                                                (third cl::fn))                                                         (xcl:unbreak-function cl::fn)))))))))(DEFUN XCL:TRACE-FUNCTION (XCL::FN-TO-TRACE &KEY ((:IN XCL::IN-FN))                                     XCL::REBREAK?)   (COND      ((CONSP XCL::FN-TO-TRACE)       (IL:FOR XCL::FN IL:IN XCL::FN-TO-TRACE IL:JOIN (XCL:TRACE-FUNCTION XCL::FN :IN                                                                          XCL::IN-FN)))      ((CONSP XCL::IN-FN)       (IL:FOR XCL::FN IL:IN XCL::IN-FN IL:JOIN (XCL:TRACE-FUNCTION XCL::FN-TO-TRACE :IN                                                                   XCL::FN)))      ((NULL (IL:GETD XCL::FN-TO-TRACE))       (ERROR 'XCL:UNDEFINED-FUNCTION :NAME XCL::FN-TO-TRACE)       NIL)      ((IL:UNSAFE.TO.MODIFY XCL::FN-TO-TRACE "trace")       (FORMAT *ERROR-OUTPUT* "~S not traced.~%" XCL::FN-TO-TRACE)       NIL)      (T (XCL:UNBREAK-FUNCTION XCL::FN-TO-TRACE :IN XCL::IN-FN :NO-ERROR T)         (UNLESS XCL::REBREAK?                               (IL:* IL:\; "Save the breaking information for REBREAK, but don't save it if we're being called from REBREAK itself.")             (SETF (GETHASH (IF (NULL XCL::IN-FN)                                XCL::FN-TO-TRACE                                `(,XCL::FN-TO-TRACE :IN ,XCL::IN-FN))                          XCL::*BREAK-HASH-TABLE*)                   (LIST XCL::FN-TO-TRACE :IN XCL::IN-FN :TRACE? T :REBREAK? T)))         (IF (NULL XCL::IN-FN)             (LET ((XCL::ORIGINAL (LET ((*PRINT-CASE* :UPCASE))                                       (MAKE-SYMBOL (FORMAT NIL "Original ~A" XCL::FN-TO-TRACE)))))                  (IL:PUTD XCL::ORIGINAL (IL:GETD XCL::FN-TO-TRACE)                         T)                  (IL:PUTD XCL::FN-TO-TRACE (COMPILE NIL (CREATE-TRACED-DEFINITION XCL::FN-TO-TRACE                                                                 NIL XCL::ORIGINAL))                         T)                  (SETF (GET XCL::FN-TO-TRACE 'IL:BROKEN)                        XCL::ORIGINAL)                  (PUSH XCL::FN-TO-TRACE IL:BROKENFNS)                  (PUSH XCL::FN-TO-TRACE XCL::*TRACED-FNS*)                  (SETQ XCL::*UNBROKEN-FNS* (DELETE XCL::FN-TO-TRACE XCL::*UNBROKEN-FNS*))                  (LIST XCL::FN-TO-TRACE))             (LET ((XCL::MIDDLE-MAN (CONSTRUCT-MIDDLE-MAN XCL::FN-TO-TRACE XCL::IN-FN)))                  (IF (NOT (HAS-CALLS XCL::IN-FN XCL::FN-TO-TRACE))                      (ERROR "~S is not called from ~S." XCL::FN-TO-TRACE XCL::IN-FN))                  (COMPILE XCL::MIDDLE-MAN (CREATE-TRACED-DEFINITION XCL::FN-TO-TRACE XCL::IN-FN                                                   XCL::FN-TO-TRACE))                  (CHANGE-CALLS XCL::FN-TO-TRACE XCL::MIDDLE-MAN XCL::IN-FN                          'UNBREAK-FROM-RESTORE-CALLS)                  (LET ((XCL::ENTRY (LIST XCL::FN-TO-TRACE XCL::IN-FN XCL::MIDDLE-MAN)))                       (PUSH XCL::ENTRY IL:BROKENFNS)                       (PUSH XCL::ENTRY XCL::*TRACED-FNS*))                  (SETQ XCL::*UNBROKEN-FNS* (DELETE `(,XCL::FN-TO-TRACE :IN ,XCL::IN-FN)                                                   XCL::*UNBROKEN-FNS* :TEST 'EQUAL))                  (LIST `(,XCL::FN-TO-TRACE :IN ,XCL::IN-FN)))))))(IL:* IL:|;;;| "Support for breaking.")(DEFUN XCL:BREAK-FUNCTION (XCL::FN-TO-BREAK &KEY ((:IN XCL::IN-FN))                                     ((:WHEN XCL::WHEN-EXPR)                                      T)                                     XCL::TRACE? XCL::REBREAK?)   (COND      (XCL::TRACE? (XCL:TRACE-FUNCTION XCL::FN-TO-BREAK :IN XCL::IN-FN :REBREAK? XCL::REBREAK?))      ((CONSP XCL::FN-TO-BREAK)       (IL:FOR XCL::FN IL:IN XCL::FN-TO-BREAK          IL:JOIN (XCL:BREAK-FUNCTION XCL::FN :IN XCL::IN-FN :WHEN XCL::WHEN-EXPR :REBREAK?                              XCL::REBREAK?)))      ((CONSP XCL::IN-FN)       (IL:FOR XCL::FN IL:IN XCL::IN-FN          IL:JOIN (XCL:BREAK-FUNCTION XCL::FN-TO-BREAK :IN XCL::FN :WHEN XCL::WHEN-EXPR :REBREAK?                             XCL::REBREAK?)))      ((IL:UNSAFE.TO.MODIFY XCL::FN-TO-BREAK "break")       (FORMAT *ERROR-OUTPUT* "~S not broken." XCL::FN-TO-BREAK)       NIL)      (T (UNLESS XCL::REBREAK?                               (IL:* IL:\; "Save the breaking information for REBREAK.  Don't do it, though, if we're being called from REBREAK.")             (SETF (GETHASH (IF (NULL XCL::IN-FN)                                XCL::FN-TO-BREAK                                `(,XCL::FN-TO-BREAK :IN ,XCL::IN-FN))                          XCL::*BREAK-HASH-TABLE*)                   (LIST XCL::FN-TO-BREAK :IN XCL::IN-FN :WHEN XCL::WHEN-EXPR :REBREAK? T)))         (WHEN (EQ XCL::WHEN-EXPR :ONCE)             (SETQ XCL::WHEN-EXPR                   `(FUNCALL ',(LET ((XCL::TRIGGERED-YET? NIL))                                    #'(LAMBDA NIL (IF XCL::TRIGGERED-YET?                                                      NIL                                                      (SETQ XCL::TRIGGERED-YET? T)))))))         (XCL:UNBREAK-FUNCTION XCL::FN-TO-BREAK :IN XCL::IN-FN :NO-ERROR T)         (IF (NULL XCL::IN-FN)             (LET* ((XCL::ORIGINAL-DEF (OR (IL:GETD XCL::FN-TO-BREAK)                                           (ERROR 'XCL:UNDEFINED-FUNCTION :NAME XCL::FN-TO-BREAK)))                    (XCL::ORIGINAL (LET ((*PRINT-CASE* :UPCASE))                                        (MAKE-SYMBOL (FORMAT NIL "Original ~A" XCL::FN-TO-BREAK)))))                   (IL:PUTD XCL::ORIGINAL XCL::ORIGINAL-DEF T)                   (IL:PUTD XCL::FN-TO-BREAK (COMPILE NIL (CREATE-BROKEN-DEFINITION XCL::FN-TO-BREAK                                                                 XCL::FN-TO-BREAK XCL::ORIGINAL                                                                  XCL::WHEN-EXPR XCL::FN-TO-BREAK))                          T)                   (SETF (GET XCL::FN-TO-BREAK 'IL:BROKEN)                         XCL::ORIGINAL)                   (PUSH XCL::FN-TO-BREAK IL:BROKENFNS)                   (SETQ XCL::*UNBROKEN-FNS* (DELETE XCL::FN-TO-BREAK XCL::*UNBROKEN-FNS*))                   (LIST XCL::FN-TO-BREAK))             (LET ((XCL::MIDDLE-MAN (CONSTRUCT-MIDDLE-MAN XCL::FN-TO-BREAK XCL::IN-FN)))                  (IF (NOT (HAS-CALLS XCL::IN-FN XCL::FN-TO-BREAK))                      (ERROR "~S is not called from ~S." XCL::FN-TO-BREAK XCL::IN-FN))                  (XCL:UNADVISE-FUNCTION XCL::FN-TO-BREAK :IN XCL::IN-FN :NO-ERROR T)                  (COMPILE XCL::MIDDLE-MAN (CREATE-BROKEN-DEFINITION XCL::FN-TO-BREAK XCL::MIDDLE-MAN                                                  XCL::FN-TO-BREAK XCL::WHEN-EXPR                                                  `(,XCL::FN-TO-BREAK :IN ,XCL::IN-FN)))                  (CHANGE-CALLS XCL::FN-TO-BREAK XCL::MIDDLE-MAN XCL::IN-FN                          'UNBREAK-FROM-RESTORE-CALLS)                  (PUSH (LIST XCL::FN-TO-BREAK XCL::IN-FN XCL::MIDDLE-MAN)                        IL:BROKENFNS)                  (SETQ XCL::*UNBROKEN-FNS* (DELETE `(,XCL::FN-TO-BREAK :IN ,XCL::IN-FN)                                                   XCL::*UNBROKEN-FNS* :TEST 'EQUAL))                  (LIST `(,XCL::FN-TO-BREAK :IN ,XCL::IN-FN)))))))(DEFUN XCL:UNBREAK-FUNCTION (XCL::BROKEN-FN &KEY ((:IN XCL::IN-FN))                                       XCL::NO-ERROR)   (COND      ((CONSP XCL::BROKEN-FN)       (IL:FOR XCL::FN IL:IN XCL::BROKEN-FN IL:JOIN (XCL:UNBREAK-FUNCTION XCL::FN :IN                                                                        XCL::IN-FN)))      ((CONSP XCL::IN-FN)       (IL:FOR XCL::FN IL:IN XCL::IN-FN IL:JOIN (XCL:UNBREAK-FUNCTION XCL::BROKEN-FN :IN                                                                   XCL::FN)))      ((NULL XCL::IN-FN)       (LET ((XCL::ORIGINAL (GET XCL::BROKEN-FN 'IL:BROKEN)))            (COND               ((NULL XCL::ORIGINAL)                (UNLESS XCL::NO-ERROR (FORMAT *ERROR-OUTPUT* "~S is not broken.~%" XCL::BROKEN-FN))                NIL)               (T (IL:PUTD XCL::BROKEN-FN (IL:GETD XCL::ORIGINAL)                         T)                  (REMPROP XCL::BROKEN-FN 'IL:BROKEN)                  (SETQ IL:BROKENFNS (DELETE XCL::BROKEN-FN IL:BROKENFNS))                  (SETQ XCL::*TRACED-FNS* (DELETE XCL::BROKEN-FN XCL::*TRACED-FNS*))                  (PUSH XCL::BROKEN-FN XCL::*UNBROKEN-FNS*)                  (LIST XCL::BROKEN-FN)))))      (T (LET* ((XCL::ENTRY (FIND-IF #'(LAMBDA (XCL::ENTRY)                                              (AND (CONSP XCL::ENTRY)                                                   (EQ (FIRST XCL::ENTRY)                                                       XCL::BROKEN-FN)                                                   (EQ (SECOND XCL::ENTRY)                                                       XCL::IN-FN)))                                   IL:BROKENFNS))                (XCL::MIDDLE-MAN (THIRD XCL::ENTRY)))               (COND                  ((NULL XCL::ENTRY)                   (UNLESS XCL::NO-ERROR (FORMAT *ERROR-OUTPUT* "~S :IN ~S is not broken.~%"                                                 XCL::BROKEN-FN XCL::IN-FN))                   NIL)                  (T (CHANGE-CALLS XCL::MIDDLE-MAN XCL::BROKEN-FN XCL::IN-FN)                     (FINISH-UNBREAKING XCL::BROKEN-FN XCL::IN-FN XCL::MIDDLE-MAN XCL::ENTRY)                     (LIST `(,XCL::BROKEN-FN :IN ,XCL::IN-FN))))))))(DEFUN XCL:REBREAK-FUNCTION (XCL::FN-TO-REBREAK &KEY ((:IN XCL::IN-FN)))   (COND      ((CONSP XCL::FN-TO-REBREAK)       (IL:FOR XCL::FN IL:IN XCL::FN-TO-REBREAK IL:JOIN (XCL:REBREAK-FUNCTION XCL::FN :IN                                                                           XCL::IN-FN)))      ((CONSP XCL::IN-FN)       (IL:FOR XCL::FN IL:IN XCL::IN-FN IL:JOIN (XCL:REBREAK-FUNCTION XCL::FN-TO-REBREAK                                                                   :IN XCL::FN)))      (T (LET* ((XCL::NAME (IF (NULL XCL::IN-FN)                               XCL::FN-TO-REBREAK                               `(,XCL::FN-TO-REBREAK :IN ,XCL::IN-FN)))                (XCL::INFO (GETHASH XCL::NAME XCL::*BREAK-HASH-TABLE*)))               (COND                  ((NULL XCL::INFO)                   (FORMAT *ERROR-OUTPUT* "~S has never been broken.~%" XCL::NAME)                   NIL)                  (T (APPLY 'XCL:BREAK-FUNCTION XCL::INFO)))))))(DEFUN CREATE-BROKEN-DEFINITION (WRAPPED-FN-NAME BROKEN-FN-NAME FN-TO-CALL WHEN-EXPR                                            BREAKPOINT-NAME)(IL:* IL:|;;;| "WRAPPED-FN-NAME must be the symbol naming the function that will break when it is called.")(IL:* IL:|;;;| "BROKEN-FN-NAME is the symbol in whose function cell our lambda-form will be put.")(IL:* IL:|;;;| "FN-TO-CALL is the function-object to be FUNCALL'ed when we want to call the unbroken version of the wrapped function.")(IL:* IL:|;;;| "BREAKPOINT-NAME is the value the debugger will use for BRKFN.")(IL:* IL:|;;;| "We return a lambda-form suitable for being called in order to (possibly) activate the breakpoint.")   (MULTIPLE-VALUE-BIND    (LAMBDA-CAR ARG-LIST CALLING-FORM)    (FUNCTION-WRAPPER-INFO WRAPPED-FN-NAME FN-TO-CALL)    `(,LAMBDA-CAR ,(IF (EQ LAMBDA-CAR 'LAMBDA)                       '(&REST XCL:ARGLIST)                       ARG-LIST)            ,@(AND ARG-LIST (MEMBER LAMBDA-CAR '(IL:LAMBDA IL:NLAMBDA))                   `((DECLARE (SPECIAL ,@(IF (SYMBOLP ARG-LIST)                                                 (LIST ARG-LIST)                                                 ARG-LIST)))))            (IL:\\CALLME '(:BROKEN ,BREAKPOINT-NAME))            (IF ,WHEN-EXPR                (LET (($POS$ (IL:STKNTH -1)))                     (UNWIND-PROTECT                         (XCL:DEBUGGER :FORM `(FUNCALL ',#'(LAMBDA NIL ,CALLING-FORM))                                :ENVIRONMENT NIL :STACK-POSITION $POS$ :CONDITION                                ',(XCL:MAKE-CONDITION 'BREAKPOINT :FUNCTION BREAKPOINT-NAME))                         (IL:RELSTK $POS$)))                ,CALLING-FORM))))(DEFUN UNBREAK-FROM-RESTORE-CALLS (FROM TO FN)(IL:* IL:|;;;| "Somebody has restored all of the changed calls in FN, including one we made, changing calls to FROM into calls to TO.  This came about from breaking (FROM :IN FN), where TO was the middle-man.  Undo that breaking.")   (LET ((ENTRY (FIND-IF #'(LAMBDA (ENTRY)                                  (AND (CONSP ENTRY)                                       (EQ (FIRST ENTRY)                                           FROM)                                       (EQ (SECOND ENTRY)                                           FN)))                       IL:BROKENFNS)))        (ASSERT (EQ TO (THIRD ENTRY))               NIL "BUG: Inconsistency in SI::UNBREAK-FROM-RESTORE-CALLS")        (FINISH-UNBREAKING FROM FN TO ENTRY)        (FORMAT *TERMINAL-IO* "(~S :IN ~S) unbroken.~%" FROM FN)))(DEFUN FINISH-UNBREAKING (BROKEN-FN IN-FN MIDDLE-MAN ENTRY)   (SETQ IL:BROKENFNS (DELETE ENTRY IL:BROKENFNS))   (SETQ XCL::*TRACED-FNS* (DELETE ENTRY XCL::*TRACED-FNS*))   (PUSH `(,BROKEN-FN :IN ,IN-FN)         XCL::*UNBROKEN-FNS*))(DEFVAR IL:BROKENFNS NIL)(DEFVAR XCL::*BREAK-HASH-TABLE* (MAKE-HASH-TABLE :TEST 'EQUAL))(DEFVAR XCL::*UNBROKEN-FNS* NIL)(IL:PUTPROPS IL:BROKEN IL:PROPTYPE IGNORE)(IL:* IL:|;;| "The old Interlisp interface to breaking.")(IL:DEFINEQ(il:break  (il:nlambda il:x                                    (il:* il:\; "Edited 13-Apr-87 13:51 by Pavel")    (il:for il:x il:in (il:nlambda.args il:x) il:join (il:if (or (il:litatom il:x)                                                                 (il:string.equal (cadr il:x)                                                                        "IN"))                                                          il:then (il:break0 il:x t)                                                        il:else (il:apply 'il:break0 il:x)))))(il:break0  (il:lambda (il:fn il:when il:coms il:brkfn)         (il:* il:\; "Edited 18-Apr-87 18:56 by Pavel")    (when il:coms (cerror "Ignore COMS" "Break 'commands' ~S no longer supported." il:coms))    (when (and il:brkfn (il:neq il:brkfn 'il:break1))          (cerror "Ignore BRKFN" "Unexpected BRKFN passed to BREAK0: ~S" il:brkfn))    (when (null il:when)          (il:setq il:when t))    (cond       ((il:listp il:fn)        (cond           ((il:string.equal (second il:fn)                   "IN")            (xcl:break-function (first il:fn)                   :in                   (third il:fn)                   :when il:when))           (t (il:for il:x il:in il:fn il:join (il:break0 il:x il:when)))))       (t (xcl:break-function il:fn :when il:when)))))(il:rebreak  (il:nlambda il:fns                                  (il:* il:\; "Edited  3-Apr-87 12:07 by Pavel")    (il:setq il:fns (il:nlambda.args il:fns))    (flet ((il:rebreak-fn (il:fn)                  (il:if (il:listp il:fn)                      il:then (xcl:rebreak-function (first il:fn)                                     :in                                     (third il:fn))                    il:else (xcl:rebreak-function il:fn))))          (cond             ((null il:fns)              (il:for il:fn il:in xcl::*unbroken-fns* il:join (il:rebreak-fn il:fn)))             ((il:equal il:fns '(t))              (and (not (null xcl::*unbroken-fns*))                   (il:rebreak-fn (car xcl::*unbroken-fns*))))             (t (il:for il:fn il:in il:fns il:join (il:rebreak-fn il:fn)))))))(xcl:unbreak  (il:nlambda xcl::fns                                (il:* il:\; "Edited  2-Apr-87 16:39 by Pavel")    (setq xcl::fns (il:nlambda.args xcl::fns))    (flet ((xcl::unbreak-entry (xcl::entry)                  (if (consp xcl::entry)                      (xcl:unbreak-function (first xcl::entry)                             :in                             (second xcl::entry))                      (xcl:unbreak-function xcl::entry))))          (cond             ((null xcl::fns)              (il:for xcl::entry il:in (reverse il:brokenfns) il:join (xcl::unbreak-entry xcl::entry)                     ))             ((equal xcl::fns '(t))              (when il:brokenfns (xcl::unbreak-entry (car il:brokenfns))))             (t (il:for xcl::fn il:in xcl::fns il:join (if (consp xcl::fn)                                                           (xcl:unbreak-function (first xcl::fn)                                                                  :in                                                                  (third xcl::fn))                                                           (xcl:unbreak-function xcl::fn))))))))(il:unbreak0  (il:lambda (il:fn)                                  (il:* il:\; "Edited  1-Apr-87 22:12 by Pavel")    (il:if (il:listp il:fn)        il:then (xcl:unbreak-function (car il:fn)                       :in                       (caddr il:fn))      il:else (xcl:unbreak-function il:fn)))))(IL:DEFINEQ(il:break1  (il:nlambda (il:brkexp il:brkwhen il:brkfn il:brkcoms il:brktype xcl:condition)                                                        (il:* il:\; "Edited 24-Mar-87 16:07 by amd")    (il:|if| (eval il:brkwhen)        il:|then|                     (il:* il:|;;|        "should probably default CONDITION  depending on BRKTYPE to interrupt, breakpoint error, etc.")              (when il:brkcoms (il:printout t "BRKCOMS no longer supported:" il:brkcoms t))              (let ((il:pos (il:stknth 0 il:brkfn)))                   (unwind-protect (xcl:debugger :form il:brkexp :environment nil :stack-position                                           il:pos :condition (or xcl:condition (xcl:make-condition                                                                               'breakpoint :function                                                                                il:brkfn)))                          (il:relstk il:pos)))      il:|else| (eval il:brkexp)))))(XCL:DEFINE-SPECIAL-FORM IL:BREAK1 (&OPTIONAL IL:EXP IL:WHEN IL:FN IL:COMS TYPE XCL:CONDITION                                               &ENVIRONMENT IL:ENV)   (IL:IF (EVAL IL:WHEN IL:ENV)       IL:THEN (WHEN IL:COMS (IL:PRINTOUT T "BRKCOMS no longer supported:" IL:COMS T))             (LET ((IL:POS (IL:STKNTH 0 IL:FN)))                  (UNWIND-PROTECT                      (XCL:DEBUGGER :FORM IL:EXP :ENVIRONMENT IL:ENV :STACK-POSITION IL:POS                              :CONDITION (OR XCL:CONDITION (XCL:MAKE-CONDITION 'BREAKPOINT :FUNCTION                                                                  IL:FN)))                      (IL:RELSTK IL:POS)))     IL:ELSE (EVAL IL:EXP IL:ENV)))(XCL:DEFOPTIMIZER IL:BREAK1 (&OPTIONAL IL:EXP IL:WHEN IL:FN IL:COMS TYPE XCL:CONDITION)                                (WHEN IL:COMS (IL:PRINTOUT T "BRKCOMS no longer supported:" IL:COMS T                                                     ))                                `(FLET                                  (($BRKEXP$ NIL ,IL:EXP))                                  (IL:IF ,IL:WHEN                                      IL:THEN                                      (LET                                       (($POS$ (IL:STKNTH 0 ',IL:FN)))                                       (UNWIND-PROTECT                                           (XCL:DEBUGGER                                            :FORM                                            `(FUNCALL ',#'$BRKEXP$)                                            :ENVIRONMENT NIL :STACK-POSITION $POS$ :CONDITION                                            ,(OR XCL:CONDITION                                                 `(IL:LOADTIMECONSTANT (XCL:MAKE-CONDITION                                                                        'BREAKPOINT :FUNCTION                                                                        ',IL:FN))))                                           (IL:RELSTK $POS$)))                                    IL:ELSE ($BRKEXP$))))(IL:* IL:|;;| "Arrange for the proper compiler and package")(IL:PUTPROPS IL:BREAK-AND-TRACE IL:FILETYPE :COMPILE-FILE)(IL:PUTPROPS IL:BREAK-AND-TRACE IL:MAKEFILE-ENVIRONMENT (:READTABLE "XCL" :PACKAGE "SYSTEM"))(IL:DECLARE\: IL:DONTEVAL@LOAD IL:DOEVAL@COMPILE IL:DONTCOPY IL:COMPILERVARS (IL:ADDTOVAR IL:NLAMA XCL:UNBREAK IL:REBREAK IL:BREAK UNTRACE TRACE)(IL:ADDTOVAR IL:NLAML IL:BREAK1)(IL:ADDTOVAR IL:LAMA ))(IL:PUTPROPS IL:BREAK-AND-TRACE IL:COPYRIGHT ("Venue & Xerox Corporation" 1987 1988 1990))(IL:DECLARE\: IL:DONTCOPY  (IL:FILEMAP (NIL (15387 17225 (TRACE 15400 . 15987) (UNTRACE 15989 . 17223)) (30814 34614 (IL:BREAK 30827 . 31413) (IL:BREAK0 31415 . 32227) (IL:REBREAK 32229 . 33091) (XCL:UNBREAK 33093 . 34284) (IL:UNBREAK0 34286 . 34612)) (34615 35663 (IL:BREAK1 34628 . 35661)))))IL:STOP