(DEFINE-FILE-INFO READTABLE "XCL" PACKAGE "XCL")
(il:filecreated " 4-Jun-90 15:11:57" il:|{PELE:MV:ENVOS}<LISPCORE>SOURCES>CMLDEFFER.;3| 50879  

      il:|changes| il:|to:|  (il:functions defconstant)

      il:|previous| il:|date:| "16-May-90 13:03:22" il:|{PELE:MV:ENVOS}<LISPCORE>SOURCES>CMLDEFFER.;2|
)


; Copyright (c) 1986, 1900, 1987, 1988, 1990 by Venue & Xerox Corporation.  All rights reserved.

(il:prettycomprint il:cmldeffercoms)

(il:rpaqq il:cmldeffercoms
          (

(il:* il:|;;;| 
"DEF-DEFINE-TYPE and DEFDEFINER -- Your One-Stop Providers of Customized File Manager Facilities.")

           
           (il:* il:|;;| "BE VERY CAREFUL CHANGING ANYTHING IN THIS FILE!!!  It is heavily self-referential and thick with bootstrapping problems.  All but the most trivial changes (and some of those) are very tricky to make without blowing yourself out of the water...  You have been warned.")

           

(il:* il:|;;;| "Also see the file deffer-runtime for stuff that must be defined before fasl files may be loaded into the init")

           (il:coms                                          (il:* il:\; "Filepkg interface")
                  (il:functions remove-comments pprint-definer pprint-definer-fitp 
                         pprint-definer-recurse)
                  (il:variables il:*remove-interlisp-comments*)
                                                             (il:* il:\; "Share with xcl?")
                  (il:functions %define-type-deldef %define-type-getdef %define-type-file-definitions
                         %define-type-filegetdef %define-type-save-defn %define-type-putdef))
           (il:coms                                          (il:* il:\; 
                                                           "Compatibility with old cmldeffer")
                  (il:declare\: il:docopy il:donteval@load (il:p (il:movd '%define-type-deldef
                                                                        'il:\\define-type-deldef)
                                                                 (il:movd '%define-type-getdef
                                                                        'il:\\define-type-getdef)
                                                                 (il:movd 
                                                                        '
                                                                        %define-type-file-definitions
                                                                        
                                                                        '
                                                                    il:\\define-type-file-definitions
                                                                        )
                                                                 (il:movd '%define-type-filegetdef
                                                                        'il:\\define-type-filegetdef)
                                                                 (il:movd '%define-type-save-defn
                                                                        'il:\\define-type-save-defn)
                                                                 (il:movd '%define-type-putdef
                                                                        'il:\\define-type-putdef)
                                                                 (il:movd 'pprint-definer
                                                                        'il:pprint-definer))))
           (il:declare\: il:docopy il:donteval@load
                  (il:p 
                        (il:* il:|;;| "Set up fake definer prototype stuff for FNS")

                        (add-prototype-fn 'il:fns 'il:nlambda
                               #'(lambda (name)
                                        (and (symbolp name)
                                             `(il:defineq (,name (il:nlambda ,@(
                                                                             %make-function-prototype
                                                                                )))))))
                        (add-prototype-fn 'il:fns 'il:lambda
                               #'(lambda (name)
                                        (and (symbolp name)
                                             `(il:defineq (,name (il:lambda ,@(
                                                                             %make-function-prototype
                                                                               )))))))))
           (il:coms                                          (il:* il:\; 
                                                           "The groundwork for bootstrapping ")
                  (il:define-types il:define-types il:functions il:variables)
                                                             (il:* il:\; 
                                                           "DefDefiner itself and friends")
                  (il:functions si::expansion-function si::macro-funcall without-filepkg))
           (il:coms                                          (il:* il:\; 
                                                           "Compatibility with old cmldeffer")
                  (il:functions il:without-filepkg))
           (il:coms                                          (il:* il:\; "Some special forms")
                  (il:functions definer named-progn))
           (il:coms                                          (il:* il:\; "Auxiliary functions")
                  (il:functions get-definer-name %delete-definer)
                  (il:functions def-define-type defdefiner)
                  (il:functions %expand-definer %definer-name))
           (il:coms                                          (il:* il:\; 
                                                           "The most commonly-used definers")
                  (il:functions defun definline defmacro)
                  (il:functions defvar defparameter defconstant defglobalvar defglobalparameter))
           (il:coms                                          (il:* il:\; 
                "Here so that the evaluator can be in the init without definers being in the init.")
                  (il:define-types il:special-forms)
                  (il:functions %remove-special-form)
                  (il:functions define-special-form)
                                                             (il:* il:\; 
                                                  "Form for defining interpreters of special forms")
                  )
           (il:coms                                          (il:* il:\; 
                                                 "Don't note changes to these properties/variables")
                  (il:prop il:proptype il:macro-fn :undefiners il:undefiners :definer-for 
                         il:definer-for :defined-by il:defined-by :definition-name il:definition-name
                         )
                                                             (il:* il:\; 
          "Templates for definers not defined here.  These should really be where they're defined.")
                  (il:prop :definition-print-template defcommand define-condition define-modify-macro
                         define-setf-method defsetf defstruct deftype))
           
           (il:* il:|;;| "Arrange for the correct compiler to be used.")

           (il:prop (il:filetype il:makefile-environment)
                  il:cmldeffer)))



(il:* il:|;;;| 
"DEF-DEFINE-TYPE and DEFDEFINER -- Your One-Stop Providers of Customized File Manager Facilities.")




(il:* il:|;;| 
"BE VERY CAREFUL CHANGING ANYTHING IN THIS FILE!!!  It is heavily self-referential and thick with bootstrapping problems.  All but the most trivial changes (and some of those) are very tricky to make without blowing yourself out of the water...  You have been warned."
)




(il:* il:|;;;| 
"Also see the file deffer-runtime for stuff that must be defined before fasl files may be loaded into the init"
)




(il:* il:\; "Filepkg interface")


(defun remove-comments (x)

(il:* il:|;;;| "Removes SEdit-style comments from the given list structure.")

   (cond
      ((not (consp x))
       x)
      ((and (consp (car x))
            (eq (caar x)
                'il:*)
            (consp (cdar x))
            (or (member (cadar x)
                       '(il:\; il:|;;| il:|;;;| il:|;;;;| il:\|)
                       :test
                       #'eq)                                 (il:* il:\; "a sedit comment")
                (eq il:*remove-interlisp-comments* t)        (il:* il:\; "always strip")
                (progn (if (eq il:*remove-interlisp-comments* ':warn)
                           (warn "Possible comment not stripped ~S" (car x)))
                       nil)))
       (remove-comments (cdr x)))
      (t (let ((a (remove-comments (car x)))
               (d (remove-comments (cdr x))))
              (if (and (eq a (car x))
                       (eq d (cdr x)))
                  x
                  (cons a d))))))

(defun pprint-definer (define-expression)
   (declare (special il:formflg il:spacewidth))          (il:* il:\; "Bound in prettyprinter")
   (cond
      ((or (null il:formflg)
           (atom (cdr define-expression)))                   (il:* il:\; 
                    "Degenerate cases or printing as a quoted form--punt to default prettyprinting")
       define-expression)
      (t
       (let ((il:tail define-expression)
             (il:left (il:dspxposition))
             template top-level-p next type form newlinep)
            (declare (special il:tail il:left))          (il:* il:\; "For comment printer")
            (setq top-level-p (eq il:left (il:dspleftmargin)))
                                                             (il:* il:\; 
                                                           "Printing definition to file, etc.")
            (setq il:left (+ il:left (* 3 il:spacewidth)))   (il:* il:\; 
                                                           "Place we will indent body")
            (il:prin1 "(")
            (il:prin2 (car il:tail))
            (setq template (or (get (pop il:tail)
                                    :definition-print-template)
                               '(:name)))

            (il:* il:|;;| "This code should, and doesn't, pay attention to the NAME function to determine where the name is to decide what should and shouldn't be bold. Right now, it always bolds the second thing. Fortunately, we currently don't have any definers that don't have either the second or CAR of the second as the definition name.")

            (il:* il:|;;| "Also, this code should be careful about calling the NAME function on the form.  Sometimes, the form is not really a call to the definer but instead a back-quoted expression in a macro.  In most such cases, the name is not really there; some comma-quoted expression is there instead.")

            (il:while (consp il:tail)
               il:do (cond
                            ((and (listp (setq next (car il:tail)))
                                  (eq (car next)
                                      il:commentflg)
                                  (il:semi-colon-comment-p next))
                                                             (il:* il:\; "Comments can appear anywhere, so print this one without consuming the template.  ENDLINE has side effect of printing comments")
                             (il:subprint/endline il:left *standard-output*)
                             (setq newlinep t))
                            ((or (atom template)
                                 (eq (setq type (pop template))
                                     :body))                 (il:* il:\; 
                                        "Once we hit the body, there's nothing more special to do.")
                             (return))
                            (t (il:spaces 1)
                               (case type
                                   (:name                    (il:* il:\; 
                                                           "Embolden the name of this thing")
                                      (setq newlinep nil)
                                      (cond
                                         ((not top-level-p)  (il:* il:\; 
                                           "Nothing special here--could even be a backquoted thing")
                                          (pprint-definer-recurse))
                                         (t (pop il:tail)
                                            (cond
                                               ((consp next) (il:* il:\; 
    "Name is a list.  Assume the real name is the car and the rest is an options list or something")
                                                (unless (eq (il:dspyposition)
                                                            (progn (il:prin1 "(")
                                                                   (il:printout nil il:.font 
                                                                          il:lambdafont il:|.P2|
                                                                          (car next)
                                                                          il:.font il:defaultfont)
                                                                   (il:spaces 1)
                                                                   (il:printdef (cdr next)
                                                                          t t t il:fnslst)
                                                                   (il:prin1 ")")
                                                                   (il:dspyposition)))
                                                             (il:* il:\; 
                                   "This thing took more than one line to print, so go to new line")
                                                    (il:subprint/endline il:left *standard-output*)
                                                    (setq newlinep t)))
                                               (t            (il:* il:\; "Atomic name is bold")
                                                  (il:printout nil il:.font il:lambdafont il:|.P2| 
                                                         next il:.font il:defaultfont))))))
                                   (:arg-list                (il:* il:\; 
                                                           "NEXT is some sort of argument list.  ")
                                      (cond
                                         ((null next)        (il:* il:\; 
                                                           "If NIL, be sure to print as ()")
                                          (il:prin1 "()")
                                          (pop il:tail))
                                         (t (pprint-definer-recurse)))
                                      (setq newlinep nil))
                                   (t                        (il:* il:\; 
                                                       "Just print it, perhaps starting a new line")
                                      (unless (or newlinep (pprint-definer-fitp next))
                                                             (il:* il:\; 
                                                           "Go to new line if getting crowded")
                                          (il:prinendline il:left))
                                      (pprint-definer-recurse)
                                      (setq newlinep nil))))))

            (il:* il:|;;| 
          "We've now gotten to the end of stuff we know how to print.  Just prettyprint the rest")

            (unless (null il:tail)
                (cond
                   (newlinep                                 (il:* il:\; "Already on new line"))
                   ((or (eq type :body)
                        (not (pprint-definer-fitp (car il:tail))))
                                                             (il:* il:\; "Go to new line and indent a bit.  Always do this for the part matching &BODY, whether or not the prettyprinter thought that the remainder would \"fit\"")
                    (il:prinendline il:left nil t))
                   (t (il:spaces 1)))
                (il:while (and (consp il:tail)
                                   (atom (setq form (car il:tail))))
                   il:do 

                         (il:* il:|;;| "Print this doc string or whatever on its own line.  This is because otherwise the prettyprinter gets confused and tries to put the next thing after the string")

                         (pprint-definer-recurse)
                         (when (and (keywordp form)
                                    (consp il:tail))         (il:* il:\; 
                                     "Some sort of keyword-value pair stuff--print it on same line")
                             (il:spaces 1)
                             (pprint-definer-recurse))
                         (when (null il:tail)
                               (return))
                         (il:subprint/endline il:left *standard-output*))
                (il:printdef il:tail t t t il:fnslst))
            (il:prin1 ")")
            nil))))

(defun pprint-definer-fitp (item)

   (il:* il:|;;| 
"True if it won't look silly to try to print ITEM at current position instead of starting new line")

   (if (consp item)
       (or (eq (car item)
               il:commentflg)
           (and (< (il:count item)
                   20)
                (il:fitp item)))
       (< (+ (il:dspxposition)
             (il:stringwidth item *standard-output*))
          (il:dsprightmargin))))

(defun pprint-definer-recurse ()

   (il:* il:|;;| 
 "Print and pop the next element.  Prettyprinter uses the variable IL:TAIL for lookahead")

   (declare (special il:tail))
   (il:superprint (car il:tail)
          il:tail nil *standard-output*)
   (setq il:tail (cdr il:tail)))

(defvar il:*remove-interlisp-comments* ':warn 
                                         "Either NIL (don't) T (always do) or :WARN (don't and warn)")



(il:* il:\; "Share with xcl?")


(defun %define-type-deldef (name type)

   (il:* il:|;;| "DELETE definition of definer-defined NAME as TYPE ")

   (undoably-setf (documentation name type)
          nil)
   (let* ((ht (gethash type *definition-hash-table*))
          (defn (and ht (gethash name ht))))
         (and ht (il:/puthash name nil ht))
         (dolist (fn (or (get type ':undefiners)
                         (get type 'il:undefiners)))
             (funcall fn name))
         (dolist (fn (or (get (car defn)
                              ':undefiners)
                         (get (car defn)
                              'il:undefiners)))
             (funcall fn name))
         name))

(defun %define-type-getdef (name type options)

   (il:* il:|;;| "GETDEF method for all definers.  The EDIT is so that when you say EDITDEF you get a copy & can know when you made edits.")

   (let* ((hash-table (gethash type *definition-hash-table*))
          (defn (and hash-table (gethash name hash-table))))
         (if (typecase options
                 (cons (member 'il:edit options :test #'eq))
                 (t (eq options 'il:edit)))
             (copy-tree defn)
             defn)))

(defun %define-type-file-definitions (type names)

   (il:* il:|;;| 
 "get the definitions for NAMES suitable for printing on a file. Like GETDEF but checks.")

   (mapcar #'(lambda (name)
                    (let ((def (%define-type-getdef name type '(il:nocopy))))
                         (if (null def)
                             (error 'il:no-such-definition :name name :type type)
                             def)))
          names))

(defun %define-type-filegetdef (name type source options notfound)
   (let ((val (il:loadfns nil source 'il:getdef 

                     (il:* il:|;;| 
        "The bletcherous lambda form is require by the interface to loadfns (can't pass a closure)")

                     `(il:lambda (first second)
                        (and (member first ',(or (get type ':defined-by)
                                                 (get type 'il:defined-by))
                                    :test
                                    #'eq)
                             (let ((namer (or (get first ':definition-name)
                                              (get first 'il:definition-name)
                                              'second)))
                                  (if (eq namer 'second)
                                      (equal second ',name)
                                      (equal (funcall namer (remove-comments (il:read)))
                                             ',name))))))))
        (cond
           ((eq (caar val)
                'il:not-found\:)
            notfound)
           ((cdr val)
            (cons 'progn val))
           (t (car val)))))

(defun %define-type-save-defn (name type definition)
   (setq type (il:getfilepkgtype type 'type))
   (let ((hash-table (gethash type *definition-hash-table*)))
        (when (null hash-table)
            (warn "Couldn't find a hash-table for ~S definitions.~%One will be created." type)
            (setq hash-table (setf (gethash type *definition-hash-table*)
                                   (make-hash-table :test #'equal :size 50 :rehash-size 50))))
        (let ((old-definition (gethash name hash-table)))
             (unless (equal definition old-definition)
                 (when (and old-definition (not (eq il:dfnflg t)))
                     (format *terminal-io* "~&New ~A definition for ~S~:[~; (but not installed)~].~%"
                            type name (member il:dfnflg '(il:prop il:allprop)
                                             :test
                                             #'eq)))
                 (il:/puthash name definition hash-table)
                 (il:markaschanged name type (if old-definition
                                                 'il:changed
                                                 'il:defined))))))

(defun %define-type-putdef (name type definition reason)
   (if (null definition)
       (%define-type-deldef name type)
       (let ((defn-without-comments (remove-comments definition)))
            (unless (and (consp defn-without-comments)
                         (member (car defn-without-comments)
                                (or (get type ':defined-by)
                                    (get type 'il:defined-by))
                                :test
                                #'eq)
                         (equal name (funcall (or (get (car defn-without-comments)
                                                       ':definition-name)
                                                  (get (car defn-without-comments)
                                                       'il:definition-name)
                                                  'second)
                                            defn-without-comments)))
                (signal 'il:definer-mismatch :name name :type type :definition definition))
            (setq definition (copy-tree definition))
            (eval (if il:lispxhist
                      (make-undoable definition)
                      definition)))))



(il:* il:\; "Compatibility with old cmldeffer")

(il:declare\: il:docopy il:donteval@load 

(il:movd '%define-type-deldef 'il:\\define-type-deldef)

(il:movd '%define-type-getdef 'il:\\define-type-getdef)

(il:movd '%define-type-file-definitions 'il:\\define-type-file-definitions)

(il:movd '%define-type-filegetdef 'il:\\define-type-filegetdef)

(il:movd '%define-type-save-defn 'il:\\define-type-save-defn)

(il:movd '%define-type-putdef 'il:\\define-type-putdef)

(il:movd 'pprint-definer 'il:pprint-definer)
)
(il:declare\: il:docopy il:donteval@load 


(il:* il:|;;| "Set up fake definer prototype stuff for FNS")


(add-prototype-fn 'il:fns 'il:nlambda #'(lambda (name)
                                               (and (symbolp name)
                                                    `(il:defineq (,name (il:nlambda ,@(
                                                                             %make-function-prototype
                                                                                       )))))))

(add-prototype-fn 'il:fns 'il:lambda #'(lambda (name)
                                              (and (symbolp name)
                                                   `(il:defineq (,name (il:lambda ,@(
                                                                             %make-function-prototype
                                                                                     )))))))
)



(il:* il:\; "The groundwork for bootstrapping ")


(def-define-type il:define-types "Definition type")

(def-define-type il:functions "Common Lisp functions/macros"
   :undefiner il:undoably-fmakunbound)

(def-define-type il:variables "Common Lisp variables"
   :undefiner undoably-makunbound)



(il:* il:\; "DefDefiner itself and friends")


(defun si::expansion-function (name arg-list body)

(il:* il:|;;;| "Shared code between DEFMACRO and DEFDEFINER.  Takes the parts of a DEFMACRO and returns two values: a LAMBDA form for the expansion function, and the documentation string found, if any.")

   (multiple-value-bind (parsed-body parsed-declarations parsed-docstring)
          (il:parse-defmacro arg-list 'si::$$macro-form body name nil :environment 
                 'si::$$macro-environment)
          (values `(lambda (si::$$macro-form si::$$macro-environment)
                          ,@parsed-declarations
                          (block ,name ,parsed-body))
                 parsed-docstring)))

(defmacro si::macro-funcall (expansion-function macro-call env)

(il:* il:|;;;| "Used by DEFDEFINER as a mechanism for delaying macro-expansion until after checking the value of DFNFLG.  The arguments (unevaluated) are a macro-expansion function and a call on that macro.  The call to MACRO-FUNCALL should expand into the result of expanding the given macro-call.")

   (funcall expansion-function macro-call env))

(defmacro without-filepkg (&body body)
   `(progn (eval-when (load)
                  ,@body)
           (eval-when (eval)
                  (unless (or (eq il:dfnflg 'il:prop)
                              (eq il:dfnflg 'il:allprop))
                      (let ((il:filepkgflg nil)
                            (il:dfnflg t))
                           ,@body)))))



(il:* il:\; "Compatibility with old cmldeffer")


(defmacro il:without-filepkg (&body body)
   `(without-filepkg ,@body))



(il:* il:\; "Some special forms")


(defmacro definer (type name definition &optional env)
   (let* ((expander (get name :definition-expander))
          (definition-without-comments (remove-comments definition))
          (definition-name (funcall (get name :definition-name)
                                  definition-without-comments)))
         `(progn (without-filepkg (si::macro-funcall ,expander ,definition-without-comments
                                         ,env))
                 (eval-when (eval)
                        (unless (null il:filepkgflg)
                            (%define-type-save-defn ',definition-name ',type ',definition)))
                 ',definition-name)))

(defmacro named-progn (definer name &rest forms)

   (il:* il:|;;| "Used by the compiler when processing definers")

   `(progn ,@forms ',name))



(il:* il:\; "Auxiliary functions")


(defun get-definer-name (definer string)
   (values (intern (concatenate 'string string (string definer))
                  (symbol-package definer))))

(defun %delete-definer (name)
   (and (symbolp name)
        (let ((type (or (get name ':definer-for)
                        (get name 'il:definer-for))))
             (il:/remprop name ':definer-for)
             (il:/remprop name 'il:definer-for)
             (il:/remprop name ':definition-name)
             (il:/remprop name 'il:definition-name)
             (il:/remprop name ':definition-expander)
             (when type
                 (if (get type ':defined-by)
                     (il:/putprop type ':defined-by (remove name (get type ':defined-by)))
                     (il:/putprop type 'il:defined-by (remove name (get type 'il:defined-by))))

                 (il:* il:|;;| "need to remove the prototype function!")

                 (let* ((lookup-type (assoc type *definition-prototypes* :test #'eq)))
                       (il:/rplacd lookup-type (remove name (cdr lookup-type)
                                                      :key
                                                      #'car)))))))

(defdefiner (def-define-type (:prototype (lambda (name)
                                                    (and (symbolp name)
                                                         `(def-define-type ,name "Description string")
                                                         )))) il:define-types (name
                                                                               description &key 
                                                                               undefiner &aux
                                                                               (changelst
                                                                                (intern
                                                                                 (concatenate
                                                                                  'string "CHANGED"
                                                                                  (string name)
                                                                                  "LST")
                                                                                 (symbol-package
                                                                                  name))))
   "Define NAME as a new definition type"

   (il:* il:|;;| "This definition is a clean interface to a hokey implementation.  It works even before the file package is loaded.")

   `(progn (setf (documentation ',name 'il:define-types)
                 ',description)
           (pushnew '(,name x (il:p il:* (%define-type-file-definitions ',name 'x)))
                  il:prettydefmacros :test 'equal)

           (il:* il:|;;| "the information about a type in the file package is split up into a number of different places. PRETTYTYPELST contains a random amount: the changelist is the variable whose top level value contains the list of changed items, and the description is a string used by files? This is duplicated in the CL:DOCUMENTATION mechanism")

           (pushnew '(,changelst ,name ,description)
                  il:prettytypelst :test 'equal)
           (defglobalvar ,changelst nil)

           (il:* il:|;;| "the definition hash table is where the definitions are really stored. Create an entry for this type. Note that definitions are compared using CL:EQUAL so that names can be strings, lists, etc.")

           (unless (gethash ',name *definition-hash-table*)
               (setf (gethash ',name *definition-hash-table*)
                     (make-hash-table :test 'equal :size 50 :rehash-size 50)))
           (pushnew ',name il:filepkgtypes)
           (setf (get ',name 'il:getdef)
                 '%define-type-getdef)
           (setf (get ',name 'il:deldef)
                 '%define-type-deldef)
           (setf (get ',name 'il:putdef)
                 '%define-type-putdef)
           (setf (get ',name 'il:filegetdef)
                 '%define-type-filegetdef)
           (setf (get ',name 'il:filepkgcontents)
                 'il:nill)
           ,@(when undefiner
                 `((pushnew ',undefiner (get ',name ':undefiners))))))

(defdefiner (defdefiner (:name (lambda (whole)
                                          (let ((name (second whole)))
                                               (if (consp name)
                                                   (car name)
                                                   name))))
                            (:prototype (lambda
                                         (name)
                                         (and (symbolp name)
                                              `(defdefiner ,name 
                                                  ,(if (eq (il:editmode)
                                                           'il:sedit)
                                                       (symbol-value (intern "BASIC-GAP" "SEDIT"))
                                                       "Type") ,@(%make-function-prototype)))))
                            (:undefiner %delete-definer)
                            (:template (:name :type :arg-list :body))) il:functions (name type 
                                                                                          arg-list 
                                                                                          &body body)
   (let*
    ((options (cond
                 ((consp name)
                  (prog1 (cdr name)
                      (setq name (car name))))
                 (t nil)))
     (name-fn nil)
     (undefiner nil)
     (prototype-fn nil)
     (template nil)
     (prettymacro nil))
    (dolist (opt-list options)
        (case (car opt-list)
            ((:undefiner) (setq undefiner (cadr opt-list)))
            ((:name) (setq name-fn (cadr opt-list)))
            ((:prototype) (setq prototype-fn (cadr opt-list)))
            ((:template) (setq template (cadr opt-list)))
            ((:prettyprintmacro) (setq prettymacro (cadr opt-list)))
            (otherwise (cerror "Ignore the option" "Unrecognized option to DefDefiner: ~S" opt-list)))
)
    (multiple-value-bind
     (expansion-fn doc)
     (si::expansion-function name arg-list body)
     (unless (or template prettymacro (not (member '&body arg-list)))
                                                             (il:* il:\; 
                                                     "Tell default prettyprinter where the body is")
         (setq template (nconc (il:for x il:in arg-list il:until (eq x '&body)
                                  il:unless (member x lambda-list-keywords) il:collect nil)
                               (list :body)))
         (when (and (null (car template))
                    (null name-fn))                          (il:* il:\; "Name is in default place")
             (setf (car template)
                   :name)))
     (let ((expander-name (get-definer-name name "definition-expander-"))
           (name-fn-name (if (consp name-fn)
                             (get-definer-name name "name-fn-"))))
          `(progn (eval-when (load eval compile)
                         (setf (get ',name ':definer-for)
                               ',type)
                         (pushnew ',name (get ',type ':defined-by))
                         (setf (symbol-function ',expander-name)
                               #',expansion-fn)
                         (setf (get ',name ':definition-expander)
                               ',expander-name)
                         ,@(if name-fn-name
                               `((setf (symbol-function ',name-fn-name)
                                       #',name-fn)))
                         (setf (get ',name ':definition-name)
                               ',(or name-fn-name name-fn 'second))
                         ,@(and undefiner (let ((undefiner-fn-name (get-definer-name name 
                                                                          "undefiner-fn-")))
                                               `((setf (symbol-function ',undefiner-fn-name)
                                                       #',undefiner)
                                                 (pushnew ',undefiner-fn-name
                                                        (get ',name ':undefiners)))))
                         ,@(and prototype-fn (let ((prototype-fn-name (get-definer-name name 
                                                                             "prototype-fn-")))
                                                  `((setf (symbol-function ',prototype-fn-name)
                                                          #',prototype-fn)
                                                    (add-prototype-fn ',type ',name
                                                           ',prototype-fn-name))))
                         ,@(and doc `((setf (documentation ',name 'function)
                                            ,doc)))
                         ,@(and template `((setf (get ',name ':definition-print-template)
                                                 ',template)))
                         (pushnew '(,name ,@(or prettymacro 'pprint-definer))
                                il:prettyprintmacros :test 'equal))
                  (defmacro ,name (&whole definition &environment env)
                     `(definer ,',type ,',name ,definition ,env)))))))

(defun %expand-definer (definer definition-without-comments &optional env)
   (funcall (get definer :definition-expander)
          definition-without-comments env))

(defun %definer-name (definer definition-without-comments)
   (funcall (get definer :definition-name)
          definition-without-comments))



(il:* il:\; "The most commonly-used definers")


(defdefiner (defun (:prototype (lambda (name)
                                          (and (symbolp name)
                                               `(defun ,name ,@(%make-function-prototype)))))
                       (:template (:name :arg-list :body))) il:functions (name args &body
                                                                               (body decls 
                                                                                     documentation))
   `(progn (setf (symbol-function ',name)
                 #'(,'lambda ,args ,@decls (block ,name ,@body)))
           ,@(and documentation `((setf (documentation ',name 'function)
                                        ,documentation)))))

(defdefiner (definline (:prototype (lambda (name)
                                              (and (symbolp name)
                                                   `(definline ,name ,@(%make-function-prototype)))))
                           (:template (:name :arg-list :body))) il:functions (name arg-list &body 
                                                                                   body &environment
                                                                                   env)

(il:* il:|;;;| "This is an INTERIM version of DEFINLINE.  Eventually, this will just turn into a DEFUN and a PROCLAIM INLINE.  (It says so right here.)  If you're using this one, DO NOT make any recursive calls in the body of the DEFINLINE.  If you do, the compiler will run forever trying to expand the optimizer...  Once the INLINE version gets working (in the PavCompiler only) that restriction will be lifted.")

   (multiple-value-bind (code decls doc)
          (parse-body body env t)
          (let ((new-lambda `(,'lambda ,arg-list ,@decls (block ,name ,@code))))
               `(progn (defun ,name ,arg-list
                          ,@body)
                       (defoptimizer ,name ,(pack (list "definline-" name)
                                                  (symbol-package name))
                                           (&rest args)
                                           (cons ',new-lambda args))))))

(defdefiner (defmacro (:prototype (lambda (name)
                                             (and (symbolp name)
                                                  `(defmacro ,name ,@(%make-function-prototype)))))
                          (:undefiner (lambda (name)
                                             (remprop name 'il:argnames)))
                          (:template (:name :arg-list :body))) il:functions (name defmacro-args &body
                                                                                  defmacro-body)
   (unless (and name (symbolp name))
          (error "Illegal name used in DEFMACRO: ~S" name))
   (let
    ((cmacroname (pack (list "expand-" name)
                       (symbol-package name))))
    (multiple-value-bind
     (expansion-fn doc-string)
     (si::expansion-function name defmacro-args defmacro-body)
     `(progn (setf (symbol-function ',cmacroname)
                   #',expansion-fn)
             (setf (macro-function ',name)
                   ',cmacroname)
             ,@(and doc-string `((setf (documentation ',name 'function)
                                       ,doc-string)))
             ,@(when compiler::*new-compiler-is-expanding*
                   `((setf (get ',name 'il:argnames)
                           ',(mapcar #'(lambda (arg)
                                              (if (member arg lambda-list-keywords)
                                                  arg
                                                  (prin1-to-string arg)))
                                    (il:\\simplify.cl.arglist defmacro-args)))))))))

(defdefiner (defvar (:prototype (lambda (name)
                                           (and (symbolp name)
                                                `(defvar ,name))))) il:variables (name &optional
                                                                                       (initial-value
                                                                                        nil ivp)
                                                                                       documentation)
   `(progn (proclaim '(special ,name))
           ,@(and ivp `((or (boundp ',name)
                            (setq ,name ,initial-value))))
           ,@(and documentation `((setf (documentation ',name 'variable)
                                        ,documentation)))))

(defdefiner (defparameter (:prototype (lambda (name)
                                                 (and (symbolp name)
                                                      `(defparameter ,name "Value"
                                                          "Documentation string"))))) il:variables (
                                                                                                 name
                                                                                                    
                                                                                        initial-value
                                                                                                    
                                                                                            &optional
                                                                                                    
                                                                                        documentation
                                                                                                    )
   `(progn (proclaim '(special ,name))
           (setq ,name ,initial-value)
           ,@(and documentation `((setf (documentation ',name 'variable)
                                        ,documentation)))))

(defdefiner (defconstant (:prototype (lambda (name)
                                                (and (symbolp name)
                                                     `(defconstant ,name "Value"
                                                         "Documentation string"))))) il:variables (
                                                                                                 name
                                                                                                   
                                                                                                value
                                                                                                   
                                                                                            &optional
                                                                                                   
                                                                                        documentation
                                                                                                   )
   `(progn ,@(if (constantp name)
                 `((set-constantp ',name nil)))
           (setq ,name ,value)
           (proclaim '(si::constant ,name))
           ,@(and documentation `((setf (documentation ',name 'variable)
                                        ,documentation)))))

(defdefiner (defglobalvar (:prototype (lambda (name)
                                                 (and (symbolp name)
                                                      `(defglobalvar ,name))))) il:variables (name
                                                                                              
                                                                                            &optional
                                                                                              (
                                                                                        initial-value
                                                                                               nil 
                                                                                               ivp)
                                                                                              
                                                                                        documentation
                                                                                              )

   (il:* il:|;;| "Use IL:SETQ here or the INIT dies.")

   `(progn (proclaim '(global ,name))
           ,@(and ivp `((or (boundp ',name)
                            (setq ,name ,initial-value))))
           ,@(and documentation `((setf (documentation ',name 'variable)
                                        ,documentation)))))

(defdefiner (defglobalparameter (:prototype (lambda (name)
                                                       (and (symbolp name)
                                                            `(defglobalparameter ,name "Value"
                                                                "Documentation string"))))) 
   il:variables (name initial-value &optional documentation)
   `(progn (proclaim '(global ,name))
           (setq ,name ,initial-value)
           ,@(and documentation `((setf (documentation ',name 'variable)
                                        ,documentation)))))



(il:* il:\; "Here so that the evaluator can be in the init without definers being in the init.")


(def-define-type il:special-forms "Common Lisp special forms"
   :undefiner %remove-special-form)

(defun %remove-special-form (x)
   (il:/remprop x 'il:special-form))

(defdefiner (define-special-form (:template (:name :arg-list :body))) il:special-forms (name
                                                                                            args 
                                                                                            &rest 
                                                                                            body)
   (cond
      ((null body)
       (assert (symbolp name)
              nil "Ill-formed short DEFINE-SPECIAL-FORM; ~S is not a symbol." args)
       `(setf (get ',name 'il:special-form)
              ',args))
      (t (let ((sf (intern (concatenate 'string "interpret-" (string name))
                          (symbol-package name))))
              (multiple-value-bind (parsed-body decls doc)
                     (il:parse-defmacro args '$$tail body name nil :path '$$tail :environment
                            '$$env)
                     `(progn (setf (symbol-function ',sf)
                                   #'(lambda ($$tail $$env)
                                            ,@decls
                                            (block ,name ,parsed-body)))
                             (setf (get ',name 'il:special-form)
                                   ',sf)))))))



(il:* il:\; "Form for defining interpreters of special forms")




(il:* il:\; "Don't note changes to these properties/variables")


(il:putprops il:macro-fn il:proptype il:functions)

(il:putprops :undefiners il:proptype ignore)

(il:putprops il:undefiners il:proptype ignore)

(il:putprops :definer-for il:proptype ignore)

(il:putprops il:definer-for il:proptype ignore)

(il:putprops :defined-by il:proptype ignore)

(il:putprops il:defined-by il:proptype ignore)

(il:putprops :definition-name il:proptype ignore)

(il:putprops il:definition-name il:proptype ignore)



(il:* il:\; 
"Templates for definers not defined here.  These should really be where they're defined.")


(il:putprops defcommand :definition-print-template (:name :arg-list :body))

(il:putprops define-condition :definition-print-template (:name :value :body))

(il:putprops define-modify-macro :definition-print-template (:name :arg-list))

(il:putprops define-setf-method :definition-print-template (:name :arg-list :body))

(il:putprops defsetf :definition-print-template (:name :arg-list :arg-list :body))

(il:putprops defstruct :definition-print-template (:name :body))

(il:putprops deftype :definition-print-template (:name :arg-list :body))



(il:* il:|;;| "Arrange for the correct compiler to be used.")


(il:putprops il:cmldeffer il:filetype :compile-file)

(il:putprops il:cmldeffer il:makefile-environment (:readtable "XCL" :package "XCL"))
(il:putprops il:cmldeffer il:copyright ("Venue & Xerox Corporation" 1986 1900 1987 1988 1990))
(il:declare\: il:dontcopy
  (il:filemap (nil)))
il:stop
