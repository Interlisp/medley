(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED " 9-Jun-2025 20:20:32" {WMEDLEY}<sources>FONT.;170 218882 

      :EDIT-BY rmk

      :CHANGES-TO (RECORDS FONTDESCRIPTOR)
                  (MACROS \FSETCHARWIDTH)
                  (VARS NSFONTFAMILIES)

      :PREVIOUS-DATE " 9-Jun-2025 20:06:18" {WMEDLEY}<sources>FONT.;167)


(PRETTYCOMPRINT FONTCOMS)

(RPAQQ FONTCOMS
       [
        (* ;; "font functions ")

        (FNS CHARWIDTH CHARWIDTHY STRINGWIDTH \CHARWIDTH.DISPLAY \STRINGWIDTH.DISPLAY 
             \STRINGWIDTH.GENERIC)
        (FNS DEFAULTFONT FONTCLASS FONTCLASSUNPARSE FONTCLASSCOMPONENT SETFONTCLASSCOMPONENT)
        [COMS                                                (* ; 
                                                             "Until we pin down the exact interface")
              (P (MOVD 'FONTCLASSCOMPONENT 'FONTCOMPONENT)
                 (MOVD 'SETFONTCLASSCOMPONENT 'SETFONTCOMPONENT]
        [COMS                                                (* ; "MAPPING FOR DOS FILENAMES ")
              (INITVARS (*DISPLAY-FONT-NAME-MAP* '((TIMESROMAN . TR)
                                                   (HELVETICA . HV)
                                                   (TIMESROMAND . TD)
                                                   (HELVETICAD . HD)
                                                   (MODERN . MD)
                                                   (CLASSIC . CL)
                                                   (GACHA . GC)
                                                   (TITAN . TI)
                                                   (LETTERGOTHIC . LG)
                                                   (BOLDPS . BP)
                                                   (TERMINAL . TM)
                                                   (CLASSICTHIN . CT)
                                                   (HIPPO . HP)
                                                   (LOGO . LG)
                                                   (MATH . MA)
                                                   (OLDENGLISH . OE)
                                                   (SYMBOL . SY]
        (VARS NSFONTFAMILIES ALTOFONTFAMILIES)
        (COMS 
              (* ;; "Creation: ")

              (FNS FONTCREATE COMPLETEFONT COMPLETEFONTP COMPLETECHARSET \COMPLETECHARSET.CSINFO 
                   PRUNEFONTSLUGS \FONT.SYMBOLMEMB \FONT.SYMBOLASSOC \FONT.COMPARESYMBOL))
        (COMS 
              (* ;; "Property extraction:")

              (FNS FONTASCENT FONTDESCENT FONTHEIGHT FONTPROP \AVGCHARWIDTH))
        (COMS 
              (* ;; "Bitmap editing/manipulation:")

              (FNS EDITCHAR)
                                                             (* ; "Should this be on EDITFONT ?")
              (FNS GETCHARBITMAP PUTCHARBITMAP \GETCHARBITMAP.CSINFO \PUTCHARBITMAP.CSINFO)
              (FNS MOVECHARBITMAP MOVEFONTCHARS \MOVEFONTCHAR SLUGCHARP.DISPLAY \GETFONTCHARINFO))
        (COMS 
              (* ;; "\FINDFONTFILE \FONTFILENAME \SEARCHFONTFILES \FONTINFOFROMFILENAME are redefined to deal with character-set directories.  That behavior is conditioned on the setting of the global variable *USEOLDFONTDIRECTORIES*, T at PARC, maybe NIL most other places.  ")

              (FNS FONTFILES \FINDFONTFILE \FONTFILENAMES \FONTFILENAME \FONTFILENAME.OLD 
                   \FONTFILENAME.NEW \FONTINFOFROMFILENAME \FONTINFOFROMFILENAME.OLD)
              (*                                             (* ; "Do we still want old fonts?")
                 (ADDVARS (*OLD-FONT-EXTENSIONS* STRIKE)))
              (INITVARS (*OLD-FONT-EXTENSIONS* NIL))
              (INITVARS (*USEOLDFONTDIRECTORIES* NIL))
              (GLOBALVARS *OLD-FONT-EXTENSIONS* *USEOLDFONTDIRECTORIES*))
        (FNS FONTCOPY FONTSAVAILABLE FONTFILEFORMAT FONTP FONTUNPARSE SETFONTDESCRIPTOR CHARCODEP 
             \STREAMCHARWIDTH \UNITWIDTHSVECTOR \CREATEDISPLAYFONT \CREATECHARSET.DISPLAY 
             \COERCECHARSET \CREATE-REAL-CHARSET.DISPLAY \BUILDSLUGCSINFO \SEARCHDISPLAYFONTFILES 
             \SEARCHFONTFILES \FONTSYMBOL \DEVICESYMBOL \FONTFACE \FONTFACE.COLOR \GETFONTDESC 
             \COERCEFONTDESC \LOOKUPFONT \LOOKUPFONTSINCORE \READDISPLAYFONTFILE SETFONTCHARENCODING)
        (FNS ACFONT.FILEP STRIKEFONT.FILEP)
                                                             (* ; "Legacy font-fille predicates")
        (COMS                                                (* ; "STRIKE format file support")
              (FNS \READSTRIKEFONTFILE \SFMAKEBOLD \SFMAKEITALIC \SFMAKEROTATEDFONT \SFROTATECSINFO 
                   \SFROTATEFONTCHARACTERS \SFFIXOFFSETSAFTERROTATION \SFROTATECSINFOOFFSETS 
                   \SFMAKECOLOR)
              (FNS WRITESTRIKEFONTFILE STRIKECSINFO))
        (FNS FONTDESCRIPTOR.DEFPRINT FONTCLASS.DEFPRINT)
        (INITRECORDS FONTCLASS FONTDESCRIPTOR CHARSETINFO)
        (SYSRECORDS FONTCLASS FONTDESCRIPTOR CHARSETINFO)
        (INITVARS (\FONTSINCORE)
               (\DEFAULTDEVICEFONTS)
               (\UNITWIDTHSVECTOR))
        (GLOBALVARS DISPLAYFONTDIRECTORIES \DEFAULTDEVICEFONTS \UNITWIDTHSVECTOR)
        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (\UNITWIDTHSVECTOR)))
        (EXPORT (OPTIMIZERS FONTPROP))
        [DECLARE%: DONTCOPY (EXPORT (RECORDS FONTCLASS FONTDESCRIPTOR FONTFACE CHARSETINFO)
                                   (MACROS FONTASCENT FONTDESCENT FONTHEIGHT \FGETOFFSET \FSETOFFSET
                                          \FGETWIDTH \FSETWIDTH \FGETCHARWIDTH \FSETCHARWIDTH 
                                          \FGETIMAGEWIDTH \FSETIMAGEWIDTH)
                                   (MACROS \XGETCHARSETINFO \GETCHARSETINFO \INSURECHARSETINFO 
                                          \CREATECSINFOELEMENT \CREATEFONTCHARSETVECTOR)
                                   (CONSTANTS (\MAXNSCHAR 65535]
        (FNS \CREATEKERNELEMENT \FSETLEFTKERN \FGETLEFTKERN)
        (COMS (FNS \CREATEFONT \CREATECHARSET \INSTALLCHARSETINFO \INSTALLCHARSETINFO.CHARENCODING)
              (GLOBALVARS DISPLAYFONTCOERCIONS DISPLAYCHARSETCOERCIONS)
              (INITVARS (DISPLAYFONTCOERCIONS NIL)
                     [DISPLAYCHARSETCOERCIONS '(((GACHA)
                                                 (TERMINAL))
                                                ((MODERN)
                                                 (CLASSIC))
                                                ((TIMESROMAN)
                                                 (CLASSIC))
                                                ((HELVETICA)
                                                 (MODERN))
                                                ((TERMINAL)
                                                 (MODERN]
                     (\DEFAULTCHARSET 0)))
        (FNS \FONTRESETCHARWIDTHS)
        (GLOBALVARS DISPLAYCHARSETFNS)
        [DECLARE%: DONTEVAL@LOAD DOCOPY (INITVARS (DISPLAYFONTDIRECTORIES NIL))
               (VARS (DISPLAYCHARSETFNS '((MEDLEYFONT MEDLEYFONT.FILEP MEDLEYFONT.GETCHARSET)
                                          (AC ACFONT.FILEP ACFONT.GETCHARSET)
                                          (STRIKE STRIKEFONT.FILEP \READSTRIKEFONTFILE]
        (DECLARE%: DONTEVAL@LOAD DOCOPY                      (* ; "The loadup might have fewer")
               (ADDVARS (DISPLAYFONTEXTENSIONS MEDLEYDISPLAYFONT DISPLAYFONT STRIKE)))
        (DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (MAXCODE 255)
                                                (DUMMYINDEX 256)))
        (MACROS \FGETCHARIMAGEWIDTH \GETFONTDESC \SETCHARSETINFO)
        (LOCALVARS . T)
        (PROP FILETYPE FONT)
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)
                                                                             (NLAML)
                                                                             (LAMA FONTCOPY])



(* ;; "font functions ")

(DEFINEQ

(CHARWIDTH
  [LAMBDA (CHARCODE FONT)                                (* rmk%: "12-Apr-85 09:46")
                                                             (* ; 
                                              "gets the width of a character code in a font/stream")
    (OR (\CHARCODEP CHARCODE)
        (\ILLEGAL.ARG CHARCODE))
    (LET (TEMP)
         (COND
            ((type? FONTDESCRIPTOR FONT)
             (\FGETCHARWIDTH FONT CHARCODE))
            ((SETQ TEMP (\OUTSTREAMARG FONT T))              (* ; 
                                                     "NIL font goes thru here--primary output file")
             (IMAGEOP 'IMCHARWIDTH TEMP TEMP CHARCODE))
            (T (\FGETCHARWIDTH (FONTCREATE FONT)
                      CHARCODE])

(CHARWIDTHY
  [LAMBDA (CHARCODE FONT)                                    (* ; "Edited 22-May-2025 09:47 by rmk")
                                                             (* edited%: "18-Mar-86 19:30")
                                                             (* ; 
                                   "Gets the Y-component of the width of a character code in a font.")
    (OR (\CHARCODEP CHARCODE)
        (\ILLEGAL.ARG CHARCODE))
    (LET (TEMP WY)
         (COND
            ((type? FONTDESCRIPTOR FONT)
             (SETQ WY (ffetch (CHARSETINFO YWIDTHS) of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                              FONT)))
             (COND
                ((FIXP WY))
                (WY (\FGETWIDTH WY (\CHAR8CODE CHARCODE)))
                (T 0)))
            ((type? STREAM (SETQ TEMP (\OUTSTREAMARG FONT T)))
                                                             (* ; 
                                                       "NIL font goes thru here--primary output file")
             (IMAGEOP 'IMCHARWIDTHY TEMP TEMP CHARCODE))
            (T [SETQ WY (ffetch (CHARSETINFO YWIDTHS) of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                                (FONTCREATE FONT]
               (COND
                  ((FIXP WY))
                  (WY (\FGETWIDTH WY (\CHAR8CODE CHARCODE)))
                  (T 0])

(STRINGWIDTH
  [LAMBDA (STR FONT FLG RDTBL)                           (* ; "Edited  8-Jan-88 14:41 by Snow")

    (* ;; "Returns the width of STR according to FONT")

    (LET (TEMP)

         (* ;; "Used in \MAPCHARS")

         (COND
            [(type? FONTDESCRIPTOR FONT)
             (\STRINGWIDTH.GENERIC STR FONT (AND FLG (\GTREADTABLE RDTBL))
                    (\FGETCHARWIDTH FONT (CHARCODE SPACE]
            [(AND FONT (SETQ TEMP (\OUTSTREAMARG FONT T)))   (* ; 
  "if you gave something for FONT, coerce it to a stream, and call the stringwidth function of it.")
             (IMAGEOP 'IMSTRINGWIDTH TEMP TEMP STR (AND FLG (\GTREADTABLE RDTBL]
            (T (SETQ TEMP (FONTCREATE (OR FONT DEFAULTFONT)))
                                                             (* ; "NIL font will pass thru here.  ie, defaultfont is used to do the stringwidth instead of the font of *standard-output*")
               (\STRINGWIDTH.GENERIC STR TEMP (AND FLG (\GTREADTABLE RDTBL))
                      (\FGETCHARWIDTH TEMP (CHARCODE SPACE])

(\CHARWIDTH.DISPLAY
  [LAMBDA (STREAM CHARCODE)                              (* rmk%: "12-Apr-85 09:42")
                                                             (* ; 
         "gets the width of a character code in a display stream.  Need to fix up for spacefactor.")
    (\FGETCHARWIDTH (ffetch (\DISPLAYDATA DDFONT) of (ffetch IMAGEDATA of STREAM))
           CHARCODE])

(\STRINGWIDTH.DISPLAY
  [LAMBDA (STREAM STR RDTBL)                             (* ; "Edited  3-Apr-87 12:07 by jop")

    (* ;; "Returns the width of for the current font/spacefactor in STREAM.")

    (LET ((DD (ffetch IMAGEDATA of STREAM)))
         (\STRINGWIDTH.GENERIC STR (ffetch (\DISPLAYDATA DDFONT) of DD)
                RDTBL
                (ffetch DDSPACEWIDTH of DD])

(\STRINGWIDTH.GENERIC
  [LAMBDA (STR FONT RDTBL SPACEWIDTH)                        (* ; "Edited 22-May-2025 09:51 by rmk")
                                                             (* ; "Edited  3-Apr-87 13:47 by jop")

    (* ;; "Returns the width of STR with SPACEWIDTH for the width of spaces.  RDTBL has already been coerced, so no FLG is needed ")

    (* ;; "This is cloned in \STRINGWIDTH.HCPYDISPLAYAUX by straight substitution -- (PUTDEF (QUOTE \STRINGWIDTH.HCPYDISPLAYAUX) (QUOTE FNS) (SUBLIS (QUOTE ((WIDTHS  . IMAGEWIDTHS) (\FGETWIDTH  . \FGETIMAGEWIDTH) (\FGETCHARWIDTH  . \FGETCHARIMAGEWIDTH))) (GETDEF (QUOTE \STRINGWIDTH.GENERIC))))")

    (* ;; "\MAPPNAME uses WIDTHSBASE CSET TOTALWIDTH FONT SPACEWIDTH free, so these become special in bytecompiler")

    (PROG NIL
          [COND
             [(LITATOM STR)
              (if RDTBL
                  then (GO SLOW)
                else (RETURN (for C WIDTHSBASE CSET inatom STR
                                sum [COND
                                       ((NEQ CSET (\CHARSET C))
                                        (SETQ CSET (\CHARSET C))
                                        (SETQ WIDTHSBASE (ffetch (CHARSETINFO WIDTHS)
                                                            of (\INSURECHARSETINFO CSET FONT]
                                    (COND
                                       ((EQ C (CHARCODE SPACE))
                                        SPACEWIDTH)
                                       (T (\FGETWIDTH WIDTHSBASE (\CHAR8CODE C]
             ((STRINGP STR)
              (RETURN
               (LET ((TOTAL 0)
                     ESC ESCWIDTH WIDTHSBASE CSET)
                    [COND
                       (RDTBL                                (* ; 
                                                       "Count delimiting quotes and internal escapes")
                              (SETQ TOTAL (UNFOLD (\FGETCHARWIDTH FONT (CHARCODE %"))
                                                 2))
                              (SETQ ESC (fetch (READTABLEP ESCAPECHAR) of RDTBL))
                              (SETQ ESCWIDTH (\FGETCHARWIDTH FONT ESC]
                    [for C instring STR
                       do [COND
                             ((NEQ (\CHARSET C)
                                   CSET)                     (* ; 
                                                       "Get the widths vector for this character set")
                              (SETQ CSET (\CHARSET C))
                              (SETQ WIDTHSBASE (ffetch (CHARSETINFO WIDTHS) of (\INSURECHARSETINFO
                                                                                CSET FONT]
                          (add TOTAL (COND
                                        ((EQ C (CHARCODE SPACE))
                                         SPACEWIDTH)
                                        (T (IPLUS (\FGETWIDTH WIDTHSBASE (\CHAR8CODE C))
                                                  (COND
                                                     ((AND RDTBL (OR (EQ C (CHARCODE %"))
                                                                     (EQ C ESC)))
                                                             (* ; "String char must be escaped")
                                                      ESCWIDTH)
                                                     (T 0]
                    TOTAL]
      SLOW
                                                             (* ; "Do the general case here")
          (RETURN (LET ((TOTALWIDTH 0)
                        WIDTHSBASE CSET (FONT FONT)
                        (SPACEWIDTH SPACEWIDTH))
                       (DECLARE (SPECVARS TOTALWIDTH WIDTHSBASE CSET FONT SPACEWIDTH))
                       (\MAPPNAME [FUNCTION (LAMBDA (DUMMY CC)
                                              (add TOTALWIDTH (COND
                                                                 ((EQ CC (CHARCODE SPACE))
                                                                  SPACEWIDTH)
                                                                 ((EQ CSET (\CHARSET CC))
                                                                  (\FGETWIDTH WIDTHSBASE (\CHAR8CODE
                                                                                          CC)))
                                                                 (T (SETQ CSET (\CHARSET CC))
                                                                    (SETQ WIDTHSBASE
                                                                     (ffetch (CHARSETINFO WIDTHS)
                                                                        of (\INSURECHARSETINFO CSET 
                                                                                  FONT)))
                                                                    (\FGETWIDTH WIDTHSBASE
                                                                           (\CHAR8CODE CC]
                              STR RDTBL RDTBL *PRINT-LEVEL* *PRINT-LENGTH*)
                       TOTALWIDTH])
)
(DEFINEQ

(DEFAULTFONT
  [LAMBDA (DEVICE FONT NOERRORFLG)                       (* ; "Edited 28-Jul-88 13:15 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:41 by FS")

    (* ;; "Returns the default font for an image type.  Really only needed to guarantee validity of the display default font for system critical routines, in case the user has smashed the variable DEFAULTFONT.  Note that SETFONTCLASSCOMPONENT and FONTCLASS guarantee that the display component is either NIL or a fontdescriptor.")

    (* ;; "FS- If FONT provided set the font descriptor.  Do not bother to check if NOERRORFLG is NEW. (old code had (AND FONT (EQ NOERRORFLG 'NEW)))")

    [OR (type? FONTCLASS DEFAULTFONT)
        (SETQ DEFAULTFONT (FONTCLASS 'DEFAULTFONT]
    (if FONT
        then 

              (* ;; "FS- Not clear the fontclass should be smashed, perhaps instead should make a new FONTCLASS and then rebind DEFAULTFONT.  Leaving alone for histerical reasons")

              (SETFONTCLASSCOMPONENT DEFAULTFONT DEVICE FONT)
      else 

            (* ;; "The code below (not mine!) is messy but is correct (unless weirdness pops up because of deep recursion).")

            (COND
               ((\COERCEFONTDESC DEFAULTFONT DEVICE T))
               (NOERRORFLG NIL)
               ((EQ (\DEVICESYMBOL DEVICE T)
                    'DISPLAY)

                (* ;; "If getting for the display and the font can't be found perhaps because of garbage in the display field of the DEFAULTFONTCLASS, then the system-guaranteed displayfont.  Otherwise, cause the error in the re-coercion.  Can never tell when DEVICE is just a symbol.")

                \GUARANTEEDDISPLAYFONT)
               ((\COERCEFONTDESC DEFAULTFONT DEVICE])

(FONTCLASS
  [LAMBDA (NAME FONTLIST CREATEFORDEVICES)               (* jds " 9-Sep-86 18:49")

    (* ;; "This builds D style font classes, which are datatypes containing entries for the various known devices.")

    (* ;; "Don't actually set up the for devices not inside CREATEFORDEVICES on the theory that any given user presumably doesn't want all the fonts for all the devices.  We wait until he actually asks for the font or the fontmaparray, at which point we note that the fields don't contain FD's, so we then apply FONTCREATE.  The actual coercion and caching is done inside \COERCEFONTDESC.  However, so as to prevent display crashes, if a display component is specified, we always do the fontcreate before we stick it in.")

    (PROG (F FC FL)
          (SETQ FL FONTLIST)
          [SETQ FC (create FONTCLASS
                          FONTCLASSNAME _ NAME
                          PRETTYFONT# _ (OR (FIXP (pop FL))
                                            1)
                          DISPLAYFD _ (AND (SETQ F (pop FL))
                                           (FONTCREATE F NIL NIL NIL 'DISPLAY))
                          PRESSFD _ (pop FL)
                          INTERPRESSFD _ (pop FL)
                          OTHERFDS _ (for FSPEC in FL
                                        collect (OR (AND (LISTP FSPEC)
                                                             (ATOM (CAR FSPEC))
                                                             (CAR FSPEC))
                                                        (ERROR "illegal font class specification"
                                                               (LIST NAME FONTLIST))) 
                                                             (* ; 
                                     "Copy the alist entry so it can be smashed in \COERCEFONTDESC")
                                              (CONS (CAR FSPEC)
                                                    (CAR (LISTP (CDR FSPEC]
          (for D inside CREATEFORDEVICES do (FONTCREATE FC NIL NIL NIL D))
          (RETURN FC])

(FONTCLASSUNPARSE
  [LAMBDA (FONTCLASS DEVICE FONT NOERRORFLG)         (* jds "24-Jan-86 11:58")
                                                             (* ; 
                                "Given a font class, unparse it to a form that might be reparsable")
    (APPEND (LIST (fetch (FONTCLASS FONTCLASSNAME) of FONTCLASS)
                  (fetch (FONTCLASS PRETTYFONT#) of FONTCLASS)
                  (FONTUNPARSE (ffetch (FONTCLASS DISPLAYFD) of FONTCLASS))
                  (FONTUNPARSE (ffetch (FONTCLASS PRESSFD) of FONTCLASS))
                  (FONTUNPARSE (ffetch (FONTCLASS INTERPRESSFD) of FONTCLASS)))
           (for X in (fetch (FONTCLASS OTHERFDS) of FONTCLASS)
              collect (LIST (CAR X)
                                (FONTUNPARSE (CDR X])

(FONTCLASSCOMPONENT
  [LAMBDA (FONTCLASS DEVICE FONT NOERRORFLG)         (* rmk%: "14-Sep-84 19:34")
    (PROG1 (FONTCREATE FONTCLASS NIL NIL NIL DEVICE NOERRORFLG)
                                                             (* ; 
                    "This works its way down to \COERCEFONTDESC, where it needs to be done quickly")
        (AND FONT (SETQ FONT (FONTCREATE FONT NIL NIL NIL DEVICE NOERRORFLG))
             (SETFONTCLASSCOMPONENT FONTCLASS DEVICE FONT)))])

(SETFONTCLASSCOMPONENT
  [LAMBDA (FONTCLASS DEVICE FONT)                    (* ; "Edited 29-Aug-91 12:20 by jds")
    (PROG ((NEWFONT (FONTCREATE FONT NIL NIL NIL DEVICE)))

     (* ;; "replaces will barf if FONTCLASS is not a fontclass")

          (SELECTQ (SETQ DEVICE (FONTPROP NEWFONT 'DEVICE))
              (DISPLAY (replace (FONTCLASS DISPLAYFD) of FONTCLASS with NEWFONT))
              (INTERPRESS (replace (FONTCLASS INTERPRESSFD) of FONTCLASS with NEWFONT
                                 ))
              (PRESS (replace (FONTCLASS PRESSFD) of FONTCLASS with NEWFONT))
              (RPLACD [OR (SASSOC DEVICE (fetch (FONTCLASS OTHERFDS) of FONTCLASS))
                          (CAR (push (fetch (FONTCLASS OTHERFDS) of FONTCLASS)
                                      (CONS DEVICE]
                     NEWFONT))
          (RETURN NEWFONT])
)



(* ; "Until we pin down the exact interface")


(MOVD 'FONTCLASSCOMPONENT 'FONTCOMPONENT)

(MOVD 'SETFONTCLASSCOMPONENT 'SETFONTCOMPONENT)



(* ; "MAPPING FOR DOS FILENAMES ")


(RPAQ? *DISPLAY-FONT-NAME-MAP*
       '((TIMESROMAN . TR)
         (HELVETICA . HV)
         (TIMESROMAND . TD)
         (HELVETICAD . HD)
         (MODERN . MD)
         (CLASSIC . CL)
         (GACHA . GC)
         (TITAN . TI)
         (LETTERGOTHIC . LG)
         (BOLDPS . BP)
         (TERMINAL . TM)
         (CLASSICTHIN . CT)
         (HIPPO . HP)
         (LOGO . LG)
         (MATH . MA)
         (OLDENGLISH . OE)
         (SYMBOL . SY)))

(RPAQQ NSFONTFAMILIES (CLASSIC MODERN TERMINAL OPTIMA TITAN BOLDPS PCTERMINAL))

(RPAQQ ALTOFONTFAMILIES (GACHA TIMESROMAN TIMESROMAND HELVETICA OLDENGLISH SNAIL TONTO))



(* ;; "Creation: ")

(DEFINEQ

(FONTCREATE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE NOERRORFLG CHARSET)
                                                             (* ; "Edited  7-Jun-2025 15:01 by rmk")
                                                             (* ; "Edited 20-May-2025 20:41 by rmk")
                                                             (* ; "Edited 10-Oct-88 09:53 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:43 by rmk:")
                                                             (* ; "Edited 10-Nov-87 18:08 by FS")

    (* ;; "Create a font descriptor for the specified font.  If NOERRORFLG, return NIL if the font doesn't exist;  otherwise cause an error.")

    (* ;; "Cache and fonts.widths traffic in uppercase only.")

    (* ;; "character set is optional and defaults to \DEFAULTCHARSET (0 in our world)")

    (DECLARE (GLOBALVARS IMAGESTREAMTYPES \DEFAULTCHARSET))
    (PROG (FONTX (CHSET (OR CHARSET \DEFAULTCHARSET)))
          (RETURN (COND
                     ((LISTP FAMILY)
                      (SELECTQ (CAR FAMILY)
                          (FONT (SETQ FONTX (CDR FAMILY)))
                          (CLASS (COND
                                    ((LITATOM (CADR FAMILY)) (* ; "litatom class name")
                                     (RETURN (FONTCLASS (CADR FAMILY)
                                                    (CDDR FAMILY)
                                                    DEVICE)))
                                    (T                       (* ; 
                       "Allows for a font named CLASS--distinguished cause its size is not a litatom")
                                       (SETQ FONTX FAMILY))))
                          (SETQ FONTX FAMILY))
                      (FONTCREATE (CAR FONTX)
                             (OR (CADR FONTX)
                                 SIZE)
                             (OR (CADDR FONTX)
                                 FACE)
                             (OR (CADDDR FONTX)
                                 ROTATION)
                             (OR (CADR (CDDDR FONTX))
                                 DEVICE)
                             NOERRORFLG CHSET))
                     ([SETQ FONTX (COND
                                     ((type? FONTDESCRIPTOR FAMILY)
                                      FAMILY)
                                     ((NULL FAMILY)
                                      (DEFAULTFONT DEVICE))
                                     ((type? FONTCLASS FAMILY)

                                 (* ;; "We know that this won't attempt a cyclic fontcreate in \COERCEFONTDESC, because we are passing a known class.  Unless NOERROFLG, an error will be caused on the actual device font if it can't be found.")

                                      (\COERCEFONTDESC FAMILY DEVICE NOERRORFLG))
                                     ((OR (IMAGESTREAMP FAMILY)
                                          (type? WINDOW FAMILY))
                                      (DSPFONT NIL FAMILY]

                      (* ;; 
                   "FAMILY was a spec for a font descriptor, use it and extend it by the other args.")

                      (COND
                         ((OR SIZE FACE ROTATION DEVICE)
                          (FONTCREATE (FONTPROP FONTX 'FAMILY)
                                 (OR SIZE (FONTPROP FONTX 'SIZE))
                                 (OR FACE (FONTPROP FONTX 'FACE))
                                 (OR ROTATION (FONTPROP FONTX 'ROTATION))
                                 (OR DEVICE (FONTPROP FONTX 'DEVICE))
                                 NOERRORFLG))
                         (T FONTX)))
                     (T (PROG (FONTFACE (DEV DEVICE))
                          RETRY
                              [OR (LITATOM FAMILY)
                                  (COND
                                     (NOERRORFLG (RETURN))
                                     (T (LISPERROR "ARG NOT LITATOM" FAMILY T]
                              [OR (AND (FIXP SIZE)
                                       (IGREATERP SIZE 0))
                                  (COND
                                     (NOERRORFLG (RETURN NIL))
                                     (T (\ILLEGAL.ARG SIZE]
                              (COND
                                 ((NULL ROTATION)
                                  (SETQ ROTATION 0))
                                 ((AND (FIXP ROTATION)
                                       (IGEQ ROTATION 0)))
                                 (NOERRORFLG (RETURN NIL))
                                 (T (\ILLEGAL.ARG ROTATION)))
                              [SETQ DEV (COND
                                           ((NULL DEVICE)
                                            'DISPLAY)
                                           ((AND (LITATOM DEVICE)
                                                 (NEQ DEVICE T))
                                                             (* ; 
  "Maybe wrong case or package, but we bet it's OK and defer  expensive coercion until we've failed.")
                                            DEV)
                                           ((SETQ DEV (\GETSTREAM DEVICE 'OUTPUT T))
                                                             (* ; "T coerces here to primary output")
                                            (fetch (IMAGEOPS IMFONTCREATE) of (fetch (STREAM IMAGEOPS
                                                                                            )
                                                                                 of DEV)))
                                           ((STRINGP DEVICE)
                                            (MKATOM (U-CASE DEVICE)))
                                           (NOERRORFLG (RETURN NIL))
                                           (T (\ILLEGAL.ARG DEVICE]
                                                             (* ; "DEV is now guanteed litatom")
                          NEWDEV
                                                             (* ; 
                                                    "Check after device since it is device-dependent")
                              (SETQ FONTFACE (OR (\FONTFACE FACE NOERRORFLG DEV)
                                                 (RETURN NIL)))
                                                             (* ; "Don't truly coerce to \FONTSYMBOL or \DEVICESYMBOL until we've had a shot at the font cache, since re-interning atoms is so expensive")
                              [RETURN (COND
                                         ((SETQ FONTX (\LOOKUPFONT FAMILY SIZE FONTFACE ROTATION DEV)
                                           )
                                          (CL:WHEN CHARSET (\INSURECHARSETINFO CHARSET FONTX))
                                          (RETURN FONTX))
                                         [(SETQ FONTX (CDR (ASSOC DEV IMAGESTREAMTYPES)))

                                 (* ;; "Device is valid, font just doesn't exist.   FONTFACE, DEV already canonical.  Make FAMILY so, so that each imagestream type doesn't have to.")

                                          (SETQ FAMILY (\FONTSYMBOL FAMILY))
                                          (COND
                                             ((SETQ FONTX (APPLY* (OR (CADR (ASSOC 'FONTCREATE FONTX)
                                                                            )
                                                                      (FUNCTION NILL))
                                                                 FAMILY SIZE FONTFACE ROTATION DEV 
                                                                 CHSET))

                                      (* ;; "default creation case.  Use fontcreate method from device, build a fontdescriptor and use setfontdescriptor to install it.")

                                           (* ;; "We should probably force all device implementations to obey these conventions, then remove these generic updates")

                                              (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONTX
                                                 with (\AVGCHARWIDTH FONTX))
                                              (SETFONTDESCRIPTOR FAMILY SIZE FONTFACE ROTATION DEV 
                                                     FONTX))
                                             (T (GO NOTFOUND]
                                         ((NEQ DEV (SETQ DEV (U-CASE DEV)))

                                 (* ;; "We didn't recognize the device, so check to see whether coercion to U-CASE IL changes anything.  Could be slow, but we're heading for an error.")

                                          (GO NEWDEV))
                                         (T (GO NOTFOUND]
                          NOTFOUND
                              (COND
                                 (NOERRORFLG (RETURN NIL))
                                 (T (ERROR "FONT NOT FOUND" (LIST FAMILY SIZE FONTFACE ROTATION DEV))
                                    (GO RETRY])

(COMPLETEFONT
  [LAMBDA (FONT EVENIFCOMPLETE)                              (* ; "Edited  8-Jun-2025 15:57 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:18 by rmk")
                                                             (* ; "Edited 23-May-2025 22:57 by rmk")
                                                             (* ; "Edited 20-May-2025 19:57 by rmk")
                                                             (* ; "Edited 16-May-2025 21:26 by rmk")

    (* ;; "This fills in all  uninstantiated charsetinfo's of f FONT. ")

    (* ;; "NOTE:  We reset \FONTSINCORE so that we don't pick up any already modified or coerced fonts, just go directory to the sources.")

    (SETQ FONT (FONTCREATE FONT))
    (CL:WHEN (OR EVENIFCOMPLETE (NOT (fetch (FONTDESCRIPTOR FONTCOMPLETEP) of FONT)))
        (for CS from 0 to \MAXCHARSET do 
                                         (* ;; 
       "Skips existing charsets--they already have as much information as they are ever going to get")

                                         (\INSURECHARSETINFO CS FONT))
        (replace (FONTDESCRIPTOR FONTCOMPLETEP) of FONT with T))
    FONT])

(COMPLETEFONTP
  [LAMBDA (FONT)                                             (* ; "Edited 24-May-2025 20:55 by rmk")
                                                             (* ; "Edited 20-May-2025 14:37 by rmk")

    (* ;; "A font is incomplete if there is a NIL in any charset slot.  Completing will install a charset everywhere, even if it is a slug charset.")

    (SETQ FONT (FONTCREATE FONT))
    (for CS from 0 to \MAXCHARSET always (\XGETCHARSETINFO FONT CS])

(COMPLETECHARSET
  [LAMBDA (DESTFONT SOURCEFONT CHARSET)                      (* ; "Edited  6-Jun-2025 10:46 by rmk")
    (SETQ DESTFONT (FONTCREATE DESTFONT))
    (LET ((DESTCSINFO (\INSURECHARSETINFO CHARSET DESTFONT)))
         (CL:UNLESS (fetch (CHARSETINFO CSCOMPLETEP) of DESTCSINFO)
             (SETQ SOURCEFONT (FONTCREATE SOURCEFONT))
             (MOVEFONTCHARS (for C from (LLSH CHARSET 8) to (IPLUS \MAXTHINCHAR (LLSH CHARSET 8))
                               when (SLUGCHARP.DISPLAY C DESTFONT) unless (SLUGCHARP.DISPLAY C 
                                                                                 SOURCEFONT)
                               collect C)
                    NIL DESTFONT SOURCEFONT))])

(\COMPLETECHARSET.CSINFO
  [LAMBDA (CSINFO FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS)
                                                             (* ; "Edited  8-Jun-2025 20:20 by rmk")
                                                             (* ; "Edited  7-Jun-2025 13:52 by rmk")

    (* ;; "Find/install all missing chars. We assume that CSINFO is or will be the charsetinfo for CHARSET in the font described by FAMILY SIZE...  For each missing code we look through all the possible coercions to find the first one with real information about that character. ")

    (CL:UNLESS [OR (fetch (CHARSETINFO CSCOMPLETEP) of CSINFO)
                   (for C CFONT in COERCIONS never (AND (SETQ CFONT (CAR C))
                                                        (EQ FAMILY (CAR CFONT))
                                                        (OR (NOT (CADR CFONT))
                                                            (EQ SIZE (CADR CFONT)))
                                                        (OR (NOT (CADDR CFONT))
                                                            (EQ CHARSET (CADDR CFONT]
        (for CODE RCSINFO from 0 to \MAXTHINCHAR
           when (AND (SLUGCHARP.DISPLAY CODE CSINFO)
                     (SETQ RCSINFO (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS
                                          CODE))) do (\MOVEFONTCHAR RCSINFO CSINFO CODE CODE)))
    (replace (CHARSETINFO CSCOMPLETEP) of CSINFO with T])

(PRUNEFONTSLUGS
  [LAMBDA (FONT)                                             (* ; "Edited  9-Jun-2025 15:02 by rmk")
                                                             (* ; "Edited 24-May-2025 21:11 by rmk")
    (SETQ FONT (FONTCREATE FONT))
    (for CS CSINFO from 0 to \MAXCHARSET when (AND (SETQ CSINFO (\XGETCHARSETINFO FONT CS))
                                                   (fetch (CHARSETINFO CSSLUGP) of CSINFO))
       do (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR) of FONT)
                 CS NIL))
    FONT])

(\FONT.SYMBOLMEMB
  [LAMBDA (USERINPUT LIST)                               (* ; "Edited  7-Feb-89 15:47 by jds")
    (for X on LIST when (\FONT.COMPARESYMBOL USERINPUT (CAR X))
       do (RETURN X])

(\FONT.SYMBOLASSOC
  [LAMBDA (USERINPUT LIST)                               (* ; "Edited 28-Jul-88 16:56 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:15 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:03 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:44 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:16 by rmk:")
    (for X FIRSTC (NC _ (NCHARS USERINPUT)) in LIST
       first (SETQ FIRSTC (CHCON1 USERINPUT))
             [if (AND (IGEQ FIRSTC (CHARCODE a))
                          (ILEQ FIRSTC (CHARCODE z)))
                 then (SETQ FIRSTC (IDIFFERENCE FIRSTC (IDIFFERENCE (CHARCODE a)
                                                                  (CHARCODE A]
       when (AND (EQ NC (NCHARS (CAR X)))
                     (EQ FIRSTC (CHCON1 (CAR X)))
                     (\FONT.COMPARESYMBOL USERINPUT (CAR X)
                            NC FIRSTC)) do (RETURN X])

(\FONT.COMPARESYMBOL
  [LAMBDA (USERINPUT KEY INPUTNC INPUTFIRSTC) (* ; 
                                                "Edited 24-May-93 16:45 by sybalsky:mv:envos")

    (* ;; " An open coded case- and package-insensitive comparison of atom pnames, assuming that KEY is already upper-case but USERINPUT may not be.  Maybe there is a simple function that does this.")

    (* ;; "INPUTNC and INPUTFIRSTC can be passed in if they are common to lots of calls")

    (COND
       ((AND (LITATOM USERINPUT)
             (EQ [CL:AREF *PACKAGE-FROM-INDEX* (fetch (PNAMECELL PACKAGEINDEX)
                                                  of (PROGN (\PNAMECELL USERINPUT]
                 *INTERLISP-PACKAGE*))

        (* ;; "If the user's symbol is in the IL package (which is where all the KEYs are), we can use EQ, which is MUCH faster.")

        (OR (EQ USERINPUT KEY)
            (EQ (U-CASE USERINPUT)
                KEY)))
       (T 
          (* ;; "Otherwise, we do the comparison character by character.")

          (AND (EQ (OR INPUTNC (NCHARS USERINPUT))
                   (NCHARS KEY))
               [COND
                  (INPUTFIRSTC (EQ INPUTFIRSTC (CHCON1 KEY)))
                  ((EQ (SETQ INPUTFIRSTC (CHCON1 USERINPUT))
                       (CHCON1 KEY)))
                  ((AND (IGEQ INPUTFIRSTC (CHARCODE a))
                        (ILEQ INPUTFIRSTC (CHARCODE z)))
                   (EQ (IDIFFERENCE INPUTFIRSTC (IDIFFERENCE (CHARCODE a)
                                                       (CHARCODE A)))
                       (CHCON1 KEY]
               (for CHAR1 inatom USERINPUT as CHAR2 inatom KEY
                  always (OR (EQ CHAR1 CHAR2)
                                 (AND (IGEQ CHAR1 (CHARCODE a))
                                      (ILEQ CHAR1 (CHARCODE z))
                                      (EQ CHAR2 (IPLUS CHAR1 (CONSTANT (IDIFFERENCE (CHARCODE A)
                                                                              (CHARCODE a])
)



(* ;; "Property extraction:")

(DEFINEQ

(FONTASCENT
  [LAMBDA (FONTSPEC)                                     (* lmm "19-NOV-82 00:23")
    (ffetch \SFAscent of (\GETFONTDESC FONTSPEC])

(FONTDESCENT
  [LAMBDA (FONTSPEC)                                     (* lmm "19-NOV-82 00:24")
                                                             (* ; "See comment in FONTASCENT")
    (ffetch \SFDescent of (\GETFONTDESC FONTSPEC])

(FONTHEIGHT
  [LAMBDA (FONTSPEC)                                     (* kbr%: " 9-Jan-86 18:29")
    (fetch (FONTDESCRIPTOR \SFHeight) of (\GETFONTDESC FONTSPEC])

(FONTPROP
  [LAMBDA (FONT PROP)                                        (* ; "Edited  8-Jun-2025 20:42 by rmk")
                                                             (* ; "Edited 24-May-2025 07:40 by rmk")
                                                             (* ; "Edited 18-May-2025 10:01 by rmk")
                                                             (* ; "Edited 16-May-2025 14:27 by rmk")
                                                             (* ; "Edited 13-May-2025 09:32 by rmk")
                                                             (* ; "Edited  2-May-2025 19:59 by rmk")
                                                             (* kbr%: "13-May-85 22:36")
    (SETQ FONT (FONTCREATE FONT))
    (SELECTQ PROP
        (HEIGHT (ffetch \SFHeight of FONT))
        (ASCENT (ffetch \SFAscent of FONT))
        (DESCENT (ffetch \SFDescent of FONT))
        (FAMILY (ffetch FONTFAMILY of FONT))
        (SIZE (ffetch FONTSIZE of FONT))
        (FACE (COPY (ffetch FONTFACE of FONT)))
        (WEIGHT (ffetch WEIGHT of (ffetch FONTFACE of FONT)))
        (SLOPE (ffetch SLOPE of (ffetch FONTFACE of FONT)))
        (EXPANSION (ffetch EXPANSION of (ffetch FONTFACE of FONT)))
        (FORECOLOR (ffetch FORECOLOR of (ffetch FONTFACE of FONT)))
        (BACKCOLOR (ffetch BACKCOLOR of (ffetch FONTFACE of FONT)))
        (ROTATION (ffetch ROTATION of FONT))
        (DEVICE (ffetch FONTDEVICE of FONT))
        (CHARENCODING (ffetch FONTCHARENCODING of FONT))
        (SPEC (LIST (ffetch FONTFAMILY of FONT)
                    (ffetch FONTSIZE of FONT)
                    (COPY (ffetch FONTFACE of FONT))
                    (ffetch ROTATION of FONT)
                    (ffetch FONTDEVICE of FONT)))
        (DEVICESPEC                                          (* ; 
                    "DEVICE fields are for communicating coercions to the particular printing device")
                    [COND
                       ((ffetch FONTDEVICESPEC of FONT)
                        (COPY (ffetch FONTDEVICESPEC of FONT)))
                       (T (FONTPROP FONT 'SPEC])
        (DEVICEFACE [COPY (COND
                             ((ffetch FONTDEVICESPEC of FONT)
                              (CADDR (ffetch FONTDEVICESPEC of FONT)))
                             (T (ffetch FONTFACE of FONT])
        (DEVICESLOPE [fetch SLOPE of (COND
                                        ((ffetch FONTDEVICESPEC of FONT)
                                         (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                        (T (ffetch FONTFACE of FONT])
        (DEVICEWEIGHT [fetch WEIGHT of (COND
                                          ((ffetch FONTDEVICESPEC of FONT)
                                           (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                          (T (ffetch FONTFACE of FONT])
        (DEVICEEXPANSION 
             [fetch EXPANSION of (COND
                                    ((ffetch FONTDEVICESPEC of FONT)
                                     (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                    (T (ffetch FONTFACE of FONT])
        (DEVICESIZE (COND
                       ((ffetch FONTDEVICESPEC of FONT)
                        (CADR (ffetch FONTDEVICESPEC of FONT)))
                       (T (ffetch FONTSIZE of FONT))))
        (DEVICEFAMILY (COND
                         ((ffetch FONTDEVICESPEC of FONT)
                          (CAR (ffetch FONTDEVICESPEC of FONT)))
                         (T (ffetch FONTFAMILY of FONT))))
        (SCALE (ffetch FONTSCALE of FONT))
        (CHARSETS (for CS CSINFO (CSVECTOR _ (ffetch FONTCHARSETVECTOR of FONT)) from 0 to 
                                                                                          \MAXCHARSET
                     eachtime (SETQ CSINFO (\GETBASEPTR CSVECTOR (UNFOLD CS 2))) when CSINFO
                     unless (fetch (CHARSETINFO CSSLUGP) of CSINFO) collect CS))
        (CHARENCODING (fetch (FONTDESCRIPTOR FONTCHARENCODING) of FONT))
        (\ILLEGAL.ARG PROP])

(\AVGCHARWIDTH
  [LAMBDA (FONT)                                             (* ; "Edited 20-May-2025 21:03 by rmk")
                                                             (* rmk%: "27-Nov-84 18:40")

    (* ;; "Returns the average width of a character, to be used in units-to-characters approximations, as in fixing the linelength")

    (LET ((W (CHARWIDTH (CHARCODE A)
                    FONT)))
         (if (NEQ 0 W)
             then W
           elseif [NEQ 0 (SETQ W (FIXR (FTIMES 0.6 (FONTPROP FONT 'HEIGHT]
             then W
           else 1])
)



(* ;; "Bitmap editing/manipulation:")

(DEFINEQ

(EDITCHAR
  [LAMBDA (CHARCODE FONT)                                (* rrb "24-MAR-82 12:22")
                                                             (* ; 
                                                 "calls the bitmap editor on a character of a font")
    (PROG ((FONTDESC (\GETFONTDESC FONT)))
          (RETURN (PUTCHARBITMAP CHARCODE FONTDESC (EDITBM (GETCHARBITMAP CHARCODE FONTDESC])
)



(* ; "Should this be on EDITFONT ?")

(DEFINEQ

(GETCHARBITMAP
  [LAMBDA (CHARCODE FONT)                                    (* ; "Edited  7-Jun-2025 09:55 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 26-Apr-89 21:49 by atm")
                                                             (* ; 
                      "returns a bitmap of the character CHARCODE from the font descriptor FONTDESC.")
    (SETQ CHARCODE (CHARCODE.DECODE CHARCODE))
    (\GETCHARBITMAP.CSINFO (\CHAR8CODE CHARCODE)
           (\INSURECHARSETINFO (\CHARSET CHARCODE)
                  (FONTCREATE FONT])

(PUTCHARBITMAP
  [LAMBDA (CHARCODE FONT NEWCHARBITMAP NEWCHARDESCENT)       (* ; "Edited  7-Jun-2025 10:16 by rmk")
                                                             (* ; "Edited 25-May-2025 15:10 by rmk")
                                                             (* ; "Edited 22-May-2025 09:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:21 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 27-Apr-89 11:19 by atm")

    (* ;; "Stores the bitmap NEWCHARBITMAP as the character CHARCODE in FONT.  If NEWCHARDESCENT is specified, it is the descent of the new bitmap, and things may be moved to accomodate it.")

    (CL:UNLESS (type? BITMAP NEWCHARBITMAP)
           (\ILLEGAL.ARG NEWCHARBITMAP))
    (SETQ CHARCODE (CHARCODE.DECODE CHARCODE))
    (SETQ FONT (FONTCREATE FONT))
    (LET ((CSINFO (\INSURECHARSETINFO (\CHARSET CHARCODE)
                         FONT)))
         (UNINTERRUPTABLY
             (CL:WHEN (\PUTCHARBITMAP.CSINFO (\CHAR8CODE CHARCODE)
                             CSINFO NEWCHARBITMAP NEWCHARDESCENT)

                 (* ;; "update the ascent/descent properties for the font as a whole.")

                 (LET [(ASCENT (IMAX (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                     (fetch (FONTDESCRIPTOR \SFAscent) of FONT)))
                       (DESCENT (IMAX (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)
                                      (fetch (FONTDESCRIPTOR \SFDescent) of FONT]
                      (replace (FONTDESCRIPTOR \SFAscent) of FONT with ASCENT)
                      (replace (FONTDESCRIPTOR \SFDescent) of FONT with DESCENT)
                      (replace (FONTDESCRIPTOR \SFHeight) of FONT with (IPLUS ASCENT DESCENT)))))
         NIL NEWCHARBITMAP])

(\GETCHARBITMAP.CSINFO
  [LAMBDA (CODE CSINFO)                                      (* ; "Edited  7-Jun-2025 09:56 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 26-Apr-89 21:49 by atm")
                                                             (* ; 
                      "returns a bitmap of the character CHARCODE from the font descriptor FONTDESC.")

    (* ;; "CODE is a thincode")

    (LET (CSBITMAP CBM CWDTH CHGHT)
         (CL:WHEN (SETQ CSBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
             (SETQ CHGHT (BITMAPHEIGHT CSBITMAP))
             (SETQ CBM (BITMAPCREATE (SETQ CWDTH (if (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO)
                                                     then (\FGETIMAGEWIDTH (fetch (CHARSETINFO 
                                                                                         IMAGEWIDTHS)
                                                                              of CSINFO)
                                                                 CODE)
                                                   else (\FGETWIDTH (fetch (CHARSETINFO WIDTHS)
                                                                       of CSINFO)
                                                               CODE)))
                              CHGHT
                              (fetch (BITMAP BITMAPBITSPERPIXEL) of CSBITMAP)))
             (BITBLT CSBITMAP (\FGETOFFSET (fetch (CHARSETINFO OFFSETS) of CSINFO)
                                     CODE)
                    0 CBM 0 0 CWDTH CHGHT))
         CBM])

(\PUTCHARBITMAP.CSINFO
  [LAMBDA (CODE CSINFO NEWCHARBITMAP NEWCHARDESCENT)         (* ; "Edited  7-Jun-2025 10:15 by rmk")
                                                             (* ; "Edited 25-May-2025 15:10 by rmk")
                                                             (* ; "Edited 22-May-2025 09:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:21 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 27-Apr-89 11:19 by atm")

    (* ;; "Stores the bitmap NEWCHARBITMAP as the thin character CODE in CSINFO.  If NEWCHARDESCENT is specified, it is the descent of the new bitmap, and things may be moved to accomodate it.")

    (LET* ((CDESCENT (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
           (CASCENT (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
           (CHEIGHT (IPLUS CDESCENT CASCENT))
           (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
           (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
           (IMWIDTHS (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO))
           (CIMWIDTH (AND IMWIDTHS (\FGETIMAGEWIDTH IMWIDTHS CODE)))
           (CWIDTH (OR CIMWIDTH (\FGETWIDTH WIDTHS CODE)))
           (FONTBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
           (OFWIDTH (fetch (BITMAP BITMAPWIDTH) of FONTBITMAP))
           TEMPBITMAP BWIDTH DW BHEIGHT BASCENT BDESCENT NDESCENT NASCENT NHEIGHT CHAROFFSET
           (BITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of FONTBITMAP)))

          (* ;; "fetch the ascents and descents of the bitmap and the new maximums.")

          (SETQ BWIDTH (fetch (BITMAP BITMAPWIDTH) of NEWCHARBITMAP))
          (SETQ BHEIGHT (fetch (BITMAP BITMAPHEIGHT) of NEWCHARBITMAP))
          (SETQ BDESCENT (OR NEWCHARDESCENT CDESCENT))
          (SETQ BASCENT (IDIFFERENCE BHEIGHT BDESCENT))
          (SETQ NDESCENT (IMAX BDESCENT CDESCENT))
          (SETQ NASCENT (IMAX BASCENT CASCENT))
          (SETQ NHEIGHT (IPLUS NDESCENT NASCENT))
          (SETQ CHAROFFSET (\FGETOFFSET OFFSETS CODE))

          (* ;; "set up a new target bitmap if any of the parameters have changed.")

          (if (EQ CHAROFFSET (\FGETOFFSET OFFSETS \MAXTHINCHAR))
              then 
                   (* ;; "changing the bitmap for a character which formerly pointed at the slug character.  Allocate a new bitmap character bitmap for this.")

                   (SETQ TEMPBITMAP (BITMAPCREATE (IPLUS OFWIDTH BWIDTH)
                                           NHEIGHT BITSPERPIXEL))
                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          OFWIDTH CHEIGHT)                   (* ; "copy the old characters over.")
                   (SETQ CHAROFFSET OFWIDTH)
            elseif (NEQ CWIDTH BWIDTH)
              then 
                   (* ;; "The bitmaps differ in width;  create a new bitmap with things at the right places, then update widths and offsets.")

                   (SETQ DW (IDIFFERENCE BWIDTH CWIDTH))     (* ; "Difference in character widths")
                   (SETQ TEMPBITMAP (BITMAPCREATE (IPLUS OFWIDTH DW)
                                           NHEIGHT BITSPERPIXEL)) 
                                                             (* ; 
                                "this may also be a taller bitmap if NHEIGHT is larger than CHEIGHT.")
                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          CHAROFFSET CHEIGHT)                (* ; 
                                                    "Copy that portion to the left of the character.")
                   (BITBLT FONTBITMAP (IPLUS CHAROFFSET CWIDTH)
                          0 TEMPBITMAP (IPLUS CHAROFFSET BWIDTH)
                          (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          (ADD1 (IDIFFERENCE OFWIDTH (IPLUS CHAROFFSET CWIDTH)))
                          CHEIGHT)                           (* ; 
                                               "Copy that portion to the right of the new character.")
            elseif (OR (IGREATERP BASCENT CASCENT)
                       (IGREATERP BDESCENT CDESCENT))
              then 
                   (* ;; 
                   "The new character is TALLER than the existing bitmap.  Make a larger bitmap.")

                   (SETQ TEMPBITMAP (BITMAPCREATE OFWIDTH NHEIGHT BITSPERPIXEL)) 

                   (* ;; "Copy the existing bitmap into it, adjusting for a larger descent in the new character (if there is one)")

                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          OFWIDTH CHEIGHT))

          (* ;; "copy the new bitmap in and update parameters.")

          (BITBLT NEWCHARBITMAP 0 0 (OR TEMPBITMAP FONTBITMAP)
                 CHAROFFSET
                 (IMAX 0 (IDIFFERENCE NDESCENT BDESCENT))
                 BWIDTH BHEIGHT)
          (CL:WHEN TEMPBITMAP
              (UNINTERRUPTABLY
                                                             (* ; 
                                                      "update the parameters for this character set.")
                  (\FSETWIDTH WIDTHS CODE BWIDTH)            (* ; "The new character's correct width")
                                                             (* ; 
                                                          "Make sure that we update imagewidths also")
                  (CL:WHEN IMWIDTHS (\FSETIMAGEWIDTH IMWIDTHS CODE BWIDTH))
                  (\FSETOFFSET OFFSETS CODE CHAROFFSET)
                  (CL:WHEN DW
                      (for I from 0 to \MAXTHINCHAR when (IGREATERP (\FGETOFFSET OFFSETS I)
                                                                CHAROFFSET)
                         do 
                            (* ;; 
         "If the imagewidth has changed, offsets after the modified character have to be adjusted.  ")

                            (add (\FGETOFFSET OFFSETS I)
                                 DW)))
                  (replace (CHARSETINFO CHARSETBITMAP) of CSINFO with TEMPBITMAP)
                  (replace (CHARSETINFO CHARSETDESCENT) of CSINFO with NDESCENT)
                  (replace (CHARSETINFO CHARSETASCENT) of CSINFO with NASCENT))
              NEWCHARBITMAP)])
)
(DEFINEQ

(MOVECHARBITMAP
  [LAMBDA (SRCECODE SRCEFONT DESTCODE DESTFONT CLIP)     (* ; "Edited 14-Dec-86 18:04 by Shih")

(* ;;; "moves a character from one font to another, clipping if necessary.")

    (PROG ((SRCEDESC (\GETFONTDESC SRCEFONT))
           (DESTDESC (\GETFONTDESC DESTFONT))
           SRCEASCENT SRCEDESCENT DESTASCENT DESTDESCENT CHARBITMAP TEMPBITMAP NEWASCENT NEWDESCENT)
          (SETQ CHARBITMAP (GETCHARBITMAP SRCECODE SRCEFONT))
          (SETQ SRCEASCENT (FONTPROP SRCEDESC 'ASCENT))
          (SETQ DESTASCENT (FONTPROP DESTDESC 'ASCENT))
          (SETQ SRCEDESCENT (FONTPROP SRCEDESC 'DESCENT))
          (SETQ DESTDESCENT (FONTPROP DESTDESC 'DESCENT))
          [SETQ NEWASCENT (COND
                             (CLIP DESTASCENT)
                             (T (IMAX SRCEASCENT DESTASCENT]
          [SETQ NEWDESCENT (COND
                              (CLIP DESTDESCENT)
                              (T (IMAX SRCEDESCENT DESTDESCENT]
          [COND
             ((OR (NEQ SRCEASCENT NEWASCENT)
                  (NEQ SRCEDESCENT NEWDESCENT))
              (SETQ TEMPBITMAP (BITMAPCREATE (BITMAPWIDTH CHARBITMAP)
                                      (IPLUS NEWASCENT NEWDESCENT)))
              (BITBLT CHARBITMAP 0 (IMAX 0 (IDIFFERENCE SRCEDESCENT NEWDESCENT))
                     TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NEWDESCENT SRCEDESCENT))
                     (BITMAPWIDTH CHARBITMAP)
                     (IMIN (IPLUS SRCEASCENT SRCEDESCENT)
                           (IPLUS NEWASCENT NEWDESCENT]
          (PUTCHARBITMAP DESTCODE DESTFONT (OR TEMPBITMAP CHARBITMAP)
                 NEWDESCENT])

(MOVEFONTCHARS
  [LAMBDA (PAIRS DEVICE DESTFONT DEFAULTSOURCEFONT)          (* ; "Edited  7-Jun-2025 00:06 by rmk")
                                                             (* ; "Edited 23-May-2025 15:02 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 13-May-2025 08:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:20 by rmk")

    (* ;; "The character information for schar in sfont replaces the information for the destination character in the destination font.")

    (* ;; "Pairs is a list of (SOURCE DEST) pairs where each SOURCE  is a list of the form (schar/code sfont) or just a character, and each DEST is a destination character/code. If a pair is a character code C, it is treated as (C C).")

    (* ;; "If a pair does not contain its own source font, then information is extracted from the DEFAULTSOURCEFONT.  If the DEFAULTSOURCEFONT is not provided, thenSFONT it is assumed that the source is the DESTFONT (which must always be provided).")

    (* ;; "This collects the source information for all the pairs before it starts, to make sure that it doesn't step on itself when source and destination are the same font.")

    (* ;; "For DISPLAY devices (the default), the bitmap is also moved.")

    (CL:UNLESS DEVICE
        (SETQ DEVICE 'DISPLAY))
    (SETQ DESTFONT (FONTCREATE DESTFONT NIL NIL NIL DEVICE))
    (SETQ DEFAULTSOURCEFONT (CL:IF DEFAULTSOURCEFONT
                                (FONTCREATE DEFAULTSOURCEFONT NIL NIL NIL DEVICE)
                                DESTFONT))

    (* ;; "Fix/check arguments, and expand out the information for all the source characters, so there is no toe-stepping if there are overlaps.")

    (SETQ PAIRS (for P S SCODE SFONT DCODE in PAIRS
                   collect (CL:WHEN (SMALLP P)
                               (SETQ P (LIST P P)))
                         (SETQ S (CAR P))
                         (SETQ DCODE (CADR P))
                         (CL:UNLESS (CHARCODEP DCODE)
                             (SETQ DCODE (CHARCODE.DECODE DCODE)))
                         (SETQ SCODE (CL:IF (LISTP S)
                                         (CAR S)
                                         S))
                         (CL:UNLESS (CHARCODEP S)
                             (SETQ SCODE (CHARCODE.DECODE SCODE)))
                         (SETQ SFONT (CL:IF (LISTP S)
                                         (FONTCREATE (CADR S)
                                                NIL NIL NIL DEVICE)
                                         DEFAULTSOURCEFONT))
                         (LIST (LIST SCODE (\GETFONTCHARINFO (\INSURECHARSETINFO (\CHARSET SCODE)
                                                                    SFONT)
                                                  (\CHAR8CODE SCODE)))
                               DCODE)))

    (* ;; "Install source character information into the destination font.  ")

    (for P DCHARCODE DCSINFO ASCENT DESCENT in PAIRS
       do (SETQ DCHARCODE (CADR P))
          (SETQ DCSINFO (\INSURECHARSETINFO (\CHARSET DCHARCODE)
                               DESTFONT))
          (CL:WHEN (fetch (CHARSETINFO CSSLUGP) of DCSINFO)  (* ; "Break the slug-sharing")
              (SETQ DCSINFO (create CHARSETINFO copying DCSINFO CSSLUGP _ NIL))
              (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR))
                     (\CHARSET DCHARCODE)
                     DCSINFO))
          (\MOVEFONTCHAR (CADAR P)
                 DCSINFO
                 (\CHAR8CODE (CAAR P))
                 (\CHAR8CODE DCHARCODE))
          (SETQ DESCENT (IMAX (fetch (CHARSETINFO CHARSETDESCENT) of DCSINFO)
                              (fetch (FONTDESCRIPTOR \SFDescent) of DESTFONT)))
          (SETQ ASCENT (IMAX (fetch (CHARSETINFO CHARSETASCENT) of DCSINFO)
                             (fetch (FONTDESCRIPTOR \SFAscent) of DESTFONT)))
          (replace (FONTDESCRIPTOR \SFAscent) of DESTFONT with ASCENT)
          (replace (FONTDESCRIPTOR \SFDescent) of DESTFONT with DESCENT)
          (replace (FONTDESCRIPTOR \SFHeight) of DESTFONT with (IPLUS DESCENT ASCENT)))
    DESTFONT])

(\MOVEFONTCHAR
  [LAMBDA (SCHARINFO DCSINFO SCODE DCODE)                    (* ; "Edited  7-Jun-2025 14:43 by rmk")

    (* ;; "Internal CSINFO-level function to move the information for (thinchar) SCODE in the source CSINFO to (thinchar) DCODE) in the destination CSINFO.")

    (* ;; "The caller (MOVEFONTCHARS) may have provided the source character information as an alist structure to avoid clobbering stepping on toes.  If SCHARINFO is a CSINFO, the alist is extracted here.")

    (CL:WHEN (type? CHARSETINFO SCHARINFO)
        (SETQ SCHARINFO (\GETFONTCHARINFO SCHARINFO SCODE)))
    (LET (DESCENT ASCENT)

         (* ;; "We have to split the width and imagewidth vectors in preparation, if the source values are different but the dest vectors are EQ. ")

         (CL:WHEN [AND (NEQ (CDR (ASSOC 'WIDTH SCHARINFO))
                            (CDR (ASSOC 'IMAGEWIDTH SCHARINFO)))
                       (OR (EQ (ffetch (CHARSETINFO WIDTHS) of DCSINFO)
                               (ffetch (CHARSETINFO IMAGEWIDTHS) of DCSINFO))
                           (NULL (ffetch (CHARSETINFO IMAGEWIDTHS) of DCSINFO]
             (replace (CHARSETINFO IMAGEWIDTHS) of DCSINFO with (\COPYARRAYBLOCK (ffetch (CHARSETINFO
                                                                                          WIDTHS)
                                                                                    of DCSINFO))))
         (CL:WHEN (CDR (ASSOC 'BITMAP SCHARINFO))
             (\PUTCHARBITMAP.CSINFO DCODE DCSINFO (CDR (ASSOC 'BITMAP SCHARINFO))
                    (CDR (ASSOC 'DESCENT SCHARINFO))))
         (\FSETWIDTH (ffetch (CHARSETINFO WIDTHS) of DCSINFO)
                DCODE
                (CDR (ASSOC 'WIDTH SCHARINFO)))
         (\FSETWIDTH (ffetch (CHARSETINFO IMAGEWIDTHS) of DCSINFO)
                DCODE
                (CDR (ASSOC 'IMAGEWIDTH SCHARINFO)))
         (CL:WHEN (AND (CDR (ASSOC 'YWIDTH SCHARINFO))
                       (ffetch (CHARSETINFO YWIDTHS) of DCSINFO))
                                                             (* ; "Is YWIDTHS real?")
             (\FSETWIDTH (ffetch (CHARSETINFO YWIDTHS) of DCSINFO)
                    DCODE
                    (CDR (ASSOC 'YWIDTH SCHARINFO))))
         (CL:WHEN (CDR (ASSOC 'LEFTKERN SCHARINFO))          (* ; "Not sure what LEFTKERN really is")
             (CL:UNLESS (CL:ARRAYP (ffetch (CHARSETINFO LEFTKERN) of DCSINFO))
                 (replace (CHARSETINFO LEFTKERN) of DCSINFO with (\CREATEKERNELEMENT)))
             (CL:SETF (CL:SVREF (ffetch (CHARSETINFO LEFTKERN) of DCSINFO)
                             DCODE)
                    (CDR (ASSOC 'LEFTKERN SCHARINFO))))
         (SETQ DESCENT (IMAX (CDR (ASSOC 'DESCENT SCHARINFO))
                             (fetch (CHARSETINFO CHARSETDESCENT) of DCSINFO)))
         (SETQ ASCENT (IMAX (CDR (ASSOC 'ASCENT SCHARINFO))
                            (fetch (CHARSETINFO CHARSETASCENT) of DCSINFO)))
         (replace (CHARSETINFO CHARSETDESCENT) of DCSINFO with DESCENT)
         (replace (CHARSETINFO CHARSETASCENT) of DCSINFO with ASCENT)
         (replace (CHARSETINFO CSSLUGP) of DCSINFO with NIL)
         DCSINFO])

(SLUGCHARP.DISPLAY
  [LAMBDA (CODE FONT/CHARSETINFO)                            (* ; "Edited  6-Jun-2025 10:24 by rmk")
                                                             (* ; "Edited 31-May-2025 23:44 by rmk")

    (* ;; "True if CODE is currently a slug in FONT or the particular CHARSETINFO.  If we are given a CSINFO, CODE is alread charset-relative.")

    (LET [(CSINFO (CL:IF (type? CHARSETINFO FONT/CHARSETINFO)
                      FONT/CHARSETINFO
                      (\XGETCHARSETINFO FONT/CHARSETINFO (\CHARSET CODE)))]
         (OR (NULL CSINFO)
             (fetch (CHARSETINFO CSSLUGP) of CSINFO)
             (EQ (\GETBASE (fetch (CHARSETINFO OFFSETS) of CSINFO)
                        (\CHAR8CODE CODE))
                 (\GETBASE (fetch (CHARSETINFO OFFSETS) of CSINFO)
                        (ADD1 \MAXTHINCHAR])

(\GETFONTCHARINFO
  [LAMBDA (CHARSETINFO CHAR8CODE)                            (* ; "Edited  7-Jun-2025 14:35 by rmk")

    (* ;; "Extracts the information about CHAR8CODE from its CHARSETINFO, holding it against the possibility that the CSINFO gets smashed.")

    `((ASCENT \, (fetch (CHARSETINFO CHARSETASCENT) of CHARSETINFO))
      (DESCENT \, (fetch (CHARSETINFO CHARSETDESCENT) of CHARSETINFO))
      (WIDTH \, (\FGETWIDTH (ffetch (CHARSETINFO WIDTHS) of CHARSETINFO)
                       CHAR8CODE))
      (YWIDTH \, (\FGETWIDTH (ffetch (CHARSETINFO YWIDTHS) of CHARSETINFO)
                        CHAR8CODE))
      (IMAGEWIDTH \, (\FGETWIDTH (ffetch (CHARSETINFO IMAGEWIDTHS) of CHARSETINFO)
                            CHAR8CODE))
      (LEFTKERN \, (CL:WHEN (CL:ARRAYP (fetch (CHARSETINFO LEFTKERN) of CHARSETINFO))
                       (CL:SVREF (fetch (CHARSETINFO LEFTKERN) of CHARSETINFO)
                              CHAR8CODE)))
      ,@(CL:WHEN (fetch (CHARSETINFO CHARSETBITMAP) of CHARSETINFO)
            (LIST (CONS 'BITMAP (\GETCHARBITMAP.CSINFO CHAR8CODE CHARSETINFO))))])
)



(* ;; 
"\FINDFONTFILE \FONTFILENAME \SEARCHFONTFILES \FONTINFOFROMFILENAME are redefined to deal with character-set directories.  That behavior is conditioned on the setting of the global variable *USEOLDFONTDIRECTORIES*, T at PARC, maybe NIL most other places.  "
)

(DEFINEQ

(FONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST)
                                                             (* ; "Edited  9-Jun-2025 09:57 by rmk")
                                                             (* ; "Edited 17-May-2025 00:06 by rmk")
                                                             (* ; "Edited 15-May-2025 16:29 by rmk")

    (* ;; "Considers all posible names for font files that respect the given characteristics, returns a list of the names of files that actually exist somewhere in DIRLST.  Does not validate their contents.")

    (APPEND (MKLIST (\FINDFONTFILE FAMILY SIZE FACE ROTATION DEVICE 'ALL DIRLST EXTLST))
           (MKLIST (\FINDFONTFILE FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST])

(\FINDFONTFILE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST)
                                                             (* ; "Edited  9-Jun-2025 09:40 by rmk")
                                                             (* ; "Edited 15-May-2025 22:41 by rmk")
                                                             (* ; "Edited 14-Sep-96 10:53 by rmk:")
                                                             (* ; "Edited  6-Oct-89 11:18 by bvm")

    (* ;; "Find any font file on any directory with any naming convention with any extension.  Note that ROTATION and DEVICE are just place holders.   DEVICE is irrelevant because DIRLST already incorporates the device information.  The variable *OLD-FONT-EXTENSIONS* can be set to suppress using the old-style lookup.  If set to a list of extensions, just those will be looked up with old-style conventions.")

    (for EXT FONTFILE inside EXTLST
       when (SETQ FONTFILE (FINDFILE (if (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                         then (\FONTFILENAME.OLD FAMILY SIZE FACE EXT CHARSET)
                                       else (\FONTFILENAME FAMILY SIZE FACE EXT CHARSET))
                                  T DIRLST)) collect FONTFILE finally 

                                                                    (* ;; 
                                       "Backward compatibility for devices that expect a single file")

                                                                    (CL:UNLESS (CDR $$VAL)
                                                                        (RETURN (CAR $$VAL)))])

(\FONTFILENAMES
  [LAMBDA (FAMILY SIZE FACE DEVICE EXTENSIONS)               (* ; "Edited 17-May-2025 12:15 by rmk")
    (APPEND [for EXT inside EXTENSIONS collect (IF (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                                   THEN (\FONTFILENAME.OLD FAMILY SIZE FACE EXT
                                                               'ALL)
                                                 ELSE (\FONTFILENAME FAMILY SIZE FACE EXT
                                                             'ALL]
           (for EXT inside EXTENSIONS collect (IF (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                                  THEN (\FONTFILENAME.OLD FAMILY SIZE FACE EXT 0)
                                                ELSE (\FONTFILENAME FAMILY SIZE FACE EXT 0])

(\FONTFILENAME
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)               (* ; "Edited 15-May-2025 15:51 by rmk")
                                                             (* ; "Edited  5-Mar-93 16:10 by rmk:")

    (* ;; "Strike file naming convention (w/o dashes, no charset) no longer supported.  New name is of the form %"familysize-face-Ccharset.ext%", e.g., MODERN12-MRR-C357.WD")

    (* ;; "**bvm 10/5/89 Slight change: partition fonts into subdirectories by charset, e.g., all Charset zero fonts are in subdirectory C0>.  This significantly speeds up any font operation that requires any local directory work (e.g., NFS servers on both Sun and D machine), and FONTSAVAILABLE on any device (since it doesn't have to wade thru all those charsets).  This behavior is conditioned on the value of *USEOLDFONTDIRECTORIES*")

    (SETQ FACE (\FONTFACE FACE))                             (* ; "Validate face")
    (LET* ([SIZEPATT (COND
                        ((EQ SIZE '*)
                         SIZE)
                        ((FIXP SIZE)
                         (if (< SIZE 10)
                             then (CONCAT 0 SIZE)
                           else SIZE))
                        (T (\ILLEGAL.ARG SIZE]
           (CSETNAME (COND
                        ((OR (NULL CHARSET)
                             (EQ CHARSET 0))                 (* ; "Charset defaults to zero.")
                         "0")
                        ((FIXP CHARSET)
                         (LET ((*PRINT-BASE* 8)
                               (*PRINT-RADIX* NIL))          (* ; "Longhand for (cl:write-to-string charset :radix nil :base 8), which is twice as slow, due to lousy keyword handling")
                              (\PRINDATUM.TO.STRING CHARSET)))
                        ((MEMB CHARSET '(T ALL))             (* ; "Don't want the charset indicatged")
                         NIL)
                        (T                                   (* ; "Somebody made the string already?")
                           CHARSET)))
           [FACESPEC (LIST (CHCON1 (fetch (FONTFACE WEIGHT) of FACE))
                           (CHCON1 (fetch (FONTFACE SLOPE) of FACE))
                           (CHCON1 (fetch (FONTFACE EXPANSION) of FACE]
           (TAIL FACESPEC))
          [if (OR (EQ (CAR TAIL)
                      (CHARCODE *))
                  (EQ (CAR (SETQ TAIL (CDR TAIL)))
                      (CHARCODE *)))
              then                                           (* ; 
              "Avoid adjacent wildcards because some devices (notably DSK) get exponentially slower.")
                   (while (EQ (CADR TAIL)
                              (CHARCODE *)) do (RPLACD TAIL (CDDR TAIL]

          (* ;; "Fortunately, CONCAT ignores packages.")

          (PACKFILENAME.STRING 'NAME (CONCAT (if *USEOLDFONTDIRECTORIES*
                                                 then ""
                                               elseif CSETNAME
                                                 then (CONCAT (PROGN 
                                                             (* ; 
                     "Lowercase because it's in a directory name, so maybe Unix will find it sooner?")
                                                                     "c")
                                                             CSETNAME ">")
                                               else "")
                                            FAMILY SIZEPATT "-" (CONCATCODES FACESPEC)
                                            (CL:IF CSETNAME
                                                (CONCAT "-C" CSETNAME)
                                                ""))
                 'EXTENSION EXTENSION])

(\FONTFILENAME.OLD
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)           (* ; "Edited 23-Sep-92 18:22 by jds")

    (* ;; "Returns old style font file names.  They were ambiguous because you could not ask for e.g. FACE (MEDIUM * REGULAR) because it maps to FamilySize-*-Charset, which also matches (BOLD * COMPRESSED), etc.  Keep this function around though for user's who don't rename their files.")
                                                             (* ; 
                     "Returns the name of the file that should contain the information for a font.")
    (SETQ FACE (\FONTFACE FACE))                         (* ; "Force legal canonical face")
    (SETQ FACE (COND
                  ((AND (EQ (CAR FACE)
                            '*)
                        (EQ (CADR FACE)
                            '*))

                   (* ;; "Avoid  adjacent wildcards because DSK gets slower exponentially (can take loooong tiiiiiime).  No need to check compression.")

                   '*)
                  (T FACE)))
    (PACKFILENAME.STRING 'NAME [PROGN 
                                      (* ;; "DISPLAYFONT AC WD and the default case")

                                      (CONCAT (CDR (SASSOC FAMILY *DISPLAY-FONT-NAME-MAP*))
                                             (COND
                                                ((EQ SIZE '*)
                                                 SIZE)
                                                ((FIXP SIZE)
                                                 (COND
                                                    ((< SIZE 10)
                                                     (CONCAT 0 SIZE))
                                                    (T SIZE)))
                                                (T (\ILLEGAL.ARG SIZE)))
                                             [COND
                                                ((EQ FACE '*)
                                                 '*)
                                                (T (SELECTQ (fetch WEIGHT of FACE)
                                                       (BOLD (SELECTQ (fetch SLOPE of FACE)
                                                                 (ITALIC "D")
                                                                 "B"))
                                                       (SELECTQ (fetch SLOPE of FACE)
                                                           (ITALIC "I")
                                                           "R"]
                                             (COND
                                                ((FIXP CHARSET)
                                                 (LET ((*PRINT-BASE* 8))
                                                      (CL:FORMAT NIL "~O" CHARSET)))
                                                (T "000"]
           'EXTENSION EXTENSION])

(\FONTFILENAME.NEW
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)           (* ; "Edited 30-Mar-87 20:00 by FS")

    (* ;; "Strike file naming convention (w/o dashes, no charset) no longer supported.")

    (LET (NAME SIZEPATT)
         (SETQ FACE (\FONTFACE FACE))                    (* ; "Validate face")
         [SETQ SIZEPATT (COND
                           ((EQ SIZE '*)
                            SIZE)
                           ((FIXP SIZE)
                            (if (< SIZE 10)
                                then (CONCAT 0 SIZE)
                              else SIZE))
                           (T (\ILLEGAL.ARG SIZE]

         (* ;; "Avoid adjacent wildcards because some devices (notably DSK) get exponentially slower.  Nicely, PACK & CONCAT ignore packages.")

         (PACKFILENAME.STRING 'NAME (CONCAT FAMILY SIZEPATT "-"
                                           [COND
                                              ((EQUAL FACE '

         (* * *)
)
                                               '*)
                                              (T (CONCAT (NTHCHAR (fetch (FONTFACE WEIGHT)
                                                                     of FACE)
                                                                1)
                                                        (NTHCHAR (fetch (FONTFACE SLOPE)
                                                                    of FACE)
                                                               1)
                                                        (NTHCHAR (fetch (FONTFACE EXPANSION)
                                                                    of FACE)
                                                               1]
                                           (COND
                                              [(FIXP CHARSET)
                                               (LET ((*PRINT-BASE* 8))
                                                    (CONCAT "-C" (\PRINDATUM.TO.STRING CHARSET]
                                              (CHARSET (CONCAT "-C" CHARSET))
                                              (T "-C0")))
                'EXTENSION EXTENSION])

(\FONTINFOFROMFILENAME
  [LAMBDA (FONTFILE DEVICE)                                  (* ; "Edited 14-Sep-96 10:23 by rmk:")
                                                             (* ; "Edited  5-Oct-89 18:28 by bvm")

    (* ;; "returns a list of the family size face rotation device of the font stored in the file name FONTFILE.  Rotation is 0 always.  Parses both new & old format files.")

    (LET ((FILENAMELIST (UNPACKFILENAME.STRING FONTFILE))
          CH SIZEBEG SIZEND NAME FAMILY SIZE FACE EXT)
         (SETQ NAME (LISTGET FILENAMELIST 'NAME))            (* ; 
         "find where the name and size are.  MUST check for ch nil below or possible infinite loop")
         (SETQ SIZEBEG (for CH# from 1 when (OR (NUMBERP (SETQ CH (NTHCHAR NAME CH#)))
                                                            (NULL CH)) do (RETURN CH#)))

         (* ;; "Get Family")

         [SETQ FAMILY (MKATOM (U-CASE (SUBSTRING NAME 1 (SUB1 SIZEBEG]

         (* ;; "Get Size")

         [SETQ SIZEND (find CH# from SIZEBEG suchthat (NOT (NUMBERP (NTHCHAR NAME CH#]
         [SETQ SIZE (MKATOM (SUBSTRING NAME SIZEBEG (SUB1 SIZEND]
         (if (EQ (NTHCHAR NAME SIZEND)
                     '-)
             then (SETQ SIZEND (ADD1 SIZEND)))

         (* ;; "Get Face")

         (SETQ NAME (U-CASE NAME))                           (* ; 
                                                   "don't need name, but checks for lowercase face")
         [SETQ FACE (LIST (COND
                             ((STRPOS "B" NAME SIZEND NIL T NIL UPPERCASEARRAY)
                              'BOLD)
                             ((STRPOS "L" NAME SIZEND NIL T NIL UPPERCASEARRAY)
                              'LIGHT)
                             (T 'MEDIUM))
                          (COND
                             ((STRPOS "I" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'ITALIC)
                             (T 'REGULAR))
                          (COND
                             ((STRPOS "E" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'EXPANDED)
                             ((STRPOS "C-" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'COMPRESSED)
                             (T 'REGULAR]
         (LIST FAMILY SIZE FACE 0 (COND
                                     ((STREAMP DEVICE)
                                      (IMAGESTREAMTYPE DEVICE))
                                     ((NULL DEVICE)
                                      [SETQ EXT (MKATOM (U-CASE (LISTGET FILENAMELIST 'EXTENSION]
                                      (SELECTQ EXT
                                          (WD 'INTERPRESS)
                                          ((STRIKE AC DISPLAYFONT) 
                                               'DISPLAY)
                                          EXT))
                                     ((LITATOM DEVICE)
                                      (\FONTSYMBOL DEVICE))
                                     (T DEVICE])

(\FONTINFOFROMFILENAME.OLD
  [LAMBDA (FONTFILE DEVICE)                              (* ; "Edited  1-Jan-87 01:29 by FS")

    (* ;; "returns a list of the family size face rotation device of the font stored in the file name FONTFILE.")

    (PROG ((FILENAMELIST (UNPACKFILENAME FONTFILE))
           SIZEBEG SIZEND NAME FAMILY SIZE)
          (SETQ NAME (LISTGET FILENAMELIST 'NAME))           (* ; 
                                                           "find where the name and size are.")
          (SETQ SIZEBEG (for CH# from 1 when (NUMBERP (NTHCHAR NAME CH#))
                           do (RETURN CH#)))
          [SETQ FAMILY (MKATOM (SUBSTRING NAME 1 (SUB1 SIZEBEG]
          (SETQ SIZEND (for CH# from SIZEBEG when (NOT (NUMBERP (NTHCHAR NAME CH#)))
                          do (RETURN CH#)))
          [SETQ SIZE (MKATOM (SUBSTRING NAME SIZEBEG (SUB1 SIZEND]
          (RETURN (LIST FAMILY SIZE (SELECTQ (LISTGET FILENAMELIST 'EXTENSION)
                                        ((DISPLAYFONT AC WD) 
                                             (LIST (COND
                                                      ((STRPOS "-B" NAME SIZEND NIL T)
                                                       'BOLD)
                                                      (T 'MEDIUM))
                                                   (COND
                                                      ((STRPOS "-I" NAME SIZEND NIL)
                                                       'ITALIC)
                                                      (T 'REGULAR))
                                                   'REGULAR))
                                        (LIST (COND
                                                 ((STRPOS "B" NAME SIZEND NIL T)
                                                  'BOLD)
                                                 (T 'MEDIUM))
                                              (COND
                                                 ((STRPOS "I" NAME SIZEND NIL)
                                                  'ITALIC)
                                                 (T 'REGULAR))
                                              'REGULAR))
                        0 DEVICE])
)



(* (* ; "Do we still want old fonts?") (ADDVARS (*OLD-FONT-EXTENSIONS* STRIKE)))


(RPAQ? *OLD-FONT-EXTENSIONS* NIL)

(RPAQ? *USEOLDFONTDIRECTORIES* NIL)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS *OLD-FONT-EXTENSIONS* *USEOLDFONTDIRECTORIES*)
)
(DEFINEQ

(FONTCOPY
  [LAMBDA FONTSPECS                                      (* ; "Edited 10-Nov-87 17:12 by FS")
                                                             (* ; 
                                            "makes a copy of a font changing the specified fields.")
    (PROG (NOERROR ERROR FAMILY FACE SIZE ROTATION DEVICE OLDFONT)

     (* ;; "Set NOERROR if we find it as a prop, but set ERROR if we find a PROP which is illegal.  Then just return NIL if NOERROR and ERROR, otherwise, call FONTCREATE.")

          [SETQ OLDFONT (\GETFONTDESC (ARG FONTSPECS 1)
                               (AND (type? FONTCLASS (ARG FONTSPECS 1))
                                    (COND
                                       ((AND (EQ FONTSPECS 2)
                                             (LISTP (ARG FONTSPECS 2)))
                                        (LISTGET (ARG FONTSPECS 2)
                                               'DEVICE))
                                       (T (for I from 2 by 2 to FONTSPECS
                                             do (COND
                                                       ((AND (NEQ I FONTSPECS)
                                                             (EQ (ARG FONTSPECS I)
                                                                 'DEVICE))
                                                        (RETURN (ARG FONTSPECS (ADD1 I]
          (SETQ FAMILY (fetch (FONTDESCRIPTOR FONTFAMILY) of OLDFONT))
          (SETQ SIZE (fetch (FONTDESCRIPTOR FONTSIZE) of OLDFONT))
          (SETQ FACE (fetch (FONTDESCRIPTOR FONTFACE) of OLDFONT))
          (SETQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of OLDFONT))
          (SETQ DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of OLDFONT))
          [for I VAL from 2 by 2 to FONTSPECS
             do [SETQ VAL (COND
                                 ((NOT (EQ I FONTSPECS))
                                  (ARG FONTSPECS (ADD1 I]
                   (SELECTQ (ARG FONTSPECS I)
                       (FAMILY (SETQ FAMILY VAL))
                       (SIZE (SETQ SIZE VAL))
                       (FACE (SETQ FACE (\FONTFACE VAL)))
                       (WEIGHT (SETQ FACE (create FONTFACE using FACE WEIGHT _ VAL)))
                       (SLOPE (SETQ FACE (create FONTFACE using FACE SLOPE _ VAL)))
                       (EXPANSION (SETQ FACE (create FONTFACE using FACE EXPANSION _ VAL)))
                       (BACKCOLOR (SETQ FACE (create FONTFACE using FACE BACKCOLOR _ VAL)))
                       (FORECOLOR (SETQ FACE (create FONTFACE using FACE FORECOLOR _ VAL)))
                       (ROTATION (SETQ ROTATION VAL))
                       (DEVICE (SETQ DEVICE VAL))
                       (NOERROR (SETQ NOERROR VAL))
                       (COND
                          [(AND (EQ I 2)
                                (EQ FONTSPECS 2)
                                (LISTP (ARG FONTSPECS 2)))
                           (for J on (ARG FONTSPECS 2) by (CDDR J)
                              do (SETQ VAL (CADR J))
                                    (SELECTQ (CAR J)
                                        (FAMILY (SETQ FAMILY VAL))
                                        (SIZE (SETQ SIZE VAL))
                                        (FACE (SETQ FACE (\FONTFACE VAL)))
                                        (WEIGHT (SETQ FACE (create FONTFACE
                                                              using FACE WEIGHT _ VAL)))
                                        (SLOPE (SETQ FACE (create FONTFACE
                                                             using FACE SLOPE _ VAL)))
                                        (EXPANSION (SETQ FACE (create FONTFACE
                                                                 using FACE EXPANSION _ VAL)))
                                        (BACKCOLOR (SETQ FACE (create FONTFACE
                                                                 using FACE BACKCOLOR _ VAL)))
                                        (FORECOLOR (SETQ FACE (create FONTFACE
                                                                 using FACE FORECOLOR _ VAL)))
                                        (ROTATION (SETQ ROTATION VAL))
                                        (DEVICE (SETQ DEVICE VAL))
                                        (NOERROR (SETQ NOERROR VAL))
                                        (COND
                                           (NOERROR 

                                                  (* ;; 
  "Fell through the SELECTQ, so an illegal PROP.  But, if NOERROR, just note the error, otherwise ")

                                                  (SETQ ERROR T))
                                           (T (\ILLEGAL.ARG (CAR J]
                          (T (if NOERROR
                                 then (SETQ ERROR T)
                               else (\ILLEGAL.ARG (ARG FONTSPECS I]
          (RETURN (if (AND NOERROR ERROR)
                      then NIL
                    else (FONTCREATE FAMILY SIZE FACE ROTATION DEVICE NOERROR])

(FONTSAVAILABLE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHECKFILESTOO?)
                                                             (* rrb " 7-Nov-84 15:41")

(* ;;; "returns a list of the fonts fitting a description that are available.  FAMILY SIZE FACE or ROTATION can be * which means get them all.  if LOADEDONLYFLG is non-NIL, only fonts in core will be considered.")

    (DECLARE (GLOBALVARS IMAGESTREAMTYPES))
    (PROG (FONTX DEV)
          [SETQ DEV (COND
                       ((type? STREAM DEVICE)
                        (COND
                           ((LISTP (SETQ DEV (IMAGESTREAMTYPE DEVICE)))
                            (CAR DEV))
                           (T DEV)))
                       (DEVICE)
                       (T 'DISPLAY]
          (RETURN
           (COND
              ((LISTP FAMILY)
               (COND
                  ((EQ (CAR FAMILY)
                       'FONT)
                   (SETQ FONTX (CDR FAMILY)))
                  (T (SETQ FONTX FAMILY)))
               (FONTSAVAILABLE (CAR FONTX)
                      (OR (CADR FONTX)
                          SIZE)
                      (OR (CADDR FONTX)
                          FACE)
                      (OR (CADDDR FONTX)
                          ROTATION)
                      DEV CHECKFILESTOO?))
              ([SETQ FONTX (COND
                              ((type? FONTDESCRIPTOR FAMILY)
                               FAMILY)
                              ((NULL FAMILY)
                               (DEFAULTFONT DEV))
                              ((type? FONTCLASS FAMILY)

                               (* ;; "We know that this won't attempt a cyclic fontcreate in \COERCEFONTDESC, because we are passing a known class.  Unless NOERROFLG, an error will be caused on the actual device font if it can't be found.")
                                                             (* ; 
                                                       "I don't know what to do in this case- rrb.")
                               (\COERCEFONTDESC FAMILY DEV T))
                              ((OR (IMAGESTREAMP FAMILY)
                                   (type? WINDOW FAMILY))
                               (DSPFONT NIL FAMILY]          (* ; 
                 "FAMILY was a spec for a font descriptor, use it and extend it by the other args.")
               (FONTSAVAILABLE (FONTPROP FONTX 'FAMILY)
                      (OR SIZE (FONTPROP FONTX 'SIZE))
                      (OR FACE (FONTPROP FONTX 'FACE))
                      (OR ROTATION (FONTPROP FONTX 'ROTATION))
                      (OR DEVICE (FONTPROP FONTX 'DEVICE))
                      CHECKFILESTOO?))
              (T (PROG ((FONTFACE FACE))
                   RETRY
                       (OR (LITATOM FAMILY)
                           (LISPERROR "ARG NOT LITATOM" FAMILY T))
                       (OR (AND (FIXP SIZE)
                                (IGREATERP SIZE 0))
                           (EQ SIZE '*)
                           (\ILLEGAL.ARG SIZE))
                       [OR (EQ FONTFACE '*)
                           (SETQ FONTFACE (OR (\FONTFACE FACE T)
                                              (RETURN NIL]
                       (OR (U-CASEP FAMILY)
                           (SETQ FAMILY (U-CASE FAMILY)))
                       (COND
                          ((NULL ROTATION)
                           (SETQ ROTATION 0))
                          ((AND (FIXP ROTATION)
                                (IGEQ ROTATION 0)))
                          ((EQ ROTATION '*))
                          (T (\ILLEGAL.ARG ROTATION)))
                       (RETURN (UNION (\LOOKUPFONTSINCORE FAMILY SIZE FONTFACE ROTATION DEV)
                                      (COND
                                         ((NOT CHECKFILESTOO?)
                                          NIL)
                                         [(EQ DEV '*)        (* ; "map thru all the devices.")
                                          (for EXTANTDEV in IMAGESTREAMTYPES
                                             join (APPLY* (OR (CADR (ASSOC 'FONTSAVAILABLE
                                                                               (CDR EXTANTDEV)))
                                                                  (FUNCTION NILL))
                                                             FAMILY SIZE FONTFACE ROTATION
                                                             (CAR EXTANTDEV]
                                         (T                  (* ; 
                                                           "apply the device font lookup function.")
                                            (APPLY* (OR [CADR (ASSOC 'FONTSAVAILABLE
                                                                     (CDR (ASSOC DEV IMAGESTREAMTYPES
                                                                                 ]
                                                        (FUNCTION NILL))
                                                   FAMILY SIZE FONTFACE ROTATION DEV])

(FONTFILEFORMAT
  [LAMBDA (STRM)                                             (* ; "Edited  7-Jun-2025 10:39 by rmk")
                                                             (* rmk%: "11-Sep-84 17:16")
                                                             (* ; "Returns the font format of STRM")
    (RESETLST
        (CL:UNLESS (OPENP STRM 'INPUT)
            [RESETSAVE NIL `(PROGN (CLOSEF? OLDVALUE])
        (CAR (find FNS in DISPLAYCHARSETFNS suchthat (APPLY* (CADR FNS)
                                                            STRM))))])

(FONTP
  [LAMBDA (X)                                            (* rmk%: "13-Sep-84 09:04")
                                                             (* ; "is X a FONTDESCRIPTOR?")
    (COND
       ((OR (type? FONTDESCRIPTOR X)
            (type? FONTCLASS X))
        X])

(FONTUNPARSE
  [LAMBDA (FONT)                                         (* kbr%: "25-Feb-86 19:40")

    (* ;; "Produces a minimal specification of the font or fontclass specification, for dumping by Tedit, imageobjects.")

    (PROG (FACE SPEC)
          (SETQ SPEC (COND
                        ((type? FONTDESCRIPTOR FONT)
                         (FONTPROP FONT 'SPEC))
                        [(type? FONTCLASS FONT)
                         (RETURN (CONS 'CLASS (FONTCLASSUNPARSE FONT]
                        (T 
                           (* ;; "Could be a non-instantiated specification in a fontclass, just use it as the spec without creating the font.")

                           FONT)))
          (OR SPEC (RETURN))
          (SETQ FACE (CADDR SPEC))                           (* ; 
                        "FACE and rotation can be NIL for a non-fontdescriptor fontclass component")
          [SETQ FACE (COND
                        ([OR (NULL FACE)
                             (EQUAL FACE '(MEDIUM REGULAR REGULAR]
                         NIL)
                        ((LITATOM FACE)
                         FACE)
                        [(LISTP FACE)
                         (PACK (LIST* (NTHCHAR (fetch (FONTFACE WEIGHT) of FACE)
                                             1)
                                      (NTHCHAR (fetch (FONTFACE SLOPE) of FACE)
                                             1)
                                      (NTHCHAR (fetch (FONTFACE EXPANSION) of FACE)
                                             1)
                                      (COND
                                         ((fetch (FONTFACE COLOR) of FACE)
                                          (LIST "-" (fetch (FONTFACE BACKCOLOR) of FACE)
                                                "-"
                                                (fetch (FONTFACE FORECOLOR) of FACE]
                        (T (SHOULDNT]                        (* ; 
                                                    "Don't return device, or any trailing defaults")
          (RETURN (CONS (CAR SPEC)
                        (CONS (CADR SPEC)
                              (COND
                                 ([AND (CADDDR SPEC)
                                       (NOT (EQ 0 (CADDDR SPEC]
                                  (LIST (OR FACE 'MRR)
                                        (CADDDR SPEC)))
                                 (FACE (CONS FACE])

(SETFONTDESCRIPTOR
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE FONT)        (* ; "Edited  1-Aug-88 16:16 by rmk:")
                                                             (* ; "Edited  5-Mar-87 19:28 by FS")

    (* ;; "saves a font descriptor under a family/size/face/rotation/device key so that it will be retreived by FONTCREATE.  This is a user entry.")

    (DECLARE (GLOBALVARS \FONTSINCORE))
    (SETQ DEVICE (\DEVICESYMBOL DEVICE))                 (* ; "Unpackageify")
    (AND FONT (SETQ FONT (\COERCEFONTDESC FONT DEVICE))) (* ; 
                            "NIL is used to clobber existing font so that next use will reread it.")
    (SETQ FAMILY (\FONTSYMBOL FAMILY))                   (* ; "Unpackageify")
    (SETQ FACE (\FONTFACE FACE NIL DEVICE))
    (OR ROTATION (SETQ ROTATION 0))
    (OR (AND (FIXP SIZE)
             (IGEQ SIZE 0))
        (\ILLEGAL.ARG SIZE))
    (PROG [(X (OR (FASSOC FAMILY \FONTSINCORE)
                  (CAR (push \FONTSINCORE (LIST FAMILY]
          [SETQ X (OR (FASSOC SIZE (CDR X))
                      (CAR (push (CDR X)
                                  (LIST SIZE]
          [SETQ X (OR (SASSOC FACE (CDR X))
                      (CAR (push (CDR X)
                                  (LIST FACE]                (* ; "SASSOC cause FACE is listp")
          [SETQ X (OR (FASSOC ROTATION (CDR X))
                      (CAR (push (CDR X)
                                  (LIST ROTATION]
          [SETQ X (OR (FASSOC DEVICE (CDR X))
                      (CAR (push (CDR X)
                                  (LIST DEVICE]
          (RPLACD X FONT)
          (RETURN FONT])

(CHARCODEP
  [LAMBDA (CHCODE)                                       (* gbn "22-Jul-85 16:35")
                                                             (* ; 
                                                           "is CHCODE a legal character code?")
    (AND (SMALLP CHCODE)
         (IGEQ CHCODE 0)
         (ILEQ CHCODE \MAXNSCHAR])

(\STREAMCHARWIDTH
  [LAMBDA (CHARCODE STREAM TTBL)                         (* JonL " 8-NOV-83 03:31")

    (* ;; "Returns the width that the printed representation of CHARCODE would occupy if printed on STREAM, allowing for the various escape sequences.  Used by \ECHOCHAR")

    (SETQ CHARCODE (LOGAND CHARCODE \CHARMASK))
    ((LAMBDA (WIDTHSVECTOR)

       (* ;; "Note in following that if the DDWIDTHSCACHE exists and has a 0 entry for some character, that may someday mean that the character's glyph simply isn't loaded;  e.g., it may want #^A")

       (SETQ WIDTHSVECTOR (OR (AND (DISPLAYSTREAMP STREAM)
                                   (SETQ WIDTHSVECTOR (ffetch IMAGEDATA of STREAM))
                                   (ffetch DDWIDTHSCACHE of WIDTHSVECTOR))
                              \UNITWIDTHSVECTOR))
       (SELECTC (fetch CCECHO of (\SYNCODE (fetch (TERMTABLEP TERMSA)
                                                      of (OR (TERMTABLEP TTBL)
                                                                 \PRIMTERMTABLE))
                                                CHARCODE))
           (INDICATE.CCE ([LAMBDA (CC)
                            (IPLUS (if (IGEQ CHARCODE (CHARCODE %#^@))
                                       then              (* ; 
                                          "A META charcode -- implies that the 8th bit is non-zero")
                                             (SETQ CC (LOADBYTE CHARCODE 0 7))
                                             (\FGETWIDTH WIDTHSVECTOR (CHARCODE %#))
                                     else 0)
                                   (if (ILESSP CC (CHARCODE SPACE))
                                       then              (* ; "A CONTROL charcode")
                                             (add CC (CONSTANT (LLSH 1 6)))
                                             (\FGETWIDTH WIDTHSVECTOR (CHARCODE ^))
                                     else 0)
                                   (\FGETWIDTH WIDTHSVECTOR CC]
                          CHARCODE))
           (SIMULATE.CCE (SELCHARQ CHARCODE
                              ((EOL CR LF BELL) 
                                   NIL)
                              (ESCAPE (\FGETWIDTH WIDTHSVECTOR (CHARCODE $)))
                              (TAB (PROG ((SPACEWIDTH (\FGETWIDTH WIDTHSVECTOR (CHARCODE SPACE)))
                                          (NEWXPOSITON (DSPXPOSITION NIL STREAM))
                                          TABWIDTH)
                                         (SETQ TABWIDTH (UNFOLD SPACEWIDTH 8))
                                         [add NEWXPOSITON (SETQ TABWIDTH
                                                               (IDIFFERENCE
                                                                TABWIDTH
                                                                (IMOD (IDIFFERENCE NEWXPOSITON
                                                                             (DSPLEFTMARGIN NIL 
                                                                                    STREAM))
                                                                      TABWIDTH]
                                         (RETURN (if (IGREATERP NEWXPOSITON (DSPRIGHTMARGIN
                                                                                 NIL STREAM))
                                                     then 
                                                             (* ; 
                                                           "tab was past rightmargin, force cr.")
                                                           NIL
                                                   else TABWIDTH))))
                              (\FGETWIDTH WIDTHSVECTOR CHARCODE)))
           (REAL.CCE (SELECTC CHARCODE
                         ((CHARCODE (EOL CR LF)) 
                              NIL)
                         (ERASECHARCODE NIL)
                         (\FGETWIDTH WIDTHSVECTOR CHARCODE)))
           (IGNORE.CCE 0)
           (SHOULDNT])

(\UNITWIDTHSVECTOR
  [LAMBDA NIL                                            (* JonL " 7-NOV-83 19:23")
    (SETQ \UNITWIDTHSVECTOR (\ALLOCBLOCK (UNFOLD (IPLUS \MAXCHAR 3)
                                                WORDSPERCELL)))
    (for I from 0 to (IPLUS \MAXCHAR 2) do (\PUTBASE \UNITWIDTHSVECTOR I 1))
    \UNITWIDTHSVECTOR])

(\CREATEDISPLAYFONT
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited  9-Jun-2025 17:42 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:11 by rmk")
                                                             (* ; "Edited 23-May-2025 14:59 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 20-May-2025 13:24 by rmk")

    (* ;; "This would be the right place to do DISPLAYFONTCOERCIONS, but that doesn't work if the target font is only partially instantiated.  \GETCHARSETINFO has to know how to do the font coercion.")
                                                             (* gbn%: "25-Jan-86 18:02")
    (LET [(FONTDESC (create FONTDESCRIPTOR
                           FONTDEVICE _ DEVICE
                           FONTFAMILY _ FAMILY
                           FONTSIZE _ SIZE
                           FONTFACE _ FACE
                           \SFAscent _ 0
                           \SFDescent _ 0
                           \SFHeight _ 0
                           ROTATION _ ROTATION
                           FONTDEVICESPEC _ (LIST FAMILY SIZE FACE ROTATION DEVICE]
         (CL:WHEN (\CREATECHARSET CHARSET FONTDESC)
                FONTDESC])

(\CREATECHARSET.DISPLAY
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET FONTDESC NOSLUG?)
                                                             (* ; "Edited  8-Jun-2025 19:57 by rmk")
                                                             (* ; "Edited  7-Jun-2025 14:47 by rmk")
                                                             (* ; "Edited 20-May-2025 15:00 by rmk")
                                                             (* ; "Edited 18-May-2025 23:31 by rmk")
                                                             (* ; "Edited 14-Jan-88 23:42 by FS")

    (* ;; "This first tries to map the requested font to another existing font, essentially slapping the characteristics specified here on the target font information. The mapping takes precedence even if the nominal font exists (but then, how would you ever get to see the nominal font).  This applies to all font charactersets; the charset coercions may pick one charset from one point in the probe sequence and another charset from a different point, depending on what exists.")

(* ;;;; "This first tries to find an exact match for the specified characteristics, by reading from a source file and possibly applying an exact rotation.  When that fails, it finds at most one entry for the family in one or more mapping alist lists.  The tail of that entry is a list of possible coerecions each of the form (Size Altfamily Altsize) where Size is either a sparticular size or *, Altfamily is the target family, and Altsize is optionally another size. The entries are considered in order.  An entry applies if its Size is * or it matches SIZE, and it tries for a real charsetinfo for CHARSET in the (Altfamily FACE (OR Altsize SIZE)).")

    (* ;; "When all coercions have been exhausted and FACE is bold and/or italic, the search process repeats with bold/italice changed to Regular, and algorithmic transformations are applied to the first result, if any.")

    (* ;; "")

    (* ;; " Example entries:")

    (* ;; "    (GACHA (* TERMINAL) (* MODERN)(* CLASSIC)")

    (* ;; "    (MODERN (* CLASSIC)")

    (* ;; "    (TERMINAL (6 TERMINAL 8) (8 TERMINAL 10)(10 TERMINAL 12)")

    (* ;; "Note that this is all keyed off the original family:  Gacha might end up at Classic because Terminal and Modern didn't work out, but that does not depend on the fact that there is a separate mapping for Modern to Classic.  This set up is redundant, but we avoid having to recurse through the mappings and thereby possibly lose control.")

    (DECLARE (GLOBALVARS DISPLAYFONTCOERCIONS DISPLAYCHARSETCOERCIONS))

    (* ;; "DISPLAYFONTCOERCIONS is a list of font coercions, each of the form (userfont coercefont  Each user-font is a list of FAMILY, and optionally SIZE and CHARSET, (e.g., (GACHA) or (GACHA 10) or (GACHA 10 143)), and each real-font is a similar list. ")

    (LET (CSINFO)

         (* ;; "If no DISPLAYFONTCOERCIONS, skip that first \COERCECHARSET call--easier debugging of the other case.")

         [SETQ CSINFO (OR (AND DISPLAYFONTCOERCIONS (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE
                                                           CHARSET DISPLAYFONTCOERCIONS))
                          (\CREATE-REAL-CHARSET.DISPLAY FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                 DISPLAYCHARSETCOERCIONS)
                          (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                 (UNFOLD (ADD1 \MAXCHARSET)
                                        2))
                          (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                                 (ADD1 \MAXCHARSET)
                                 (\BUILDSLUGCSINFO (fetch (FONTDESCRIPTOR FONTAVGCHARWIDTH)
                                                      of FONTDESC)
                                        (FONTPROP FONTDESC 'ASCENT)
                                        (FONTPROP FONTDESC 'DESCENT)
                                        (FONTPROP FONTDESC 'DEVICE]
         (\COMPLETECHARSET.CSINFO CSINFO FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                DISPLAYCHARSETCOERCIONS)
         CSINFO])

(\COERCECHARSET
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS CODE)
                                                             (* ; "Edited  8-Jun-2025 19:36 by rmk")
                                                             (* ; "Edited  7-Jun-2025 13:39 by rmk")
                                                             (* ; "Edited 21-May-2025 10:50 by rmk")
                                                             (* ; "Edited 17-May-2025 21:32 by rmk")

    (* ;; "COERCIONS is a set of (oldspec newspec) pairs, where a spec is either just a font name or a font name with a size.  If oldspec matches the current requested characteristics, then \CREATE-REAL-CHARSET.DISPLAY recurses.  ")

    (* ;; "That may not be optimal.  If a given newspec can't be found, maybe there is a specification later in the map that would be better than depending on the recursive coercion.  For example, it might try to boldify something before it finds a better alternative to start with.")

    (* ;; "Suppose we are looking for Gacha Bold for the character set 41.  If Gacha maps to Terminal and Terminal has 41 but not bold, we might want it to bolidify Terminal 41, but we might do better first to see whetherDFc")

    (* ;; " ")

    (* ;; "If CODE is given, this passes over candidates that don't instantiate CODE")

    (for C REALFONT CSINFO CFONT in COERCIONS when [AND (SETQ CFONT (CAR C))
                                                        (EQ FAMILY (CAR CFONT))
                                                        (OR (NOT (CADR CFONT))
                                                            (EQ SIZE (CADR CFONT)))
                                                        (OR (NOT (CADDR CFONT))
                                                            (EQ CHARSET (CADDR CFONT)))
                                                        (SETQ REALFONT (CADR C))
                                                        [SETQ CSINFO
                                                         (\INSURECHARSETINFO
                                                          (OR (CADDR REALFONT)
                                                              CHARSET)
                                                          (FONTCREATE (OR (CAR REALFONT)
                                                                          FAMILY)
                                                                 (OR (CADR REALFONT)
                                                                     SIZE)
                                                                 FACE ROTATION DEVICE
                                                                 (OR (CADDR REALFONT)
                                                                     CHARSET]
                                                        (NOT (AND CODE (SLUGCHARP.DISPLAY CODE CSINFO
                                                                              ]
       do (RETURN CSINFO])

(\CREATE-REAL-CHARSET.DISPLAY
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS)
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 18-May-2025 21:08 by rmk")
                                                             (* ; "Edited 26-Jun-2022 12:37 by rmk")
                                                             (* ; "Edited 15-Jan-88 00:02 by FS")

    (* ;; "Called when \CREATECHARSET,DISPLAY needs a so-far uninstantiated charsetinfo.  Best cases: it finds a real one with the specified characterists, or one that differs only in some 90 degree rotation. Code for such bitmap rotations is exact.")

    (* ;; "Each time, this looks at the original source file, it does not pick up a previously instantiated charsetinfo from the specified font.  That keeps it pure--the coercion here won't be infected by changes made to a FONTCREATE-cached font.  And presumably  that lookup happens only once for this font, because \GETCHARSETINFO first checks to see if the (perhaps slug) info already exists.  So at most 255 lookups at each level of the chain..")

    (* ;; "")

    (* ;; 
   " When a real/rotated character set can't be found, we pile on coercions in some priority order. ")

    (OR (\READDISPLAYFONTFILE FAMILY SIZE FACE ROTATION 'DISPLAY CHARSET)
        (LET (XFONT CSINFO)

             (* ;; "The charset is not directly available. It can be rotated, coerced from somewhere else, or bolded/italicized algorithmically.   ")

             (* ;; "")

             (* ;; "This maintains original strategy in that the algorithmic face transformations are applied before a coercion to another font.  So for TIMESROMAN BOLD, it will transform when it sees TIMESROMAN REGULAR, even though there may be an actual CLASSIC BOLD of that face.  ")

             (if (NEQ ROTATION 0)
                 then (CL:UNLESS (MEMB ROTATION '(90 270))
                             (ERROR "only implemented rotations are 0, 90 and 270." ROTATION))
                      (CL:WHEN (SETQ XFONT (\CREATEFONT FAMILY SIZE FACE 0 'DISPLAY CHARSET))

                          (* ;; "Do not call FONTCREATE here.  The user might have modified (via PUTCHARBITMAP, etc.) the in-memory version of the source.  .")

                          (CL:WHEN (SETQ CSINFO (\INSURECHARSETINFO CHARSET XFONT T))
                                 (\SFROTATECSINFO CSINFO ROTATION)))
               elseif (AND (EQ 'BOLD (fetch WEIGHT of FACE))
                           (SETQ XFONT (\CREATEDISPLAYFONT FAMILY SIZE
                                              (create FONTFACE using FACE WEIGHT _ 'MEDIUM)
                                              0
                                              'DISPLAY CHARSET))
                           (SETQ CSINFO (\INSURECHARSETINFO CHARSET XFONT))
                           (\SFMAKEBOLD CSINFO))
               elseif (AND (EQ 'ITALIC (fetch (FONTFACE SLOPE) of FACE))
                           (SETQ XFONT (\CREATEDISPLAYFONT FAMILY SIZE
                                              (create FONTFACE using FACE SLOPE _ 'REGULAR)
                                              0
                                              'DISPLAY CHARSET))
                           (SETQ CSINFO (\INSURECHARSETINFO CHARSET XFONT T))
                           (\SFMAKEITALIC CSINFO))
               else (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS])

(\BUILDSLUGCSINFO
  [LAMBDA (WIDTH ASCENT DESCENT DEVICE SCALE)                (* ; "Edited 20-May-2025 14:50 by rmk")
                                                             (* ; "Edited 18-May-2025 21:52 by rmk")
                                                             (* ; "Edited 12-May-2025 21:09 by rmk")
                                                             (* ; "Edited  9-May-93 23:12 by rmk:")

    (* ;; "builds a csinfo which contains only the slug (black rectangle) character. ")

    (SETQ SCALE (OR SCALE 1))
    (LET ((CSINFO (create CHARSETINFO
                         CHARSETASCENT _ ASCENT
                         CHARSETDESCENT _ DESCENT
                         CSSLUGP _ T))
          WIDTHS OFFSETS BITMAP IMAGEWIDTHS)
         (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
         (for I from 0 to \MAXTHINCHAR do (\FSETWIDTH WIDTHS I WIDTH))
         (REPLACE IMAGEWIDTHS OF CSINFO WITH WIDTHS)
         (replace (CHARSETINFO OFFSETS) of CSINFO with (SETQ OFFSETS (\CREATECSINFOELEMENT)))
         (for I from 0 to \MAXTHINCHAR do (\FSETOFFSET OFFSETS I 0))
         (CL:WHEN (MEMB DEVICE \DISPLAYSTREAMTYPES)
             [replace (CHARSETINFO CHARSETBITMAP) of CSINFO
                with (SETQ BITMAP (BITMAPCREATE (ROUND (QUOTIENT WIDTH SCALE))
                                         (ROUND (QUOTIENT (IPLUS ASCENT DESCENT)
                                                       SCALE]
             [BLTSHADE BLACKSHADE BITMAP 1 NIL (SUB1 (ROUND (QUOTIENT WIDTH SCALE])
         CSINFO])

(\SEARCHDISPLAYFONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* ; "Edited 16-May-2025 14:42 by rmk")
                                                             (* ; "Edited  5-Mar-87 18:55 by FS")

    (* ;; "     This function called via APPLY in IMAGESTREAMTYPES.")

    (* ;; "     Returns a list of the fonts that can be read in for displaylike devices.  Rotation is ignored because it is assumed that all devices support 0 90 and 270.")

    (* ;; "     Note we *allow* a device that is not 'DISPLAY for guys like 4DISPLAY, 8DISPLAY, 24DISPLAY, and also possibly for FX80,  etc. (guys that want DISPLAYFONTS anyway).  Should have some hook though for FONTEXTENSIONS, FONTDIRECTORIES??")

    (DECLARE (GLOBALVARS DISPLAYFONTEXTENSIONS DISPLAYFONTDIRECTORIES))
    (\SEARCHFONTFILES FAMILY SIZE FACE ROTATION DEVICE DISPLAYFONTDIRECTORIES DISPLAYFONTEXTENSIONS])

(\SEARCHFONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE DIRLST EXTLST)   (* ; "Edited 17-May-2025 14:09 by rmk")
                                                             (* ; "Edited 15-May-2025 23:12 by rmk")
                                                             (* ; "Edited 14-Sep-96 10:54 by rmk:")
                                                             (* ; "Edited  6-Oct-89 12:34 by bvm")

    (* ;; "GENERIC FUNCTION")

    (* ;; "returns a list of the fonts that can be read in for a device.  Rotation is ignored because it is assumed that all devices support 0 90 and 270.")

    (SETQ FAMILY (\FONTSYMBOL FAMILY))
    (SETQ DEVICE (\FONTSYMBOL DEVICE))
    (SETQ FACE (\FONTFACE FACE))
    (for FILEPATTERN FILEDIR FONTSFOUND (FILING.ENUEMRATION.DEPTH _ 1)
       IN (\FONTFILENAMES FAMILY SIZE FACE DEVICE EXTLST)
       do (SETQ FILEDIR (FILENAMEFIELD FILEPATTERN 'DIRECTORY))
          (SETQ FILEDIR (CL:IF FILEDIR
                            (CONCAT ">" FILEDIR ">")
                            ""))
          (for DIR inside DIRLST eachtime 

                                   (* ;; "The file pattern might have an extending subdirectory (C41>) that might not exist, but DIRECTORYNAMEP makes sure that it does.")

                                       (SETQ DIR (CONCAT DIR ">" (OR FILEDIR "")))
             when (DIRECTORYNAMEP DIR)
             do (for FONTFILE THISFONT THISFACE in (DIRECTORY DIR) eachtime (SETQ THISFONT
                                                                             (\FONTINFOFROMFILENAME
                                                                              FONTFILE DEVICE))
                                                                         (SETQ THISFACE (CADDR 
                                                                                             THISFONT
                                                                                               )) 

                                                                         (* ;; 
                                                 "make sure the face, size, and family really match.")
 when [AND (NOT (MEMBER THISFONT FONTSFOUND))
           (OR (EQ FAMILY '*)
               (EQ FAMILY (CAR THISFONT)))
           (OR (EQ SIZE '*)
               (EQ SIZE (CADR THISFONT)))
           (OR (EQ FACE '*)
               (EQUAL FACE THISFACE)
               (AND (OR (EQ (CAR FACE)
                            '*)
                        (EQ (CAR FACE)
                            (CAR THISFACE)))
                    (OR (EQ (CADR FACE)
                            '*)
                        (EQ (CADR FACE)
                            (CADR THISFACE)))
                    (OR (EQ (CADDR FACE)
                            '*)
                        (EQ (CADDR FACE)
                            (CADDR THISFACE] do (push FONTSFOUND THISFONT)))
       finally (RETURN (DREVERSE FONTSFOUND])

(\FONTSYMBOL
  [LAMBDA (X ElseReturnXFlg)                             (* ; "Edited 28-Jul-88 11:59 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:32 by FS")

    (* ;; "Return a symbol in IL package and is in uppercase.  Currently the function IL:U-CASE is believed to do this, but if it changes, this is the font hook.  ElseReturnXFlg is if you want an IL symbol if X is a symbol or string, otherwise just X.")

    (COND
       ((LITATOM X)
        (U-CASE X))
       ((STRINGP X)
        (MKATOM (U-CASE X)))
       (ElseReturnXFlg X)
       (T (ERROR "Want an IL symbol"])

(\DEVICESYMBOL
  [LAMBDA (X ElseReturnXFlg)                             (* ; "Edited  7-Oct-88 20:07 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:43 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:33 by FS")

    (* ;; "Return a canonicalized atom good for comparing with DEVICE symbols")

    (LET ((STRM (\GETSTREAM X 'OUTPUT T)))
         (COND
            (STRM (fetch (IMAGEOPS IMFONTCREATE) of (fetch (STREAM IMAGEOPS) of
                                                                                         STRM)))
            ((NULL X)
             'DISPLAY)
            (T                                               (* ; "because its used in ASSOC.")
               (\FONTSYMBOL X ElseReturnXFlg])

(\FONTFACE
  [LAMBDA (FACE NOERRORFLG DEV)                          (* ; "Edited  1-Aug-88 09:44 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:50 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:49 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:41 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:38 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:44 by rmk:")
                                                             (* ; "Edited 25-Feb-87 22:58 by FS")

    (* ;; "Coerces FACE into standard FONTFACE record, usually returns a CONSTANT (so you'd better not RPLACD or REPLACE fields!!)")

    (PROG (UNKNOWN (WEIGHT 'MEDIUM)
                 (SLOPE 'REGULAR)
                 (EXPANSION 'REGULAR)
                 (OLDFACE FACE))

     (* ;; "On error, can signal, or return NIL, or return REGULAR face.")

          [SETQ UNKNOWN (COND
                           ((EQ NOERRORFLG 'REGULAR)
                            'REGULAR)
                           (T 'ERROR]
          [COND
             ((type? FONTFACE FACE)

              (* ;; "List Case.  Unpack because want to validate fields")

              (SETQ WEIGHT (fetch (FONTFACE WEIGHT) of FACE))
              (SETQ SLOPE (fetch (FONTFACE SLOPE) of FACE))
              (SETQ EXPANSION (fetch (FONTFACE EXPANSION) of FACE))

              (* ;; "Handle unknown faces")

              [OR (\FONT.SYMBOLMEMB WEIGHT '             (* BOLD MEDIUM LIGHT))
                  (SETQ WEIGHT (COND
                                  ((\FONT.COMPARESYMBOL WEIGHT 'REGULAR)

                                   (* ;; "Clean up WEIGHT REGULAR vs. MEDIUM")

                                   (SETQ WEIGHT 'MEDIUM))
                                  (T UNKNOWN]
              (OR (\FONT.SYMBOLMEMB SLOPE '              (* REGULAR ITALIC))
                  (SETQ SLOPE UNKNOWN))
              (OR (\FONT.SYMBOLMEMB EXPANSION '          (* COMPRESSED REGULAR EXPANDED))
                  (SETQ EXPANSION UNKNOWN)))
             ((OR (LITATOM FACE)
                  (STRINGP FACE))
              (COND
                 ((NULL FACE)                                (* ; "Fast vanilla default")
                  )
                 ((EQ (NCHARS FACE)
                      3)                                     (* ; "3 char notation case")
                  (SETQ WEIGHT (SELCHARQ (CHCON1 FACE)
                                    ((B b) 
                                         'BOLD)
                                    ((M m R r) 
                                         'MEDIUM)
                                    ((L l) 
                                         'LIGHT)
                                    UNKNOWN))
                  (SETQ SLOPE (SELCHARQ (NTHCHARCODE FACE 2)
                                   ((R r) 
                                        'REGULAR)
                                   ((I i) 
                                        'ITALIC)
                                   UNKNOWN))
                  (SETQ EXPANSION (SELCHARQ (NTHCHARCODE FACE 3)
                                       ((R r) 
                                            'REGULAR)
                                       ((C c) 
                                            'COMPRESSED)
                                       ((E e) 
                                            'EXPANDED)
                                       UNKNOWN)))
                 ((SELECTQ FACE
                      (BOLD (SETQ WEIGHT 'BOLD))
                      (ITALIC (SETQ SLOPE 'ITALIC))
                      (BOLDITALIC (SETQ WEIGHT 'BOLD)
                                  (SETQ SLOPE 'ITALIC))
                      ((STANDARD REGULAR) 
                           T)
                      NIL))
                 ((\FONT.COMPARESYMBOL FACE 'BOLD)
                  (SETQ WEIGHT 'BOLD))
                 ((\FONT.COMPARESYMBOL FACE 'ITALIC)
                  (SETQ SLOPE 'ITALIC))
                 ((\FONT.COMPARESYMBOL FACE 'BOLDITALIC)
                  (SETQ WEIGHT 'BOLD)
                  (SETQ SLOPE 'ITALIC))
                 ((\FONT.SYMBOLMEMB FACE '(STANDARD REGULAR NIL NNN))
                                                             (* ; "Vanilla case")
                  )
                 ((STRPOS "-" FACE)                          (* ; "Color fontface spec!")
                  (SETQ FACE (\FONTFACE.COLOR FACE NOERRORFLG DEV))
                  (RETURN FACE))
                 ((\FONT.SYMBOLMEMB FACE '               (* ***))
                                                             (* ; "Wildcard case")
                  (SETQ WEIGHT '*)
                  (SETQ SLOPE '*)
                  (SETQ EXPANSION '*))
                 (T                                          (* ; "Other litatom error case")
                    (SETQ WEIGHT UNKNOWN)
                    (SETQ SLOPE UNKNOWN)
                    (SETQ EXPANSION UNKNOWN]
          (if (OR (EQ WEIGHT 'ERROR)
                      (EQ SLOPE 'ERROR)
                      (EQ EXPANSION 'ERROR))
              then (if NOERRORFLG
                           then (RETURN NIL)
                         else (\ILLEGAL.ARG OLDFACE)))

     (* ;; "Avoid consing by returning constant faces (historical:  really, would have been better to return MRR, but users have know about this for too long (rmk))")

          (RETURN (COND
                     ((AND (EQ WEIGHT 'MEDIUM)
                           (EQ SLOPE 'REGULAR)
                           (EQ EXPANSION 'REGULAR))          (* ; "MRR")
                      (CONSTANT (create FONTFACE)))
                     [(AND (EQ WEIGHT 'BOLD)
                           (EQ SLOPE 'REGULAR)
                           (EQ EXPANSION 'REGULAR))          (* ; "BRR")
                      (CONSTANT (create FONTFACE
                                       WEIGHT _ 'BOLD]
                     [(AND (EQ WEIGHT 'MEDIUM)
                           (EQ SLOPE 'ITALIC)
                           (EQ EXPANSION 'REGULAR))          (* ; "MIR")
                      (CONSTANT (create FONTFACE
                                       SLOPE _ 'ITALIC]
                     [(AND (EQ WEIGHT 'BOLD)
                           (EQ SLOPE 'ITALIC)
                           (EQ EXPANSION 'REGULAR))          (* ; "BIR")
                      (CONSTANT (create FONTFACE
                                       WEIGHT _ 'BOLD
                                       SLOPE _ 'ITALIC]
                     (T                                      (* ; "Otherwise, cons up")
                        (create FONTFACE
                               WEIGHT _ WEIGHT
                               SLOPE _ SLOPE
                               EXPANSION _ EXPANSION])

(\FONTFACE.COLOR
  [LAMBDA (FACE NOERRORFLG DEV)                          (* ; "Edited 28-Jul-88 14:51 by rmk:")
                                                             (* ; "Edited 28-Jul-88 13:09 by rmk:")
                                                             (* ; "Edited 24-Mar-87 17:03 by FS")

    (* ;; "This used to be \FONTFACE.  Renamed \FONTFACE.COLOR, and \FONTFACE rewritten.  The section below should also be redone")

    (* ;; "Takes a variety of user specifications and converts them to a standard FONTFACE record.")

    (* ;; "b/w fontfaces are extended by an optional '-backcolor-forecolor'")

    (* ;; "the atom NNN is interpreted the same as NIL or MRR to cover up a bug described in AR 3025, the FONTNNN bug")

    (DECLARE (GLOBALVARS \COLORDISPLAYSTREAMTYPES))
    (SETQ DEV (\DEVICESYMBOL DEV))
    (PROG (BWFACE POS OLDPOS BITSPERPIXEL BACKCOLOR FORECOLOR ANSWER)

     (* ;; "First get a FONTFACE ANSWER.")

          [SETQ ANSWER (COND
                          ((type? FONTFACE FACE)
                           FACE)
                          ((LITATOM FACE)
                           (OR (U-CASEP FACE)
                               (SETQ FACE (U-CASE FACE)))
                           (SETQ POS (STRPOS "-" FACE))
                           (COND
                              [POS (SETQ BWFACE (SUBATOM FACE 1 (SUB1 POS]
                              (T (SETQ BWFACE FACE)))
                           [SETQ ANSWER (SELECTQ BWFACE
                                            ((* ***) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ '*
                                                                  SLOPE _ '*
                                                                  EXPANSION _ '*)))
                                            ((NIL MRR STANDARD NNN) 
                                                 (CONSTANT (create FONTFACE)))
                                            ((ITALIC MIR) 
                                                 (CONSTANT (create FONTFACE
                                                                  SLOPE _ 'ITALIC)))
                                            ((BOLD BRR) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ 'BOLD)))
                                            ((BOLDITALIC BIR) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ 'BOLD
                                                                  SLOPE _ 'ITALIC)))
                                            (create FONTFACE
                                                   WEIGHT _ (SELCHARQ (NTHCHARCODE FACE 1)
                                                                 (M 'MEDIUM)
                                                                 (B 'BOLD)
                                                                 (L 'LIGHT)
                                                                 (GO ERROR))
                                                   SLOPE _ (SELCHARQ (NTHCHARCODE FACE 2)
                                                                (R 'REGULAR)
                                                                (I 'ITALIC)
                                                                (GO ERROR))
                                                   EXPANSION _ (SELCHARQ (NTHCHARCODE FACE 3)
                                                                    (R 'REGULAR)
                                                                    (C 'COMPRESSED)
                                                                    (E 'EXPANDED)
                                                                    (GO ERROR]
                           (COND
                              (POS                           (* ; "Color FONTFACE.  *")
                                   (SETQ OLDPOS POS)
                                   (SETQ POS (STRPOS "-" FACE (ADD1 OLDPOS)))
                                   (COND
                                      ((NULL POS)
                                       (GO ERROR)))
                                   (SETQ BITSPERPIXEL (\DISPLAYSTREAMTYPEBPP DEV))
                                   (SETQ BACKCOLOR (COLORNUMBERP (SUBATOM FACE (ADD1 OLDPOS)
                                                                        (SUB1 POS))
                                                          BITSPERPIXEL))
                                   (SETQ OLDPOS POS)
                                   (SETQ FORECOLOR (COLORNUMBERP (SUBATOM FACE (ADD1 OLDPOS)
                                                                        -1)
                                                          BITSPERPIXEL))
                                                             (* ; 
                                                         "COPY ANSWER to avoid smashing constants.")
                                   (SETQ ANSWER (COPY ANSWER))
                                   (replace (FONTFACE BACKCOLOR) of ANSWER with BACKCOLOR
                                          )
                                   (replace (FONTFACE FORECOLOR) of ANSWER with FORECOLOR
                                          )))
                           ANSWER)
                          (T (GO ERROR]

     (* ;; "Coerce on or off COLOR.")

          (SETQ ANSWER (COND
                          ((AND (NOT (FMEMB DEV \COLORDISPLAYSTREAMTYPES))
                                (fetch (FONTFACE COLOR) of ANSWER))
                           (SETQ ANSWER (COPY ANSWER))
                           (replace (FONTFACE COLOR) of ANSWER with NIL)
                           ANSWER)
                          ((AND (FMEMB DEV \COLORDISPLAYSTREAMTYPES)
                                (NULL (fetch (FONTFACE COLOR) of ANSWER)))
                           (SETQ FACE (COPY FACE))
                           (replace (FONTFACE BACKCOLOR) of ANSWER with 0)
                           (replace (FONTFACE FORECOLOR) of ANSWER with
                                                                           (MAXIMUMCOLOR (
                                                                                \DISPLAYSTREAMTYPEBPP
                                                                                          DEV)))
                           ANSWER)
                          (T ANSWER)))
          (RETURN ANSWER)
      ERROR
          (COND
             (NOERRORFLG (RETURN NIL))
             (T (\ILLEGAL.ARG FACE])

(\GETFONTDESC
  [LAMBDA (SPEC DEVICE NOERRORFLG)                       (* J.Gibbons " 5-Dec-82 16:53")

    (* ;; "Coerces SPEC to a fontdescriptor")
                                                             (* ; 
                                                "\GETFONTDESC HAS MACRO, BUT OLD CALLS STILL EXIST")
    (\COERCEFONTDESC SPEC DEVICE NOERRORFLG])

(\COERCEFONTDESC
  [LAMBDA (SPEC STREAM NOERRORFLG)                       (* ; "Edited 29-Aug-91 12:19 by jds")

    (* ;; "Coerces SPEC to a fontdescriptor appropriate for STREAM.  Go back thru FONTCREATE for various coercions in order to make sure that the cache gets set up")

    (DECLARE (GLOBALVARS DEFAULTFONT))
    (PROG (FONT DEVICE)
          [COND
             ((type? FONTDESCRIPTOR SPEC)
              (SETQ FONT SPEC))
             [(type? FONTCLASS SPEC)
              [SETQ DEVICE (COND
                              ((NULL STREAM)                 (* ; "Default is display")

                               (* ;; "COULDN'T THIS BRANCH BE INTENDED TO MEAN 4DISPLAY, 8DISPLAY, 24DISPLAY?  PEOPLE PROBABLY SHOULDN'T BE CALLING \COERCEFONTDESC WITH STREAM = NIL.")

                               'DISPLAY)
                              ((IMAGESTREAMP STREAM)
                               (IMAGESTREAMTYPE STREAM))
                              ((LITATOM STREAM)
                               (\DEVICESYMBOL STREAM))
                              (STREAM STREAM)
                              (T 
                                 (* ;; "I don't think this case should be allowed.")

                                 'DISPLAY]
              [SETQ FONT (SELECTQ DEVICE
                             (DISPLAY (fetch (FONTCLASS DISPLAYFD) of SPEC))
                             (INTERPRESS (fetch (FONTCLASS INTERPRESSFD) of SPEC))
                             (PRESS (fetch (FONTCLASS PRESSFD) of SPEC))
                             (CDR (SASSOC DEVICE (fetch (FONTCLASS OTHERFDS) of SPEC]
              (RETURN (COND
                         ((type? FONTDESCRIPTOR FONT)

                          (* ;; 
     "We don't always create FD's for devices before they are needed, so do it now and save result")

                          FONT)
                         [(NULL FONT)

                          (* ;; "NIL means create FONT but don't cache.")

                          (COND
                             ((AND (FMEMB DEVICE \DISPLAYSTREAMTYPES)
                                   (SETQ FONT (\COERCEFONTDESC SPEC 'DISPLAY NOERRORFLG))
                                   (SETQ FONT (FONTCOPY FONT 'DEVICE STREAM 'NOERROR NOERRORFLG))
                                   )

                              (* ;; 
                            "Coerce existing black & white font to color font, but don't cache.")

                              FONT)
                             [(EQ SPEC DEFAULTFONT)

                              (* ;; "Break cycles with NIL in the defaultfont")

                              (COND
                                 (NOERRORFLG NIL)
                                 ((EQ DEVICE 'DISPLAY)

                                  (* ;; "Function DEFAULTFONT guarantees system integrity")

                                  (DEFAULTFONT 'DISPLAY))
                                 ((EQUAL DEVICE '(HARDCOPY DISPLAY))

                                  (* ;; 
                "MAKE DISPLAY-HARDCOPY FONTS default to the corresponding display font, copied....")

                                  (FONTCOPY (DEFAULTFONT 'DISPLAY)
                                         'DEVICE STREAM 'NOERROR NOERRORFLG))
                                 (T (ERROR (CONCAT DEVICE " component for DEFAULTFONT undefined"]
                             (T (FONTCREATE DEFAULTFONT NIL NIL NIL STREAM NOERRORFLG]
                         ((SETQ FONT (FONTCREATE FONT NIL NIL NIL STREAM NOERRORFLG))

                          (* ;; "Might get NIL if NOERRORFLG")

                          (SETFONTCLASSCOMPONENT SPEC DEVICE FONT]
             ((NULL SPEC)
              (RETURN (\COERCEFONTDESC DEFAULTFONT STREAM NOERRORFLG)))
             ((OR (IMAGESTREAMP SPEC)
                  (type? WINDOW SPEC))
              (SETQ FONT (DSPFONT NIL SPEC)))
             (T 
                (* ;; "If called with NOERRORFLG=T (e.g.  from DSPFONT) we want to suppress invalid arg errors as well as font not found, so we can move on to other possible coercions.")

                (RETURN (FONTCREATE SPEC NIL NIL NIL STREAM NOERRORFLG]

     (* ;; "Here if arg was a fontdescriptor or imagestream")

          (RETURN (COND
                     ((NULL STREAM)

                      (* ;; 
                    "NIL device doesn't default to display if a fully-specified font was found")

                      FONT)
                     ([OR (EQ STREAM (fetch (FONTDESCRIPTOR FONTDEVICE) of FONT))
                          (AND (type? STREAM STREAM)
                               (EQ (fetch (IMAGEOPS IMFONTCREATE) of (fetch (STREAM
                                                                                         IMAGEOPS)
                                                                                of STREAM))
                                   (fetch (FONTDESCRIPTOR FONTDEVICE) of FONT]
                      FONT)
                     (T 
                        (* ;; "Here if doesn't match or if DEVICE is not explicitly a stream.")

                        (FONTCOPY FONT 'DEVICE STREAM 'NOERROR NOERRORFLG])

(\LOOKUPFONT
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)             (* ; "Edited 28-Jul-88 17:05 by rmk:")
                                                             (* ; "Edited 28-Jul-88 17:04 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:44 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:02 by rmk:")
                                                             (* ; "Edited 28-Jul-88 13:54 by rmk:")
                                                             (* ; "Edited 26-Feb-87 00:20 by FS")

    (* ;; "looks up a font in the internal cache.  SASSOC for listp FACE")

    (DECLARE (GLOBALVARS \FONTSINCORE))

    (* ;; "Someone had better have already made FACE canonical")

    (LET [(X (CDR (FASSOC ROTATION (CDR (SASSOC FACE (CDR (FASSOC SIZE (CDR (OR (FASSOC FAMILY 
                                                                                       \FONTSINCORE)
                                                                                (\FONT.SYMBOLASSOC
                                                                                 FAMILY \FONTSINCORE]
         (CDR (OR (FASSOC DEVICE X)
                  (\FONT.SYMBOLASSOC DEVICE X])

(\LOOKUPFONTSINCORE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* ; "Edited 25-Apr-93 13:07 by rmk:")
                                                             (* rrb "25-Sep-84 12:10")

(* ;;; "returns a list of the fonts that are available in core.  * is used to match anything.")

    (DECLARE (GLOBALVARS \FONTSINCORE))
    (for FAMBUCKET in \FONTSINCORE when (OR (EQ FAMILY '*)
                                                        (EQ FAMILY (CAR FAMBUCKET)))
       join (for SIZEBUCKET in (CDR FAMBUCKET) when (OR (EQ SIZE '*)
                                                                        (EQ SIZE (CAR SIZEBUCKET)))
                   join (for FACEBUCKET in (CDR SIZEBUCKET)
                               when (OR (EQ FACE '*)
                                            (EQUAL FACE (CAR FACEBUCKET)))
                               join (for ROTBUCKET in (CDR FACEBUCKET)
                                           when (OR (EQ ROTATION '*)
                                                        (EQ ROTATION (CAR ROTBUCKET)))
                                           join (for DEVBUCKET in (CDR ROTBUCKET)
                                                       when (AND (OR (EQ DEVICE '*)
                                                                         (EQ DEVICE (CAR DEVBUCKET)))
                                                                     (TYPE? FONTDESCRIPTOR
                                                                            (CDR DEVBUCKET)))
                                                       collect (LIST (CAR FAMBUCKET)
                                                                         (CAR SIZEBUCKET)
                                                                         (CAR FACEBUCKET)
                                                                         (CAR ROTBUCKET)
                                                                         (CAR DEVBUCKET])

(\READDISPLAYFONTFILE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited  9-Jun-2025 20:06 by rmk")
                                                             (* ; "Edited  7-Jun-2025 10:32 by rmk")
                                                             (* ; "Edited  4-Jun-2025 23:41 by rmk")
                                                             (* ; "Edited 27-May-2025 23:00 by rmk")
                                                             (* ; "Edited 24-May-2025 20:38 by rmk")
                                                             (* ; "Edited 20-May-2025 18:04 by rmk")
                                                             (* ; "Edited 18-May-2025 11:27 by rmk")
                                                             (* ; "Edited 17-May-2025 00:32 by rmk")
                                                             (* ; "Edited  8-Oct-96 10:17 by rmk:")
                                                            (* ; "Edited 30-Sep-96 12:03 by kaplan")
                                                             (* ; "Edited  2-Jan-87 17:55 by FS")

    (* ;; "This enumerates all possible filenames for display fonts with the specified characteristics, determines the format for each such file, and applies the appropriate reading function for that format to produce and install the desired CHARSET. ")

    (* ;; "I stripped the CACHEDISPLAYFONTS machinery from this. It previously kept the retrieved fonts so that NSDISPLAYSIZES and SMALLSCREEN size coercions can be done and undone without always going out to the directories.  We want to get rid of NSDISPLAYSIZES by better coordinating hardcopy and display font images, and switching screen sizes is a rare event--that mechanism should cache the fonts if it wants to eventually switch back.")

    (* ;; "CADR of each DISPLAYCHARSETFNS is a test-predicate on the open stream.     If it returns true, the CADDR is applied to get the CSINFO. ")

    (CL:WHEN (EQ ROTATION 0)
        (RESETLST
            (for F STRM CSINFO in (FONTFILES FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                         DISPLAYFONTDIRECTORIES DISPLAYFONTEXTENSIONS)
               do

               (* ;; "We know that F exists.  Open it here and pass the stream to the charset functions, and ensure it is closed on exist.")

               (CL:WHEN (for FNS in DISPLAYCHARSETFNS
                           do [RESETSAVE (SETQ STRM (OPENSTREAM F 'INPUT))
                                     `(PROGN (CLOSEF? OLDVALUE]
                              (CL:WHEN (APPLY* (CADR FNS)
                                              STRM)

                                  (* ;; 
        "Assume that predicate leaves stream (open or closed) in proper state for retrieval function")

                                  (SETQ CSINFO (APPLY* (CADDR FNS)
                                                      STRM FAMILY SIZE FACE ROTATION DEVICE CHARSET))
                                  (CLOSEF? STRM)
                                  (CL:WHEN (type? CHARSETINFO CSINFO)
                                         (RETURN T)))
                              (CLOSEF? STRM))
                   (CL:UNLESS (CDR (ASSOC 'CSCHARENCODING (fetch (CHARSETINFO CSINFOPROPS)
                                                             of CSINFO)))
                       (change (fetch (CHARSETINFO CSINFOPROPS) of CSINFO)
                              (CONS (CONS 'CSCHARENCODING
                                          (if (MEMB FAMILY NSFONTFAMILIES)
                                              then 'XCCS$
                                            elseif (MEMB FAMILY ALTOFONTFAMILIES)
                                              then (CL:WHEN (AND (MEMB FAMILY '(GACHA HELVETICA))
                                                                 (EQ SIZE 10))
                                                             (* ; "The default loadup and menu fonts")
                                                       (replace (CHARSETINFO CSCOMPLETEP)
                                                          of CSINFO with T))
                                                   'ALTOTEXT
                                            else FAMILY))
                                    DATUM)))
                   (RETURN CSINFO)) 

               (* ;; "Close on each file")

               (CLOSEF? STRM))))])

(SETFONTCHARENCODING
  [LAMBDA (FONT CHARENCODING)                                (* ; "Edited 23-May-2025 14:54 by rmk")
                                                             (* ; "Edited 21-May-2025 22:27 by rmk")
                                                             (* ; "Edited  2-May-2025 16:03 by rmk")
    (replace (FONTDESCRIPTOR FONTCHARENCODING) of (FONTCREATE FONT) with CHARENCODING)
    (for CS CSI ECELL from 0 to \MAXCHARSET when (AND (SETQ CSI (\XGETCHARSETINFO FONT CS))
                                                      (NOT (fetch (CHARSETINFO CSSLUGP) of CSI)))
       do (RPLACD [OR (ASSOC 'CSCHARENCODING (fetch (CHARSETINFO CSINFOPROPS) of CSI))
                      (CAR (push (fetch (CHARSETINFO CSINFOPROPS) of CSI)
                                 (CONS 'CSCHARENCODING]
                 CHARENCODING])
)
(DEFINEQ

(ACFONT.FILEP
  [LAMBDA (FILE)                                             (* ; "Edited 15-May-2025 17:48 by rmk")
    (RESETLST
        (CL:UNLESS (OPENP FILE 'INPUT)
            [RESETSAVE (SETQ FILE (OPENSTREAM FILE 'INPUT 'OLD))
                   `(PROGN (CLOSEF? OLDVALUE])

        (* ;; "This is the length of a standard index header.  Other files could also have this value, but it's a pretty good discriminator")

        (* ;; "Skip to byte 25;  do it with BINS so works for non-randaccessp devices.  This skips the standard name header, then look for type 3 in the following header")

        (CL:WHEN (EQ (\WIN FILE)
                     (LOGOR (LLSH 16 8)
                            12))
            (FRPTQ 22 (\BIN FILE))                           (* ; "(SETFILEPTR STRM 25)")
            (EQ 3 (LRSH (\BIN FILE)
                        4))))])

(STRIKEFONT.FILEP
  [LAMBDA (FILE)                                             (* ; "Edited 15-May-2025 17:47 by rmk")

    (* ;; "If high bit of type is on, then must be strike.  If 2nd bit is on, must be strike-index, and we punt.  We don't care about the 3rd bit")

    (* ;; "first word has high bits (onebit index fixed).  Onebit means 'new-style font' , index is 0 for simple strike, 1 for index, and fixed is if all chars have max width.  Lisp doesn't care about 'fixed'")

    (RESETLST
        (CL:UNLESS (OPENP FILE 'INPUT)
            [RESETSAVE (SETQ FILE (OPENSTREAM FILE 'INPUT 'OLD))
                   `(PROGN (CLOSEF? OLDVALUE])
        (CL:WHEN [MEMB (\WIN FILE)
                       (CONSTANT (LIST (LLSH 1 15)
                                       (LOGOR (LLSH 1 15)
                                              (LLSH 1 13]
               T))])
)



(* ; "Legacy font-fille predicates")




(* ; "STRIKE format file support")

(DEFINEQ

(\READSTRIKEFONTFILE
  [LAMBDA (STRM FAMILY SIZE FACE)                            (* ; "Edited  9-Jun-2025 14:22 by rmk")
                                                             (* ; "Edited 12-Jul-2022 09:19 by rmk")
                                                             (* ; "Edited  4-Dec-92 12:11 by jds")
                                                             (* ; 
                               "STRM has already been determined to be a vanilla strike-format file.")
                                                             (* ; "returns a charsetinfo")
    (RESETLST
        (CL:UNLESS (\GETSTREAM STRM 'INPUT T)
            [RESETSAVE (SETQ STRM (OPENSTREAM STRM 'INPUT 'OLD))
                   `(PROGN (CLOSEF? OLDVALUE])
        (SETFILEPTR STRM 0)
        (CL:UNLESS (STRIKEFONT.FILEP STRM)
               (ERROR "Not a STRIKE font file" STRM))
        (CL:UNLESS (EQ 2 (GETFILEPTR STRM))
               (SETFILEPTR STRM 2))
        (LET (CSINFO NUMBCODES RW BITMAP OFFSETS FIRSTCHAR LASTCHAR HEIGHT WIDTHS)
             (SETQ CSINFO (create CHARSETINFO))
             (SETQ FIRSTCHAR (\WIN STRM))                    (* ; "minimum ascii code")
             (SETQ LASTCHAR (\WIN STRM))                     (* ; "maximum ascii code")
             (\WIN STRM)                                     (* ; 
                                                             "MaxWidth which isn't used by anyone.")
             (\WIN STRM)                                     (* ; 
                                                             "number of words in this StrikeBody")
             (replace (CHARSETINFO CHARSETASCENT) of CSINFO with (\WIN STRM))
                                                             (* ; 
                                                             "ascent in scan lines (=FBBdy+FBBoy)")
             (replace (CHARSETINFO CHARSETDESCENT) of CSINFO with (\WIN STRM))
                                                             (* ; "descent in scan-lines (=FBBoy)")
             (\WIN STRM)                                     (* ; 
                                                    "offset in bits (<0 for kerning, else 0, =FBBox)")
             (SETQ RW (\WIN STRM))                           (* ; "raster width of bitmap")
                                                             (* ; "height of bitmap")

             (* ;; "JDS 12/4/92:  Apparently, these fields can be signed values, if all chars, e.g., ride above the base line.")

             (SETQ HEIGHT (IPLUS (SIGNED (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                        16)
                                 (SIGNED (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)
                                        16)))
             (SETQ BITMAP (BITMAPCREATE (UNFOLD RW BITSPERWORD)
                                 HEIGHT))
             (\BINS STRM (fetch BITMAPBASE of BITMAP)
                    0
                    (UNFOLD (ITIMES RW HEIGHT)
                           BYTESPERWORD))                    (* ; "read bits into bitmap")
             (replace (CHARSETINFO CHARSETBITMAP) of CSINFO with BITMAP)
             (SETQ NUMBCODES (IPLUS (IDIFFERENCE LASTCHAR FIRSTCHAR)
                                    3))                      (* ; 
                                    "(SETQ OFFSETS (ARRAY (IPLUS \MAXCHAR 3) (QUOTE SMALLPOSP) 0 0))")
             (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
                                                             (* ; "initialise the offsets to 0")
             (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETOFFSET OFFSETS I 0))
                                                             (* ; 
                                                             "(AIN OFFSETS FIRSTCHAR NUMBCODES STRM)")
             (for I from FIRSTCHAR as J from 1 to NUMBCODES do (\FSETOFFSET OFFSETS I (\WIN STRM)))
             (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
             (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETWIDTH WIDTHS I 0))
                                                             (* ; 
     "(replace WIDTHS of (CHARSETINFO CSINFO) with (ARRAY (IPLUS \MAXCHAR 3) (QUOTE SMALLPOSP) 0 0))")
             (\FONTRESETCHARWIDTHS CSINFO FIRSTCHAR LASTCHAR)
             (replace (CHARSETINFO IMAGEWIDTHS) of CSINFO with (fetch (CHARSETINFO WIDTHS)
                                                                  of CSINFO))
             CSINFO))])

(\SFMAKEBOLD
  [LAMBDA (CSINFO)                                       (* gbn "25-Jul-85 04:52")
    (PROG* ((OLDCHARBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
            (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
            (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
            (HEIGHT (IPLUS (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                           (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)))
            NEWCHARBITMAP OFFSET UNKNOWNOFFSET UNKNOWNWIDTH)
           (SETQ NEWCHARBITMAP (BITMAPCREATE (fetch BITMAPWIDTH of OLDCHARBITMAP)
                                      (fetch BITMAPHEIGHT of OLDCHARBITMAP)))
           (SETQ UNKNOWNOFFSET (\FGETOFFSET OFFSETS (ADD1 \MAXCHAR)))
           (SETQ UNKNOWNWIDTH (\FGETWIDTH WIDTHS (ADD1 \MAXCHAR)))
           [for I from 0 to \MAXCHAR
              do (COND
                        ((EQ (SETQ OFFSET (\FGETOFFSET OFFSETS I))
                             UNKNOWNOFFSET)                  (* ; 
             "if this is the magic charcode with the slug image (charcode 256) then leave it alone")
                         NIL)
                        (T                                   (* ; 
                                                          "overlap two blts to produce bold effect")
                           (BITBLT OLDCHARBITMAP OFFSET 0 NEWCHARBITMAP OFFSET 0 (\FGETWIDTH WIDTHS I
                                                                                        )
                                  HEIGHT
                                  'INPUT
                                  'REPLACE)
                           (BITBLT OLDCHARBITMAP OFFSET 0 NEWCHARBITMAP (ADD1 OFFSET)
                                  0
                                  (SUB1 (\FGETWIDTH WIDTHS I))
                                  HEIGHT
                                  'INPUT
                                  'PAINT]                    (* ; 
                                                          "fill in the slug for the magic charcode")
           (BITBLT OLDCHARBITMAP UNKNOWNOFFSET 0 NEWCHARBITMAP UNKNOWNOFFSET 0 UNKNOWNWIDTH HEIGHT
                  'INPUT
                  'REPLACE)
           (RETURN (create CHARSETINFO using CSINFO CHARSETBITMAP _ NEWCHARBITMAP])

(\SFMAKEITALIC
  [LAMBDA (CSINFO)                                       (* gbn "18-Sep-85 17:57")
    (PROG ((WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
           (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
           (ASCENT (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
           (DESCENT (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
           (OLDBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
           HEIGHT OFFSET NEWBITMAP WIDTH UNKNOWNOFFSET UNKNOWNWIDTH N M R XN XX YN YX)
          (SETQ HEIGHT (IPLUS ASCENT DESCENT))
          (SETQ NEWBITMAP (BITMAPCREATE (fetch BITMAPWIDTH of OLDBITMAP)
                                 (fetch BITMAPHEIGHT of OLDBITMAP)))
          (SETQ UNKNOWNOFFSET (\FGETOFFSET OFFSETS (ADD1 \MAXTHINCHAR)))
          (SETQ UNKNOWNWIDTH (\FGETWIDTH WIDTHS (ADD1 \MAXTHINCHAR)))
          (SETQ N (IDIFFERENCE 0 (IQUOTIENT (IPLUS DESCENT 3)
                                        4)))
          (SETQ M (IQUOTIENT (IPLUS ASCENT 3)
                         4))
          [for I from 0 to \MAXTHINCHAR
             do (COND
                       ((EQ (SETQ OFFSET (\FGETOFFSET OFFSETS I))
                            UNKNOWNOFFSET)                   (* ; 
             "if this is the magic charcode with the slug image (charcode 256) then leave it alone")
                        NIL)
                       (T (SETQ WIDTH (\FGETWIDTH WIDTHS I))
                          (for J from N to M
                             do (SETQ R (IPLUS OFFSET WIDTH))
                                   (SETQ XN (IMIN R (IMAX (IPLUS OFFSET J)
                                                          0)))
                                   (SETQ XX (IMIN R (IMAX (IPLUS R J)
                                                          0)))
                                   [SETQ YN (IMAX 0 (IPLUS DESCENT (ITIMES J 4]
                                   [SETQ YX (IMIN HEIGHT (IPLUS DESCENT (IPLUS (ITIMES J 4)
                                                                               4]
                                   (COND
                                      ((AND (IGREATERP XX XN)
                                            (IGREATERP YX YN))
                                       (BITBLT OLDBITMAP OFFSET YN NEWBITMAP XN YN (IDIFFERENCE
                                                                                    XX XN)
                                              (IDIFFERENCE YX YN)
                                              'INPUT
                                              'REPLACE]
          (BITBLT OLDBITMAP UNKNOWNOFFSET 0 NEWBITMAP UNKNOWNOFFSET 0 UNKNOWNWIDTH HEIGHT
                 'INPUT
                 'REPLACE)
          (RETURN (create CHARSETINFO using CSINFO CHARSETBITMAP _ NEWBITMAP])

(\SFMAKEROTATEDFONT
  [LAMBDA (FONTDESC ROTATION)                            (* ; "Edited 30-Mar-87 20:35 by FS")

    (* ;; "takes a fontdecriptor and rotates it.")

    (* ;; "1/5/86 JDS.  Masterscope claims nobody calls this.  Let's find out....")

    (HELP "ROTATED fonts need to be fixed for NS Chars & New FONTDESCRIPTOR fields")
                                                             (* (create FONTDESCRIPTOR using 
                                                           FONTDESC (SETQ CHARACTERBITMAP
                                                           (\SFROTATEFONTCHARACTERS
                                                           (fetch (FONTDESCRIPTOR 
                                                           CHARACTERBITMAP) of FONTDESC) 
                                                           ROTATION)) (SETQ ROTATION ROTATION)
                                                           (SETQ \SFOffsets (
                                                           \SFFIXOFFSETSAFTERROTATION FONTDESC 
                                                           ROTATION)) (SETQ FONTCHARSETVECTOR
                                                           (\ALLOCBLOCK (ADD1 \MAXCHARSET) T))))

    (* ;; "If you uncomment out the code above, remove this comment and the NIL below")

    NIL])

(\SFROTATECSINFO
  [LAMBDA (CSINFO ROTATION)                              (* gbn "15-Sep-85 14:38")

    (* ;; "takes a CHARSETINFO and rotates it and produces a rotated equivalent one.")

    (create CHARSETINFO using CSINFO CHARSETBITMAP _ (\SFROTATEFONTCHARACTERS
                                                              (fetch (CHARSETINFO CHARSETBITMAP)
                                                                 of CSINFO)
                                                              ROTATION)
                                  OFFSETS _ (\SFROTATECSINFOOFFSETS CSINFO ROTATION])

(\SFROTATEFONTCHARACTERS
  [LAMBDA (CHARBITMAP ROTATION)                          (* ; "Edited 22-Sep-87 10:38 by Snow")

(* ;;; "rotate a bitmap either 90 or 270 for fonts.")

    (CASE ROTATION
        (0 CHARBITMAP)
        (90 (ROTATE-BITMAP-LEFT CHARBITMAP))
        (180 (ROTATE-BITMAP (ROTATE-BITMAP CHARBITMAP)))
        (270 (ROTATE-BITMAP CHARBITMAP)))])

(\SFFIXOFFSETSAFTERROTATION
  [LAMBDA (FONTDESC ROTATION)                            (* ; "Edited 30-Mar-87 20:35 by FS")

    (* ;; "adjusts offsets in case where rotation turned things around.")

    (HELP "NEED TO UPDATE THIS FN TO NSCHARS & NEW FONT FIELDS")
                                                             (* (COND ((EQ ROTATION 270)
                                                           (PROG ((OFFSETS (fetch
                                                           (FONTDESCRIPTOR \SFOffsets) of 
                                                           FONTDESC)) (WIDTHS
                                                           (fetch (FONTDESCRIPTOR \SFWidths) of 
                                                           FONTDESC)) (BITMAPHEIGHT
                                                           (BITMAPWIDTH (fetch
                                                           (FONTDESCRIPTOR CHARACTERBITMAP) of 
                                                           FONTDESC))) NEWOFFSETS)
                                                           (SETQ NEWOFFSETS (COPYARRAY OFFSETS))
                                                           (for CHARCODE from 0 to \MAXCHAR do
                                                           (SETA NEWOFFSETS CHARCODE
                                                           (IDIFFERENCE BITMAPHEIGHT
                                                           (IPLUS (ELT OFFSETS CHARCODE)
                                                           (ELT WIDTHS CHARCODE)))))
                                                           (* ; 
                                         "may be some problem with dummy character representation.")
                                                           (RETURN NEWOFFSETS)))
                                                           (T (fetch (FONTDESCRIPTOR \SFOffsets)
  of FONTDESC))))

    (* ;; "If you uncomment out the code above, remove this comment and the NIL below")

    NIL])

(\SFROTATECSINFOOFFSETS
  [LAMBDA (CSINFO ROTATION)                              (* gbn "15-Sep-85 14:36")
                                                             (* ; 
                                     "adjusts offsets in case where rotation turned things around.")
    (COND
       ((EQ ROTATION 270)
        (PROG ((OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
               (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
               (BITMAPHEIGHT (BITMAPWIDTH (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO)))
               NEWOFFSETS)
              (SETQ NEWOFFSETS (\CREATECSINFOELEMENT))
              [for CHARCODE from 0 to \MAXCHAR
                 do (\FSETOFFSET NEWOFFSETS CHARCODE (IDIFFERENCE BITMAPHEIGHT
                                                                (IPLUS (\FGETOFFSET OFFSETS CHARCODE)
                                                                       (\FGETWIDTH WIDTHS CHARCODE]
                                                             (* ; 
                                         "may be some problem with dummy character representation.")
              (RETURN NEWOFFSETS)))
       (T (fetch (CHARSETINFO OFFSETS) of CSINFO])

(\SFMAKECOLOR
  [LAMBDA (BWCSINFO BACKCOLOR FORECOLOR BITSPERPIXEL)    (* kbr%: " 6-Feb-86 18:17")

    (* ;; "makes a csinfo that has a character bitmap that is colorized.")

    (PROG (CHARACTERBITMAP COLORCSINFO)
          [COND
             ((IMAGESTREAMP BITSPERPIXEL)
              (OR BACKCOLOR (SETQ BACKCOLOR (DSPBACKCOLOR NIL BITSPERPIXEL)))
              (OR FORECOLOR (SETQ FORECOLOR (DSPCOLOR NIL BITSPERPIXEL)))
              (SETQ BITSPERPIXEL (IMAGESTREAMTYPE BITSPERPIXEL]
          [SETQ BITSPERPIXEL (COND
                                ((NUMBERP BITSPERPIXEL)
                                 BITSPERPIXEL)
                                (T (\DISPLAYSTREAMTYPEBPP BITSPERPIXEL]
          (SETQ BACKCOLOR (COLORNUMBERP BACKCOLOR BITSPERPIXEL))
          (SETQ FORECOLOR (COLORNUMBERP FORECOLOR BITSPERPIXEL))
          (SETQ CHARACTERBITMAP (COLORIZEBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of 
                                                                                             BWCSINFO
                                                       )
                                       BACKCOLOR FORECOLOR BITSPERPIXEL))
          (SETQ COLORCSINFO (create CHARSETINFO using BWCSINFO CHARSETBITMAP _ 
                                                          CHARACTERBITMAP))
          (RETURN COLORCSINFO])
)
(DEFINEQ

(WRITESTRIKEFONTFILE
  [LAMBDA (FONT CHARSET FILE)                                (* ; "Edited 22-May-2025 09:53 by rmk")
                                                             (* ; "Edited  1-Feb-2025 12:27 by mth")
                                                             (* ; "Edited 12-Jul-2022 14:36 by rmk")
                                                             (* kbr%: "21-Oct-85 15:08")
                                                             (* ; 
                                                           "Write strike FILE using info in FONT.  *")
    (CL:UNLESS (FONTP FONT)
           (LISPERROR "ILLEGAL ARG" FONT))
    (CL:UNLESS CHARSET (SETQ CHARSET 0))
    (CL:UNLESS (AND (IGEQ CHARSET 0)
                    (ILEQ CHARSET \MAXCHARSET))
           (LISPERROR "ILLEGAL ARG" CHARSET))
    (LET (STREAM CSINFO FIRSTCHAR LASTCHAR WIDTHS MAXWIDTH LENGTH RASTERWIDTH DUMMYCHAR DUMMYOFFSET 
                PREVIOUSOFFSET OFFSETS)
         (SETQ CSINFO (\INSURECHARSETINFO CHARSET FONT T))
         (CL:UNLESS CSINFO (ERROR "Couldn't find charset " CHARSET))
         (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
         (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
         (SETQ DUMMYOFFSET (\FGETOFFSET OFFSETS DUMMYINDEX))
         [SETQ FIRSTCHAR (for I from 0 to MAXCODE thereis (NOT (EQ (\FGETOFFSET OFFSETS I)
                                                                   DUMMYOFFSET]
         [SETQ LASTCHAR (for I from MAXCODE to 0 by -1 thereis (NOT (EQ (\FGETOFFSET OFFSETS I)
                                                                        DUMMYOFFSET]
         (SETQ DUMMYCHAR (ADD1 LASTCHAR))
         [SETQ STREAM (OPENSTREAM FILE 'OUTPUT 'NEW '((TYPE BINARY]
         (\WOUT STREAM 32768)                                (* ; "STRIKE HEADER.  *")
         (\WOUT STREAM FIRSTCHAR)
         (\WOUT STREAM LASTCHAR)
         (SETQ MAXWIDTH 0)
         [for I from 0 to DUMMYINDEX do (SETQ MAXWIDTH (IMAX MAXWIDTH (\FGETWIDTH WIDTHS I]
         (\WOUT STREAM MAXWIDTH)                             (* ; "STRIKE BODY.  *")
                                                             (* ; "Length.  *")
         (SETQ RASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of (fetch (CHARSETINFO CHARSETBITMAP)
                                                                   of CSINFO)))
         (SETQ LENGTH (IPLUS 8 (IDIFFERENCE LASTCHAR FIRSTCHAR)
                             (ITIMES (fetch (FONTDESCRIPTOR \SFHeight) of FONT)
                                    RASTERWIDTH)))
         (\WOUT STREAM LENGTH)                               (* ; 
                                      "Ascent, Descent, Xoffset (no longer used) and Rasterwidth.  *")
         (\WOUT STREAM (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
         (\WOUT STREAM (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
         (\WOUT STREAM 0)
         (\WOUT STREAM RASTERWIDTH)                          (* ; "Bitmap.  *")
         [\BOUTS STREAM (fetch (BITMAP BITMAPBASE) of (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
                0
                (ITIMES 2 RASTERWIDTH (IPLUS (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                             (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO]
                                                             (* ; "Offsets.  *")
         (for I WIDTH OFFSET (CODE _ 0) from FIRSTCHAR to DUMMYCHAR first (\WOUT STREAM CODE)
            do (SETQ OFFSET (\FGETOFFSET OFFSETS I))
               (SETQ WIDTH (\FGETWIDTH WIDTHS I))
               (CL:UNLESS (AND (IEQP OFFSET DUMMYOFFSET)
                               (NOT (IEQP I DUMMYCHAR)))
                      (ADD CODE WIDTH))
               (\WOUT STREAM CODE))
         (CLOSEF STREAM])

(STRIKECSINFO
  [LAMBDA (CSINFO)                                       (* ; "Edited 27-Apr-89 13:39 by atm")

    (* ;; "Returns a STRIKE type font descriptor (EQ WIDTHS IMAGEWIDTHS), cause we know how to write those guys out (they read quicker  but display slower).  If (EQ WIDTHS IMAGEWIDTHS), just return original.")

    (PROG (WIDTHS OFFSETS IMWIDTHS OLDBM BMWIDTH BMHEIGHT NEWBM NEWOFFSET NEWWIDTH OLDOFFSET 
                 DUMMYOFFSET NEWOFFSETS)
          (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
          (SETQ IMWIDTHS (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO))
          (if (EQ WIDTHS IMWIDTHS)
              then (RETURN CSINFO))
          (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
          (SETQ OLDBM (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
          (SETQ DUMMYOFFSET (\FGETOFFSET OFFSETS 256))
          (SETQ BMHEIGHT (BITMAPHEIGHT OLDBM))
          [SETQ BMWIDTH (for I from 0 to \MAXTHINCHAR
                           sum (if (IEQP DUMMYOFFSET (\FGETOFFSET OFFSETS I))
                                       then 0
                                     else (IMAX (\FGETIMAGEWIDTH IMWIDTHS I)
                                                    (\FGETWIDTH WIDTHS I]

     (* ;; "")

     (* ;; "Initialize new offsets vector")

     (* ;; "")

          (SETQ NEWOFFSETS (\CREATECSINFOELEMENT))
          (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETOFFSET NEWOFFSETS I 0))
          (\FSETOFFSET NEWOFFSETS (ADD1 \MAXTHINCHAR)
                 BMWIDTH)

     (* ;; "")

     (* ;; "Adjust bitmap with so width = imagewidth, fill offsets")

     (* ;; "")

          (SETQ NEWBM (BITMAPCREATE BMWIDTH BMHEIGHT 1))
          (SETQ NEWOFFSET 0)
          [for I from 0 to 255
             do (SETQ OLDOFFSET (\FGETOFFSET OFFSETS I))
                   (if (IEQP DUMMYOFFSET OLDOFFSET)
                       then (\FSETOFFSET NEWOFFSETS I BMWIDTH)
                     else (\FSETOFFSET NEWOFFSETS I NEWOFFSET)
                           (SETQ NEWWIDTH (IMAX (\FGETIMAGEWIDTH IMWIDTHS I)
                                                (\FGETWIDTH WIDTHS I)))
                           (BITBLT OLDBM OLDOFFSET 0 NEWBM NEWOFFSET 0 (\FGETWIDTH IMWIDTHS I)
                                  BMHEIGHT
                                  'REPLACE)
                           (SETQ NEWOFFSET (IPLUS NEWOFFSET NEWWIDTH]

     (* ;; "")

     (* ;; "Make new CSInfo record withs IMAGEWIDTHS, WIDTHS the same")

     (* ;; "")

          (SETQ WIDTHS (COPYALL WIDTHS))
          [for I from 0 to \MAXTHINCHAR do (\FSETWIDTH WIDTHS I
                                                                  (IMAX (\FGETWIDTH WIDTHS I)
                                                                        (\FGETIMAGEWIDTH IMWIDTHS I]
          (RETURN (create CHARSETINFO
                         WIDTHS _ WIDTHS
                         OFFSETS _ NEWOFFSETS
                         IMAGEWIDTHS _ WIDTHS
                         CHARSETBITMAP _ NEWBM
                         YWIDTHS _ (fetch (CHARSETINFO YWIDTHS) of CSINFO)
                         CHARSETASCENT _ (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                         CHARSETDESCENT _ (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO])
)
(DEFINEQ

(FONTDESCRIPTOR.DEFPRINT
  [LAMBDA (FONT STREAM)                                      (* ; "Edited 14-Dec-2024 09:13 by rmk")
    (LET ((LOC (LOC FONT))
          (FACE (fetch (FONTDESCRIPTOR FONTFACE) of FONT)))

         (* ;; "Could lowercase the family, but maybe too dangerous if a BREAK on L-CASE.")

         (* ;; "Somehow flag the device too?")

         (CONS (CONCAT "{" (fetch (FONTDESCRIPTOR FONTFAMILY) of FONT)
                      (fetch (FONTDESCRIPTOR FONTSIZE) of FONT)
                      "-"
                      (SELECTQ (fetch (FONTFACE WEIGHT) of FACE)
                          (MEDIUM 'M)
                          (BOLD 'B)
                          (fetch (FONTFACE WEIGHT) of FACE))
                      (SELECTQ (fetch (FONTFACE SLOPE) of FACE)
                          (ITALIC 'I)
                          (REGULAR 'R)
                          (fetch (FONTFACE SLOPE) of FACE))
                      (SELECTQ (fetch (FONTFACE EXPANSION) of FACE)
                          (REGULAR 'R)
                          (fetch (FONTFACE EXPANSION) of FACE))
                      "/"
                      (OCTALSTRING (CAR LOC))
                      ","
                      (OCTALSTRING (CDR LOC))
                      "}"])

(FONTCLASS.DEFPRINT
  [LAMBDA (FONTCLASS STREAM)                                 (* ; "Edited 14-Dec-2024 16:51 by rmk")
    (LET ((LOC (LOC FONTCLASS)))
         (CONS (CONCAT "{" (OR (fetch (FONTCLASS FONTCLASSNAME) of FONTCLASS)
                               'FONTCLASS)
                      "/"
                      (OCTALSTRING (CAR LOC))
                      ","
                      (OCTALSTRING (CDR LOC))
                      "}"])
)

(/DECLAREDATATYPE 'FONTCLASS '(BYTE POINTER POINTER POINTER POINTER POINTER)
       '((FONTCLASS 0 (BITS . 7))
         (FONTCLASS 2 POINTER)
         (FONTCLASS 4 POINTER)
         (FONTCLASS 6 POINTER)
         (FONTCLASS 8 POINTER)
         (FONTCLASS 10 POINTER))
       '12)

(DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))

(/DECLAREDATATYPE 'FONTDESCRIPTOR
       '(POINTER FLAG POINTER POINTER POINTER WORD WORD WORD WORD SIGNEDWORD SIGNEDWORD SIGNEDWORD 
               SIGNEDWORD POINTER POINTER POINTER POINTER POINTER (BITS 8)
               WORD POINTER POINTER FLAG POINTER)
       '((FONTDESCRIPTOR 0 POINTER)
         (FONTDESCRIPTOR 0 (FLAGBITS . 0))
         (FONTDESCRIPTOR 2 POINTER)
         (FONTDESCRIPTOR 4 POINTER)
         (FONTDESCRIPTOR 6 POINTER)
         (FONTDESCRIPTOR 8 (BITS . 15))
         (FONTDESCRIPTOR 9 (BITS . 15))
         (FONTDESCRIPTOR 10 (BITS . 15))
         (FONTDESCRIPTOR 11 (BITS . 15))
         (FONTDESCRIPTOR 12 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 13 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 14 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 15 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 16 POINTER)
         (FONTDESCRIPTOR 18 POINTER)
         (FONTDESCRIPTOR 20 POINTER)
         (FONTDESCRIPTOR 22 POINTER)
         (FONTDESCRIPTOR 24 POINTER)
         (FONTDESCRIPTOR 26 (BITS . 7))
         (FONTDESCRIPTOR 27 (BITS . 15))
         (FONTDESCRIPTOR 28 POINTER)
         (FONTDESCRIPTOR 30 POINTER)
         (FONTDESCRIPTOR 30 (FLAGBITS . 0))
         (FONTDESCRIPTOR 32 POINTER))
       '34)

(DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))

(/DECLAREDATATYPE 'CHARSETINFO '(POINTER FLAG FLAG POINTER POINTER POINTER POINTER WORD WORD POINTER
                                       POINTER)
       '((CHARSETINFO 0 POINTER)
         (CHARSETINFO 0 (FLAGBITS . 0))
         (CHARSETINFO 0 (FLAGBITS . 16))
         (CHARSETINFO 2 POINTER)
         (CHARSETINFO 4 POINTER)
         (CHARSETINFO 6 POINTER)
         (CHARSETINFO 8 POINTER)
         (CHARSETINFO 10 (BITS . 15))
         (CHARSETINFO 11 (BITS . 15))
         (CHARSETINFO 12 POINTER)
         (CHARSETINFO 14 POINTER))
       '16)
(ADDTOVAR SYSTEMRECLST

(DATATYPE FONTCLASS ((PRETTYFONT# BYTE)
                     DISPLAYFD PRESSFD INTERPRESSFD OTHERFDS FONTCLASSNAME))

(DATATYPE FONTDESCRIPTOR ((FONTDEVICE POINTER)
                          (FONTCOMPLETEP FLAG)
                          (FONTFAMILY POINTER)
                          (FONTSIZE POINTER)
                          (FONTFACE POINTER)
                          (\SFAscent WORD)
                          (\SFDescent WORD)
                          (\SFHeight WORD)
                          (ROTATION WORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL POINTER)
                          (NIL POINTER)
                          (FONTDEVICESPEC POINTER)
                          (OTHERDEVICEFONTPROPS POINTER)
                          (FONTSCALE POINTER)
                          (\SFFACECODE BITS 8)
                          (FONTAVGCHARWIDTH WORD)
                          (FONTCHARENCODING POINTER)
                          (FONTCHARSETVECTOR POINTER)
                          (FONTHASLEFTKERNS FLAG)
                          (FONTEXTRAFIELD2 POINTER)))

(DATATYPE CHARSETINFO (WIDTHS (CSSLUGP FLAG)
                             (CSCOMPLETEP FLAG)
                             OFFSETS IMAGEWIDTHS CHARSETBITMAP YWIDTHS (CHARSETASCENT WORD)
                             (CHARSETDESCENT WORD)
                             LEFTKERN CSINFOPROPS))
)

(RPAQ? \FONTSINCORE )

(RPAQ? \DEFAULTDEVICEFONTS )

(RPAQ? \UNITWIDTHSVECTOR )
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS DISPLAYFONTDIRECTORIES \DEFAULTDEVICEFONTS \UNITWIDTHSVECTOR)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(\UNITWIDTHSVECTOR)
)
(* "FOLLOWING DEFINITIONS EXPORTED")
(DEFOPTIMIZER FONTPROP (&REST ARGS)
                       (SELECTQ (AND (EQ (CAADR ARGS)
                                         'QUOTE)
                                     (CADADR ARGS))
                           (ASCENT (LIST 'FONTASCENT (CAR ARGS)))
                           (DESCENT (LIST 'FONTDESCENT (CAR ARGS)))
                           (HEIGHT (LIST 'FONTHEIGHT (CAR ARGS)))
                           'IGNOREMACRO))

(* "END EXPORTED DEFINITIONS")

(DECLARE%: DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE FONTCLASS ((PRETTYFONT# BYTE)
                     DISPLAYFD PRESSFD INTERPRESSFD OTHERFDS FONTCLASSNAME)
                    (INIT (DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))))

(DATATYPE FONTDESCRIPTOR ((FONTDEVICE POINTER)
                          (FONTCOMPLETEP FLAG)
                          (FONTFAMILY POINTER)
                          (FONTSIZE POINTER)
                          (FONTFACE POINTER)
                          (\SFAscent WORD)
                          (\SFDescent WORD)
                          (\SFHeight WORD)
                          (ROTATION WORD)
                          (NIL SIGNEDWORD)

                          (* ;; "Was FBBOX.  The fields are NIL'ed out now because they became irrelevant when multiple charsets were introduced.  They remain as a place-holder in the layout pending a recompile of all referring functions.")

                          (NIL SIGNEDWORD)                   (* ; "Was FBBOY")
                          (NIL SIGNEDWORD)                   (* ; "Was FBBDX")
                          (NIL SIGNEDWORD)                   (* ; "Was FBBDY")
                          (NIL POINTER)                      (* ; "Was \SFLKerns")
                          (NIL POINTER)                      (* ; "Was \SFRWidths")
                          (FONTDEVICESPEC POINTER)           (* ; 
        "Holds the spec by which the font is known to the printing device, if coercion has been done")
                          (OTHERDEVICEFONTPROPS POINTER)     (* ; 
                                                 "For individual devices to hang special information")
                          (FONTSCALE POINTER)
                          (\SFFACECODE BITS 8)
                          (FONTAVGCHARWIDTH WORD)            (* ; 
                            "Set in FONTCREATE, used to fix up the linelength when DSPFONT is called")
                          (FONTCHARENCODING POINTER)         (* ; "Was FONTIMAGEWIDTHS: This is the image width, as opposed to the advanced width;  initial hack for accents, kerning.  Fields is referenced by FONTCREATE.")
                          (FONTCHARSETVECTOR POINTER)        (* ; "A 257-pointer block, with one pointer per 'character set' --each group of 256 character codes.  Each pointer is either NIL if there's no info for that charset, or is a CHARSETINFO, containing widths, char bitmap, etc for the characters in that charset. The last cell if not NIL is the %"slug%" charsetinfo that can be shared as the dummy entry for otherwise NIL charsets")
                          (FONTHASLEFTKERNS FLAG)            (* ; 
                                        "T if at least one character set has an entry for left kerns")
                          (FONTEXTRAFIELD2 POINTER))
                         FONTCHARSETVECTOR _ (\CREATEFONTCHARSETVECTOR)
                         (INIT (DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))))

(RECORD FONTFACE (WEIGHT SLOPE EXPANSION)
                 [ACCESSFNS ((COLOR (CDDDR DATUM)
                                    (RPLACD (CDDR DATUM)
                                           NEWVALUE))
                             (BACKCOLOR [COND
                                           ((CDDDR DATUM)
                                            (CAR (CDDDR DATUM]
                                    (PROGN [COND
                                              ((NULL (CDDDR DATUM))
                                               (RPLACD (CDDR DATUM)
                                                      (LIST NIL NIL]
                                           (RPLACA (CDDDR DATUM)
                                                  NEWVALUE)))
                             (FORECOLOR [COND
                                           ((CDDDR DATUM)
                                            (CADR (CDDDR DATUM]
                                    (PROGN [COND
                                              ((NULL (CDDDR DATUM))
                                               (RPLACD (CDDR DATUM)
                                                      (LIST NIL NIL]
                                           (RPLACA (CDR (CDDDR DATUM))
                                                  NEWVALUE]
                 WEIGHT _ 'MEDIUM SLOPE _ 'REGULAR EXPANSION _ 'REGULAR (TYPE? LISTP))

(DATATYPE CHARSETINFO (WIDTHS                                (* ; "The advance-width of each character, an array indexed by charcode.  Usually the same as the imagewidth, but can differ for accents, kerns kerns.  This is what should be used for stringwidth calculations.")
                             (CSSLUGP FLAG)                  (* ; "True if this is a slug charset")
                             (CSCOMPLETEP FLAG)              (* ; 
    "True if there is no further data to fill in any remaining slug-characters in a non-slug charset")
                             OFFSETS                         (* ; 
                              "Offset of each character into the image bitmap;  X value of left edge")
                             IMAGEWIDTHS                     (* ; "imagewidths is not automagically allocated since it is not always needed.  But at least some times the IMAGEWIDTHS and WIDTHS vectors are EQ in this case.")
                             CHARSETBITMAP                   (* ; 
                                         "Bitmap containing the character images, indexed by OFFSETS")
                             YWIDTHS
                             (CHARSETASCENT WORD)            (* ; 
                                                      "Max ascent for all characters in this CHARSET")
                             (CHARSETDESCENT WORD)           (* ; 
                                                     "Max descent for all characters in this CHARSET")
                             LEFTKERN CSINFOPROPS            (* ; "Alist of extra properties"))
                      WIDTHS _ (\CREATECSINFOELEMENT)
                      OFFSETS _ (\CREATECSINFOELEMENT))
)

(/DECLAREDATATYPE 'FONTCLASS '(BYTE POINTER POINTER POINTER POINTER POINTER)
       '((FONTCLASS 0 (BITS . 7))
         (FONTCLASS 2 POINTER)
         (FONTCLASS 4 POINTER)
         (FONTCLASS 6 POINTER)
         (FONTCLASS 8 POINTER)
         (FONTCLASS 10 POINTER))
       '12)

(DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))

(/DECLAREDATATYPE 'FONTDESCRIPTOR
       '(POINTER FLAG POINTER POINTER POINTER WORD WORD WORD WORD SIGNEDWORD SIGNEDWORD SIGNEDWORD 
               SIGNEDWORD POINTER POINTER POINTER POINTER POINTER (BITS 8)
               WORD POINTER POINTER FLAG POINTER)
       '((FONTDESCRIPTOR 0 POINTER)
         (FONTDESCRIPTOR 0 (FLAGBITS . 0))
         (FONTDESCRIPTOR 2 POINTER)
         (FONTDESCRIPTOR 4 POINTER)
         (FONTDESCRIPTOR 6 POINTER)
         (FONTDESCRIPTOR 8 (BITS . 15))
         (FONTDESCRIPTOR 9 (BITS . 15))
         (FONTDESCRIPTOR 10 (BITS . 15))
         (FONTDESCRIPTOR 11 (BITS . 15))
         (FONTDESCRIPTOR 12 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 13 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 14 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 15 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 16 POINTER)
         (FONTDESCRIPTOR 18 POINTER)
         (FONTDESCRIPTOR 20 POINTER)
         (FONTDESCRIPTOR 22 POINTER)
         (FONTDESCRIPTOR 24 POINTER)
         (FONTDESCRIPTOR 26 (BITS . 7))
         (FONTDESCRIPTOR 27 (BITS . 15))
         (FONTDESCRIPTOR 28 POINTER)
         (FONTDESCRIPTOR 30 POINTER)
         (FONTDESCRIPTOR 30 (FLAGBITS . 0))
         (FONTDESCRIPTOR 32 POINTER))
       '34)

(DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))

(/DECLAREDATATYPE 'CHARSETINFO '(POINTER FLAG FLAG POINTER POINTER POINTER POINTER WORD WORD POINTER
                                       POINTER)
       '((CHARSETINFO 0 POINTER)
         (CHARSETINFO 0 (FLAGBITS . 0))
         (CHARSETINFO 0 (FLAGBITS . 16))
         (CHARSETINFO 2 POINTER)
         (CHARSETINFO 4 POINTER)
         (CHARSETINFO 6 POINTER)
         (CHARSETINFO 8 POINTER)
         (CHARSETINFO 10 (BITS . 15))
         (CHARSETINFO 11 (BITS . 15))
         (CHARSETINFO 12 POINTER)
         (CHARSETINFO 14 POINTER))
       '16)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS FONTASCENT MACRO ((FONTSPEC)
                            (ffetch \SFAscent of (\GETFONTDESC FONTSPEC))))

(PUTPROPS FONTDESCENT MACRO ((FONTSPEC)
                             (ffetch \SFDescent of (\GETFONTDESC FONTSPEC))))

(PUTPROPS FONTHEIGHT MACRO ((FONTSPEC)
                            (ffetch \SFHeight of (\GETFONTDESC FONTSPEC))))

(PUTPROPS \FGETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE)
                              (\GETBASE OFFSETSBLOCK CHAR8CODE)))

(PUTPROPS \FSETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE OFFSET)
                              (\PUTBASE OFFSETSBLOCK CHAR8CODE OFFSET)))

(PUTPROPS \FGETWIDTH DMACRO ((WIDTHSBLOCK CHAR8CODE)
                             (\GETBASE WIDTHSBLOCK CHAR8CODE)))

(PUTPROPS \FSETWIDTH DMACRO ((WIDTHSBLOCK CHAR8CODE VAL)
                             (\PUTBASE WIDTHSBLOCK CHAR8CODE VAL)))

(PUTPROPS \FGETCHARWIDTH MACRO (OPENLAMBDA (FONTDESC CHARCODE)
                                 (\FGETWIDTH (ffetch (CHARSETINFO WIDTHS) of (\INSURECHARSETINFO
                                                                              (\CHARSET CHARCODE)
                                                                              FONTDESC))
                                        (\CHAR8CODE CHARCODE))))

(PUTPROPS \FSETCHARWIDTH MACRO (OPENLAMBDA (FONTDESC CHARCODE WIDTH)
                                 (\FSETWIDTH (ffetch (CHARSETINFO WIDTHS) of (\INSURECHARSETINFO
                                                                              (\CHARSET CHARCODE)
                                                                              FONTDESC))
                                        (\CHAR8CODE CHARCODE)
                                        WIDTH)))

(PUTPROPS \FGETIMAGEWIDTH MACRO ((IMAGEWIDTHSBLOCK CHAR8CODE)
                                 (\GETBASE IMAGEWIDTHSBLOCK CHAR8CODE)))

(PUTPROPS \FSETIMAGEWIDTH DMACRO ((WIDTHSBLOCK INDEX WIDTH)
                                  (\PUTBASE WIDTHSBLOCK INDEX WIDTH)))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \XGETCHARSETINFO MACRO ((FONTDESC CHARSET)

                                  (* ;; 
                 "Temporary until other callers of \GETCHARSETINFO are changes to \INSURECHARSETINFO")

                                  (* ;; 
                          "Fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  ")

                                  (* ;; 
       "NOTE Current \GETCHARSETINFO takes the vector, not the font, as does current \SETCHARSETINFO")

                                  (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                         (UNFOLD CHARSET 2))))

(PUTPROPS \GETCHARSETINFO MACRO [(CHARSET FONTDESC)

                                 (* ;; "fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  If NIL, then creates the required charset, maybe a slug (with CSSLUGP T).")

                                 (OR (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                            (UNFOLD CHARSET 2))
                                     (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                                            CHARSET
                                            (\CREATECHARSET CHARSET FONTDESC])

(PUTPROPS \INSURECHARSETINFO MACRO [(CHARSET FONTDESC)

                                 (* ;; "fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  If NIL, then creates the required charset, maybe a slug (with CSSLUGP T).")

                                    (OR (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                               (UNFOLD CHARSET 2))
                                        (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                                               CHARSET
                                               (\CREATECHARSET CHARSET FONTDESC])

(PUTPROPS \CREATECSINFOELEMENT MACRO (NIL (\ALLOCBLOCK (FOLDHI (IPLUS \MAXTHINCHAR 3)
                                                              WORDSPERCELL))))

(PUTPROPS \CREATEFONTCHARSETVECTOR MACRO (NIL 

                                            (* ;; "Allocates a block for the character set records, including one extra slot to hold the common slug charsetinfo")

                                              (\ALLOCBLOCK (IPLUS 2 \MAXCHARSET)
                                                     T)))
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ \MAXNSCHAR 65535)


(CONSTANTS (\MAXNSCHAR 65535))
)

(* "END EXPORTED DEFINITIONS")

)
(DEFINEQ

(\CREATEKERNELEMENT
  [LAMBDA NIL                                                (* ; "Edited 17-May-2025 09:36 by rmk")

    (* ;; "This is bogus, see \FGETLEFTKERN.  But whatever is here will be preserved if written out in a Medley format fontfile")

    (CL:MAKE-ARRAY (IPLUS \MAXTHINCHAR 3)
           :ELEMENT-TYPE
           '(SIGNED-BYTE 16)
           :INITIAL-ELEMENT 0])

(\FSETLEFTKERN
  [LAMBDA (LEFTKERNBLOCK INDEX KERNVALUE)                    (* ; "Edited 17-May-2025 09:18 by rmk")
    (CL:SETF (CL:AREF LEFTKERNBLOCK INDEX)
           KERNVALUE])

(\FGETLEFTKERN
  [LAMBDA (FONT PREVCHARCODE CHARCODE)                       (* ; "Edited 22-May-2025 09:53 by rmk")
                                                             (* ; "Edited 18-May-2025 21:30 by rmk")
                                                             (* ; "Edited  1-May-2025 11:08 by rmk")
                                                             (* ; "Edited 19-Dec-2024 15:25 by rmk")

    (* ;; "Returns the kern information for CHARCODE in FONT, given that it is an immediate successor of PREVCHARCODE.  Returns 0 if no PREVCHARCODE/CHARCODE kerning is specified.  For now, assume that the kerning information is sparse for characters within a character set, stored as a 2-level alist.  ")

    (* ;; "If the kerning information for a character is already a FIXP, then it is an offset no matter what the preceding character might be.  This appears to be the way at least AC font files are set up.")

    (OR [AND (fetch (FONTDESCRIPTOR FONTHASLEFTKERNS) of FONT)
             (LET [(CHARKERNS (CDR (FASSOC (\CHAR8CODE CHARCODE)
                                          (fetch (CHARSETINFO LEFTKERN) of (\INSURECHARSETINFO
                                                                            (\CHARSET CHARCODE)
                                                                            FONT]
                  (OR (FIXP CHARKERNS)
                      (CDR (FASSOC PREVCHARCODE CHARKERNS]
        0])
)
(DEFINEQ

(\CREATEFONT
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 20-May-2025 21:10 by rmk")

    (* ;; "Generic font creation.  Uses fontcreate method from device, build a fontdescriptor but doesn't call SETFONTDESCRIPTOR to install it.")

    (* ;; "\DEFAULTCHARSET is kind of foolish, since \AVGCHARWIDTH wants the width of A=0,101 and therefore forces charset 0.   (A may be some random character in Symbol, Math, but...).")

    (DECLARE (GLOBALVARS \DEFAULTCHARSET))
    (CL:UNLESS DEVICE
        (SETQ DEVICE 'DISPLAY))
    (LET (FN FONT)
         (CL:WHEN [AND [SETQ FN (CADR (ASSOC 'FONTCREATE (CDR (ASSOC DEVICE IMAGESTREAMTYPES]
                       (SETQ FONT (APPLY* FN (\FONTSYMBOL FAMILY)
                                         SIZE
                                         (\FONTFACE FACE)
                                         (OR ROTATION 0)
                                         DEVICE
                                         (OR CHARSET \DEFAULTCHARSET]
             (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONT with (\AVGCHARWIDTH FONT))
             FONT)])

(\CREATECHARSET
  [LAMBDA (CHARSET FONT NOSLUG?)                             (* ; "Edited  9-Jun-2025 17:55 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:10 by rmk")
                                                             (* ; "Edited 18-May-2025 21:40 by rmk")
                                                             (* ; "Edited 16-May-2025 21:37 by rmk")
                                                             (* ; "Edited 12-Jul-2022 14:37 by rmk")
                                                             (* ; "Edited  8-May-93 23:42 by rmk:")
                                                             (* ; "Edited  4-Dec-92 11:43 by jds")

    (* ;; "Creates and returns the CHARSETINFO for charset CHARSET in fontdesc FONT, installing it in fonts FONTCHARSETVECTOR")
                                                             (* ; 
    "NOSLUG?  means don't create an empty (slug) csinfo if the charset is not found, just return NIL")
    (DECLARE (GLOBALVARS \DISPLAYSTREAMTYPES))
    (CL:WHEN (OR (ILESSP CHARSET 0)
                 (IGREATERP CHARSET \MAXCHARSET))
           (\ILLEGAL.ARG CHARSET))
    (LET* [[CREATEFN (CADR (ASSOC 'CREATECHARSET (CDR (ASSOC (FONTPROP FONT 'DEVICE)
                                                             IMAGESTREAMTYPES]
           (CSINFO (APPLY CREATEFN (APPEND (FONTPROP FONT 'DEVICESPEC)
                                          (LIST CHARSET FONT NOSLUG?]

          (* ;; "Create a descriptor of info for that charset. If we got one, the subfunction may have ignored NOSLUG?.  But if not, we store it in the vector so that we don't search later.  But we don't return a slug.  ")

          (CL:WHEN CSINFO
              (\INSTALLCHARSETINFO FONT CSINFO CHARSET)
              (CL:UNLESS (fetch (CHARSETINFO CSSLUGP) of CSINFO)
                     CSINFO))])

(\INSTALLCHARSETINFO
  [LAMBDA (FONT CSINFO CHARSET)                              (* ; "Edited 25-May-2025 07:48 by rmk")
                                                             (* ; "Edited 23-May-2025 14:44 by rmk")
                                                             (* ; "Edited 12-Jul-2022 15:08 by rmk")
    (replace \SFAscent of FONT with (IMAX (fetch \SFAscent of FONT)
                                          (SIGNED (fetch CHARSETASCENT of CSINFO)
                                                 16)))
    (replace (FONTDESCRIPTOR \SFDescent) of FONT with (IMAX (fetch (FONTDESCRIPTOR \SFDescent)
                                                               of FONT)
                                                            (SIGNED (fetch (CHARSETINFO 
                                                                                  CHARSETDESCENT)
                                                                       of CSINFO)
                                                                   16)))
                                                             (* ; 
                                "jtm: height = ascent + descent, not (IMAX fontHeight charSetHeight)")
    (replace (FONTDESCRIPTOR \SFHeight) of FONT with (IPLUS (fetch (FONTDESCRIPTOR \SFAscent)
                                                               of FONT)
                                                            (ffetch (FONTDESCRIPTOR \SFDescent)
                                                               of FONT)))
    (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR) of FONT)
           CHARSET CSINFO)

    (* ;; "\AVGCHARWIDTH has to be confused after the CSINFO is stuck in.")

    (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONT with (\AVGCHARWIDTH FONT))
    (\INSTALLCHARSETINFO.CHARENCODING FONT CSINFO CHARSET)
    CSINFO])

(\INSTALLCHARSETINFO.CHARENCODING
  [LAMBDA (FONT CSINFO CHARSET)                              (* ; "Edited 25-May-2025 23:05 by rmk")
                                                             (* ; "Edited 24-May-2025 21:42 by rmk")
    (CL:UNLESS (fetch (CHARSETINFO CSSLUGP) of CSINFO)
        (LET [(FONTCHARENCODING (fetch (FONTDESCRIPTOR FONTCHARENCODING) of FONT))
              (CSCHARENCODING (CDR (ASSOC 'CSCHARENCODING (fetch (CHARSETINFO CSINFOPROPS)
                                                             of CSINFO]
             (if (EQ FONTCHARENCODING CSCHARENCODING)
               elseif FONTCHARENCODING
                 then (CL:WHEN NIL
                          CSCHARENCODING
                          (ERROR (CONCAT "The character encoding for character set " CHARSET 
                                        " does not match the font's encoding")
                                 (LIST FONT CSINFO)))
                      (change (fetch (CHARSETINFO CSINFOPROPS) of CSINFO)
                             (CONS (CONS 'CSCHARENCODING FONTCHARENCODING)
                                   DATUM))
               else (replace (FONTDESCRIPTOR FONTCHARENCODING) of FONT with CSCHARENCODING))))])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS DISPLAYFONTCOERCIONS DISPLAYCHARSETCOERCIONS)
)

(RPAQ? DISPLAYFONTCOERCIONS NIL)

(RPAQ? DISPLAYCHARSETCOERCIONS '(((GACHA)
                                  (TERMINAL))
                                 ((MODERN)
                                  (CLASSIC))
                                 ((TIMESROMAN)
                                  (CLASSIC))
                                 ((HELVETICA)
                                  (MODERN))
                                 ((TERMINAL)
                                  (MODERN))))

(RPAQ? \DEFAULTCHARSET 0)
(DEFINEQ

(\FONTRESETCHARWIDTHS
  [LAMBDA (CSINFO FIRSTCHAR LASTCHAR)                    (* AJB " 6-Dec-85 14:42")
                                                             (* ; 
                                                     "sets the widths array from the offsets array")
    (PROG ((mincharcode FIRSTCHAR)
           (maxcharcode LASTCHAR)
           (offsets (fetch (CHARSETINFO OFFSETS) of CSINFO))
           (widths (fetch (CHARSETINFO WIDTHS) of CSINFO))
           left right charoffset dummycharoffset dummycharwidth)
          (SETQ dummycharoffset (\FGETOFFSET offsets (ADD1 maxcharcode)))
          (SETQ dummycharwidth (IDIFFERENCE (\FGETOFFSET offsets (IPLUS maxcharcode 2))
                                      dummycharoffset))
          [for charcode from 0 to \MAXCHAR
             do (COND
                       ((OR (ILESSP charcode mincharcode)
                            (IGREATERP charcode maxcharcode))
                        (\FSETOFFSET offsets charcode dummycharoffset)
                        (\FSETWIDTH widths charcode dummycharwidth))
                       (T (SETQ left (\FGETWIDTH offsets charcode))
                          (SETQ right (\FGETWIDTH offsets (ADD1 charcode)))
                          (COND
                             ((EQ left right)
                              (\FSETOFFSET offsets charcode dummycharoffset)
                              (\FSETWIDTH widths charcode dummycharwidth))
                             (T (\FSETWIDTH widths charcode (IDIFFERENCE right left]
          (\FSETWIDTH widths (ADD1 \MAXCHAR)
                 dummycharwidth)
          (\FSETOFFSET offsets (ADD1 \MAXCHAR)
                 dummycharoffset])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS DISPLAYCHARSETFNS)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(RPAQ? DISPLAYFONTDIRECTORIES NIL)


(RPAQQ DISPLAYCHARSETFNS ((MEDLEYFONT MEDLEYFONT.FILEP MEDLEYFONT.GETCHARSET)
                          (AC ACFONT.FILEP ACFONT.GETCHARSET)
                          (STRIKE STRIKEFONT.FILEP \READSTRIKEFONTFILE)))
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(ADDTOVAR DISPLAYFONTEXTENSIONS MEDLEYDISPLAYFONT DISPLAYFONT STRIKE)
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ MAXCODE 255)

(RPAQQ DUMMYINDEX 256)


(CONSTANTS (MAXCODE 255)
       (DUMMYINDEX 256))
)
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \FGETCHARIMAGEWIDTH MACRO (OPENLAMBDA (FONT CHARCODE)
                                      (\FGETWIDTH (ffetch (CHARSETINFO IMAGEWIDTHS)
                                                     of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                               FONT))
                                             (\CHAR8CODE CHARCODE))))

(PROGN (PUTPROPS \GETFONTDESC DMACRO [X (COND
                                           ((CDR X)
                                            (CONS '\COERCEFONTDESC X))
                                           (T `(\DTEST ,(CAR X)
                                                      'FONTDESCRIPTOR])
       (PUTPROPS \GETFONTDESC MACRO (= . \COERCEFONTDESC)))

(PUTPROPS \SETCHARSETINFO MACRO ((CHARSETVECTOR CHARSET CSINFO)
                                 (\RPLPTR CHARSETVECTOR (UNFOLD CHARSET 2)
                                        CSINFO)))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)

(PUTPROPS FONT FILETYPE :FAKE-COMPILE-FILE)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA FONTCOPY)
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (8030 17476 (CHARWIDTH 8040 . 8825) (CHARWIDTHY 8827 . 10300) (STRINGWIDTH 10302 . 11395
) (\CHARWIDTH.DISPLAY 11397 . 11810) (\STRINGWIDTH.DISPLAY 11812 . 12236) (\STRINGWIDTH.GENERIC 12238
 . 17474)) (17477 23859 (DEFAULTFONT 17487 . 19320) (FONTCLASS 19322 . 21484) (FONTCLASSUNPARSE 21486
 . 22385) (FONTCLASSCOMPONENT 22387 . 22896) (SETFONTCLASSCOMPONENT 22898 . 23857)) (24712 42324 (
FONTCREATE 24722 . 34079) (COMPLETEFONT 34081 . 35376) (COMPLETEFONTP 35378 . 35893) (COMPLETECHARSET 
35895 . 36680) (\COMPLETECHARSET.CSINFO 36682 . 38257) (PRUNEFONTSLUGS 38259 . 38869) (
\FONT.SYMBOLMEMB 38871 . 39101) (\FONT.SYMBOLASSOC 39103 . 40261) (\FONT.COMPARESYMBOL 40263 . 42322))
 (42363 48199 (FONTASCENT 42373 . 42541) (FONTDESCENT 42543 . 42812) (FONTHEIGHT 42814 . 43000) (
FONTPROP 43002 . 47585) (\AVGCHARWIDTH 47587 . 48197)) (48246 48687 (EDITCHAR 48256 . 48685)) (48733 
60299 (GETCHARBITMAP 48743 . 49565) (PUTCHARBITMAP 49567 . 51644) (\GETCHARBITMAP.CSINFO 51646 . 53553
) (\PUTCHARBITMAP.CSINFO 53555 . 60297)) (60300 71961 (MOVECHARBITMAP 60310 . 61986) (MOVEFONTCHARS 
61988 . 66498) (\MOVEFONTCHAR 66500 . 69871) (SLUGCHARP.DISPLAY 69873 . 70771) (\GETFONTCHARINFO 70773
 . 71959)) (72237 90137 (FONTFILES 72247 . 73058) (\FINDFONTFILE 73060 . 74777) (\FONTFILENAMES 74779
 . 75653) (\FONTFILENAME 75655 . 79530) (\FONTFILENAME.OLD 79532 . 82481) (\FONTFILENAME.NEW 82483 . 
84740) (\FONTINFOFROMFILENAME 84742 . 87856) (\FONTINFOFROMFILENAME.OLD 87858 . 90135)) (90404 159617 
(FONTCOPY 90414 . 95722) (FONTSAVAILABLE 95724 . 100929) (FONTFILEFORMAT 100931 . 101520) (FONTP 
101522 . 101821) (FONTUNPARSE 101823 . 104387) (SETFONTDESCRIPTOR 104389 . 106098) (CHARCODEP 106100
 . 106461) (\STREAMCHARWIDTH 106463 . 110627) (\UNITWIDTHSVECTOR 110629 . 110992) (\CREATEDISPLAYFONT 
110994 . 112427) (\CREATECHARSET.DISPLAY 112429 . 116740) (\COERCECHARSET 116742 . 119817) (
\CREATE-REAL-CHARSET.DISPLAY 119819 . 123498) (\BUILDSLUGCSINFO 123500 . 125165) (
\SEARCHDISPLAYFONTFILES 125167 . 126100) (\SEARCHFONTFILES 126102 . 129185) (\FONTSYMBOL 129187 . 
129837) (\DEVICESYMBOL 129839 . 130708) (\FONTFACE 130710 . 137900) (\FONTFACE.COLOR 137902 . 144822) 
(\GETFONTDESC 144824 . 145215) (\COERCEFONTDESC 145217 . 150602) (\LOOKUPFONT 150604 . 151948) (
\LOOKUPFONTSINCORE 151950 . 154023) (\READDISPLAYFONTFILE 154025 . 158672) (SETFONTCHARENCODING 158674
 . 159615)) (159618 161404 (ACFONT.FILEP 159628 . 160512) (STRIKEFONT.FILEP 160514 . 161402)) (161493 
178797 (\READSTRIKEFONTFILE 161503 . 166285) (\SFMAKEBOLD 166287 . 168683) (\SFMAKEITALIC 168685 . 
171588) (\SFMAKEROTATEDFONT 171590 . 172991) (\SFROTATECSINFO 172993 . 173630) (
\SFROTATEFONTCHARACTERS 173632 . 174012) (\SFFIXOFFSETSAFTERROTATION 174014 . 176153) (
\SFROTATECSINFOOFFSETS 176155 . 177424) (\SFMAKECOLOR 177426 . 178795)) (178798 186272 (
WRITESTRIKEFONTFILE 178808 . 182812) (STRIKECSINFO 182814 . 186270)) (186273 188112 (
FONTDESCRIPTOR.DEFPRINT 186283 . 187634) (FONTCLASS.DEFPRINT 187636 . 188110)) (205968 208079 (
\CREATEKERNELEMENT 205978 . 206374) (\FSETLEFTKERN 206376 . 206569) (\FGETLEFTKERN 206571 . 208077)) (
208080 214589 (\CREATEFONT 208090 . 209255) (\CREATECHARSET 209257 . 211252) (\INSTALLCHARSETINFO 
211254 . 213280) (\INSTALLCHARSETINFO.CHARENCODING 213282 . 214587)) (215209 216961 (
\FONTRESETCHARWIDTHS 215219 . 216959)))))
STOP
