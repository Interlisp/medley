(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "27-Jul-2025 13:39:57" 
{DSK}<Users>kaplan>Local>medley3.5>working-medley>sources>FONT.;375 239724 

      :EDIT-BY rmk

      :CHANGES-TO (FNS \FONT.CHECKARGS \FONT.CHECKARGS1 \COERCEFONTDESC)
                  (MACROS FONTASCENT FONTDESCENT FONTHEIGHT)

      :PREVIOUS-DATE "25-Jul-2025 21:38:56" {WMEDLEY}<sources>FONT.;372)


(PRETTYCOMPRINT FONTCOMS)

(RPAQQ FONTCOMS
       [
        (* ;; "font functions ")

        (DECLARE%: EVAL@COMPILE DONTCOPY                     (* ; 
                                  "Can't be loaded/not needed during INIT, load at end of LOAD-LISP.")
               (FILES (SYSLOAD)
                      MULTI-ALIST))
        (FNS CHARWIDTH CHARWIDTHY STRINGWIDTH \CHARWIDTH.DISPLAY \STRINGWIDTH.DISPLAY 
             \STRINGWIDTH.GENERIC)
        (COMS (FNS DEFAULTFONT FONTCLASS FONTCLASSUNPARSE FONTCLASSCOMPONENT SETFONTCLASSCOMPONENT 
                   GETFONTCLASSCOMPONENT)
              (MACROS \GETFONTCLASSCOMPONENT \SETFONTCLASSCOMPONENT))
        (VARS NSFONTFAMILIES ALTOFONTFAMILIES)
        (COMS 
              (* ;; "Creation: ")

              (FNS FONTCREATE FONTCREATE1 FONTCREATE.SLUGFD \FONT.CHECKARGS \FONT.CHECKARGS1 
                   \FONTCREATE1.NOFN FONTFILEP \READCHARSET \COERCEFONTSPEC)
              (FNS \COERCEFONTDESC)
              (MACROS SPREADFONTSPEC)
              (FNS COMPLETE.FONT COMPLETEFONTP COMPLETE.CHARSET PRUNEFONTSLUGS))
        (COMS 
              (* ;; "Property extraction:")

              (FNS FONTASCENT FONTDESCENT FONTHEIGHT FONTPROP \AVGCHARWIDTH))
        (COMS 
              (* ;; "Moving character information")

              (FNS EDITCHAR)
                                                             (* ; "Should this be on EDITFONT ?")
              (FNS GETCHARBITMAP PUTCHARBITMAP \GETCHARBITMAP.CSINFO \PUTCHARBITMAP.CSINFO)
              (FNS MOVECHARBITMAP MOVEFONTCHARS \MOVEFONTCHAR SLUGCHARP.DISPLAY \GETCHARINFO)
              (MACROS UPDATEINFOELEMENT))
        (COMS 
              (* ;; "\FINDFONTFILE \FONTFILENAME \SEARCHFONTFILES \FONTINFOFROMFILENAME are redefined to deal with character-set directories.  That behavior is conditioned on the setting of the global variable *USEOLDFONTDIRECTORIES*, T at PARC, maybe NIL most other places.  ")

              (FNS FONTFILES \FINDFONTFILE \FONTFILENAMES \FONTFILENAME \FONTFILENAME.OLD 
                   \FONTFILENAME.NEW \FONTINFOFROMFILENAME \FONTINFOFROMFILENAME.OLD)
              (*                                             (* ; "Do we still want old fonts?")
                 (ADDVARS (*OLD-FONT-EXTENSIONS* STRIKE)))
              (INITVARS (*OLD-FONT-EXTENSIONS* NIL))
              (INITVARS (*USEOLDFONTDIRECTORIES* NIL))
              (GLOBALVARS *OLD-FONT-EXTENSIONS* *USEOLDFONTDIRECTORIES*))
        (FNS FONTCOPY FONTP FONTUNPARSE SETFONTDESCRIPTOR \STREAMCHARWIDTH \UNITWIDTHSVECTOR 
             \COERCECHARSET \BUILDSLUGCSINFO \FONTSYMBOL \DEVICESYMBOL \FONTFACE \FONTFACE.COLOR 
             SETFONTCHARENCODING)
        (FNS FONTSAVAILABLE FONTEXISTS? \FONTSAVAILABLE.INCORE \SEARCHFONTFILES FLUSHFONTSINCORE 
             MATCHFONTFACE FINDFONTFILES)
        (INITVARS \FONTEXISTS?-CACHE)
        (COMS                                                (* ; 
                                                            "Functions for DISPLAY IMAGESTREAMTYPES ")
              (FNS \CREATEDISPLAYFONT \CREATECHARSET.DISPLAY \FONTEXISTS?.DISPLAY))
        (FNS STRIKEFONT.FILEP STRIKEFONT.GETCHARSET WRITESTRIKEFONTFILE STRIKECSINFO)
        (COMS                                                (* ; "Bitmap faking")
              (FNS MAKEBOLD.CHARSET MAKEBOLD.CHAR MAKEITALIC.CHARSET MAKEITALIC.CHAR \SFMAKEBOLD 
                   \SFMAKEITALIC)
              (FNS \SFMAKEROTATEDFONT \SFROTATECSINFO \SFROTATEFONTCHARACTERS \SFROTATECSINFOOFFSETS)
              (FNS \SFMAKECOLOR))
        (FNS FONTDESCRIPTOR.DEFPRINT FONTCLASS.DEFPRINT)
        (INITRECORDS FONTCLASS FONTDESCRIPTOR CHARSETINFO)
        (SYSRECORDS FONTCLASS FONTDESCRIPTOR CHARSETINFO)
        (INITVARS (\FONTSINCORE)
               (\DEFAULTDEVICEFONTS)
               (\UNITWIDTHSVECTOR))
        (GLOBALVARS \DEFAULTDEVICEFONTS \UNITWIDTHSVECTOR)
        (DECLARE%: DONTEVAL@LOAD DOCOPY (P (\UNITWIDTHSVECTOR)))
        (EXPORT (OPTIMIZERS FONTPROP))
        (DECLARE%: DONTCOPY (EXPORT (RECORDS FONTCLASS FONTDESCRIPTOR FONTFACE CHARSETINFO)
                                   (MACROS FONTASCENT FONTDESCENT FONTHEIGHT \FGETOFFSET \FSETOFFSET
                                          \FGETWIDTH \FSETWIDTH \FGETCHARWIDTH \FSETCHARWIDTH 
                                          \FGETIMAGEWIDTH \FSETIMAGEWIDTH)
                                   (MACROS \XGETCHARSETINFO \GETCHARSETINFO \INSURECHARSETINFO 
                                          \CREATECSINFOELEMENT \CREATEFONTCHARSETVECTOR CHARSETPROP)
                                   (CONSTANTS (\MAXNSCHAR 65535)))
               (MACROS INDIRECTCHARSETP MAKECSSOURCE))
        (FNS \CREATEKERNELEMENT \FSETLEFTKERN \FGETLEFTKERN)
        [COMS (FNS \CREATEFONT \CREATECHARSET \INSTALLCHARSETINFO \INSTALLCHARSETINFO.CHARENCODING)
              (EXPORT (GLOBALVARS DISPLAYFONTDIRECTORIES DISPLAYFONTEXTENSIONS DISPLAYGLYPHCOERCIONS
                             DISPLAYFONTCOERCIONS))
              
              (* ;; "Removed ((CLASSIC 36) (CLASSIC 24)) so that TIMESROMAN 36 BOLD boldifies rather than coercing to CLASSIC 24 BOLD.")

              (INITVARS [DISPLAYFONTCOERCIONS '(((HELVETICA 1)
                                                 (HELVETICA 4))
                                                ((HELVETICA 2)
                                                 (HELVETICA 4))
                                                ((MODERN 60)
                                                 (MODERN 48))
                                                ((MODERN 96)
                                                 (MODERN 72))
                                                ((MODERN 120)
                                                 (MODERN 72))
                                                ((PALATINO 9)
                                                 (PALATINO 12))
                                                ((PALATINO 8)
                                                 (PALATINO 10))
                                                ((PALATINO 6)
                                                 (PALATINO 10))
                                                ((TITAN 6)
                                                 (TITAN 10))
                                                ((TITAN 9 (TITAN 10)))
                                                ((LPT)
                                                 (AMTEX]
                     [DISPLAYGLYPHCOERCIONS '(((GACHA)
                                               (TERMINAL))
                                              ((MODERN)
                                               (CLASSIC))
                                              ((TIMESROMAN)
                                               (CLASSIC))
                                              ((HELVETICA)
                                               (MODERN))
                                              ((TERMINAL)
                                               (MODERN]
                     [ADOBEDISPLAYFONTCOERCIONS '(((HELVETICABLACK 16)
                                                   (HELVETICABLACK 18))
                                                  ((SYMBOL)
                                                   (ADOBESYMBOL))
                                                  ((SYMBOL 11)
                                                   (ADOBESYMBOL 10))
                                                  ((AVANTGARDE-DEMI)
                                                   (AVANTGARDE))
                                                  ((AVANTGARDE-BOOK)
                                                   (AVANTGARDE))
                                                  ((NEWCENTURYSCHLBK)
                                                   (CENTURYSCHOOLBOOK))
                                                  ((BOOKMAN-LIGHT)
                                                   (BOOKMAN))
                                                  ((BOOKMAN-DEMI)
                                                   (BOOKMAN))
                                                  ((HELVETICA-NARROW)
                                                   (HELVETICANARROW))
                                                  ((HELVETICA 24)
                                                   (ADOBEHELVETICA 24]
                     (\DEFAULTCHARSET 0))
              (COMS                                          (* ; "MAPPING FOR DOS FILENAMES ")
                    (INITVARS (*DISPLAY-FONT-NAME-MAP* '((TIMESROMAN . TR)
                                                         (HELVETICA . HV)
                                                         (TIMESROMAND . TD)
                                                         (HELVETICAD . HD)
                                                         (MODERN . MD)
                                                         (CLASSIC . CL)
                                                         (GACHA . GC)
                                                         (TITAN . TI)
                                                         (LETTERGOTHIC . LG)
                                                         (BOLDPS . BP)
                                                         (TERMINAL . TM)
                                                         (CLASSICTHIN . CT)
                                                         (HIPPO . HP)
                                                         (LOGO . LG)
                                                         (MATH . MA)
                                                         (OLDENGLISH . OE)
                                                         (SYMBOL . SY]
        (FNS \FONTRESETCHARWIDTHS)
        (GLOBALVARS DISPLAYCHARSETFNS)
        [DECLARE%: DONTEVAL@LOAD DOCOPY (INITVARS (DISPLAYFONTDIRECTORIES NIL))
               (ADDVARS (DISPLAYCHARSETFNS (STRIKE STRIKEFONT.FILEP STRIKEFONT.GETCHARSET]
        (DECLARE%: DONTEVAL@LOAD DOCOPY                      (* ; "The loadup might have fewer")
               (ADDVARS (DISPLAYFONTEXTENSIONS MEDLEYDISPLAYFONT DISPLAYFONT)))
        (DECLARE%: EVAL@COMPILE DONTCOPY (CONSTANTS (MAXCODE 255)
                                                (DUMMYINDEX 256)))
        (MACROS \FGETCHARIMAGEWIDTH \SETCHARSETINFO)
        (LOCALVARS . T)
        (PROP FILETYPE FONT)
        (DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA)
                                                                             (NLAML)
                                                                             (LAMA FONTCOPY])



(* ;; "font functions ")

(DECLARE%: EVAL@COMPILE DONTCOPY 

(FILESLOAD (SYSLOAD)
       MULTI-ALIST)
)
(DEFINEQ

(CHARWIDTH
  [LAMBDA (CHARCODE FONT)                                (* rmk%: "12-Apr-85 09:46")
                                                             (* ; 
                                              "gets the width of a character code in a font/stream")
    (OR (\CHARCODEP CHARCODE)
        (\ILLEGAL.ARG CHARCODE))
    (LET (TEMP)
         (COND
            ((type? FONTDESCRIPTOR FONT)
             (\FGETCHARWIDTH FONT CHARCODE))
            ((SETQ TEMP (\OUTSTREAMARG FONT T))              (* ; 
                                                     "NIL font goes thru here--primary output file")
             (IMAGEOP 'IMCHARWIDTH TEMP TEMP CHARCODE))
            (T (\FGETCHARWIDTH (FONTCREATE FONT)
                      CHARCODE])

(CHARWIDTHY
  [LAMBDA (CHARCODE FONT)                                    (* ; "Edited 22-May-2025 09:47 by rmk")
                                                             (* edited%: "18-Mar-86 19:30")
                                                             (* ; 
                                   "Gets the Y-component of the width of a character code in a font.")
    (OR (\CHARCODEP CHARCODE)
        (\ILLEGAL.ARG CHARCODE))
    (LET (TEMP WY)
         (COND
            ((type? FONTDESCRIPTOR FONT)
             (SETQ WY (ffetch (CHARSETINFO YWIDTHS) of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                              FONT)))
             (COND
                ((FIXP WY))
                (WY (\FGETWIDTH WY (\CHAR8CODE CHARCODE)))
                (T 0)))
            ((type? STREAM (SETQ TEMP (\OUTSTREAMARG FONT T)))
                                                             (* ; 
                                                       "NIL font goes thru here--primary output file")
             (IMAGEOP 'IMCHARWIDTHY TEMP TEMP CHARCODE))
            (T [SETQ WY (ffetch (CHARSETINFO YWIDTHS) of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                                (FONTCREATE FONT]
               (COND
                  ((FIXP WY))
                  (WY (\FGETWIDTH WY (\CHAR8CODE CHARCODE)))
                  (T 0])

(STRINGWIDTH
  [LAMBDA (STR FONT FLG RDTBL)                           (* ; "Edited  8-Jan-88 14:41 by Snow")

    (* ;; "Returns the width of STR according to FONT")

    (LET (TEMP)

         (* ;; "Used in \MAPCHARS")

         (COND
            [(type? FONTDESCRIPTOR FONT)
             (\STRINGWIDTH.GENERIC STR FONT (AND FLG (\GTREADTABLE RDTBL))
                    (\FGETCHARWIDTH FONT (CHARCODE SPACE]
            [(AND FONT (SETQ TEMP (\OUTSTREAMARG FONT T)))   (* ; 
  "if you gave something for FONT, coerce it to a stream, and call the stringwidth function of it.")
             (IMAGEOP 'IMSTRINGWIDTH TEMP TEMP STR (AND FLG (\GTREADTABLE RDTBL]
            (T (SETQ TEMP (FONTCREATE (OR FONT DEFAULTFONT)))
                                                             (* ; "NIL font will pass thru here.  ie, defaultfont is used to do the stringwidth instead of the font of *standard-output*")
               (\STRINGWIDTH.GENERIC STR TEMP (AND FLG (\GTREADTABLE RDTBL))
                      (\FGETCHARWIDTH TEMP (CHARCODE SPACE])

(\CHARWIDTH.DISPLAY
  [LAMBDA (STREAM CHARCODE)                              (* rmk%: "12-Apr-85 09:42")
                                                             (* ; 
         "gets the width of a character code in a display stream.  Need to fix up for spacefactor.")
    (\FGETCHARWIDTH (ffetch (\DISPLAYDATA DDFONT) of (ffetch IMAGEDATA of STREAM))
           CHARCODE])

(\STRINGWIDTH.DISPLAY
  [LAMBDA (STREAM STR RDTBL)                             (* ; "Edited  3-Apr-87 12:07 by jop")

    (* ;; "Returns the width of for the current font/spacefactor in STREAM.")

    (LET ((DD (ffetch IMAGEDATA of STREAM)))
         (\STRINGWIDTH.GENERIC STR (ffetch (\DISPLAYDATA DDFONT) of DD)
                RDTBL
                (ffetch DDSPACEWIDTH of DD])

(\STRINGWIDTH.GENERIC
  [LAMBDA (STR FONT RDTBL SPACEWIDTH)                        (* ; "Edited 22-May-2025 09:51 by rmk")
                                                             (* ; "Edited  3-Apr-87 13:47 by jop")

    (* ;; "Returns the width of STR with SPACEWIDTH for the width of spaces.  RDTBL has already been coerced, so no FLG is needed ")

    (* ;; "This is cloned in \STRINGWIDTH.HCPYDISPLAYAUX by straight substitution -- (PUTDEF (QUOTE \STRINGWIDTH.HCPYDISPLAYAUX) (QUOTE FNS) (SUBLIS (QUOTE ((WIDTHS  . IMAGEWIDTHS) (\FGETWIDTH  . \FGETIMAGEWIDTH) (\FGETCHARWIDTH  . \FGETCHARIMAGEWIDTH))) (GETDEF (QUOTE \STRINGWIDTH.GENERIC))))")

    (* ;; "\MAPPNAME uses WIDTHSBASE CSET TOTALWIDTH FONT SPACEWIDTH free, so these become special in bytecompiler")

    (PROG NIL
          [COND
             [(LITATOM STR)
              (if RDTBL
                  then (GO SLOW)
                else (RETURN (for C WIDTHSBASE CSET inatom STR
                                sum [COND
                                       ((NEQ CSET (\CHARSET C))
                                        (SETQ CSET (\CHARSET C))
                                        (SETQ WIDTHSBASE (ffetch (CHARSETINFO WIDTHS)
                                                            of (\INSURECHARSETINFO CSET FONT]
                                    (COND
                                       ((EQ C (CHARCODE SPACE))
                                        SPACEWIDTH)
                                       (T (\FGETWIDTH WIDTHSBASE (\CHAR8CODE C]
             ((STRINGP STR)
              (RETURN
               (LET ((TOTAL 0)
                     ESC ESCWIDTH WIDTHSBASE CSET)
                    [COND
                       (RDTBL                                (* ; 
                                                       "Count delimiting quotes and internal escapes")
                              (SETQ TOTAL (UNFOLD (\FGETCHARWIDTH FONT (CHARCODE %"))
                                                 2))
                              (SETQ ESC (fetch (READTABLEP ESCAPECHAR) of RDTBL))
                              (SETQ ESCWIDTH (\FGETCHARWIDTH FONT ESC]
                    [for C instring STR
                       do [COND
                             ((NEQ (\CHARSET C)
                                   CSET)                     (* ; 
                                                       "Get the widths vector for this character set")
                              (SETQ CSET (\CHARSET C))
                              (SETQ WIDTHSBASE (ffetch (CHARSETINFO WIDTHS) of (\INSURECHARSETINFO
                                                                                CSET FONT]
                          (add TOTAL (COND
                                        ((EQ C (CHARCODE SPACE))
                                         SPACEWIDTH)
                                        (T (IPLUS (\FGETWIDTH WIDTHSBASE (\CHAR8CODE C))
                                                  (COND
                                                     ((AND RDTBL (OR (EQ C (CHARCODE %"))
                                                                     (EQ C ESC)))
                                                             (* ; "String char must be escaped")
                                                      ESCWIDTH)
                                                     (T 0]
                    TOTAL]
      SLOW
                                                             (* ; "Do the general case here")
          (RETURN (LET ((TOTALWIDTH 0)
                        WIDTHSBASE CSET (FONT FONT)
                        (SPACEWIDTH SPACEWIDTH))
                       (DECLARE (SPECVARS TOTALWIDTH WIDTHSBASE CSET FONT SPACEWIDTH))
                       (\MAPPNAME [FUNCTION (LAMBDA (DUMMY CC)
                                              (add TOTALWIDTH (COND
                                                                 ((EQ CC (CHARCODE SPACE))
                                                                  SPACEWIDTH)
                                                                 ((EQ CSET (\CHARSET CC))
                                                                  (\FGETWIDTH WIDTHSBASE (\CHAR8CODE
                                                                                          CC)))
                                                                 (T (SETQ CSET (\CHARSET CC))
                                                                    (SETQ WIDTHSBASE
                                                                     (ffetch (CHARSETINFO WIDTHS)
                                                                        of (\INSURECHARSETINFO CSET 
                                                                                  FONT)))
                                                                    (\FGETWIDTH WIDTHSBASE
                                                                           (\CHAR8CODE CC]
                              STR RDTBL RDTBL *PRINT-LEVEL* *PRINT-LENGTH*)
                       TOTALWIDTH])
)
(DEFINEQ

(DEFAULTFONT
  [LAMBDA (DEVICE FONT NOERRORFLG)                           (* ; "Edited 14-Jul-2025 22:43 by rmk")
                                                             (* ; "Edited  5-Jul-2025 13:30 by rmk")
                                                             (* ; "Edited 28-Jul-88 13:15 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:41 by FS")
    (DECLARE (GLOBALVARS DEFAULTFONT))

    (* ;; "It is a natural mistake for the user to set DEFAULTFONT to an actual font instead of a class.   In that case we up it into a class, ignoring FONT if the given DEFAULTFONT designates a font descriptor.")

    (CL:UNLESS DEVICE
        (SETQ DEVICE 'DISPLAY))
    (CL:UNLESS (type? FONTCLASS DEFAULTFONT)

        (* ;; "If total garbage, we want to fall through to the coerce, to protect the system. NLSETQ to suppress even invalid-argument errors.")

        (CL:WHEN DEFAULTFONT
            [SETQ FONT (CAR (NLSETQ (FONTCREATE DEFAULTFONT NIL NIL NIL DEVICE T])
        (SETQ DEFAULTFONT (FONTCLASS 'DEFAULTFONT)))
    (CL:IF FONT
        (SETFONTCLASSCOMPONENT DEFAULTFONT DEVICE FONT)
        (FONTCREATE DEFAULTFONT NIL NIL NIL DEVICE NOERRORFLG))])

(FONTCLASS
  [LAMBDA (NAME FONTLIST CREATEFORDEVICES)               (* jds " 9-Sep-86 18:49")

    (* ;; "This builds D style font classes, which are datatypes containing entries for the various known devices.")

    (* ;; "Don't actually set up the for devices not inside CREATEFORDEVICES on the theory that any given user presumably doesn't want all the fonts for all the devices.  We wait until he actually asks for the font or the fontmaparray, at which point we note that the fields don't contain FD's, so we then apply FONTCREATE.  The actual coercion and caching is done inside \COERCEFONTDESC.  However, so as to prevent display crashes, if a display component is specified, we always do the fontcreate before we stick it in.")

    (PROG (F FC FL)
          (SETQ FL FONTLIST)
          [SETQ FC (create FONTCLASS
                          FONTCLASSNAME _ NAME
                          PRETTYFONT# _ (OR (FIXP (pop FL))
                                            1)
                          DISPLAYFD _ (AND (SETQ F (pop FL))
                                           (FONTCREATE F NIL NIL NIL 'DISPLAY))
                          PRESSFD _ (pop FL)
                          INTERPRESSFD _ (pop FL)
                          OTHERFDS _ (for FSPEC in FL
                                        collect (OR (AND (LISTP FSPEC)
                                                             (ATOM (CAR FSPEC))
                                                             (CAR FSPEC))
                                                        (ERROR "illegal font class specification"
                                                               (LIST NAME FONTLIST))) 
                                                             (* ; 
                                     "Copy the alist entry so it can be smashed in \COERCEFONTDESC")
                                              (CONS (CAR FSPEC)
                                                    (CAR (LISTP (CDR FSPEC]
          (for D inside CREATEFORDEVICES do (FONTCREATE FC NIL NIL NIL D))
          (RETURN FC])

(FONTCLASSUNPARSE
  [LAMBDA (FONTCLASS DEVICE FONT NOERRORFLG)         (* jds "24-Jan-86 11:58")
                                                             (* ; 
                                "Given a font class, unparse it to a form that might be reparsable")
    (APPEND (LIST (fetch (FONTCLASS FONTCLASSNAME) of FONTCLASS)
                  (fetch (FONTCLASS PRETTYFONT#) of FONTCLASS)
                  (FONTUNPARSE (ffetch (FONTCLASS DISPLAYFD) of FONTCLASS))
                  (FONTUNPARSE (ffetch (FONTCLASS PRESSFD) of FONTCLASS))
                  (FONTUNPARSE (ffetch (FONTCLASS INTERPRESSFD) of FONTCLASS)))
           (for X in (fetch (FONTCLASS OTHERFDS) of FONTCLASS)
              collect (LIST (CAR X)
                                (FONTUNPARSE (CDR X])

(FONTCLASSCOMPONENT
  [LAMBDA (FONTCLASS DEVICE FONT NOERRORFLG)                 (* ; "Edited  4-Jul-2025 10:32 by rmk")
                                                             (* rmk%: "14-Sep-84 19:34")

    (* ;; "Returns the old DEVICE-specific font of the class. Only if FONT designates a font descriptor is that descriptor installed.")

    (PROG1 (FONTCREATE FONTCLASS NIL NIL NIL DEVICE NOERRORFLG)
        (AND FONT (SETQ FONT (FONTCREATE FONT NIL NIL NIL DEVICE NOERRORFLG))
             (SETFONTCLASSCOMPONENT FONTCLASS DEVICE FONT)))])

(SETFONTCLASSCOMPONENT
  [LAMBDA (FONTCLASS DEVICE FONT)                            (* ; "Edited  5-Jul-2025 09:53 by rmk")
                                                             (* ; "Edited 15-Jun-2025 00:02 by rmk")
                                                             (* ; "Edited 29-Aug-91 12:20 by jds")
    (\SETFONTCLASSCOMPONENT FONTCLASS DEVICE (FONTCREATE FONT NIL NIL NIL DEVICE])

(GETFONTCLASSCOMPONENT
  [LAMBDA (FONTCLASS DEVICE NOERRORFLG)                      (* ; "Edited  5-Jul-2025 09:54 by rmk")
                                                             (* ; "Edited 14-Jun-2025 20:32 by rmk")

    (* ;; "This is a user entry")

    (LET (FONT)
         (if (type? FONTCLASS FONTCLASS)
             then (SETQ FONT (\GETFONTCLASSCOMPONENT FONTCLASS DEVICE)) 

                  (* ;; "Component may no be a properly instantiated font description.  Let FONTCREATE have a try, possibly error.")

                  (CL:UNLESS (type? FONTDESCRIPTOR FONT)
                      (if (SETQ FONT (FONTCREATE FONT NIL NIL NIL 'DEVICE T))
                          then (\SETFONTCLASSCOMPONENT FONTCLASS DEVICE FONT)
                        elseif NOERRORFLG
                        else (ERROR (CONCAT "Invalid " DEVICE " fontclass component")
                                    FONTCLASS)))
                  FONT
           elseif NOERRORFLG
             then NIL
           else (ERROR "NOT A FONTCLASS" FONTCLASS])
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \GETFONTCLASSCOMPONENT MACRO (OPENLAMBDA (FCLASS DEVICE)
                                         (SELECTQ DEVICE
                                             (DISPLAY (fetch (FONTCLASS DISPLAYFD) of FCLASS))
                                             (INTERPRESS (fetch (FONTCLASS INTERPRESSFD) of FCLASS))
                                             (PRESS (fetch (FONTCLASS PRESSFD) of FCLASS))
                                             (GETMULTI (fetch (FONTCLASS OTHERFDS) of FCLASS)
                                                    DEVICE))))

(PUTPROPS \SETFONTCLASSCOMPONENT MACRO (OPENLAMBDA (FCLASS DEVICE NEWFONT)
                                         (SELECTQ DEVICE
                                             (DISPLAY (replace (FONTCLASS DISPLAYFD) of FCLASS
                                                         with NEWFONT))
                                             (INTERPRESS (replace (FONTCLASS INTERPRESSFD)
                                                            of FCLASS with NEWFONT))
                                             (PRESS (replace (FONTCLASS PRESSFD) of FCLASS
                                                       with NEWFONT))
                                             (PUTMULTI (fetch (FONTCLASS OTHERFDS) of FCLASS)
                                                    DEVICE NEWFONT))))
)

(RPAQQ NSFONTFAMILIES (CLASSIC MODERN TERMINAL OPTIMA TITAN BOLDPS PCTERMINAL))

(RPAQQ ALTOFONTFAMILIES (GACHA TIMESROMAN TIMESROMAND HELVETICA OLDENGLISH SNAIL TONTO))



(* ;; "Creation: ")

(DEFINEQ

(FONTCREATE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE NOERRORFLG CHARSET)
                                                             (* ; "Edited 21-Jul-2025 09:11 by rmk")
                                                             (* ; "Edited 11-Jul-2025 10:23 by rmk")
                                                             (* ; "Edited  4-Jul-2025 12:10 by rmk")
                                                             (* ; "Edited 27-Jun-2025 10:29 by rmk")
                                                             (* ; "Edited 21-Jun-2025 14:53 by rmk")
                                                             (* ; "Edited 20-May-2025 20:41 by rmk")
                                                             (* ; "Edited 10-Oct-88 09:53 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:43 by rmk:")
                                                             (* ; "Edited 10-Nov-87 18:08 by FS")

    (* ;; "Returns the requested font descriptor.  If NOERRORFLG, return NIL if the requested  font or CHARSET doesn't exist;  otherwise cause an error.  And always cause an error if any argument is bogus.")

    (* ;; "A font exists if it has at least one charset, even if the optionally desired CHARSET doesn't exist.  There is no difference between all the characters in a missing charset and particular missing characters in an existing charset:  they will show up as slugs. ")

    (* ;; "Original code picked off and returned a fontclass for (CLASS ...).  That's now handled in \FONT.CHECKARGS, and it coerces to a fontdescriptor for DEVICE, not a class.")

    (PROG (FONTSPEC)
      RETRY
                                                             (* ; "Back to here if ERROR returns")
          (SETQ FONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE CHARSET))

     (* ;; "If FONTSPEC is a fontdescriptor, it's what we want")

          (RETURN (if (type? FONTDESCRIPTOR FONTSPEC)
                      then FONTSPEC
                    else (SPREADFONTSPEC FONTSPEC)
                         (if (FONTCREATE1 FAMILY SIZE FACE ROTATION DEVICE (OR CHARSET 
                                                                               \DEFAULTCHARSET))
                           elseif NOERRORFLG
                             then NIL
                           else (ERROR "FONT NOT FOUND" FONTSPEC)
                                (GO RETRY])

(FONTCREATE1
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 24-Jul-2025 19:52 by rmk")
                                                             (* ; "Edited 23-Jul-2025 10:01 by rmk")
                                                             (* ; "Edited 17-Jul-2025 23:48 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited  4-Jul-2025 17:05 by rmk")
                                                             (* ; "Edited 21-Jun-2025 09:28 by rmk")
                                                             (* ; "Edited 18-Jun-2025 14:50 by rmk")
                                                             (* ; "Edited 16-Jun-2025 12:07 by rmk")
                                                             (* ; "Edited 14-Jun-2025 20:53 by rmk")
                                                             (* ; "Edited 10-Jun-2025 23:54 by rmk")

    (* ;; "Causes an error only if the arguments are bogus, otherwise returns NIL if font or character set not found. Error happens at FONTCREATE")

    (DECLARE (GLOBALVARS IMAGESTREAMTYPES \FONTSINCORE))
    (LET (FONTX)
         (CL:WHEN (if (SETQ FONTX (GETMULTI \FONTSINCORE FAMILY SIZE FACE ROTATION DEVICE))
                      then (\INSURECHARSETINFO CHARSET FONTX)
                    elseif (AND (FONTEXISTS? FAMILY SIZE FACE ROTATION DEVICE CHARSET)
                                (SETQ FONTX (\CREATEFONT FAMILY SIZE FACE ROTATION DEVICE CHARSET))
                                (\INSURECHARSETINFO CHARSET FONTX))
                      then (PUTMULTI \FONTSINCORE FAMILY SIZE FACE ROTATION DEVICE FONTX))
             (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONTX with (\AVGCHARWIDTH FONTX))
             FONTX)])

(FONTCREATE.SLUGFD
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 14-Jun-2025 23:25 by rmk")
                                                             (* ; "Edited 13-Jun-2025 09:44 by rmk")
                                                             (* ; "Edited 11-Jun-2025 10:59 by rmk")

    (* ;; "For the REMEMBER case,  dummy font descriptor completely fillled with a slug charsetinfo")

    (LET* ([FONTDESC (create FONTDESCRIPTOR
                            FONTDEVICE _ DEVICE
                            FONTFAMILY _ FAMILY
                            FONTSIZE _ SIZE
                            FONTFACE _ FACE
                            \SFAscent _ SIZE
                            \SFDescent _ 0
                            \SFHeight _ SIZE
                            ROTATION _ ROTATION
                            FONTDEVICESPEC _ (LIST FAMILY SIZE FACE ROTATION DEVICE)
                            FONTCHARENCODING _ 'MCCS
                            FONTAVGCHARWIDTH _ (FIXR (FTIMES SIZE 0.75]
           (SLUGCSINFO (\BUILDSLUGCSINFO FONTDESC)))
          (if CHARSET
              then (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                          CHARSET SLUGCSINFO)
            else (for CS from 0 to (ADD1 \MAXCHARSET) do (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR
                                                                             of FONTDESC)
                                                                CS SLUGCSINFO)))
          FONTDESC])

(\FONT.CHECKARGS
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 27-Jul-2025 13:30 by rmk")
                                                             (* ; "Edited 22-Jul-2025 23:07 by rmk")
                                                             (* ; "Edited 21-Jul-2025 09:22 by rmk")
                                                             (* ; "Edited 14-Jul-2025 20:09 by rmk")
                                                             (* ; "Edited 11-Jul-2025 10:15 by rmk")
                                                             (* ; "Edited  5-Jul-2025 13:37 by rmk")
                                                             (* ; "Edited  2-Jul-2025 16:50 by rmk")
                                                             (* ; "Edited 27-Jun-2025 10:42 by rmk")
                                                             (* ; "Edited 15-Jun-2025 00:25 by rmk")

    (* ;; "Decodes and checks the various ways of specifying the arguments to font lookup functions.")

    (* ;; "If FAMILY can be coerced to a font descriptor and none of its properties are overwritten by the other aguments, then that font descriptor is returned.  Otherwise the value is the coerce fontspec (family size face rotation device).  CHARSET is checked for validity but not coerced.")

    (LET (FONTX)
         (SETQ DEVICE (if (NULL DEVICE)
                          then (CL:IF (type? FONTDESCRIPTOR FAMILY)
                                   (fetch (FONTDESCRIPTOR FONTDEVICE) of FAMILY)
                                   'DISPLAY)
                        elseif (OR (AND (LITATOM DEVICE)
                                        (NEQ DEVICE T))
                                   (STRINGP DEVICE))
                          then (\DEVICESYMBOL DEVICE)
                        elseif [AND (SETQ DEVICE (\GETSTREAM DEVICE 'OUTPUT T))
                                    (CAR (MKLIST (IMAGESTREAMTYPE DEVICE]
                        else (\ILLEGAL.ARG DEVICE)))
         (CL:WHEN (AND (EQ 'CLASS (CAR FAMILY))
                       (LITATOM (CADR FAMILY)))

             (* ;; "This used to be at the entry to FONTCREATE, and it returned the FONTCLASS.  That seemed wrong--FONTCREATE should always return a fontdescriptor.  So here we build a throwaway fontclass, coerce it to its device font, and fall through.")

             (SETQ FAMILY (\FONT.CHECKARGS1 (FONTCLASS (CADR FAMILY)
                                                   (CDDR FAMILY))
                                 DEVICE)))
         (CL:UNLESS (AND FAMILY (LITATOM FAMILY)
                         (NEQ FAMILY T))

             (* ;; "FAMILY T or NIL produces an error below")

             [if (LISTP FAMILY)
                 then (SETQ FONTX (CL:IF (EQ 'FONT (CAR FAMILY))
                                      (CDR FAMILY)
                                      FAMILY))
                      (SETQ FAMILY (pop FONTX))
                      (SETQ SIZE (OR (pop FONTX)
                                     SIZE))
                      (SETQ FACE (OR (pop FONTX)
                                     FACE))
                      (SETQ ROTATION (OR (pop FONTX)
                                         ROTATION))
                      (SETQ DEVICE (OR (pop FONTX)
                                       DEVICE))
                      (SETQ CHARSET (pop FONTX))
                      (SETQ FONTX NIL)
               elseif (SETQ FONTX (CL:IF (type? FONTDESCRIPTOR FAMILY)
                                      FAMILY
                                      (\FONT.CHECKARGS1 FAMILY DEVICE T)))
                 then 
                      (* ;; 
                    "FAMILY was a spec for a font descriptor. Are any of its properties overwritten?")

                      (SETQ FAMILY (fetch (FONTDESCRIPTOR FONTFAMILY) of FONTX))
                      (CL:UNLESS SIZE
                          (SETQ SIZE (fetch (FONTDESCRIPTOR FONTSIZE) of FONTX)))
                      (CL:UNLESS FACE
                          (SETQ FACE (fetch (FONTDESCRIPTOR FONTFACE) of FONTX)))
                      (CL:UNLESS ROTATION
                          (SETQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of FONTX)))
                      (CL:UNLESS DEVICE
                          (SETQ DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of FONTX)))])

         (* ;; "The arguments are now coerced, validate them.")

         (CL:UNLESS (AND FAMILY (LITATOM FAMILY)
                         (NEQ FAMILY T))
                (ERROR "Illegal font family" FAMILY))
         (SETQ FAMILY (U-CASE FAMILY))
         (CL:UNLESS (OR (AND (FIXP SIZE)
                             (IGREATERP SIZE 0))
                        (EQ SIZE '*))
                (ERROR "Illegal font size" SIZE))
         (CL:UNLESS (EQ FACE '*)
             (SETQ FACE (\FONTFACE FACE NIL DEVICE)))
         (if (NULL ROTATION)
             then (SETQ ROTATION 0)
           elseif (AND (FIXP ROTATION)
                       (IGEQ ROTATION 0))
           elseif (EQ ROTATION '*)
           else (\ILLEGAL.ARG ROTATION))
         (CL:WHEN CHARSET
             (CL:UNLESS (<= 0 CHARSET \MAXCHARSET)
                    (\ILLEGAL.ARG CHARSET)))
         (CL:WHEN FONTX

             (* ;; "Return FONTX only if no fields were overwritten")

             (CL:UNLESS (AND (EQ SIZE (fetch (FONTDESCRIPTOR FONTSIZE) of FONTX))
                             (EQUAL FACE (fetch (FONTDESCRIPTOR FONTFACE) of FONTX))
                             (EQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of FONTX))
                             (EQ DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of FONTX)))
                    (SETQ FONTX NIL)))
         (OR FONTX (LIST FAMILY SIZE FACE ROTATION DEVICE])

(\FONT.CHECKARGS1
  [LAMBDA (SPEC STREAM NOERRORFLG)                           (* ; "Edited 22-Jul-2025 18:47 by rmk")
                                                             (* ; "Edited 14-Jul-2025 19:40 by rmk")
                                                             (* ; "Edited  5-Jul-2025 14:16 by rmk")
                                                             (* ; "Edited 29-Aug-91 12:19 by jds")

    (* ;; "Coerces SPEC to a fontdescriptor appropriate for STREAM (defaulting to DISPLAY).")

    (* ;; "SPEC can be a font descriptor, a font class, any of the symbolic ways of describing those, or NIL (= DEFAULTFONT).  If SPEC is a class whose component for a non-display device is uninstantiated, the display component is used as a template for the requested device font. ")

    (* ;; "STREAM denotes a device:  NIL means DISPLAY, another atom is a device name itself, an IMAGESTREAM means its IMAGESTREAMTYPE.  Anything else here maps to DISPLAY, but maybe that should be an illegal arg error, even of NOERRORFLG.")

    (DECLARE (GLOBALVARS DEFAULTFONT \GUARANTEEDDISPLAYFONT))
    (LET (FONT DEVICE TEMP)
         (CL:UNLESS SPEC
             (if DEFAULTFONT
                 then (SETQ SPEC DEFAULTFONT)
               else (ERROR "No DEFAULTFONT")))
         (SETQ DEVICE (if (NULL STREAM)
                          then                               (* ; "Default is display")
                               'DISPLAY
                        elseif (OR (LITATOM STREAM)
                                   (STRINGP STREAM))
                          then (\DEVICESYMBOL STREAM)
                        elseif (IMAGESTREAMP STREAM)
                          then (IMAGESTREAMTYPE STREAM)
                        elseif STREAM
                        else 
                             (* ;; "Original jds comment:  should this be allowed?")

                             'DISPLAY))
         (if (type? FONTCLASS SPEC)
             then (SETQ FONT (\GETFONTCLASSCOMPONENT SPEC DEVICE))
                  (if (type? FONTDESCRIPTOR FONT)
                      then 
                           (* ;; "It must be a font for DEVICE")

                           FONT
                    elseif (AND FONT (SETQ TEMP (FONTCREATE FONT NIL NIL NIL DEVICE T)))
                      then (\SETFONTCLASSCOMPONENT DEFAULTFONT DEVICE TEMP)
                    elseif (MEMB DEVICE \DISPLAYSTREAMTYPES)
                      then (if (EQ SPEC DEFAULTFONT)
                               then                          (* ; "Guarantee system integrity")
                                    (\SETFONTCLASSCOMPONENT DEFAULTFONT DEVICE \GUARANTEEDDISPLAYFONT
                                           )
                             elseif NOERRORFLG
                               then NIL
                             else (ERROR (CONCAT "DISPLAY component for " SPEC " is invalid")))
                    elseif (SETQ FONT (FONTCREATE (\GETFONTCLASSCOMPONENT SPEC 'DISPLAY)
                                             NIL NIL NIL DEVICE NOERRORFLG))
                      then 
                           (* ;; "If the DEVICE component was garbage, we use the display component as a template for an appropriate FD.")

                           (\SETFONTCLASSCOMPONENT SPEC DEVICE FONT)
                    elseif NOERRORFLG
                      then NIL
                    else (ERROR (CONCAT DEVICE " component for " SPEC " is invalid")))
           elseif (SETQ FONT (if (type? FONTDESCRIPTOR SPEC)
                                 then SPEC
                               elseif (OR (IMAGESTREAMP SPEC)
                                          (type? WINDOW SPEC))
                                 then (DSPFONT NIL SPEC)))
             then (if (NULL STREAM)
                      then 
                           (* ;; 
                          "NIL device doesn't default to display if a fully-specified font was found")

                           FONT
                    elseif (EQ DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of FONT))
                      then FONT
                    else 
                         (* ;; "Switch device")

                         (FONTCREATE FONT NIL NIL NIL DEVICE NOERRORFLG])

(\FONTCREATE1.NOFN
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 16-Jun-2025 12:08 by rmk")
    (ERROR (CONCAT "FONTCREATE function is not specified for image-type " DEVICE])

(FONTFILEP
  [LAMBDA (FILE DEVICE)                                      (* ; "Edited 13-Jul-2025 13:41 by rmk")
                                                             (* ; "Edited 27-Jun-2025 22:54 by rmk")
    (CL:UNLESS DEVICE
        (SETQ DEVICE 'DISPLAY))
    (RESETLST
        (if (EQ DEVICE 'DISPLAY)
            then (for FNS STRM in (GETATOMVAL (PACK* DEVICE 'CHARSETFNS))
                    first [RESETSAVE (SETQ STRM (OPENSTREAM FILE 'INPUT))
                                 `(PROGN (CLOSEF? OLDVALUE]
                    do (CL:WHEN (CAR (NLSETQ (APPLY* (CADR FNS)
                                                    STRM)))
                           (RETURN (CAR FNS)))
                       (CLOSEF? STRM))))])

(\READCHARSET
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 21-Jul-2025 18:35 by rmk")
                                                             (* ; "Edited 14-Jul-2025 19:51 by rmk")
                                                             (* ; "Edited 12-Jul-2025 13:20 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited  6-Jul-2025 13:09 by rmk")

    (* ;; "This finds the first file in the directories/extensions order that contains information about charset, determines its format, and reads it in.  The assumption is that the first such existing file is the one we want. ")

    (CL:WHEN (EQ ROTATION 0)
        (RESETLST
            (for FILE STRM CSINFO in (FONTFILES FAMILY SIZE FACE ROTATION DEVICE CHARSET)
               do 
                  (* ;; "We know that FILE exists and is the best source of information about charset--maybe none. We assume FILE is one of the valid formats, we open it separately for each format-type, and ensure it is closed on exit.  We can't used CL:WITHOPEN-FILE because that doesn't exist in the loadup when the first font is created.")

                  (for FNS in (GETATOMVAL (PACK* DEVICE 'CHARSETFNS))
                     do [RESETSAVE (SETQ STRM (OPENSTREAM FILE 'INPUT))
                               `(PROGN (CLOSEF? OLDVALUE]
                        (CL:WHEN (CAR (NLSETQ (APPLY* (CADR FNS)
                                                     STRM)))

                            (* ;; "Assume that predicate leaves stream (open or closed) in proper state for its retrieval function.  The FILE may be of the right type, but it may not contain this CHARSET (e.g. a complete MEDLEYFONTFILE but CHARSET doesn't exist anywhere).")

                            (SETQ CSINFO (APPLY* (CADDR FNS)
                                                STRM CHARSET FAMILY SIZE FACE ROTATION DEVICE))
                            (CL:WHEN (type? CHARSETINFO CSINFO)
                                (CL:UNLESS (CHARSETPROP CSINFO 'CSCHARENCODING)

                                    (* ;; "The file didn't know its own encoding")

                                    (CHARSETPROP CSINFO 'CSCHARENCODING (if (NEQ CHARSET 0)
                                                                            then 'MCCS
                                                                          elseif (MEMB FAMILY 
                                                                                       NSFONTFAMILIES
                                                                                       )
                                                                            then 'XCCS$
                                                                          elseif (MEMB FAMILY 
                                                                                     ALTOFONTFAMILIES
                                                                                       )
                                                                            then 'ALTOTEXT
                                                                          else FAMILY)))

                                (* ;; "Remember the file that this basic charset information came from, before any character coercions, for informational purposes.  Path and version won't be valid if sysout moves, or if PSEUDOFILENAME's aren't aligned.  Don't want files to be new atoms, for loadup.")

                                (CHARSETPROP CSINFO 'FILE (MKSTRING (PSEUDOFILENAME FILE)))
                                (CL:UNLESS (CHARSETPROP CSINFO 'SOURCE)
                                    (CHARSETPROP CSINFO 'SOURCE (MAKECSSOURCE FAMILY SIZE FACE 
                                                                       ROTATION DEVICE CHARSET)))
                                (RETURN))) 

                        (* ;; "Prepare for next format-type")

                        (CLOSEF? STRM))
                  (CL:WHEN CSINFO (RETURN CSINFO)))))])

(\COERCEFONTSPEC
  [LAMBDA (COERCIONS FAMILY SIZE FACE ROTATION DEVICE CHARSET)
                                                             (* ; "Edited 23-Jul-2025 15:39 by rmk")

    (* ;; "Produces a list of coerced fontspecs, one for each coercion whose right side matches the given parameters.")

    (* ;; "If MFAMILY is NIL, use FAMILY--default when nothing else matches.")

    (for C MATCH TARGET MFAMILY MSIZE TFAMILY TSIZE COERCED in COERCIONS
       eachtime (SETQ MATCH (CAR C))
             (if (LISTP MATCH)
                 then (SETQ MFAMILY (OR (CAR MATCH)
                                        FAMILY))
                      (SETQ MSIZE (OR (CADR MATCH)
                                      SIZE))
               else (SETQ MFAMILY (OR MATCH FAMILY))
                    (SETQ MSIZE SIZE)) when [AND (EQ FAMILY MFAMILY)
                                                 (EQ SIZE MSIZE)
                                                 (PROGN (SETQ TARGET (CADR C))
                                                             (* ; 
                                "Don't include the input in the output, if the coercions have a loop")
                                                        (if (LISTP TARGET)
                                                            then (SETQ TFAMILY (OR (CAR TARGET)
                                                                                   FAMILY))
                                                                 (SETQ TSIZE (OR (CADR TARGET)
                                                                                 SIZE))
                                                          else (SETQ TFAMILY TARGET)
                                                               (SETQ TSIZE SIZE))
                                                        (NOT (AND (EQ FAMILY TFAMILY)
                                                                  (EQ SIZE TSIZE]
       unless (MEMBER (SETQ COERCED (LIST TFAMILY TSIZE FACE ROTATION DEVICE CHARSET))
                     $$VAL) collect COERCED])
)
(DEFINEQ

(\COERCEFONTDESC
  [LAMBDA (SPEC STREAM NOERRORFLG)                           (* ; "Edited 27-Jul-2025 13:38 by rmk")
                                                             (* ; "Edited 22-Jul-2025 18:47 by rmk")
                                                             (* ; "Edited 14-Jul-2025 19:40 by rmk")
                                                             (* ; "Edited  5-Jul-2025 14:16 by rmk")
                                                             (* ; "Edited 29-Aug-91 12:19 by jds")

    (* ;; "It was intended to remove this function in favor of FONTCREATE as FONT was cleaned up to avoid stack overflows in certain situations.  The calls in system code have been replaced, but the macros for FONTASCENT, FONTDESCENT, and FONTHEIGHT were putting out calls.  So there may be calls in user code that still has compiled references.")

    (* ;; "Those macro calls all had NIL for STREAM and NOERRORFLG. So here we give a dummy definition that just calls FONTCREATE")

    (* ;; "We probably should put out a macro to compile \COERCEFONTDESC away.")

    (FONTCREATE SPEC])
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS SPREADFONTSPEC MACRO (OPENLAMBDA (FONTSPEC)
                                 (CL:WHEN (type? FONTDESCRIPTOR FONTSPEC)
                                     (SETQ FONTSPEC (FONTPROP FONTSPEC 'SPEC)))
                                 (SETQ SIZE (CADR FONTSPEC))
                                 (SETQ FACE (CADDR FONTSPEC))
                                 (SETQ ROTATION (CADDDR FONTSPEC))
                                 (SETQ DEVICE (CAR (CDDDDR FONTSPEC)))
                                 (SETQ CHARSET (CADR (CDDDDR FONTSPEC)))
                                 (SETQ FAMILY (CAR FONTSPEC))))
)
(DEFINEQ

(COMPLETE.FONT
  [LAMBDA (FONTSPEC EVENIFCOMPLETE)                          (* ; "Edited 21-Jun-2025 11:37 by rmk")
                                                             (* ; "Edited 19-Jun-2025 14:42 by rmk")
                                                             (* ; "Edited 12-Jun-2025 22:06 by rmk")
                                                             (* ; "Edited  8-Jun-2025 15:57 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:18 by rmk")
                                                             (* ; "Edited 23-May-2025 22:57 by rmk")
                                                             (* ; "Edited 20-May-2025 19:57 by rmk")
                                                             (* ; "Edited 16-May-2025 21:26 by rmk")

    (* ;; "This returns a FONTDESCRIPTOR for FONTSPEC that is complete with respect to all known character sources.  A caller that wants to insure that only files sources are considered should reset \FONTSINCORE and \FONTEXISTS?-CACHE. If reset, we still get the benefit of previous completions/coercions in this run if medleyfont files have been created for them.")

    (LET ((FONT (FONTCREATE FONTSPEC)))                      (* ; 
                                               "This will pick up FAMILY/SIZE...properties from FONT")
         (CL:WHEN (OR EVENIFCOMPLETE (NOT (fetch (FONTDESCRIPTOR FONTCOMPLETEP) of FONT)))
             (for CS from 0 to \MAXCHARSET do 
                                              (* ;; 
       "Skips existing charsets--they already have as much information as they are ever going to get")

                                              (\INSURECHARSETINFO CS FONT))
             (replace (FONTDESCRIPTOR FONTCOMPLETEP) of FONT with T))
         (PRUNEFONTSLUGS FONT)
         FONT])

(COMPLETEFONTP
  [LAMBDA (FONT)                                             (* ; "Edited 24-May-2025 20:55 by rmk")
                                                             (* ; "Edited 20-May-2025 14:37 by rmk")

    (* ;; "A font is incomplete if there is a NIL in any charset slot.  Completing will install a charset everywhere, even if it is a slug charset.")

    (SETQ FONT (FONTCREATE FONT))
    (for CS from 0 to \MAXCHARSET always (\XGETCHARSETINFO FONT CS])

(COMPLETE.CHARSET
  [LAMBDA (CSINFO FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS FONTDESC)
                                                             (* ; "Edited 12-Jul-2025 13:15 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited  9-Jul-2025 09:12 by rmk")
                                                             (* ; "Edited 21-Jun-2025 08:49 by rmk")
                                                             (* ; "Edited 18-Jun-2025 23:18 by rmk")
                                                             (* ; "Edited  8-Jun-2025 20:20 by rmk")
                                                             (* ; "Edited  7-Jun-2025 13:52 by rmk")

    (* ;; "CSINFO has some characters for this charset, but others may fill in from later fonts in the coercion chain. We assume that CSINFO is or will be the charsetinfo for CHARSET in the font described by FAMILY SIZE...  For each missing code we look through all the possible coercions to find the first font with real information about that character. We copy that character up to CSINFO.")

    (CL:UNLESS (fetch (CHARSETINFO CSCOMPLETEP) of CSINFO)
        [for THINCODE SOURCECSINFO GLYPHADDED from 0 to \MAXTHINCHAR
           when (AND (SLUGCHARP.DISPLAY THINCODE CSINFO)
                     (SETQ SOURCECSINFO (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                               COERCIONS THINCODE)))
           do (\MOVEFONTCHAR SOURCECSINFO CSINFO THINCODE THINCODE FONTDESC)
              (SETQ GLYPHADDED T) finally (CL:WHEN GLYPHADDED(* ; "The source is now here")
                                              (CHARSETPROP CSINFO 'SOURCE
                                                     (MAKECSSOURCE FAMILY SIZE FACE ROTATION DEVICE 
                                                            CHARSET)))]
        (replace (CHARSETINFO CSCOMPLETEP) of CSINFO with T))
    CSINFO])

(PRUNEFONTSLUGS
  [LAMBDA (FONT)                                             (* ; "Edited  9-Jun-2025 15:02 by rmk")
                                                             (* ; "Edited 24-May-2025 21:11 by rmk")
    (SETQ FONT (FONTCREATE FONT))
    (for CS CSINFO from 0 to \MAXCHARSET when (AND (SETQ CSINFO (\XGETCHARSETINFO FONT CS))
                                                   (fetch (CHARSETINFO CSSLUGP) of CSINFO))
       do (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR) of FONT)
                 CS NIL))
    FONT])
)



(* ;; "Property extraction:")

(DEFINEQ

(FONTASCENT
  [LAMBDA (FONTSPEC)                                         (* ; "Edited 14-Jul-2025 22:52 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:47 by rmk")
                                                             (* lmm "19-NOV-82 00:23")
    (ffetch \SFAscent of (FONTCREATE FONTSPEC])

(FONTDESCENT
  [LAMBDA (FONTSPEC)                                         (* ; "Edited 14-Jul-2025 22:53 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:47 by rmk")
                                                             (* lmm "19-NOV-82 00:24")
                                                             (* ; "See comment in FONTASCENT")
    (ffetch \SFDescent of (FONTCREATE FONTSPEC])

(FONTHEIGHT
  [LAMBDA (FONTSPEC)                                         (* ; "Edited 14-Jul-2025 22:52 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:47 by rmk")
                                                             (* kbr%: " 9-Jan-86 18:29")
    (fetch (FONTDESCRIPTOR \SFHeight) of (FONTCREATE FONTSPEC])

(FONTPROP
  [LAMBDA (FONT PROP)                                        (* ; "Edited 23-Jul-2025 17:01 by rmk")
                                                             (* ; "Edited 13-Jul-2025 22:44 by rmk")
                                                             (* ; "Edited  8-Jun-2025 20:42 by rmk")
                                                             (* ; "Edited 24-May-2025 07:40 by rmk")
                                                             (* ; "Edited 18-May-2025 10:01 by rmk")
                                                             (* ; "Edited 16-May-2025 14:27 by rmk")
                                                             (* ; "Edited 13-May-2025 09:32 by rmk")
                                                             (* ; "Edited  2-May-2025 19:59 by rmk")
                                                             (* kbr%: "13-May-85 22:36")
    (SETQ FONT (FONTCREATE FONT))
    (SELECTQ PROP
        (HEIGHT (ffetch \SFHeight of FONT))
        (ASCENT (ffetch \SFAscent of FONT))
        (DESCENT (ffetch \SFDescent of FONT))
        (FAMILY (ffetch FONTFAMILY of FONT))
        (SIZE (ffetch FONTSIZE of FONT))
        (FACE (COPY (ffetch FONTFACE of FONT)))
        (WEIGHT (ffetch WEIGHT of (ffetch FONTFACE of FONT)))
        (SLOPE (ffetch SLOPE of (ffetch FONTFACE of FONT)))
        (EXPANSION (ffetch EXPANSION of (ffetch FONTFACE of FONT)))
        (FORECOLOR (ffetch FORECOLOR of (ffetch FONTFACE of FONT)))
        (BACKCOLOR (ffetch BACKCOLOR of (ffetch FONTFACE of FONT)))
        (ROTATION (ffetch ROTATION of FONT))
        (DEVICE (ffetch FONTDEVICE of FONT))
        (CHARENCODING [OR (ffetch FONTCHARENCODING of FONT)
                          (freplace FONTCHARENCODING of FONT
                             with (if (NEQ CHARSET 0)
                                      then 'MCCS
                                    elseif (MEMB (fetch (FONTDESCRIPTOR FONTFAMILY) of FONT)
                                                 NSFONTFAMILIES)
                                      then 'XCCS$
                                    elseif (MEMB (fetch (FONTDESCRIPTOR FONTFAMILY) of FONT)
                                                 ALTOFONTFAMILIES)
                                      then 'ALTOTEXT
                                    else (fetch (FONTDESCRIPTOR FONTFAMILY) of FONT])
        (SPEC (LIST (ffetch FONTFAMILY of FONT)
                    (ffetch FONTSIZE of FONT)
                    (COPY (ffetch FONTFACE of FONT))
                    (ffetch ROTATION of FONT)
                    (ffetch FONTDEVICE of FONT)))
        (DEVICESPEC                                          (* ; 
                    "DEVICE fields are for communicating coercions to the particular printing device")
                    [COND
                       ((ffetch FONTDEVICESPEC of FONT)
                        (COPY (ffetch FONTDEVICESPEC of FONT)))
                       (T (FONTPROP FONT 'SPEC])
        (DEVICEFACE [COPY (COND
                             ((ffetch FONTDEVICESPEC of FONT)
                              (CADDR (ffetch FONTDEVICESPEC of FONT)))
                             (T (ffetch FONTFACE of FONT])
        (DEVICESLOPE [fetch SLOPE of (COND
                                        ((ffetch FONTDEVICESPEC of FONT)
                                         (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                        (T (ffetch FONTFACE of FONT])
        (DEVICEWEIGHT [fetch WEIGHT of (COND
                                          ((ffetch FONTDEVICESPEC of FONT)
                                           (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                          (T (ffetch FONTFACE of FONT])
        (DEVICEEXPANSION 
             [fetch EXPANSION of (COND
                                    ((ffetch FONTDEVICESPEC of FONT)
                                     (CADDR (ffetch FONTDEVICESPEC of FONT)))
                                    (T (ffetch FONTFACE of FONT])
        (DEVICESIZE (COND
                       ((ffetch FONTDEVICESPEC of FONT)
                        (CADR (ffetch FONTDEVICESPEC of FONT)))
                       (T (ffetch FONTSIZE of FONT))))
        (DEVICEFAMILY (COND
                         ((ffetch FONTDEVICESPEC of FONT)
                          (CAR (ffetch FONTDEVICESPEC of FONT)))
                         (T (ffetch FONTFAMILY of FONT))))
        (SCALE (ffetch FONTSCALE of FONT))
        (CHARSETS (for CS CSINFO (CSVECTOR _ (ffetch FONTCHARSETVECTOR of FONT)) from 0 to 
                                                                                          \MAXCHARSET
                     eachtime (SETQ CSINFO (\GETBASEPTR CSVECTOR (UNFOLD CS 2))) when CSINFO
                     unless (fetch (CHARSETINFO CSSLUGP) of CSINFO) collect CS))
        (\ILLEGAL.ARG PROP])

(\AVGCHARWIDTH
  [LAMBDA (FONT)                                             (* ; "Edited 10-Jul-2025 23:24 by rmk")
                                                             (* ; "Edited 20-May-2025 21:03 by rmk")
                                                             (* rmk%: "27-Nov-84 18:40")

    (* ;; "Returns the average width of a character, to be used in units-to-characters approximations, as in fixing the linelength")

    (LET ((W (CHARWIDTH (CHARCODE A)
                    FONT)))
         (if (NEQ 0 W)
             then W
           elseif [NEQ 0 (SETQ W (FIXR (FTIMES 0.6 (FONTPROP FONT 'HEIGHT]
             then W
           else 1])
)



(* ;; "Moving character information")

(DEFINEQ

(EDITCHAR
  [LAMBDA (CHARCODE FONT)                                    (* ; "Edited 14-Jul-2025 22:54 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:47 by rmk")
                                                             (* rrb "24-MAR-82 12:22")
                                                             (* ; 
                                                   "calls the bitmap editor on a character of a font")
    (LET ((FONTDESC (FONTCREATE FONT)))
         (PUTCHARBITMAP CHARCODE FONTDESC (EDITBM (GETCHARBITMAP CHARCODE FONTDESC])
)



(* ; "Should this be on EDITFONT ?")

(DEFINEQ

(GETCHARBITMAP
  [LAMBDA (CHARCODE FONT)                                    (* ; "Edited  7-Jun-2025 09:55 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 26-Apr-89 21:49 by atm")
                                                             (* ; 
                      "returns a bitmap of the character CHARCODE from the font descriptor FONTDESC.")
    (SETQ CHARCODE (CHARCODE.DECODE CHARCODE))
    (\GETCHARBITMAP.CSINFO (\CHAR8CODE CHARCODE)
           (\INSURECHARSETINFO (\CHARSET CHARCODE)
                  (FONTCREATE FONT])

(PUTCHARBITMAP
  [LAMBDA (CHARCODE FONT NEWCHARBITMAP NEWCHARDESCENT)       (* ; "Edited  7-Jun-2025 10:16 by rmk")
                                                             (* ; "Edited 25-May-2025 15:10 by rmk")
                                                             (* ; "Edited 22-May-2025 09:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:21 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 27-Apr-89 11:19 by atm")

    (* ;; "Stores the bitmap NEWCHARBITMAP as the character CHARCODE in FONT.  If NEWCHARDESCENT is specified, it is the descent of the new bitmap, and things may be moved to accomodate it.")

    (CL:UNLESS (type? BITMAP NEWCHARBITMAP)
           (\ILLEGAL.ARG NEWCHARBITMAP))
    (SETQ CHARCODE (CHARCODE.DECODE CHARCODE))
    (SETQ FONT (FONTCREATE FONT))
    (LET ((CSINFO (\INSURECHARSETINFO (\CHARSET CHARCODE)
                         FONT)))
         (UNINTERRUPTABLY
             (CL:WHEN (\PUTCHARBITMAP.CSINFO (\CHAR8CODE CHARCODE)
                             CSINFO NEWCHARBITMAP NEWCHARDESCENT)

                 (* ;; "update the ascent/descent properties for the font as a whole.")

                 (LET [(ASCENT (IMAX (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                     (fetch (FONTDESCRIPTOR \SFAscent) of FONT)))
                       (DESCENT (IMAX (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)
                                      (fetch (FONTDESCRIPTOR \SFDescent) of FONT]
                      (replace (FONTDESCRIPTOR \SFAscent) of FONT with ASCENT)
                      (replace (FONTDESCRIPTOR \SFDescent) of FONT with DESCENT)
                      (replace (FONTDESCRIPTOR \SFHeight) of FONT with (IPLUS ASCENT DESCENT)))))
         NIL NEWCHARBITMAP])

(\GETCHARBITMAP.CSINFO
  [LAMBDA (CODE CSINFO)                                      (* ; "Edited  7-Jun-2025 09:56 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 26-Apr-89 21:49 by atm")
                                                             (* ; 
                      "returns a bitmap of the character CHARCODE from the font descriptor FONTDESC.")

    (* ;; "CODE is a thincode")

    (LET (CSBITMAP CBM CWDTH CHGHT)
         (CL:WHEN (SETQ CSBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
             (SETQ CHGHT (BITMAPHEIGHT CSBITMAP))
             (SETQ CBM (BITMAPCREATE (SETQ CWDTH (if (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO)
                                                     then (\FGETIMAGEWIDTH (fetch (CHARSETINFO 
                                                                                         IMAGEWIDTHS)
                                                                              of CSINFO)
                                                                 CODE)
                                                   else (\FGETWIDTH (fetch (CHARSETINFO WIDTHS)
                                                                       of CSINFO)
                                                               CODE)))
                              CHGHT
                              (fetch (BITMAP BITMAPBITSPERPIXEL) of CSBITMAP)))
             (BITBLT CSBITMAP (\FGETOFFSET (fetch (CHARSETINFO OFFSETS) of CSINFO)
                                     CODE)
                    0 CBM 0 0 CWDTH CHGHT))
         CBM])

(\PUTCHARBITMAP.CSINFO
  [LAMBDA (CODE CSINFO NEWCHARBITMAP NEWCHARDESCENT)         (* ; "Edited  7-Jun-2025 10:15 by rmk")
                                                             (* ; "Edited 25-May-2025 15:10 by rmk")
                                                             (* ; "Edited 22-May-2025 09:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:21 by rmk")
                                                             (* ; "Edited 25-Apr-2025 11:21 by rmk")
                                                             (* ; "Edited 27-Apr-89 11:19 by atm")

    (* ;; "Stores the bitmap NEWCHARBITMAP as the thin character CODE in CSINFO.  If NEWCHARDESCENT is specified, it is the descent of the new bitmap, and things may be moved to accomodate it.")

    (LET* ((CDESCENT (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
           (CASCENT (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
           (CHEIGHT (IPLUS CDESCENT CASCENT))
           (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
           (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
           (IMWIDTHS (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO))
           (CIMWIDTH (AND IMWIDTHS (\FGETIMAGEWIDTH IMWIDTHS CODE)))
           (CWIDTH (OR CIMWIDTH (\FGETWIDTH WIDTHS CODE)))
           (FONTBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
           (OFWIDTH (fetch (BITMAP BITMAPWIDTH) of FONTBITMAP))
           TEMPBITMAP BWIDTH DW BHEIGHT BASCENT BDESCENT NDESCENT NASCENT NHEIGHT CHAROFFSET
           (BITSPERPIXEL (fetch (BITMAP BITMAPBITSPERPIXEL) of FONTBITMAP)))

          (* ;; "fetch the ascents and descents of the bitmap and the new maximums.")

          (SETQ BWIDTH (fetch (BITMAP BITMAPWIDTH) of NEWCHARBITMAP))
          (SETQ BHEIGHT (fetch (BITMAP BITMAPHEIGHT) of NEWCHARBITMAP))
          (SETQ BDESCENT (OR NEWCHARDESCENT CDESCENT))
          (SETQ BASCENT (IDIFFERENCE BHEIGHT BDESCENT))
          (SETQ NDESCENT (IMAX BDESCENT CDESCENT))
          (SETQ NASCENT (IMAX BASCENT CASCENT))
          (SETQ NHEIGHT (IPLUS NDESCENT NASCENT))
          (SETQ CHAROFFSET (\FGETOFFSET OFFSETS CODE))

          (* ;; "set up a new target bitmap if any of the parameters have changed.")

          (if (EQ CHAROFFSET (\FGETOFFSET OFFSETS \MAXTHINCHAR))
              then 
                   (* ;; "changing the bitmap for a character which formerly pointed at the slug character.  Allocate a new bitmap character bitmap for this.")

                   (SETQ TEMPBITMAP (BITMAPCREATE (IPLUS OFWIDTH BWIDTH)
                                           NHEIGHT BITSPERPIXEL))
                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          OFWIDTH CHEIGHT)                   (* ; "copy the old characters over.")
                   (SETQ CHAROFFSET OFWIDTH)
            elseif (NEQ CWIDTH BWIDTH)
              then 
                   (* ;; "The bitmaps differ in width;  create a new bitmap with things at the right places, then update widths and offsets.")

                   (SETQ DW (IDIFFERENCE BWIDTH CWIDTH))     (* ; "Difference in character widths")
                   (SETQ TEMPBITMAP (BITMAPCREATE (IPLUS OFWIDTH DW)
                                           NHEIGHT BITSPERPIXEL)) 
                                                             (* ; 
                                "this may also be a taller bitmap if NHEIGHT is larger than CHEIGHT.")
                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          CHAROFFSET CHEIGHT)                (* ; 
                                                    "Copy that portion to the left of the character.")
                   (BITBLT FONTBITMAP (IPLUS CHAROFFSET CWIDTH)
                          0 TEMPBITMAP (IPLUS CHAROFFSET BWIDTH)
                          (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          (ADD1 (IDIFFERENCE OFWIDTH (IPLUS CHAROFFSET CWIDTH)))
                          CHEIGHT)                           (* ; 
                                               "Copy that portion to the right of the new character.")
            elseif (OR (IGREATERP BASCENT CASCENT)
                       (IGREATERP BDESCENT CDESCENT))
              then 
                   (* ;; 
                   "The new character is TALLER than the existing bitmap.  Make a larger bitmap.")

                   (SETQ TEMPBITMAP (BITMAPCREATE OFWIDTH NHEIGHT BITSPERPIXEL)) 

                   (* ;; "Copy the existing bitmap into it, adjusting for a larger descent in the new character (if there is one)")

                   (BITBLT FONTBITMAP 0 0 TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NDESCENT CDESCENT))
                          OFWIDTH CHEIGHT))

          (* ;; "copy the new bitmap in and update parameters.")

          (BITBLT NEWCHARBITMAP 0 0 (OR TEMPBITMAP FONTBITMAP)
                 CHAROFFSET
                 (IMAX 0 (IDIFFERENCE NDESCENT BDESCENT))
                 BWIDTH BHEIGHT)
          (CL:WHEN TEMPBITMAP
              (UNINTERRUPTABLY
                                                             (* ; 
                                                      "update the parameters for this character set.")
                  (\FSETWIDTH WIDTHS CODE BWIDTH)            (* ; "The new character's correct width")
                                                             (* ; 
                                                          "Make sure that we update imagewidths also")
                  (CL:WHEN IMWIDTHS (\FSETIMAGEWIDTH IMWIDTHS CODE BWIDTH))
                  (\FSETOFFSET OFFSETS CODE CHAROFFSET)
                  (CL:WHEN DW
                      (for I from 0 to \MAXTHINCHAR when (IGREATERP (\FGETOFFSET OFFSETS I)
                                                                CHAROFFSET)
                         do 
                            (* ;; 
         "If the imagewidth has changed, offsets after the modified character have to be adjusted.  ")

                            (add (\FGETOFFSET OFFSETS I)
                                 DW)))
                  (replace (CHARSETINFO CHARSETBITMAP) of CSINFO with TEMPBITMAP)
                  (replace (CHARSETINFO CHARSETDESCENT) of CSINFO with NDESCENT)
                  (replace (CHARSETINFO CHARSETASCENT) of CSINFO with NASCENT))
              NEWCHARBITMAP)])
)
(DEFINEQ

(MOVECHARBITMAP
  [LAMBDA (SRCECODE SRCEFONT DESTCODE DESTFONT CLIP)         (* ; "Edited 14-Jul-2025 22:53 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:47 by rmk")
                                                             (* ; "Edited 14-Dec-86 18:04 by Shih")

(* ;;; "moves a character from one font to another, clipping if necessary.")

    (PROG ((SRCEDESC (FONTCREATE SRCEFONT))
           (DESTDESC (FONTCREATE DESTFONT))
           SRCEASCENT SRCEDESCENT DESTASCENT DESTDESCENT CHARBITMAP TEMPBITMAP NEWASCENT NEWDESCENT)
          (SETQ CHARBITMAP (GETCHARBITMAP SRCECODE SRCEFONT))
          (SETQ SRCEASCENT (FONTPROP SRCEDESC 'ASCENT))
          (SETQ DESTASCENT (FONTPROP DESTDESC 'ASCENT))
          (SETQ SRCEDESCENT (FONTPROP SRCEDESC 'DESCENT))
          (SETQ DESTDESCENT (FONTPROP DESTDESC 'DESCENT))
          [SETQ NEWASCENT (COND
                             (CLIP DESTASCENT)
                             (T (IMAX SRCEASCENT DESTASCENT]
          [SETQ NEWDESCENT (COND
                              (CLIP DESTDESCENT)
                              (T (IMAX SRCEDESCENT DESTDESCENT]
          [COND
             ((OR (NEQ SRCEASCENT NEWASCENT)
                  (NEQ SRCEDESCENT NEWDESCENT))
              (SETQ TEMPBITMAP (BITMAPCREATE (BITMAPWIDTH CHARBITMAP)
                                      (IPLUS NEWASCENT NEWDESCENT)))
              (BITBLT CHARBITMAP 0 (IMAX 0 (IDIFFERENCE SRCEDESCENT NEWDESCENT))
                     TEMPBITMAP 0 (IMAX 0 (IDIFFERENCE NEWDESCENT SRCEDESCENT))
                     (BITMAPWIDTH CHARBITMAP)
                     (IMIN (IPLUS SRCEASCENT SRCEDESCENT)
                           (IPLUS NEWASCENT NEWDESCENT]
          (PUTCHARBITMAP DESTCODE DESTFONT (OR TEMPBITMAP CHARBITMAP)
                 NEWDESCENT])

(MOVEFONTCHARS
  [LAMBDA (PAIRS DESTFONT DEFAULTSOURCEFONT)                 (* ; "Edited 24-Jul-2025 21:05 by rmk")
                                                             (* ; "Edited  9-Jul-2025 09:13 by rmk")
                                                             (* ; "Edited 17-Jun-2025 19:53 by rmk")
                                                             (* ; "Edited  7-Jun-2025 00:06 by rmk")
                                                             (* ; "Edited 23-May-2025 15:02 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")
                                                             (* ; "Edited 13-May-2025 08:56 by rmk")
                                                             (* ; "Edited  1-May-2025 13:20 by rmk")

    (* ;; "The character information for schar in sfont replaces the information for the destination character in the destination font.")

    (* ;; "Pairs is a list of (SOURCE DEST) pairs where each source  is a list of the form (schar/code sfont) or just a character, and each DEST is a destination character/code. If a pair is a character code C, it is treated as (C C).")

    (* ;; "If a pair does not contain its own source font, then information is extracted from the DEFAULTSOURCEFONT.  If the DEFAULTSOURCEFONT is not provided, thenSFONT it is assumed that the source is the DESTFONT (which must always be provided).")

    (* ;; "This collects the source information for all the pairs before it starts, to make sure that it doesn't step on itself when source and destination are the same font.")

    (CL:WHEN PAIRS
        (SETQ DESTFONT (FONTCREATE DESTFONT))
        (LET ((DEVICE (FONTPROP DESTFONT 'DEVICE))
              PAIRINFO)
             (SETQ DEFAULTSOURCEFONT (CL:IF DEFAULTSOURCEFONT
                                         (FONTCREATE DEFAULTSOURCEFONT NIL NIL NIL DEVICE)
                                         DESTFONT))

             (* ;; "Fix/check arguments, and expand out the information for all the source characters, so there is no toe-stepping if there are overlaps.")

             (SETQ PAIRINFO (for P S SCODE SFONT DCODE SCSINFO DCSINFO in PAIRS
                               collect (CL:WHEN (SMALLP P)
                                           (SETQ P (LIST P P)))
                                     (SETQ S (CAR P))
                                     (SETQ DCODE (CADR P))
                                     (CL:UNLESS (CHARCODEP DCODE)
                                         (SETQ DCODE (CHARCODE.DECODE DCODE)))
                                     (CL:UNLESS (\INSURECHARSETINFO (\CHARSET DCODE)
                                                       DESTFONT))
                                     (SETQ SCODE (CL:IF (LISTP S)
                                                     (CAR S)
                                                     S))
                                     (CL:UNLESS (CHARCODEP SCODE)
                                         (SETQ SCODE (CHARCODE.DECODE SCODE)))
                                     (SETQ SFONT (CL:IF (LISTP S)
                                                     (FONTCREATE (CADR S)
                                                            NIL NIL NIL DEVICE)
                                                     DEFAULTSOURCEFONT))
                                     (CL:UNLESS (SETQ SCSINFO (\INSURECHARSETINFO (\CHARSET SCODE)
                                                                     SFONT)))
                                     (CL:UNLESS (SETQ DCSINFO (\INSURECHARSETINFO (\CHARSET DCODE)
                                                                     DESTFONT))

                                         (* ;; 
   "If the destination csinfo doesn't exist, initialize with a copy of the source character's csinfo")

                                         (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of DESTFONT)
                                                (\CHARSET DCODE)
                                                (COPYALL SCSINFO)))
                                     (LIST (LIST SCODE (\GETCHARINFO SCSINFO (\CHAR8CODE SCODE)))
                                           DCODE)))

             (* ;; "Install source character information into the destination font.  ")

             (for P DCHARCODE DCSINFO ASCENT DESCENT in PAIRINFO
                do (SETQ DCHARCODE (CADR P))
                   (SETQ DCSINFO (\XGETCHARSETINFO DESTFONT (\CHARSET DCHARCODE)))
                   (CL:WHEN (fetch (CHARSETINFO CSSLUGP) of DCSINFO)
                                                             (* ; "Break the slug-sharing")
                       (SETQ DCSINFO (create CHARSETINFO copying DCSINFO CSSLUGP _ NIL))
                       (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR))
                              (\CHARSET DCHARCODE)
                              DCSINFO))
                   (\MOVEFONTCHAR (CADAR P)
                          DCSINFO
                          (\CHAR8CODE (CAAR P))
                          (\CHAR8CODE DCHARCODE)
                          DESTFONT))))
    DESTFONT])

(\MOVEFONTCHAR
  [LAMBDA (SCHARINFO DCSINFO SCODE DCODE DFONT)              (* ; "Edited 24-Jul-2025 10:47 by rmk")
                                                             (* ; "Edited 22-Jul-2025 13:18 by rmk")
                                                             (* ; "Edited  8-Jul-2025 22:23 by rmk")
                                                             (* ; "Edited 17-Jun-2025 19:53 by rmk")
                                                             (* ; "Edited  7-Jun-2025 14:43 by rmk")

    (* ;; "Internal CSINFO-level function to move the information for (thinchar) SCODE in the source CSINFO to (thinchar) DCODE) in the destination CSINFO.")

    (* ;; "The caller (MOVEFONTCHARS) may have provided the source character information as an alist structure to avoid stepping on toes.  If SCHARINFO is a CSINFO, the alist is extracted here.")

    (* ;; "If DFONT is provided, its ascent and descent may be adjusted to reflect SCHARINFO.")

    (CL:WHEN (type? CHARSETINFO SCHARINFO)
        (SETQ SCHARINFO (\GETCHARINFO SCHARINFO SCODE)))
    (LET (DESCENT ASCENT TEMP)
         (CL:WHEN [AND (FGETMULTI SCHARINFO 'IMAGEWIDTHS)
                       (NEQ (FGETMULTI SCHARINFO 'WIDTHS)
                            (FGETMULTI SCHARINFO 'IMAGEWIDTHS))
                       (OR (EQ (ffetch (CHARSETINFO WIDTHS) of DCSINFO)
                               (ffetch (CHARSETINFO IMAGEWIDTHS) of DCSINFO))
                           (NULL (ffetch (CHARSETINFO IMAGEWIDTHS) of DCSINFO]

             (* ;; "We have to split the width and imagewidth vectors in preparation, if the character values are different but the dest vectors are EQ. ")

             (replace (CHARSETINFO IMAGEWIDTHS) of DCSINFO with (\COPYARRAYBLOCK (ffetch (CHARSETINFO
                                                                                          WIDTHS)
                                                                                    of DCSINFO))))
         (CL:WHEN (SETQ TEMP (FGETMULTI SCHARINFO 'BITMAP))
             (\PUTCHARBITMAP.CSINFO DCODE DCSINFO TEMP (FGETMULTI SCHARINFO 'DESCENT)))
         (UPDATEINFOELEMENT WIDTHS)
         (UPDATEINFOELEMENT IMAGEWIDTHS)
         (UPDATEINFOELEMENT YWIDTHS)
         (CL:WHEN (FGETMULTI SCHARINFO 'LEFTKERN)
             (\FSETLEFTKERN DCSINFO DCODE (FGETMULTI SCHARINFO 'LEFTKERN)))
         (SETQ DESCENT (IMAX (FGETMULTI SCHARINFO 'DESCENT)
                             (fetch (CHARSETINFO CHARSETDESCENT) of DCSINFO)))
         (SETQ ASCENT (IMAX (FGETMULTI SCHARINFO 'ASCENT)
                            (fetch (CHARSETINFO CHARSETASCENT) of DCSINFO)))
         (replace (CHARSETINFO CHARSETDESCENT) of DCSINFO with DESCENT)
         (replace (CHARSETINFO CHARSETASCENT) of DCSINFO with ASCENT)
         (replace (CHARSETINFO CSSLUGP) of DCSINFO with NIL)
         (CL:WHEN DFONT
             (SETQ DESCENT (IMAX DESCENT (fetch (FONTDESCRIPTOR \SFDescent) of DFONT)))
             (SETQ ASCENT (IMAX ASCENT (fetch (FONTDESCRIPTOR \SFAscent) of DFONT)))
             (replace (FONTDESCRIPTOR \SFAscent) of DFONT with ASCENT)
             (replace (FONTDESCRIPTOR \SFDescent) of DFONT with DESCENT)
             (replace (FONTDESCRIPTOR \SFHeight) of DFONT with (IPLUS DESCENT ASCENT)))
         DCSINFO])

(SLUGCHARP.DISPLAY
  [LAMBDA (CODE FONT/CHARSETINFO)                            (* ; "Edited  6-Jun-2025 10:24 by rmk")
                                                             (* ; "Edited 31-May-2025 23:44 by rmk")

    (* ;; "True if CODE is currently a slug in FONT or the particular CHARSETINFO.  If we are given a CSINFO, CODE is alread charset-relative.")

    (LET [(CSINFO (CL:IF (type? CHARSETINFO FONT/CHARSETINFO)
                      FONT/CHARSETINFO
                      (\XGETCHARSETINFO FONT/CHARSETINFO (\CHARSET CODE)))]
         (OR (NULL CSINFO)
             (fetch (CHARSETINFO CSSLUGP) of CSINFO)
             (EQ (\GETBASE (fetch (CHARSETINFO OFFSETS) of CSINFO)
                        (\CHAR8CODE CODE))
                 (\GETBASE (fetch (CHARSETINFO OFFSETS) of CSINFO)
                        (ADD1 \MAXTHINCHAR])

(\GETCHARINFO
  [LAMBDA (CSINFO CHAR8CODE)                                 (* ; "Edited 23-Jul-2025 15:59 by rmk")
                                                             (* ; "Edited 22-Jul-2025 12:48 by rmk")
                                                             (* ; "Edited  8-Jul-2025 22:50 by rmk")
                                                             (* ; "Edited  7-Jun-2025 14:35 by rmk")
    (LET (TEMP)
         `((ASCENT \, (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
           (DESCENT \, (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
           (WIDTHS \, (CL:WHEN (SETQ TEMP (ffetch (CHARSETINFO WIDTHS) of CSINFO))
                             (\FGETWIDTH TEMP CHAR8CODE)))
           (YWIDTHS \, (CL:WHEN (SETQ TEMP (ffetch (CHARSETINFO YWIDTHS) of CSINFO))
                              (\FGETWIDTH TEMP CHAR8CODE)))
           (IMAGEWIDTHS \, (CL:WHEN (SETQ TEMP (ffetch (CHARSETINFO IMAGEWIDTHS) of CSINFO))
                                  (\FGETWIDTH TEMP CHAR8CODE)))
           (LEFTKERN \, (CL:WHEN (ARRAYP (fetch (CHARSETINFO LEFTKERN) of CSINFO))
                            (ELT (fetch (CHARSETINFO LEFTKERN) of CSINFO)
                                 CHAR8CODE)))
           (BITMAP \, (CL:WHEN (SETQ TEMP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
                             (\GETCHARBITMAP.CSINFO CHAR8CODE CSINFO])
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS UPDATEINFOELEMENT MACRO [(FIELD)
                                   (LET [(DBLOCK (ffetch (CHARSETINFO FIELD) of DCSINFO))
                                         (NEWVAL (FGETMULTI SCHARINFO 'FIELD]
                                        (CL:WHEN NEWVAL
                                            (CL:UNLESS DBLOCK
                                                (SETQ DBLOCK (\CREATECSINFOELEMENT))
                                                (freplace (CHARSETINFO FIELD) of DCSINFO with DBLOCK))
                                            (\FSETWIDTH DBLOCK DCODE NEWVAL))])
)



(* ;; 
"\FINDFONTFILE \FONTFILENAME \SEARCHFONTFILES \FONTINFOFROMFILENAME are redefined to deal with character-set directories.  That behavior is conditioned on the setting of the global variable *USEOLDFONTDIRECTORIES*, T at PARC, maybe NIL most other places.  "
)

(DEFINEQ

(FONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST)
                                                             (* ; "Edited 11-Jul-2025 09:42 by rmk")
                                                             (* ; "Edited  6-Jul-2025 10:40 by rmk")
                                                             (* ; "Edited 19-Jun-2025 17:09 by rmk")
                                                             (* ; "Edited 13-Jun-2025 22:48 by rmk")
                                                             (* ; "Edited  9-Jun-2025 09:57 by rmk")
                                                             (* ; "Edited 17-May-2025 00:06 by rmk")
                                                             (* ; "Edited 15-May-2025 16:29 by rmk")

    (* ;; "Considers all posible names for font files that respect the given characteristics, returns a list of the names of files that actually exist somewhere in DIRLST.  Does not validate their contents.")

    [SETQ DIRLST (MKLIST (OR DIRLST (GETATOMVAL (PACK* DEVICE "FONTDIRECTORIES"]
    [SETQ EXTLST (MKLIST (OR EXTLST (GETATOMVAL (PACK* DEVICE "FONTEXTENSIONS"]
    (CL:UNLESS CHARSET (SETQ CHARSET \DEFAULTCHARSET))
    (APPEND (MKLIST (\FINDFONTFILE FAMILY SIZE FACE ROTATION DEVICE 'NOCHARSET DIRLST EXTLST))
           (MKLIST (\FINDFONTFILE FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST])

(\FINDFONTFILE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET DIRLST EXTLST)
                                                             (* ; "Edited  9-Jun-2025 09:40 by rmk")
                                                             (* ; "Edited 15-May-2025 22:41 by rmk")
                                                             (* ; "Edited 14-Sep-96 10:53 by rmk:")
                                                             (* ; "Edited  6-Oct-89 11:18 by bvm")

    (* ;; "Find any font file on any directory with any naming convention with any extension.  Note that ROTATION and DEVICE are just place holders.   DEVICE is irrelevant because DIRLST already incorporates the device information.  The variable *OLD-FONT-EXTENSIONS* can be set to suppress using the old-style lookup.  If set to a list of extensions, just those will be looked up with old-style conventions.")

    (for EXT FONTFILE inside EXTLST
       when (SETQ FONTFILE (FINDFILE (if (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                         then (\FONTFILENAME.OLD FAMILY SIZE FACE EXT CHARSET)
                                       else (\FONTFILENAME FAMILY SIZE FACE EXT CHARSET))
                                  T DIRLST)) collect FONTFILE finally 

                                                                    (* ;; 
                                       "Backward compatibility for devices that expect a single file")

                                                                    (CL:UNLESS (CDR $$VAL)
                                                                        (RETURN (CAR $$VAL)))])

(\FONTFILENAMES
  [LAMBDA (FAMILY SIZE FACE DEVICE EXTENSIONS)               (* ; "Edited 17-May-2025 12:15 by rmk")
    (APPEND [for EXT inside EXTENSIONS collect (IF (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                                   THEN (\FONTFILENAME.OLD FAMILY SIZE FACE EXT
                                                               'ALL)
                                                 ELSE (\FONTFILENAME FAMILY SIZE FACE EXT
                                                             'ALL]
           (for EXT inside EXTENSIONS collect (IF (FMEMB EXT *OLD-FONT-EXTENSIONS*)
                                                  THEN (\FONTFILENAME.OLD FAMILY SIZE FACE EXT 0)
                                                ELSE (\FONTFILENAME FAMILY SIZE FACE EXT 0])

(\FONTFILENAME
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)               (* ; "Edited 11-Jul-2025 09:39 by rmk")
                                                             (* ; "Edited 15-May-2025 15:51 by rmk")
                                                             (* ; "Edited  5-Mar-93 16:10 by rmk:")

    (* ;; "Strike file naming convention (w/o dashes, no charset) no longer supported.  New name is of the form %"familysize-face-Ccharset.ext%", e.g., MODERN12-MRR-C357.WD")

    (* ;; "**bvm 10/5/89 Slight change: partition fonts into subdirectories by charset, e.g., all Charset zero fonts are in subdirectory C0>.  This significantly speeds up any font operation that requires any local directory work (e.g., NFS servers on both Sun and D machine), and FONTSAVAILABLE on any device (since it doesn't have to wade thru all those charsets).  This behavior is conditioned on the value of *USEOLDFONTDIRECTORIES*")

    (SETQ FACE (\FONTFACE FACE))                             (* ; "Validate face")
    (LET* ([SIZEPATT (COND
                        ((EQ SIZE '*)
                         SIZE)
                        ((FIXP SIZE)
                         (if (< SIZE 10)
                             then (CONCAT 0 SIZE)
                           else SIZE))
                        (T (\ILLEGAL.ARG SIZE]
           (CSETNAME (COND
                        ((OR (NULL CHARSET)
                             (EQ CHARSET 0))                 (* ; "Charset defaults to zero.")
                         "0")
                        ((FIXP CHARSET)
                         (LET ((*PRINT-BASE* 8)
                               (*PRINT-RADIX* NIL))          (* ; "Longhand for (cl:write-to-string charset :radix nil :base 8), which is twice as slow, due to lousy keyword handling")
                              (\PRINDATUM.TO.STRING CHARSET)))
                        ((EQ CHARSET 'NOCHARSET)             (* ; "Don't want the charset indicated")
                         NIL)
                        (T                                   (* ; "Somebody made the string already?")
                           CHARSET)))
           [FACESPEC (LIST (CHCON1 (fetch (FONTFACE WEIGHT) of FACE))
                           (CHCON1 (fetch (FONTFACE SLOPE) of FACE))
                           (CHCON1 (fetch (FONTFACE EXPANSION) of FACE]
           (TAIL FACESPEC))
          [if (OR (EQ (CAR TAIL)
                      (CHARCODE *))
                  (EQ (CAR (SETQ TAIL (CDR TAIL)))
                      (CHARCODE *)))
              then                                           (* ; 
              "Avoid adjacent wildcards because some devices (notably DSK) get exponentially slower.")
                   (while (EQ (CADR TAIL)
                              (CHARCODE *)) do (RPLACD TAIL (CDDR TAIL]

          (* ;; "Fortunately, CONCAT ignores packages.")

          (PACKFILENAME.STRING 'NAME (CONCAT (if *USEOLDFONTDIRECTORIES*
                                                 then ""
                                               elseif CSETNAME
                                                 then (CONCAT (PROGN 
                                                             (* ; 
                     "Lowercase because it's in a directory name, so maybe Unix will find it sooner?")
                                                                     "c")
                                                             CSETNAME ">")
                                               else "")
                                            FAMILY SIZEPATT "-" (CONCATCODES FACESPEC)
                                            (CL:IF CSETNAME
                                                (CONCAT "-C" CSETNAME)
                                                ""))
                 'EXTENSION EXTENSION])

(\FONTFILENAME.OLD
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)           (* ; "Edited 23-Sep-92 18:22 by jds")

    (* ;; "Returns old style font file names.  They were ambiguous because you could not ask for e.g. FACE (MEDIUM * REGULAR) because it maps to FamilySize-*-Charset, which also matches (BOLD * COMPRESSED), etc.  Keep this function around though for user's who don't rename their files.")
                                                             (* ; 
                     "Returns the name of the file that should contain the information for a font.")
    (SETQ FACE (\FONTFACE FACE))                         (* ; "Force legal canonical face")
    (SETQ FACE (COND
                  ((AND (EQ (CAR FACE)
                            '*)
                        (EQ (CADR FACE)
                            '*))

                   (* ;; "Avoid  adjacent wildcards because DSK gets slower exponentially (can take loooong tiiiiiime).  No need to check compression.")

                   '*)
                  (T FACE)))
    (PACKFILENAME.STRING 'NAME [PROGN 
                                      (* ;; "DISPLAYFONT AC WD and the default case")

                                      (CONCAT (CDR (SASSOC FAMILY *DISPLAY-FONT-NAME-MAP*))
                                             (COND
                                                ((EQ SIZE '*)
                                                 SIZE)
                                                ((FIXP SIZE)
                                                 (COND
                                                    ((< SIZE 10)
                                                     (CONCAT 0 SIZE))
                                                    (T SIZE)))
                                                (T (\ILLEGAL.ARG SIZE)))
                                             [COND
                                                ((EQ FACE '*)
                                                 '*)
                                                (T (SELECTQ (fetch WEIGHT of FACE)
                                                       (BOLD (SELECTQ (fetch SLOPE of FACE)
                                                                 (ITALIC "D")
                                                                 "B"))
                                                       (SELECTQ (fetch SLOPE of FACE)
                                                           (ITALIC "I")
                                                           "R"]
                                             (COND
                                                ((FIXP CHARSET)
                                                 (LET ((*PRINT-BASE* 8))
                                                      (CL:FORMAT NIL "~O" CHARSET)))
                                                (T "000"]
           'EXTENSION EXTENSION])

(\FONTFILENAME.NEW
  [LAMBDA (FAMILY SIZE FACE EXTENSION CHARSET)           (* ; "Edited 30-Mar-87 20:00 by FS")

    (* ;; "Strike file naming convention (w/o dashes, no charset) no longer supported.")

    (LET (NAME SIZEPATT)
         (SETQ FACE (\FONTFACE FACE))                    (* ; "Validate face")
         [SETQ SIZEPATT (COND
                           ((EQ SIZE '*)
                            SIZE)
                           ((FIXP SIZE)
                            (if (< SIZE 10)
                                then (CONCAT 0 SIZE)
                              else SIZE))
                           (T (\ILLEGAL.ARG SIZE]

         (* ;; "Avoid adjacent wildcards because some devices (notably DSK) get exponentially slower.  Nicely, PACK & CONCAT ignore packages.")

         (PACKFILENAME.STRING 'NAME (CONCAT FAMILY SIZEPATT "-"
                                           [COND
                                              ((EQUAL FACE '

         (* * *)
)
                                               '*)
                                              (T (CONCAT (NTHCHAR (fetch (FONTFACE WEIGHT)
                                                                     of FACE)
                                                                1)
                                                        (NTHCHAR (fetch (FONTFACE SLOPE)
                                                                    of FACE)
                                                               1)
                                                        (NTHCHAR (fetch (FONTFACE EXPANSION)
                                                                    of FACE)
                                                               1]
                                           (COND
                                              [(FIXP CHARSET)
                                               (LET ((*PRINT-BASE* 8))
                                                    (CONCAT "-C" (\PRINDATUM.TO.STRING CHARSET]
                                              (CHARSET (CONCAT "-C" CHARSET))
                                              (T "-C0")))
                'EXTENSION EXTENSION])

(\FONTINFOFROMFILENAME
  [LAMBDA (FONTFILE DEVICE NOCHARSET)                        (* ; "Edited 10-Jul-2025 09:42 by rmk")
                                                             (* ; "Edited 26-Jun-2025 23:03 by rmk")
                                                             (* ; "Edited 14-Sep-96 10:23 by rmk:")
                                                             (* ; "Edited  5-Oct-89 18:28 by bvm")

    (* ;; "returns a list of the family size face rotation device of the font stored in the file name FONTFILE.  Rotation is 0 always.  Parses both new & old format files.")

    (LET ((FILENAMELIST (UNPACKFILENAME.STRING FONTFILE))
          CH SIZEBEG SIZEND NAME FAMILY SIZE FACE EXT CHARSET)
         (SETQ NAME (LISTGET FILENAMELIST 'NAME))            (* ; 
           "find where the name and size are.  MUST check for ch nil below or possible infinite loop")
         (SETQ SIZEBEG (for CH# from 1 when (OR (NUMBERP (SETQ CH (NTHCHAR NAME CH#)))
                                                (NULL CH)) do (RETURN CH#)))

         (* ;; "Get Family")

         [SETQ FAMILY (MKATOM (U-CASE (SUBSTRING NAME 1 (SUB1 SIZEBEG]

         (* ;; "Get Size")

         [SETQ SIZEND (find CH# from SIZEBEG suchthat (NOT (NUMBERP (NTHCHAR NAME CH#]
         [SETQ SIZE (MKATOM (SUBSTRING NAME SIZEBEG (SUB1 SIZEND]
         (if (EQ (NTHCHAR NAME SIZEND)
                 '-)
             then (SETQ SIZEND (ADD1 SIZEND)))

         (* ;; "Get Face")

         (SETQ NAME (U-CASE NAME))                           (* ; 
                                                     "don't need name, but checks for lowercase face")
         [SETQ FACE (LIST (COND
                             ((STRPOS "B" NAME SIZEND NIL T NIL UPPERCASEARRAY)
                              'BOLD)
                             ((STRPOS "L" NAME SIZEND NIL T NIL UPPERCASEARRAY)
                              'LIGHT)
                             (T 'MEDIUM))
                          (COND
                             ((STRPOS "I" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'ITALIC)
                             (T 'REGULAR))
                          (COND
                             ((STRPOS "E" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'EXPANDED)
                             ((STRPOS "C-" NAME SIZEND NIL NIL NIL UPPERCASEARRAY)
                              'COMPRESSED)
                             (T 'REGULAR]
         (CL:WHEN (SETQ CHARSET (STRPOS "-c" NAME NIL NIL NIL T UPPERCASEARRAY))
             [SETQ CHARSET (FIXP (MKATOM (CONCAT (SUBSTRING NAME CHARSET)
                                                "Q"])
         (LIST* FAMILY SIZE FACE 0 (COND
                                      ((STREAMP DEVICE)
                                       (IMAGESTREAMTYPE DEVICE))
                                      ((NULL DEVICE)
                                       [SETQ EXT (MKATOM (U-CASE (LISTGET FILENAMELIST 'EXTENSION]
                                       (SELECTQ EXT
                                           ((WD MEDLEYINTERPRESSFONT) 
                                                'INTERPRESS)
                                           ((STRIKE AC DISPLAYFONT MEDLEYDISPLAYFONT) 
                                                'DISPLAY)
                                           EXT))
                                      ((LITATOM DEVICE)
                                       (\FONTSYMBOL DEVICE))
                                      (T DEVICE))
                (CL:UNLESS NOCHARSET (CONS CHARSET])

(\FONTINFOFROMFILENAME.OLD
  [LAMBDA (FONTFILE DEVICE)                              (* ; "Edited  1-Jan-87 01:29 by FS")

    (* ;; "returns a list of the family size face rotation device of the font stored in the file name FONTFILE.")

    (PROG ((FILENAMELIST (UNPACKFILENAME FONTFILE))
           SIZEBEG SIZEND NAME FAMILY SIZE)
          (SETQ NAME (LISTGET FILENAMELIST 'NAME))           (* ; 
                                                           "find where the name and size are.")
          (SETQ SIZEBEG (for CH# from 1 when (NUMBERP (NTHCHAR NAME CH#))
                           do (RETURN CH#)))
          [SETQ FAMILY (MKATOM (SUBSTRING NAME 1 (SUB1 SIZEBEG]
          (SETQ SIZEND (for CH# from SIZEBEG when (NOT (NUMBERP (NTHCHAR NAME CH#)))
                          do (RETURN CH#)))
          [SETQ SIZE (MKATOM (SUBSTRING NAME SIZEBEG (SUB1 SIZEND]
          (RETURN (LIST FAMILY SIZE (SELECTQ (LISTGET FILENAMELIST 'EXTENSION)
                                        ((DISPLAYFONT AC WD) 
                                             (LIST (COND
                                                      ((STRPOS "-B" NAME SIZEND NIL T)
                                                       'BOLD)
                                                      (T 'MEDIUM))
                                                   (COND
                                                      ((STRPOS "-I" NAME SIZEND NIL)
                                                       'ITALIC)
                                                      (T 'REGULAR))
                                                   'REGULAR))
                                        (LIST (COND
                                                 ((STRPOS "B" NAME SIZEND NIL T)
                                                  'BOLD)
                                                 (T 'MEDIUM))
                                              (COND
                                                 ((STRPOS "I" NAME SIZEND NIL)
                                                  'ITALIC)
                                                 (T 'REGULAR))
                                              'REGULAR))
                        0 DEVICE])
)



(* (* ; "Do we still want old fonts?") (ADDVARS (*OLD-FONT-EXTENSIONS* STRIKE)))


(RPAQ? *OLD-FONT-EXTENSIONS* NIL)

(RPAQ? *USEOLDFONTDIRECTORIES* NIL)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS *OLD-FONT-EXTENSIONS* *USEOLDFONTDIRECTORIES*)
)
(DEFINEQ

(FONTCOPY
  [LAMBDA FONTSPECS                                          (* ; "Edited 14-Jul-2025 23:04 by rmk")
                                                             (* ; "Edited  5-Jul-2025 18:54 by rmk")
                                                             (* ; "Edited 10-Nov-87 17:12 by FS")
                                                             (* ; 
                                              "makes a copy of a font changing the specified fields.")
    (PROG (NOERROR ERROR FAMILY FACE SIZE ROTATION DEVICE OLDFONT)

     (* ;; "Set NOERROR if we find it as a prop, but set ERROR if we find a PROP which is illegal.  Then just return NIL if NOERROR and ERROR, otherwise, call FONTCREATE.")

          [SETQ OLDFONT (FONTCREATE (ARG FONTSPECS 1)
                               NIL NIL NIL
                               (CL:WHEN (type? FONTCLASS (ARG FONTSPECS 1))
                                   [COND
                                      ((AND (EQ FONTSPECS 2)
                                            (LISTP (ARG FONTSPECS 2)))
                                       (LISTGET (ARG FONTSPECS 2)
                                              'DEVICE))
                                      (T (for I from 2 by 2 to FONTSPECS
                                            do (COND
                                                  ((AND (NEQ I FONTSPECS)
                                                        (EQ (ARG FONTSPECS I)
                                                            'DEVICE))
                                                   (RETURN (ARG FONTSPECS (ADD1 I])]
          (SETQ FAMILY (fetch (FONTDESCRIPTOR FONTFAMILY) of OLDFONT))
          (SETQ SIZE (fetch (FONTDESCRIPTOR FONTSIZE) of OLDFONT))
          (SETQ FACE (fetch (FONTDESCRIPTOR FONTFACE) of OLDFONT))
          (SETQ ROTATION (fetch (FONTDESCRIPTOR ROTATION) of OLDFONT))
          (SETQ DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of OLDFONT))
          [for I VAL from 2 by 2 to FONTSPECS
             do [SETQ VAL (COND
                             ((NOT (EQ I FONTSPECS))
                              (ARG FONTSPECS (ADD1 I]
                (SELECTQ (ARG FONTSPECS I)
                    (FAMILY (SETQ FAMILY VAL))
                    (SIZE (SETQ SIZE VAL))
                    (FACE (SETQ FACE (\FONTFACE VAL)))
                    (WEIGHT (SETQ FACE (create FONTFACE using FACE WEIGHT _ VAL)))
                    (SLOPE (SETQ FACE (create FONTFACE using FACE SLOPE _ VAL)))
                    (EXPANSION (SETQ FACE (create FONTFACE using FACE EXPANSION _ VAL)))
                    (BACKCOLOR (SETQ FACE (create FONTFACE using FACE BACKCOLOR _ VAL)))
                    (FORECOLOR (SETQ FACE (create FONTFACE using FACE FORECOLOR _ VAL)))
                    (ROTATION (SETQ ROTATION VAL))
                    (DEVICE (SETQ DEVICE VAL))
                    (NOERROR (SETQ NOERROR VAL))
                    (COND
                       [(AND (EQ I 2)
                             (EQ FONTSPECS 2)
                             (LISTP (ARG FONTSPECS 2)))
                        (for J on (ARG FONTSPECS 2) by (CDDR J)
                           do (SETQ VAL (CADR J))
                              (SELECTQ (CAR J)
                                  (FAMILY (SETQ FAMILY VAL))
                                  (SIZE (SETQ SIZE VAL))
                                  (FACE (SETQ FACE (\FONTFACE VAL)))
                                  (WEIGHT (SETQ FACE (create FONTFACE using FACE WEIGHT _ VAL)))
                                  (SLOPE (SETQ FACE (create FONTFACE using FACE SLOPE _ VAL)))
                                  (EXPANSION (SETQ FACE (create FONTFACE using FACE EXPANSION _ VAL)))
                                  (BACKCOLOR (SETQ FACE (create FONTFACE using FACE BACKCOLOR _ VAL)))
                                  (FORECOLOR (SETQ FACE (create FONTFACE using FACE FORECOLOR _ VAL)))
                                  (ROTATION (SETQ ROTATION VAL))
                                  (DEVICE (SETQ DEVICE VAL))
                                  (NOERROR (SETQ NOERROR VAL))
                                  (COND
                                     (NOERROR 

                                            (* ;; 
    "Fell through the SELECTQ, so an illegal PROP.  But, if NOERROR, just note the error, otherwise ")

                                            (SETQ ERROR T))
                                     (T (\ILLEGAL.ARG (CAR J]
                       (T (if NOERROR
                              then (SETQ ERROR T)
                            else (\ILLEGAL.ARG (ARG FONTSPECS I]
          (RETURN (if (AND NOERROR ERROR)
                      then NIL
                    else (FONTCREATE FAMILY SIZE FACE ROTATION DEVICE NOERROR])

(FONTP
  [LAMBDA (X)                                            (* rmk%: "13-Sep-84 09:04")
                                                             (* ; "is X a FONTDESCRIPTOR?")
    (COND
       ((OR (type? FONTDESCRIPTOR X)
            (type? FONTCLASS X))
        X])

(FONTUNPARSE
  [LAMBDA (FONT)                                         (* kbr%: "25-Feb-86 19:40")

    (* ;; "Produces a minimal specification of the font or fontclass specification, for dumping by Tedit, imageobjects.")

    (PROG (FACE SPEC)
          (SETQ SPEC (COND
                        ((type? FONTDESCRIPTOR FONT)
                         (FONTPROP FONT 'SPEC))
                        [(type? FONTCLASS FONT)
                         (RETURN (CONS 'CLASS (FONTCLASSUNPARSE FONT]
                        (T 
                           (* ;; "Could be a non-instantiated specification in a fontclass, just use it as the spec without creating the font.")

                           FONT)))
          (OR SPEC (RETURN))
          (SETQ FACE (CADDR SPEC))                           (* ; 
                        "FACE and rotation can be NIL for a non-fontdescriptor fontclass component")
          [SETQ FACE (COND
                        ([OR (NULL FACE)
                             (EQUAL FACE '(MEDIUM REGULAR REGULAR]
                         NIL)
                        ((LITATOM FACE)
                         FACE)
                        [(LISTP FACE)
                         (PACK (LIST* (NTHCHAR (fetch (FONTFACE WEIGHT) of FACE)
                                             1)
                                      (NTHCHAR (fetch (FONTFACE SLOPE) of FACE)
                                             1)
                                      (NTHCHAR (fetch (FONTFACE EXPANSION) of FACE)
                                             1)
                                      (COND
                                         ((fetch (FONTFACE COLOR) of FACE)
                                          (LIST "-" (fetch (FONTFACE BACKCOLOR) of FACE)
                                                "-"
                                                (fetch (FONTFACE FORECOLOR) of FACE]
                        (T (SHOULDNT]                        (* ; 
                                                    "Don't return device, or any trailing defaults")
          (RETURN (CONS (CAR SPEC)
                        (CONS (CADR SPEC)
                              (COND
                                 ([AND (CADDDR SPEC)
                                       (NOT (EQ 0 (CADDDR SPEC]
                                  (LIST (OR FACE 'MRR)
                                        (CADDDR SPEC)))
                                 (FACE (CONS FACE])

(SETFONTDESCRIPTOR
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE FONT)            (* ; "Edited 21-Jul-2025 08:55 by rmk")
                                                             (* ; "Edited 14-Jul-2025 22:37 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited 19-Jun-2025 21:21 by rmk")
                                                             (* ; "Edited 14-Jun-2025 23:47 by rmk")
                                                             (* ; "Edited  1-Aug-88 16:16 by rmk:")
                                                             (* ; "Edited  5-Mar-87 19:28 by FS")

    (* ;; "Saves a font descriptor under a family/size/face/rotation/device key so that it will be retreived by FONTCREATE.  This is a user entry.")

    (DECLARE (GLOBALVARS \FONTSINCORE))
    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (PUTMULTI \FONTSINCORE FAMILY SIZE FACE ROTATION DEVICE (AND FONT (FONTCREATE FONT NIL NIL NIL 
                                                                             DEVICE])

(\STREAMCHARWIDTH
  [LAMBDA (CHARCODE STREAM TTBL)                         (* JonL " 8-NOV-83 03:31")

    (* ;; "Returns the width that the printed representation of CHARCODE would occupy if printed on STREAM, allowing for the various escape sequences.  Used by \ECHOCHAR")

    (SETQ CHARCODE (LOGAND CHARCODE \CHARMASK))
    ((LAMBDA (WIDTHSVECTOR)

       (* ;; "Note in following that if the DDWIDTHSCACHE exists and has a 0 entry for some character, that may someday mean that the character's glyph simply isn't loaded;  e.g., it may want #^A")

       (SETQ WIDTHSVECTOR (OR (AND (DISPLAYSTREAMP STREAM)
                                   (SETQ WIDTHSVECTOR (ffetch IMAGEDATA of STREAM))
                                   (ffetch DDWIDTHSCACHE of WIDTHSVECTOR))
                              \UNITWIDTHSVECTOR))
       (SELECTC (fetch CCECHO of (\SYNCODE (fetch (TERMTABLEP TERMSA)
                                                      of (OR (TERMTABLEP TTBL)
                                                                 \PRIMTERMTABLE))
                                                CHARCODE))
           (INDICATE.CCE ([LAMBDA (CC)
                            (IPLUS (if (IGEQ CHARCODE (CHARCODE %#^@))
                                       then              (* ; 
                                          "A META charcode -- implies that the 8th bit is non-zero")
                                             (SETQ CC (LOADBYTE CHARCODE 0 7))
                                             (\FGETWIDTH WIDTHSVECTOR (CHARCODE %#))
                                     else 0)
                                   (if (ILESSP CC (CHARCODE SPACE))
                                       then              (* ; "A CONTROL charcode")
                                             (add CC (CONSTANT (LLSH 1 6)))
                                             (\FGETWIDTH WIDTHSVECTOR (CHARCODE ^))
                                     else 0)
                                   (\FGETWIDTH WIDTHSVECTOR CC]
                          CHARCODE))
           (SIMULATE.CCE (SELCHARQ CHARCODE
                              ((EOL CR LF BELL) 
                                   NIL)
                              (ESCAPE (\FGETWIDTH WIDTHSVECTOR (CHARCODE $)))
                              (TAB (PROG ((SPACEWIDTH (\FGETWIDTH WIDTHSVECTOR (CHARCODE SPACE)))
                                          (NEWXPOSITON (DSPXPOSITION NIL STREAM))
                                          TABWIDTH)
                                         (SETQ TABWIDTH (UNFOLD SPACEWIDTH 8))
                                         [add NEWXPOSITON (SETQ TABWIDTH
                                                               (IDIFFERENCE
                                                                TABWIDTH
                                                                (IMOD (IDIFFERENCE NEWXPOSITON
                                                                             (DSPLEFTMARGIN NIL 
                                                                                    STREAM))
                                                                      TABWIDTH]
                                         (RETURN (if (IGREATERP NEWXPOSITON (DSPRIGHTMARGIN
                                                                                 NIL STREAM))
                                                     then 
                                                             (* ; 
                                                           "tab was past rightmargin, force cr.")
                                                           NIL
                                                   else TABWIDTH))))
                              (\FGETWIDTH WIDTHSVECTOR CHARCODE)))
           (REAL.CCE (SELECTC CHARCODE
                         ((CHARCODE (EOL CR LF)) 
                              NIL)
                         (ERASECHARCODE NIL)
                         (\FGETWIDTH WIDTHSVECTOR CHARCODE)))
           (IGNORE.CCE 0)
           (SHOULDNT])

(\UNITWIDTHSVECTOR
  [LAMBDA NIL                                            (* JonL " 7-NOV-83 19:23")
    (SETQ \UNITWIDTHSVECTOR (\ALLOCBLOCK (UNFOLD (IPLUS \MAXCHAR 3)
                                                WORDSPERCELL)))
    (for I from 0 to (IPLUS \MAXCHAR 2) do (\PUTBASE \UNITWIDTHSVECTOR I 1))
    \UNITWIDTHSVECTOR])

(\COERCECHARSET
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS THINCODE)
                                                             (* ; "Edited 24-Jul-2025 00:19 by rmk")
                                                             (* ; "Edited  8-Jul-2025 08:14 by rmk")
                                                             (* ; "Edited 11-Jun-2025 09:13 by rmk")
                                                             (* ; "Edited  7-Jun-2025 13:39 by rmk")
                                                             (* ; "Edited 21-May-2025 10:50 by rmk")

    (* ;; "COERCIONS is a set of (oldspec newspec) pairs, where a spec is either just a font name or a font name with a size.  If oldspec matches the current requested characteristics, then that csinfo is returned.")
                                                             (* ; "")
    (for C CSINFO FONT in (\COERCEFONTSPEC COERCIONS FAMILY SIZE FACE ROTATION DEVICE CHARSET)
       eachtime (SPREADFONTSPEC C) when [AND (SETQ FONT (FONTCREATE1 FAMILY SIZE FACE ROTATION DEVICE
                                                               CHARSET))
                                             (SETQ CSINFO (\INSURECHARSETINFO CHARSET FONT))
                                             (NOT (AND THINCODE (SLUGCHARP.DISPLAY THINCODE CSINFO]
       do (RETURN CSINFO])

(\BUILDSLUGCSINFO
  [LAMBDA (WIDTH HEIGHT DESCENT DEVICE SCALE)                (* ; "Edited 15-Jun-2025 12:42 by rmk")
                                                             (* ; "Edited 13-Jun-2025 22:55 by rmk")
                                                             (* ; "Edited 11-Jun-2025 10:56 by rmk")
                                                             (* ; "Edited 20-May-2025 14:50 by rmk")
                                                             (* ; "Edited 18-May-2025 21:52 by rmk")
                                                             (* ; "Edited 12-May-2025 21:09 by rmk")
                                                             (* ; "Edited  9-May-93 23:12 by rmk:")

    (* ;; "builds a csinfo which contains only the slug (black rectangle) character.  Maybe there should only be a single FONTDESC argument")

    (CL:WHEN (type? FONTDESCRIPTOR WIDTH)
        (SETQ HEIGHT (OR HEIGHT (fetch (FONTDESCRIPTOR \SFHeight) of WIDTH)))
        (SETQ DESCENT (OR DESCENT (fetch (FONTDESCRIPTOR \SFDescent) of WIDTH)))
        (SETQ DEVICE (OR DEVICE (fetch (FONTDESCRIPTOR FONTDEVICE) of WIDTH)))

        (* ;; "SCALE is only used for the display bitmap")

        (SETQ SCALE (OR SCALE (fetch (FONTDESCRIPTOR FONTSCALE) of WIDTH)
                        1))
        (SETQ WIDTH (CL:IF (EQ 0 (fetch (FONTDESCRIPTOR FONTAVGCHARWIDTH) of WIDTH))
                        (FIXR (FTIMES HEIGHT 0.6))
                        (fetch (FONTDESCRIPTOR FONTAVGCHARWIDTH) of WIDTH))))
    (LET ((CSINFO (create CHARSETINFO
                         CHARSETASCENT _ (IDIFFERENCE HEIGHT DESCENT)
                         CHARSETDESCENT _ DESCENT
                         CSSLUGP _ T
                         CSCOMPLETEP _ T))
          WIDTHS OFFSETS BITMAP IMAGEWIDTHS)
         (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
         (for I from 0 to \MAXTHINCHAR do (\FSETWIDTH WIDTHS I WIDTH))
         (replace IMAGEWIDTHS OF CSINFO with WIDTHS)
         (replace (CHARSETINFO OFFSETS) of CSINFO with (SETQ OFFSETS (\CREATECSINFOELEMENT)))
         (for I from 0 to \MAXTHINCHAR do (\FSETOFFSET OFFSETS I 0))
         (CL:WHEN (MEMB DEVICE \DISPLAYSTREAMTYPES)
             (SETQ BITMAP (BITMAPCREATE (ROUND (QUOTIENT WIDTH SCALE))
                                 (ROUND (QUOTIENT HEIGHT SCALE))
                                 1))
             [BLTSHADE BLACKSHADE BITMAP 1 NIL (SUB1 (ROUND (QUOTIENT WIDTH SCALE]
             (replace (CHARSETINFO CHARSETBITMAP) of CSINFO with BITMAP))
         CSINFO])

(\FONTSYMBOL
  [LAMBDA (X ElseReturnXFlg)                             (* ; "Edited 28-Jul-88 11:59 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:32 by FS")

    (* ;; "Return a symbol in IL package and is in uppercase.  Currently the function IL:U-CASE is believed to do this, but if it changes, this is the font hook.  ElseReturnXFlg is if you want an IL symbol if X is a symbol or string, otherwise just X.")

    (COND
       ((LITATOM X)
        (U-CASE X))
       ((STRINGP X)
        (MKATOM (U-CASE X)))
       (ElseReturnXFlg X)
       (T (ERROR "Want an IL symbol"])

(\DEVICESYMBOL
  [LAMBDA (X ElseReturnXFlg)                             (* ; "Edited  7-Oct-88 20:07 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:43 by rmk:")
                                                             (* ; "Edited 24-Mar-87 14:33 by FS")

    (* ;; "Return a canonicalized atom good for comparing with DEVICE symbols")

    (LET ((STRM (\GETSTREAM X 'OUTPUT T)))
         (COND
            (STRM (fetch (IMAGEOPS IMFONTCREATE) of (fetch (STREAM IMAGEOPS) of
                                                                                         STRM)))
            ((NULL X)
             'DISPLAY)
            (T                                               (* ; "because its used in ASSOC.")
               (\FONTSYMBOL X ElseReturnXFlg])

(\FONTFACE
  [LAMBDA (FACE NOERRORFLG DEV)                              (* ; "Edited 21-Jun-2025 23:16 by rmk")
                                                             (* ; "Edited  1-Aug-88 09:44 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:50 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:49 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:41 by rmk:")
                                                             (* ; "Edited 28-Jul-88 15:38 by rmk:")
                                                             (* ; "Edited 28-Jul-88 14:44 by rmk:")
                                                             (* ; "Edited 25-Feb-87 22:58 by FS")

    (* ;; "Coerces FACE into standard FONTFACE record, usually returns a CONSTANT (so you'd better not RPLACD or REPLACE fields!!)")

    (PROG ((UNKNOWN (CL:IF (EQ NOERRORFLG 'REGULAR)
                        'REGULAR
                        'ERROR))
           (WEIGHT 'MEDIUM)
           (SLOPE 'REGULAR)
           (EXPANSION 'REGULAR)
           (OLDFACE FACE))

     (* ;; "On error, can signal, or return NIL, or return REGULAR face.")

          [COND
             ((type? FONTFACE FACE)

              (* ;; "List Case.  Unpack because want to validate fields")

              (SETQ WEIGHT (U-CASE (fetch (FONTFACE WEIGHT) of FACE)))
              (SETQ SLOPE (U-CASE (fetch (FONTFACE SLOPE) of FACE)))
              (SETQ EXPANSION (U-CASE (fetch (FONTFACE EXPANSION) of FACE)))

              (* ;; "Handle unknown faces")

              (CL:UNLESS (MEMB WEIGHT '(BOLD MEDIUM LIGHT *))(* ; 
                                                       "STRING.EQUAL is case and package insensitive")
                  (SETQ WEIGHT (COND
                                  ((STRING.EQUAL WEIGHT 'REGULAR)

                                   (* ;; "Clean up WEIGHT REGULAR vs. MEDIUM")

                                   (SETQ WEIGHT 'MEDIUM))
                                  (T UNKNOWN))))
              (CL:UNLESS (MEMB SLOPE '(REGULAR ITALIC *))
                     (SETQ SLOPE UNKNOWN))
              (CL:UNLESS (MEMB EXPANSION '(COMPRESSED REGULAR EXPANDED *))
                     (SETQ EXPANSION UNKNOWN)))
             ((OR (LITATOM FACE)
                  (STRINGP FACE))
              (COND
                 ((NULL FACE)                                (* ; "Fast vanilla default")
                  )
                 ((EQ (NCHARS FACE)
                      3)                                     (* ; "3 char notation case")
                  (SETQ WEIGHT (SELCHARQ (CHCON1 FACE)
                                    ((B b) 
                                         'BOLD)
                                    ((M m R r) 
                                         'MEDIUM)
                                    ((L l) 
                                         'LIGHT)
                                    UNKNOWN))
                  (SETQ SLOPE (SELCHARQ (NTHCHARCODE FACE 2)
                                   ((R r) 
                                        'REGULAR)
                                   ((I i) 
                                        'ITALIC)
                                   UNKNOWN))
                  (SETQ EXPANSION (SELCHARQ (NTHCHARCODE FACE 3)
                                       ((R r) 
                                            'REGULAR)
                                       ((C c) 
                                            'COMPRESSED)
                                       ((E e) 
                                            'EXPANDED)
                                       UNKNOWN)))
                 ((SELECTQ FACE
                      (BOLD (SETQ WEIGHT 'BOLD))
                      (ITALIC (SETQ SLOPE 'ITALIC))
                      (BOLDITALIC (SETQ WEIGHT 'BOLD)
                                  (SETQ SLOPE 'ITALIC))
                      ((STANDARD REGULAR) 
                           T)
                      NIL))
                 ((STRING.EQUAL FACE 'BOLD)
                  (SETQ WEIGHT 'BOLD))
                 ((STRING.EQUAL FACE 'ITALIC)
                  (SETQ SLOPE 'ITALIC))
                 ((STRING.EQUAL FACE 'BOLDITALIC)
                  (SETQ WEIGHT 'BOLD)
                  (SETQ SLOPE 'ITALIC))
                 ((MEMB FACE '(STANDARD REGULAR NIL NNN))    (* ; "Vanilla case")
                  )
                 ((STRPOS "-" FACE)                          (* ; "Color fontface spec!")
                  (SETQ FACE (\FONTFACE.COLOR FACE NOERRORFLG DEV))
                  (RETURN FACE))
                 ((MEMB FACE '                               (* ***))
                                                             (* ; "Wildcard case")
                  (SETQ WEIGHT '*)
                  (SETQ SLOPE '*)
                  (SETQ EXPANSION '*))
                 (T                                          (* ; "Other litatom error case")
                    (SETQ WEIGHT UNKNOWN)
                    (SETQ SLOPE UNKNOWN)
                    (SETQ EXPANSION UNKNOWN]
          (if (OR (EQ WEIGHT 'ERROR)
                  (EQ SLOPE 'ERROR)
                  (EQ EXPANSION 'ERROR))
              then (if NOERRORFLG
                       then (RETURN NIL)
                     else (\ILLEGAL.ARG OLDFACE)))

     (* ;; "Avoid consing by returning constant faces (historical:  really, would have been better to return MRR, but users have know about this for too long (rmk))")

          (RETURN (COND
                     ((AND (EQ WEIGHT 'MEDIUM)
                           (EQ SLOPE 'REGULAR)
                           (EQ EXPANSION 'REGULAR))          (* ; "MRR")
                      (CONSTANT (create FONTFACE)))
                     [(AND (EQ WEIGHT 'BOLD)
                           (EQ SLOPE 'REGULAR)
                           (EQ EXPANSION 'REGULAR))          (* ; "BRR")
                      (CONSTANT (create FONTFACE
                                       WEIGHT _ 'BOLD]
                     [(AND (EQ WEIGHT 'MEDIUM)
                           (EQ SLOPE 'ITALIC)
                           (EQ EXPANSION 'REGULAR))          (* ; "MIR")
                      (CONSTANT (create FONTFACE
                                       SLOPE _ 'ITALIC]
                     [(AND (EQ WEIGHT 'BOLD)
                           (EQ SLOPE 'ITALIC)
                           (EQ EXPANSION 'REGULAR))          (* ; "BIR")
                      (CONSTANT (create FONTFACE
                                       WEIGHT _ 'BOLD
                                       SLOPE _ 'ITALIC]
                     (T                                      (* ; "Otherwise, cons up")
                        (create FONTFACE
                               WEIGHT _ WEIGHT
                               SLOPE _ SLOPE
                               EXPANSION _ EXPANSION])

(\FONTFACE.COLOR
  [LAMBDA (FACE NOERRORFLG DEV)                          (* ; "Edited 28-Jul-88 14:51 by rmk:")
                                                             (* ; "Edited 28-Jul-88 13:09 by rmk:")
                                                             (* ; "Edited 24-Mar-87 17:03 by FS")

    (* ;; "This used to be \FONTFACE.  Renamed \FONTFACE.COLOR, and \FONTFACE rewritten.  The section below should also be redone")

    (* ;; "Takes a variety of user specifications and converts them to a standard FONTFACE record.")

    (* ;; "b/w fontfaces are extended by an optional '-backcolor-forecolor'")

    (* ;; "the atom NNN is interpreted the same as NIL or MRR to cover up a bug described in AR 3025, the FONTNNN bug")

    (DECLARE (GLOBALVARS \COLORDISPLAYSTREAMTYPES))
    (SETQ DEV (\DEVICESYMBOL DEV))
    (PROG (BWFACE POS OLDPOS BITSPERPIXEL BACKCOLOR FORECOLOR ANSWER)

     (* ;; "First get a FONTFACE ANSWER.")

          [SETQ ANSWER (COND
                          ((type? FONTFACE FACE)
                           FACE)
                          ((LITATOM FACE)
                           (OR (U-CASEP FACE)
                               (SETQ FACE (U-CASE FACE)))
                           (SETQ POS (STRPOS "-" FACE))
                           (COND
                              [POS (SETQ BWFACE (SUBATOM FACE 1 (SUB1 POS]
                              (T (SETQ BWFACE FACE)))
                           [SETQ ANSWER (SELECTQ BWFACE
                                            ((* ***) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ '*
                                                                  SLOPE _ '*
                                                                  EXPANSION _ '*)))
                                            ((NIL MRR STANDARD NNN) 
                                                 (CONSTANT (create FONTFACE)))
                                            ((ITALIC MIR) 
                                                 (CONSTANT (create FONTFACE
                                                                  SLOPE _ 'ITALIC)))
                                            ((BOLD BRR) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ 'BOLD)))
                                            ((BOLDITALIC BIR) 
                                                 (CONSTANT (create FONTFACE
                                                                  WEIGHT _ 'BOLD
                                                                  SLOPE _ 'ITALIC)))
                                            (create FONTFACE
                                                   WEIGHT _ (SELCHARQ (NTHCHARCODE FACE 1)
                                                                 (M 'MEDIUM)
                                                                 (B 'BOLD)
                                                                 (L 'LIGHT)
                                                                 (GO ERROR))
                                                   SLOPE _ (SELCHARQ (NTHCHARCODE FACE 2)
                                                                (R 'REGULAR)
                                                                (I 'ITALIC)
                                                                (GO ERROR))
                                                   EXPANSION _ (SELCHARQ (NTHCHARCODE FACE 3)
                                                                    (R 'REGULAR)
                                                                    (C 'COMPRESSED)
                                                                    (E 'EXPANDED)
                                                                    (GO ERROR]
                           (COND
                              (POS                           (* ; "Color FONTFACE.  *")
                                   (SETQ OLDPOS POS)
                                   (SETQ POS (STRPOS "-" FACE (ADD1 OLDPOS)))
                                   (COND
                                      ((NULL POS)
                                       (GO ERROR)))
                                   (SETQ BITSPERPIXEL (\DISPLAYSTREAMTYPEBPP DEV))
                                   (SETQ BACKCOLOR (COLORNUMBERP (SUBATOM FACE (ADD1 OLDPOS)
                                                                        (SUB1 POS))
                                                          BITSPERPIXEL))
                                   (SETQ OLDPOS POS)
                                   (SETQ FORECOLOR (COLORNUMBERP (SUBATOM FACE (ADD1 OLDPOS)
                                                                        -1)
                                                          BITSPERPIXEL))
                                                             (* ; 
                                                         "COPY ANSWER to avoid smashing constants.")
                                   (SETQ ANSWER (COPY ANSWER))
                                   (replace (FONTFACE BACKCOLOR) of ANSWER with BACKCOLOR
                                          )
                                   (replace (FONTFACE FORECOLOR) of ANSWER with FORECOLOR
                                          )))
                           ANSWER)
                          (T (GO ERROR]

     (* ;; "Coerce on or off COLOR.")

          (SETQ ANSWER (COND
                          ((AND (NOT (FMEMB DEV \COLORDISPLAYSTREAMTYPES))
                                (fetch (FONTFACE COLOR) of ANSWER))
                           (SETQ ANSWER (COPY ANSWER))
                           (replace (FONTFACE COLOR) of ANSWER with NIL)
                           ANSWER)
                          ((AND (FMEMB DEV \COLORDISPLAYSTREAMTYPES)
                                (NULL (fetch (FONTFACE COLOR) of ANSWER)))
                           (SETQ FACE (COPY FACE))
                           (replace (FONTFACE BACKCOLOR) of ANSWER with 0)
                           (replace (FONTFACE FORECOLOR) of ANSWER with
                                                                           (MAXIMUMCOLOR (
                                                                                \DISPLAYSTREAMTYPEBPP
                                                                                          DEV)))
                           ANSWER)
                          (T ANSWER)))
          (RETURN ANSWER)
      ERROR
          (COND
             (NOERRORFLG (RETURN NIL))
             (T (\ILLEGAL.ARG FACE])

(SETFONTCHARENCODING
  [LAMBDA (FONT CHARENCODING)                                (* ; "Edited 19-Jul-2025 23:28 by rmk")
                                                             (* ; "Edited 12-Jul-2025 13:15 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited  6-Jul-2025 21:41 by rmk")
                                                             (* ; "Edited 23-May-2025 14:54 by rmk")
                                                             (* ; "Edited 21-May-2025 22:27 by rmk")
                                                             (* ; "Edited  2-May-2025 16:03 by rmk")

    (* ;; "The FONT charencoding is the same as its charset 0 encoding (e.g. ALTOTEXT).  But all higher charsets are MCCS")

    (replace (FONTDESCRIPTOR FONTCHARENCODING) of (FONTCREATE FONT) with CHARENCODING)
    (CHARSETPROP (\XGETCHARSETINFO FONT 0)
           'CSCHARENCODING CHARENCODING])
)
(DEFINEQ

(FONTSAVAILABLE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHECKFILESTOO?)  (* ; "Edited 21-Jul-2025 08:55 by rmk")
                                                             (* ; "Edited 21-Jun-2025 15:41 by rmk")
                                                             (* ; "Edited 14-Jun-2025 11:06 by rmk")
                                                             (* ; "Edited 12-Jun-2025 10:48 by rmk")
                                                             (* rrb " 7-Nov-84 15:41")

(* ;;; "returns a list of the fonts fitting a description that are available.  FAMILY SIZE FACE or ROTATION can be * which means get them all.  if CHECKFILESTOO? is NIL, only fonts in core will be considered. If ONLY, fonts in memory will be ignored.")

    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (UNION (CL:UNLESS (EQ 'ONLY CHECKFILESTOO?)
                  (\FONTSAVAILABLE.INCORE FAMILY SIZE FACE ROTATION DEVICE))
           (CL:WHEN CHECKFILESTOO?
               (if (EQ DEVICE '*)
                   then                                      (* ; 
                                                             "map thru all the imagestream devices")
                        (for I in IMAGESTREAMTYPES
                           join (APPLY* (OR (CADR (ASSOC 'FONTSAVAILABLE (CDR I)))
                                            (FUNCTION NILL))
                                       FAMILY SIZE FACE ROTATION (CAR I)))
                 else                                        (* ; 
                                                             "apply the device font lookup function.")
                      (APPLY* (OR [CADR (ASSOC 'FONTSAVAILABLE (CDR (ASSOC DEVICE IMAGESTREAMTYPES]
                                  (FUNCTION NILL))
                             FAMILY SIZE FACE ROTATION DEVICE)))])

(FONTEXISTS?
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET NOCOERCIONS)
                                                             (* ; "Edited 25-Jul-2025 21:21 by rmk")
                                                             (* ; "Edited 23-Jul-2025 13:02 by rmk")
                                                             (* ; "Edited 21-Jul-2025 09:05 by rmk")
                                                             (* ; "Edited 10-Jul-2025 12:38 by rmk")
                                                             (* ; "Edited 27-Jun-2025 10:27 by rmk")
                                                             (* ; "Edited 22-Jun-2025 09:02 by rmk")
                                                             (* ; "Edited 20-Jun-2025 00:37 by rmk")
                                                             (* ; "Edited 17-Jun-2025 23:06 by rmk")
                                                             (* ; "Edited 16-Jun-2025 10:08 by rmk")

    (* ;; "Do we have any way of finding or creating the font, even by coercion from other fonts?  If not NIL, value is either the font in memory or the file that contains information about the requested CHARSET.  The DEVICE can have a FONTEXISTS? function for the case where we can't find a file--presumably returns the file for a coercion to a different font specification.")

    (* ;; 
 "Tries device specific coercions if the original request can't be satisfied and NOCOERCIONS is NIL.")

    (DECLARE (GLOBALVARS \FONTSINCORE \FONTEXISTS?-CACHE IMAGESTREAMTYPES))
    (LET ((FONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE CHARSET))
          VAL)
         (if (type? FONTDESCRIPTOR FONTSPEC)
             then 
                  (* ;; 
                  "FAMILY was a font descriptor, unmodified by other args: record that it exists")

                  (SPREADFONTSPEC (FONTPROP FONTSPEC 'SPEC))
                  (PUTMULTI \FONTEXISTS?-CACHE FAMILY SIZE FACE ROTATION DEVICE CHARSET FONTSPEC)
           else (SPREADFONTSPEC FONTSPEC)
                (if (GETMULTI \FONTSINCORE FAMILY SIZE FACE ROTATION DEVICE CHARSET)
                  elseif (SETQ VAL (GETMULTI \FONTEXISTS?-CACHE FAMILY SIZE FACE ROTATION DEVICE 
                                          CHARSET))
                    then (CL:UNLESS (EQ VAL 'NO)
                                VAL)
                  else (CL:WHEN (MEMB ROTATION '(0 90 270))  (* ; 
                                              "Only 0 really exists. We cache just the first file.  ")
                           (SETQ VAL (OR (CAR (FONTFILES FAMILY SIZE FACE 0 DEVICE 0))
                                         (AND CHARSET (NEQ CHARSET 0)
                                              (FONTFILES FAMILY SIZE FACE 0 DEVICE CHARSET))
                                         (APPLY* (OR [CADR (ASSOC 'FONTEXISTS?
                                                                  (CDR (ASSOC DEVICE IMAGESTREAMTYPES
                                                                              ]
                                                     (FUNCTION NILL))
                                                FAMILY SIZE FACE 0 DEVICE CHARSET))))
                       (if VAL
                           then (PUTMULTI \FONTEXISTS?-CACHE FAMILY SIZE FACE ROTATION DEVICE CHARSET
                                       VAL)
                         elseif [AND (NOT NOCOERCIONS)
                                     (find FS in (\COERCEFONTSPEC (GETATOMVAL (PACK* DEVICE 
                                                                                     "FONTCOERCIONS")
                                                                         )
                                                        FAMILY SIZE FACE ROTATION DEVICE CHARSET)
                                        suchthat (SETQ VAL (FONTEXISTS? FS NIL NIL NIL DEVICE CHARSET
                                                                  T]
                           then (PUTMULTI \FONTEXISTS?-CACHE FAMILY SIZE FACE ROTATION DEVICE CHARSET
                                       VAL)
                         else (PUTMULTI \FONTEXISTS?-CACHE FAMILY SIZE FACE ROTATION DEVICE CHARSET
                                     'NO)
                              NIL])

(\FONTSAVAILABLE.INCORE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* ; "Edited 21-Jul-2025 09:27 by rmk")
                                                             (* ; "Edited 21-Jun-2025 11:17 by rmk")
                                                             (* ; "Edited 25-Apr-93 13:07 by rmk:")
                                                             (* rrb "25-Sep-84 12:10")

    (* ;; "Returns a list of the fonts that are available in core.  * matches anything.  * can appear as a component of FACE")

    (DECLARE (GLOBALVARS \FONTSINCORE))
    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (COLLECTMULTI \FONTSINCORE (FUNCTION (LAMBDA (FM S FC R D FONT)
                                           (CL:WHEN [AND (OR (EQ FAMILY FM)
                                                             (EQ FAMILY '*))
                                                         (OR (EQ SIZE S)
                                                             (EQ SIZE '*))
                                                         (MATCHFONTFACE FACE FC)
                                                         (OR (EQ ROTATION R)
                                                             (EQ ROTATION '*))
                                                         (OR (EQ DEVICE D)
                                                             (EQ DEVICE '*]
                                               (push $$COLLECT (LIST FM S FC R D)))])

(\SEARCHFONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE DIRLST EXTLST)   (* ; "Edited 21-Jul-2025 08:57 by rmk")
                                                             (* ; "Edited 10-Jul-2025 11:19 by rmk")
                                                             (* ; "Edited 21-Jun-2025 12:00 by rmk")
                                                             (* ; "Edited 13-Jun-2025 22:49 by rmk")
                                                             (* ; "Edited 12-Jun-2025 08:49 by rmk")
                                                             (* ; "Edited 17-May-2025 14:09 by rmk")
                                                             (* ; "Edited 15-May-2025 23:12 by rmk")
                                                             (* ; "Edited 14-Sep-96 10:54 by rmk:")
                                                             (* ; "Edited  6-Oct-89 12:34 by bvm")

    (* ;; "GENERIC FUNCTION")

    (* ;; "returns a list of the fonts that can be read in for a device.  Rotation is ignored because it is assumed that all devices support 0 90 and 270.")

    (* ;; "Just in case the caller hasn't check the arguments:")

    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (CL:UNLESS DIRLST
        [SETQ DIRLST (MKLIST (GETATOMVAL (PACK* DEVICE "FONTDIRECTORIES"])
    (CL:UNLESS EXTLST
        [SETQ EXTLST (MKLIST (GETATOMVAL (PACK* DEVICE "FONTEXTENSIONS"])
    (for FILEPATTERN FILEDIR FONTSFOUND (FILING.ENUMERATION.DEPTH _ 1)
       IN (\FONTFILENAMES FAMILY SIZE FACE DEVICE EXTLST)
       do (SETQ FILEDIR (FILENAMEFIELD FILEPATTERN 'DIRECTORY))
          (SETQ FILEDIR (CL:IF FILEDIR
                            (CONCAT ">" FILEDIR ">")
                            ""))
          (for DIR inside DIRLST eachtime 

                                   (* ;; "The file pattern might have an extending subdirectory (C41>) that might not exist, but DIRECTORYNAMEP makes sure that it does.")

                                       (SETQ DIR (CONCAT DIR ">" (OR FILEDIR "")))
             when (DIRECTORYNAMEP DIR) do (for FONTFILE THISFONT in (DIRECTORY DIR)
                                             eachtime (SETQ THISFONT (\FONTINFOFROMFILENAME FONTFILE
                                                                            DEVICE T)) 

                                                   (* ;; 
                                                 "make sure the face, size, and family really match.")
 when (AND (OR (EQ FAMILY '*)
               (EQ FAMILY (CAR THISFONT)))
           (OR (EQ SIZE '*)
               (EQ SIZE (CADR THISFONT)))
           (MATCHFONTFACE FACE (CADDR THISFONT))) unless (MEMBER THISFONT FONTSFOUND)
                                             do (push FONTSFOUND THISFONT)))
       finally (RETURN (DREVERSE FONTSFOUND])

(FLUSHFONTSINCORE
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE)                 (* ; "Edited 21-Jul-2025 08:59 by rmk")
                                                             (* ; "Edited 21-Jun-2025 11:19 by rmk")
    (DECLARE (GLOBALVARS \FONTSINCORE))
    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (MAPMULTI \FONTSINCORE (FUNCTION (LAMBDA (FM S FC R TAIL)
                                       (CL:WHEN [AND (OR (EQ FAMILY FM)
                                                         (EQ FAMILY '*))
                                                     (OR (EQ SIZE S)
                                                         (EQ SIZE '*))
                                                     (MATCHFONTFACE FACE FC)
                                                     (OR (EQ ROTATION R)
                                                         (EQ ROTATION '*))
                                                     (OR (EQ DEVICE (CAR TAIL))
                                                         (EQ DEVICE '*]
                                              (RPLACD TAIL])

(MATCHFONTFACE
  [LAMBDA (PATTERN FACE)                                     (* ; "Edited 21-Jun-2025 11:57 by rmk")

    (* ;; "Does FACE match a PATTERN that may contain stars?")

    (OR (EQ PATTERN '*)
        (EQUAL PATTERN FACE)
        (LET ((PWEIGHT (fetch (FONTFACE WEIGHT) of PATTERN))
              (PSLOPE (fetch (FONTFACE SLOPE) of PATTERN))
              (PEXPANSION (fetch (FONTFACE EXPANSION) of PATTERN)))
             (AND (OR (EQ PWEIGHT (fetch (FONTFACE WEIGHT) of FACE))
                      (EQ PWEIGHT '*))
                  (OR (EQ PSLOPE (fetch (FONTFACE SLOPE) of FACE))
                      (EQ PSLOPE '*))
                  (OR (EQ PEXPANSION (fetch (FONTFACE EXPANSION) of FACE))
                      (EQ PEXPANSION '*])

(FINDFONTFILES
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE DIRLST EXTLST)   (* ; "Edited 21-Jul-2025 09:00 by rmk")
                                                             (* ; "Edited 29-Jun-2025 09:08 by rmk")

    (* ;; "GENERIC FUNCTION")

    (* ;; "returns a list of the fontfiles that can be read in for a device.  Rotation is ignored because it is assumed that all devices support 0 90 and 270.")

    (* ;; "The same algorithm as \SEARCHFONTFILES except returns the file names.  This may return several files for the same specification")

    (SPREADFONTSPEC (\FONT.CHECKARGS FAMILY SIZE FACE ROTATION DEVICE))
    (CL:UNLESS DIRLST
        [SETQ DIRLST (MKLIST (GETATOMVAL (PACK* DEVICE "FONTDIRECTORIES"])
    (CL:UNLESS EXTLST
        [SETQ EXTLST (MKLIST (GETATOMVAL (PACK* DEVICE "FONTEXTENSIONS"])
    (for FILEPATTERN FILEDIR FONTSFOUND (FILING.ENUMERATION.DEPTH _ 1)
       IN (\FONTFILENAMES FAMILY SIZE FACE DEVICE EXTLST)
       do (SETQ FILEDIR (FILENAMEFIELD FILEPATTERN 'DIRECTORY))
          (SETQ FILEDIR (CL:IF FILEDIR
                            (CONCAT ">" FILEDIR ">")
                            ""))
          (for DIR inside DIRLST eachtime 

                                   (* ;; "The file pattern might have an extending subdirectory (C41>) that might not exist, but DIRECTORYNAMEP makes sure that it does.")

                                       (SETQ DIR (CONCAT DIR ">" (OR FILEDIR "")))
             when (DIRECTORYNAMEP DIR) do (for FONTFILE FONTSPEC THISFACE in (DIRECTORY DIR)
                                             eachtime (SETQ FONTSPEC (\FONTINFOFROMFILENAME FONTFILE
                                                                            DEVICE))
                                                   (SETQ THISFACE (CADDR FONTSPEC)) 

                                                   (* ;; 
                                                 "make sure the face, size, and family really match.")
 when (AND (NOT (MEMBER FONTFILE FONTSFOUND))
           (OR (EQ FAMILY '*)
               (EQ FAMILY (CAR FONTSPEC)))
           (OR (EQ SIZE '*)
               (EQ SIZE (CADR FONTSPEC)))
           (MATCHFONTFACE FACE THISFACE)) do (push FONTSFOUND FONTFILE)))
       finally (RETURN (DREVERSE FONTSFOUND])
)

(RPAQ? \FONTEXISTS?-CACHE NIL)



(* ; "Functions for DISPLAY IMAGESTREAMTYPES ")

(DEFINEQ

(\CREATEDISPLAYFONT
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 13-Jun-2025 22:58 by rmk")
                                                             (* ; "Edited  9-Jun-2025 17:42 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:11 by rmk")
                                                             (* ; "Edited 23-May-2025 14:59 by rmk")
                                                             (* ; "Edited 22-May-2025 09:52 by rmk")

    (* ;; "FONTCREATE1 has determined that there is at least one source file for this font, so the font exists in at least some character sets, although maybe not CHARSET.")

    (* ;; "This would be the right place to do DISPLAYFONTCOERCIONS, but that doesn't work if the target font is only partially instantiated.  \GETCHARSETINFO has to know how to do the font coercion.")
                                                             (* gbn%: "25-Jan-86 18:02")
    (LET [(FONTDESC (create FONTDESCRIPTOR
                           FONTDEVICE _ DEVICE
                           FONTFAMILY _ FAMILY
                           FONTSIZE _ SIZE
                           FONTFACE _ FACE
                           \SFAscent _ 0
                           \SFDescent _ 0
                           \SFHeight _ 0
                           ROTATION _ ROTATION
                           FONTDEVICESPEC _ (LIST FAMILY SIZE FACE ROTATION DEVICE]
         (\CREATECHARSET CHARSET FONTDESC)
         FONTDESC])

(\CREATECHARSET.DISPLAY
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET FONTDESC)(* ; "Edited 22-Jul-2025 22:04 by rmk")
                                                             (* ; "Edited 13-Jul-2025 11:44 by rmk")
                                                             (* ; "Edited 11-Jul-2025 11:00 by rmk")
                                                             (* ; "Edited  8-Jul-2025 08:14 by rmk")
                                                             (* ; "Edited  6-Jul-2025 22:55 by rmk")
                                                             (* ; "Edited  8-Jun-2025 19:57 by rmk")
                                                             (* ; "Edited 20-May-2025 15:00 by rmk")
                                                             (* ; "Edited 18-May-2025 23:31 by rmk")
                                                             (* ; "Edited 14-Jan-88 23:42 by FS")

    (* ;; "The first case is simple:  A DISPLAYFONTCOERCIONS substitution for one font for another.  E.g. Use the information derived for HELVETICA 4 to construct the fontdescriptor for Helvetic 3. ")

    (* ;; "After that, it uses requested source files and/or DISPLAYGLYPHCOERCIONS to produce and complete the CHARSETINFO:")

    (* ;; "This first tries to find a source file that exactly matches the characteristics of the requested charset.  The charset is %"completed%" by filling in any missing characters from further down the coercion chain.  Thus, the missing characters for e.g. TERMINAL 357 will be filled in from MODERN357, and then perhaps CLASSIC357.")

    (* ;; "If an exact match file cannot be found for a requested rotation, the rotation 0 charset is obtained and rotated.")

    (* ;; "If a non-existent Kanji or Chinese charset is requested for a non-MRR face, the MRR charset is used unmodified.  We don't try to boldify or italicize Kanji or Chinese.")

    (* ;; "When all coercions have been exhausted and FACE is bold and/or italic, the search process repeats with bold/italice changed to Regular, and algorithmic transformations are applied to the first result, if any.")

    (* ;; "If all else fails, it looks for the next charset in the coercion list, and fills that in with further coercions for missing characters.")

    (* ;; "")

    (* ;; "Maybe nobody cares about Classic 36...let's remove that coercion and see what happens.")

    (* ;; "There is a strategy question about the priority of charset coercion with respect to the other transformations.  It might seem better to coerce to a real charset, if any, before apply the algorithmic bolding/italicizing.  But the glitch is that nonexistent MODERN 36 BOLD would first coerce to CLASSIC 36, which also doesn't exist.   But CLASSIC 36 has a font-substitution to CLASSIC 24, and the result would be the glyphs for CLASSIC 24-BRR, which  turns out to be much less attractive and appropriate than the boldified version of MODERN36-MRR.  So, to get MODERN36 bold, either the CHARSET coercion has to come after the bolding, the coercion of CLASSIC36 to CLASSIC24 has to be removed or refined, or the whole-font substitution should come after the charset coercion. ")

    (DECLARE (GLOBALVARS DISPLAYFONTCOERCIONS DISPLAYGLYPHCOERCIONS))
    (LET (CSINFO)

         (* ;; "If no DISPLAYFONTCOERCIONS, skip that first \COERCECHARSET call--easier debugging of the other case.")

         (SETQ CSINFO (if (AND DISPLAYFONTCOERCIONS (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE
                                                           CHARSET DISPLAYFONTCOERCIONS))
                        elseif (SETQ CSINFO (OR (\READCHARSET FAMILY SIZE FACE ROTATION DEVICE 
                                                       CHARSET)
                                                (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE 
                                                       CHARSET DISPLAYGLYPHCOERCIONS)))
                          then 
                               (* ;; "This completes CSINFO with glyphs for all codes from possibly different sources, even if just asking for a single THINCODE. We never return an incomplete CSINFO.")

                               (COMPLETE.CHARSET CSINFO FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                      DISPLAYGLYPHCOERCIONS FONTDESC)
                        elseif (NEQ ROTATION 0)
                          then (CL:UNLESS (MEMB ROTATION '(90 270))
                                      (ERROR "only implemented rotations are 0, 90 and 270." ROTATION
                                             ))
                               (CL:WHEN (SETQ CSINFO (\CREATECHARSET.DISPLAY FAMILY SIZE FACE 0 
                                                            DEVICE CHARSET FONTDESC))
                                      (\SFROTATECSINFO CSINFO ROTATION))
                        elseif (OR (KANJICHARSETP CHARSET)
                                   (CHINESECHARSETP CHARSET))
                          then (CL:UNLESS (EQUAL FACE '(MEDIUM REGULAR REGULAR))
                                   (\CREATECHARSET.DISPLAY FAMILY SIZE '(MEDIUM REGULAR REGULAR)
                                          ROTATION DEVICE CHARSET FONTDESC))
                        elseif (EQ 'BOLD (fetch (FONTFACE WEIGHT) of FACE))
                          then (MAKEBOLD.CHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                      DISPLAYGLYPHCOERCIONS)
                        elseif (EQ 'ITALIC (fetch (FONTFACE SLOPE) of FACE))
                          then (MAKEITALIC.CHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                      DISPLAYGLYPHCOERCIONS)))
         CSINFO])

(\FONTEXISTS?.DISPLAY
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 25-Jul-2025 21:38 by rmk")
                                                             (* ; "Edited 13-Jul-2025 11:45 by rmk")
                                                             (* ; "Edited 22-Jun-2025 08:53 by rmk")

    (* ;; "Order doesn't matter here, only need one to work")

    (OR (AND (EQ 'BOLD (fetch (FONTFACE WEIGHT) of FACE))
             (FONTEXISTS? FAMILY SIZE (create FONTFACE using FACE WEIGHT _ 'MEDIUM)
                    ROTATION DEVICE CHARSET))
        (AND (EQ 'ITALIC (fetch (FONTFACE SLOPE) of FACE))
             (FONTEXISTS? FAMILY SIZE (create FONTFACE using FACE SLOPE _ 'REGULAR)
                    ROTATION DEVICE CHARSET))
        (for C VAL in (\COERCEFONTSPEC (APPEND DISPLAYFONTCOERCIONS DISPLAYGLYPHCOERCIONS)
                             FAMILY SIZE FACE ROTATION DEVICE CHARSET) when (SETQ VAL (FONTEXISTS?
                                                                                       C))
           do (RETURN VAL])
)
(DEFINEQ

(STRIKEFONT.FILEP
  [LAMBDA (FILE)                                             (* ; "Edited 15-May-2025 17:47 by rmk")

    (* ;; "If high bit of type is on, then must be strike.  If 2nd bit is on, must be strike-index, and we punt.  We don't care about the 3rd bit")

    (* ;; "first word has high bits (onebit index fixed).  Onebit means 'new-style font' , index is 0 for simple strike, 1 for index, and fixed is if all chars have max width.  Lisp doesn't care about 'fixed'")

    (RESETLST
        (CL:UNLESS (OPENP FILE 'INPUT)
            [RESETSAVE (SETQ FILE (OPENSTREAM FILE 'INPUT 'OLD))
                   `(PROGN (CLOSEF? OLDVALUE])
        (CL:WHEN [MEMB (\WIN FILE)
                       (CONSTANT (LIST (LLSH 1 15)
                                       (LOGOR (LLSH 1 15)
                                              (LLSH 1 13]
               T))])

(STRIKEFONT.GETCHARSET
  [LAMBDA (STRM)                                             (* ; "Edited 14-Jul-2025 19:52 by rmk")
                                                             (* ; "Edited  9-Jun-2025 14:22 by rmk")
                                                             (* ; "Edited 12-Jul-2022 09:19 by rmk")
                                                             (* ; "Edited  4-Dec-92 12:11 by jds")

    (* ;; "STRM has already been determined to be a vanilla strike-format file holding only the desired charset.")
                                                             (* ; "returns a charsetinfo")
    (RESETLST
        (CL:UNLESS (\GETSTREAM STRM 'INPUT T)
            [RESETSAVE (SETQ STRM (OPENSTREAM STRM 'INPUT 'OLD))
                   `(PROGN (CLOSEF? OLDVALUE])
        (SETFILEPTR STRM 0)
        (CL:UNLESS (STRIKEFONT.FILEP STRM)
               (ERROR "Not a STRIKE font file" STRM))
        (CL:UNLESS (EQ 2 (GETFILEPTR STRM))
               (SETFILEPTR STRM 2))
        (LET (CSINFO NUMBCODES RW BITMAP OFFSETS FIRSTCHAR LASTCHAR HEIGHT WIDTHS)
             (SETQ CSINFO (create CHARSETINFO))
             (SETQ FIRSTCHAR (\WIN STRM))                    (* ; "minimum ascii code")
             (SETQ LASTCHAR (\WIN STRM))                     (* ; "maximum ascii code")
             (\WIN STRM)                                     (* ; 
                                                             "MaxWidth which isn't used by anyone.")
             (\WIN STRM)                                     (* ; 
                                                             "number of words in this StrikeBody")
             (replace (CHARSETINFO CHARSETASCENT) of CSINFO with (\WIN STRM))
                                                             (* ; 
                                                             "ascent in scan lines (=FBBdy+FBBoy)")
             (replace (CHARSETINFO CHARSETDESCENT) of CSINFO with (\WIN STRM))
                                                             (* ; "descent in scan-lines (=FBBoy)")
             (\WIN STRM)                                     (* ; 
                                                    "offset in bits (<0 for kerning, else 0, =FBBox)")
             (SETQ RW (\WIN STRM))                           (* ; "raster width of bitmap")
                                                             (* ; "height of bitmap")

             (* ;; "JDS 12/4/92:  Apparently, these fields can be signed values, if all chars, e.g., ride above the base line.")

             (SETQ HEIGHT (IPLUS (SIGNED (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                        16)
                                 (SIGNED (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)
                                        16)))
             (SETQ BITMAP (BITMAPCREATE (UNFOLD RW BITSPERWORD)
                                 HEIGHT))
             (\BINS STRM (fetch BITMAPBASE of BITMAP)
                    0
                    (UNFOLD (ITIMES RW HEIGHT)
                           BYTESPERWORD))                    (* ; "read bits into bitmap")
             (replace (CHARSETINFO CHARSETBITMAP) of CSINFO with BITMAP)
             (SETQ NUMBCODES (IPLUS (IDIFFERENCE LASTCHAR FIRSTCHAR)
                                    3))                      (* ; 
                                    "(SETQ OFFSETS (ARRAY (IPLUS \MAXCHAR 3) (QUOTE SMALLPOSP) 0 0))")
             (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
                                                             (* ; "initialise the offsets to 0")
             (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETOFFSET OFFSETS I 0))
                                                             (* ; 
                                                             "(AIN OFFSETS FIRSTCHAR NUMBCODES STRM)")
             (for I from FIRSTCHAR as J from 1 to NUMBCODES do (\FSETOFFSET OFFSETS I (\WIN STRM)))
             (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
             (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETWIDTH WIDTHS I 0))
                                                             (* ; 
     "(replace WIDTHS of (CHARSETINFO CSINFO) with (ARRAY (IPLUS \MAXCHAR 3) (QUOTE SMALLPOSP) 0 0))")
             (\FONTRESETCHARWIDTHS CSINFO FIRSTCHAR LASTCHAR)
             (replace (CHARSETINFO IMAGEWIDTHS) of CSINFO with (fetch (CHARSETINFO WIDTHS)
                                                                  of CSINFO))
             CSINFO))])

(WRITESTRIKEFONTFILE
  [LAMBDA (FONT CHARSET FILE)                                (* ; "Edited 22-May-2025 09:53 by rmk")
                                                             (* ; "Edited  1-Feb-2025 12:27 by mth")
                                                             (* ; "Edited 12-Jul-2022 14:36 by rmk")
                                                             (* kbr%: "21-Oct-85 15:08")
                                                             (* ; 
                                                           "Write strike FILE using info in FONT.  *")
    (CL:UNLESS (FONTP FONT)
           (LISPERROR "ILLEGAL ARG" FONT))
    (CL:UNLESS CHARSET (SETQ CHARSET 0))
    (CL:UNLESS (AND (IGEQ CHARSET 0)
                    (ILEQ CHARSET \MAXCHARSET))
           (LISPERROR "ILLEGAL ARG" CHARSET))
    (LET (STREAM CSINFO FIRSTCHAR LASTCHAR WIDTHS MAXWIDTH LENGTH RASTERWIDTH DUMMYCHAR DUMMYOFFSET 
                PREVIOUSOFFSET OFFSETS)
         (SETQ CSINFO (\INSURECHARSETINFO CHARSET FONT T))
         (CL:UNLESS CSINFO (ERROR "Couldn't find charset " CHARSET))
         (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
         (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
         (SETQ DUMMYOFFSET (\FGETOFFSET OFFSETS DUMMYINDEX))
         [SETQ FIRSTCHAR (for I from 0 to MAXCODE thereis (NOT (EQ (\FGETOFFSET OFFSETS I)
                                                                   DUMMYOFFSET]
         [SETQ LASTCHAR (for I from MAXCODE to 0 by -1 thereis (NOT (EQ (\FGETOFFSET OFFSETS I)
                                                                        DUMMYOFFSET]
         (SETQ DUMMYCHAR (ADD1 LASTCHAR))
         [SETQ STREAM (OPENSTREAM FILE 'OUTPUT 'NEW '((TYPE BINARY]
         (\WOUT STREAM 32768)                                (* ; "STRIKE HEADER.  *")
         (\WOUT STREAM FIRSTCHAR)
         (\WOUT STREAM LASTCHAR)
         (SETQ MAXWIDTH 0)
         [for I from 0 to DUMMYINDEX do (SETQ MAXWIDTH (IMAX MAXWIDTH (\FGETWIDTH WIDTHS I]
         (\WOUT STREAM MAXWIDTH)                             (* ; "STRIKE BODY.  *")
                                                             (* ; "Length.  *")
         (SETQ RASTERWIDTH (fetch (BITMAP BITMAPRASTERWIDTH) of (fetch (CHARSETINFO CHARSETBITMAP)
                                                                   of CSINFO)))
         (SETQ LENGTH (IPLUS 8 (IDIFFERENCE LASTCHAR FIRSTCHAR)
                             (ITIMES (fetch (FONTDESCRIPTOR \SFHeight) of FONT)
                                    RASTERWIDTH)))
         (\WOUT STREAM LENGTH)                               (* ; 
                                      "Ascent, Descent, Xoffset (no longer used) and Rasterwidth.  *")
         (\WOUT STREAM (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
         (\WOUT STREAM (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
         (\WOUT STREAM 0)
         (\WOUT STREAM RASTERWIDTH)                          (* ; "Bitmap.  *")
         [\BOUTS STREAM (fetch (BITMAP BITMAPBASE) of (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
                0
                (ITIMES 2 RASTERWIDTH (IPLUS (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                                             (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO]
                                                             (* ; "Offsets.  *")
         (for I WIDTH OFFSET (CODE _ 0) from FIRSTCHAR to DUMMYCHAR first (\WOUT STREAM CODE)
            do (SETQ OFFSET (\FGETOFFSET OFFSETS I))
               (SETQ WIDTH (\FGETWIDTH WIDTHS I))
               (CL:UNLESS (AND (IEQP OFFSET DUMMYOFFSET)
                               (NOT (IEQP I DUMMYCHAR)))
                      (ADD CODE WIDTH))
               (\WOUT STREAM CODE))
         (CLOSEF STREAM])

(STRIKECSINFO
  [LAMBDA (CSINFO)                                       (* ; "Edited 27-Apr-89 13:39 by atm")

    (* ;; "Returns a STRIKE type font descriptor (EQ WIDTHS IMAGEWIDTHS), cause we know how to write those guys out (they read quicker  but display slower).  If (EQ WIDTHS IMAGEWIDTHS), just return original.")

    (PROG (WIDTHS OFFSETS IMWIDTHS OLDBM BMWIDTH BMHEIGHT NEWBM NEWOFFSET NEWWIDTH OLDOFFSET 
                 DUMMYOFFSET NEWOFFSETS)
          (SETQ WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
          (SETQ IMWIDTHS (fetch (CHARSETINFO IMAGEWIDTHS) of CSINFO))
          (if (EQ WIDTHS IMWIDTHS)
              then (RETURN CSINFO))
          (SETQ OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
          (SETQ OLDBM (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
          (SETQ DUMMYOFFSET (\FGETOFFSET OFFSETS 256))
          (SETQ BMHEIGHT (BITMAPHEIGHT OLDBM))
          [SETQ BMWIDTH (for I from 0 to \MAXTHINCHAR
                           sum (if (IEQP DUMMYOFFSET (\FGETOFFSET OFFSETS I))
                                       then 0
                                     else (IMAX (\FGETIMAGEWIDTH IMWIDTHS I)
                                                    (\FGETWIDTH WIDTHS I]

     (* ;; "")

     (* ;; "Initialize new offsets vector")

     (* ;; "")

          (SETQ NEWOFFSETS (\CREATECSINFOELEMENT))
          (for I from 0 to (IPLUS \MAXTHINCHAR 2) do (\FSETOFFSET NEWOFFSETS I 0))
          (\FSETOFFSET NEWOFFSETS (ADD1 \MAXTHINCHAR)
                 BMWIDTH)

     (* ;; "")

     (* ;; "Adjust bitmap with so width = imagewidth, fill offsets")

     (* ;; "")

          (SETQ NEWBM (BITMAPCREATE BMWIDTH BMHEIGHT 1))
          (SETQ NEWOFFSET 0)
          [for I from 0 to 255
             do (SETQ OLDOFFSET (\FGETOFFSET OFFSETS I))
                   (if (IEQP DUMMYOFFSET OLDOFFSET)
                       then (\FSETOFFSET NEWOFFSETS I BMWIDTH)
                     else (\FSETOFFSET NEWOFFSETS I NEWOFFSET)
                           (SETQ NEWWIDTH (IMAX (\FGETIMAGEWIDTH IMWIDTHS I)
                                                (\FGETWIDTH WIDTHS I)))
                           (BITBLT OLDBM OLDOFFSET 0 NEWBM NEWOFFSET 0 (\FGETWIDTH IMWIDTHS I)
                                  BMHEIGHT
                                  'REPLACE)
                           (SETQ NEWOFFSET (IPLUS NEWOFFSET NEWWIDTH]

     (* ;; "")

     (* ;; "Make new CSInfo record withs IMAGEWIDTHS, WIDTHS the same")

     (* ;; "")

          (SETQ WIDTHS (COPYALL WIDTHS))
          [for I from 0 to \MAXTHINCHAR do (\FSETWIDTH WIDTHS I
                                                                  (IMAX (\FGETWIDTH WIDTHS I)
                                                                        (\FGETIMAGEWIDTH IMWIDTHS I]
          (RETURN (create CHARSETINFO
                         WIDTHS _ WIDTHS
                         OFFSETS _ NEWOFFSETS
                         IMAGEWIDTHS _ WIDTHS
                         CHARSETBITMAP _ NEWBM
                         YWIDTHS _ (fetch (CHARSETINFO YWIDTHS) of CSINFO)
                         CHARSETASCENT _ (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                         CHARSETDESCENT _ (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO])
)



(* ; "Bitmap faking")

(DEFINEQ

(MAKEBOLD.CHARSET
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS)
                                                             (* ; "Edited 21-Jun-2025 09:10 by rmk")

    (* ;; "BOLD is requested in FACE, so we look for an MRR or MIR that we can bold.  If we find one, we presume that it is complete for all characters in its face.  But there may be other fonts in the coercion chain that have true information about the bold face that we are after. We look for those before we try to adjust the characters in the non-bold CSINFO that we found.")

    (LET ((FONTX (FONTCREATE1 FAMILY SIZE (create FONTFACE using FACE WEIGHT _ 'MEDIUM)
                        0
                        'DISPLAY CHARSET))
          CSINFO SOURCECSINFO)
         (CL:WHEN (AND FONTX (SETQ CSINFO (\XGETCHARSETINFO FONTX CHARSET))
                       (NOT (fetch (CHARSETINFO CSSLUGP) of CSINFO)))
             (SETQ CSINFO (create CHARSETINFO copying CSINFO))
             (for THINCODE from 0 to \MAXTHINCHAR
                do (if (SLUGCHARP.DISPLAY THINCODE CSINFO)
                       then 
                            (* ;; "Look for a bold glyph for THINCODE lurking somewhere down the chain, copy it up.  There may be different sources for different codes.")

                            (CL:WHEN (SETQ SOURCECSINFO
                                      (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                             COERCIONS THINCODE))
                                   (\MOVEFONTCHAR SOURCECSINFO CSINFO THINCODE THINCODE))
                     else (MAKEBOLD.CHAR THINCODE CSINFO)))
             (replace (CHARSETINFO CSCOMPLETEP) of CSINFO with T)
             CSINFO)])

(MAKEBOLD.CHAR
  [LAMBDA (THINCODE CSINFO)                                  (* ; "Edited 17-Jun-2025 08:22 by rmk")

    (* ;; "Replaces the bitmap for THINCODE in CSINFO with a bolder one:  overlaps 2 bits to produce the bold effect.  Could be iterated for bigger fonts, but eventually the open spaces would be closed up.")

    (CL:UNLESS (SLUGCHARP.DISPLAY THINCODE CSINFO)
        (LET* [(OLDCHARBITMAP (\GETCHARBITMAP.CSINFO THINCODE CSINFO))
               (NEWCHARBITMAP (BITMAPCREATE (ADD1 (fetch BITMAPWIDTH of OLDCHARBITMAP))
                                     (fetch BITMAPHEIGHT of OLDCHARBITMAP)))
               (CWIDTH (\FGETWIDTH (fetch (CHARSETINFO WIDTHS) of CSINFO)
                              THINCODE))
               (HEIGHT (IPLUS (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                              (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO]

              (* ;; 
             "Paint in a shifted copy 1 bit over. The new bitmap is 1 bit wider, to keep the margin.")

              (BITBLT OLDCHARBITMAP 0 0 NEWCHARBITMAP 0 0 CWIDTH HEIGHT 'INPUT 'REPLACE)
              (BITBLT OLDCHARBITMAP 0 0 NEWCHARBITMAP 1 0 CWIDTH HEIGHT 'INPUT 'PAINT)
              (\PUTCHARBITMAP.CSINFO THINCODE CSINFO NEWCHARBITMAP)))])

(MAKEITALIC.CHARSET
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET COERCIONS)
                                                             (* ; "Edited 21-Jun-2025 09:10 by rmk")

    (* ;; "ITALIC is requested, so we look for an MRR or MIR that we can italicize.  If we find one, we presume that it is complete for all characters in its face.  But there may be other fonts in the coercion chain that have true information about the italic face that we are after. We look for those before we try to adjust the characters in  non-italic CSINFO that we found.")

    (LET ((FONTX (FONTCREATE1 FAMILY SIZE (create FONTFACE using FACE SLOPE _ 'REGULAR)
                        0
                        'DISPLAY CHARSET))
          CSINFO SOURCECSINFO)
         (CL:WHEN (AND FONTX (SETQ CSINFO (\XGETCHARSETINFO FONTX CHARSET))
                       (NOT (fetch (CHARSETINFO CSSLUGP) of CSINFO)))
             (SETQ CSINFO (create CHARSETINFO copying CSINFO))
             (for THINCODE from 0 to \MAXTHINCHAR
                do (if (SLUGCHARP.DISPLAY THINCODE CSINFO)
                       then 
                            (* ;; "Look for an italic glyph for THINCODE lurking somewhere down the chain, copy it up. There may be different sources for different codes.")

                            (CL:WHEN (SETQ SOURCECSINFO
                                      (\COERCECHARSET FAMILY SIZE FACE ROTATION DEVICE CHARSET 
                                             COERCIONS THINCODE))
                                   (\MOVEFONTCHAR SOURCECSINFO CSINFO THINCODE THINCODE))
                     else (MAKEITALIC.CHAR THINCODE CSINFO)))
             (replace (CHARSETINFO CSCOMPLETEP) of CSINFO with T)
             CSINFO)])

(MAKEITALIC.CHAR
  [LAMBDA (THINCODE CSINFO)                                  (* ; "Edited 18-Jun-2025 14:12 by rmk")
                                                             (* ; "Edited 17-Jun-2025 09:54 by rmk")

    (* ;; "Replaces the bitmap for THINCODE in CSINFO with a slanted one:  It shifts rows to the right as a function of their vertical position. ")

    (CL:UNLESS (SLUGCHARP.DISPLAY THINCODE CSINFO)
        (LET* ((OLDBITMAP (\GETCHARBITMAP.CSINFO THINCODE CSINFO))
               (NEWBITMAP (BITMAPCREATE (fetch BITMAPWIDTH of OLDBITMAP)
                                 (fetch BITMAPHEIGHT of OLDBITMAP)))
               (WIDTH (\FGETWIDTH (fetch (CHARSETINFO WIDTHS) of CSINFO)
                             THINCODE))
               (ASCENT (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
               (DESCENT (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
               (HEIGHT (IPLUS ASCENT DESCENT)))
              [for ROW XX XN YN YX from (IMINUS (IQUOTIENT (IPLUS DESCENT 3)
                                                       4)) to (IQUOTIENT (IPLUS ASCENT 3)
                                                                     4)
                 do (SETQ XN (IMIN WIDTH (IMAX ROW 0)))
                    (SETQ XX (IMIN WIDTH (IMAX (IPLUS WIDTH ROW)
                                               0)))
                    [SETQ YN (IMAX 0 (IPLUS DESCENT (ITIMES ROW 4]
                    [SETQ YX (IMIN HEIGHT (IPLUS DESCENT (ITIMES (ADD1 ROW)
                                                                4]
                    (CL:WHEN (AND (IGREATERP XX XN)
                                  (IGREATERP YX YN))
                        (BITBLT OLDBITMAP 0 YN NEWBITMAP XN YN (IDIFFERENCE XX XN)
                               (IDIFFERENCE YX YN)
                               'INPUT
                               'REPLACE))]
              (\PUTCHARBITMAP.CSINFO THINCODE CSINFO NEWBITMAP)))])

(\SFMAKEBOLD
  [LAMBDA (CSINFO)                                           (* ; "Edited 16-Jun-2025 23:22 by rmk")
                                                             (* gbn "25-Jul-85 04:52")
    (LET ((OLDCHARBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
          (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
          (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
          (HEIGHT (IPLUS (fetch (CHARSETINFO CHARSETASCENT) of CSINFO)
                         (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO)))
          NEWCHARBITMAP OFFSET SLUGOFFSET SLUGWIDTH)
         (SETQ NEWCHARBITMAP (BITMAPCREATE (fetch BITMAPWIDTH of OLDCHARBITMAP)
                                    (fetch BITMAPHEIGHT of OLDCHARBITMAP)))
         (SETQ SLUGOFFSET (\FGETOFFSET OFFSETS (ADD1 \MAXCHAR)))
         (SETQ SLUGWIDTH (\FGETWIDTH WIDTHS (ADD1 \MAXCHAR)))
         (for I from 0 to \MAXCHAR unless (EQ SLUGOFFSET (SETQ OFFSET (\FGETOFFSET OFFSETS I)))
            do                                               (* ; 
                                                            "overlap two blts to produce bold effect")
               (BITBLT OLDCHARBITMAP OFFSET 0 NEWCHARBITMAP OFFSET 0 (\FGETWIDTH WIDTHS I)
                      HEIGHT
                      'INPUT
                      'REPLACE)
               (BITBLT OLDCHARBITMAP OFFSET 0 NEWCHARBITMAP (ADD1 OFFSET)
                      0
                      (SUB1 (\FGETWIDTH WIDTHS I))
                      HEIGHT
                      'INPUT
                      'PAINT))                               (* ; 
                                                            "fill in the slug for the magic charcode")
         (BITBLT OLDCHARBITMAP SLUGOFFSET 0 NEWCHARBITMAP SLUGOFFSET 0 SLUGWIDTH HEIGHT 'INPUT
                'REPLACE)
         (create CHARSETINFO using CSINFO CHARSETBITMAP _ NEWCHARBITMAP])

(\SFMAKEITALIC
  [LAMBDA (CSINFO)                                           (* ; "Edited 16-Jun-2025 23:20 by rmk")
                                                             (* gbn "18-Sep-85 17:57")
    (LET ((WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
          (OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
          (ASCENT (fetch (CHARSETINFO CHARSETASCENT) of CSINFO))
          (DESCENT (fetch (CHARSETINFO CHARSETDESCENT) of CSINFO))
          (OLDBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO))
          HEIGHT OFFSET NEWBITMAP WIDTH SLUGOFFSET SLUGWIDTH N M R XN XX YN YX)
         (SETQ HEIGHT (IPLUS ASCENT DESCENT))
         (SETQ NEWBITMAP (BITMAPCREATE (fetch BITMAPWIDTH of OLDBITMAP)
                                (fetch BITMAPHEIGHT of OLDBITMAP)))
         (SETQ SLUGOFFSET (\FGETOFFSET OFFSETS (ADD1 \MAXTHINCHAR)))
         (SETQ SLUGWIDTH (\FGETWIDTH WIDTHS (ADD1 \MAXTHINCHAR)))
         (SETQ N (IDIFFERENCE 0 (IQUOTIENT (IPLUS DESCENT 3)
                                       4)))
         (SETQ M (IQUOTIENT (IPLUS ASCENT 3)
                        4))
         [for I from 0 to \MAXTHINCHAR unless (EQ SLUGOFFSET (SETQ OFFSET (\FGETOFFSET OFFSETS I)))
            do (SETQ WIDTH (\FGETWIDTH WIDTHS I))
               (for J from N to M do (SETQ R (IPLUS OFFSET WIDTH))
                                     (SETQ XN (IMIN R (IMAX (IPLUS OFFSET J)
                                                            0)))
                                     (SETQ XX (IMIN R (IMAX (IPLUS R J)
                                                            0)))
                                     [SETQ YN (IMAX 0 (IPLUS DESCENT (ITIMES J 4]
                                     [SETQ YX (IMIN HEIGHT (IPLUS DESCENT (IPLUS (ITIMES J 4)
                                                                                 4]
                                     (CL:WHEN (AND (IGREATERP XX XN)
                                                   (IGREATERP YX YN))
                                         (BITBLT OLDBITMAP OFFSET YN NEWBITMAP XN YN (IDIFFERENCE
                                                                                      XX XN)
                                                (IDIFFERENCE YX YN)
                                                'INPUT
                                                'REPLACE))]
         (BITBLT OLDBITMAP SLUGOFFSET 0 NEWBITMAP SLUGOFFSET 0 SLUGWIDTH HEIGHT 'INPUT 'REPLACE)
         (create CHARSETINFO using CSINFO CHARSETBITMAP _ NEWBITMAP])
)
(DEFINEQ

(\SFMAKEROTATEDFONT
  [LAMBDA (FONTDESC ROTATION)                            (* ; "Edited 30-Mar-87 20:35 by FS")

    (* ;; "takes a fontdecriptor and rotates it.")

    (* ;; "1/5/86 JDS.  Masterscope claims nobody calls this.  Let's find out....")

    (HELP "ROTATED fonts need to be fixed for NS Chars & New FONTDESCRIPTOR fields")
                                                             (* (create FONTDESCRIPTOR using 
                                                           FONTDESC (SETQ CHARACTERBITMAP
                                                           (\SFROTATEFONTCHARACTERS
                                                           (fetch (FONTDESCRIPTOR 
                                                           CHARACTERBITMAP) of FONTDESC) 
                                                           ROTATION)) (SETQ ROTATION ROTATION)
                                                           (SETQ \SFOffsets (
                                                           \SFFIXOFFSETSAFTERROTATION FONTDESC 
                                                           ROTATION)) (SETQ FONTCHARSETVECTOR
                                                           (\ALLOCBLOCK (ADD1 \MAXCHARSET) T))))

    (* ;; "If you uncomment out the code above, remove this comment and the NIL below")

    NIL])

(\SFROTATECSINFO
  [LAMBDA (CSINFO ROTATION)                              (* gbn "15-Sep-85 14:38")

    (* ;; "takes a CHARSETINFO and rotates it and produces a rotated equivalent one.")

    (create CHARSETINFO using CSINFO CHARSETBITMAP _ (\SFROTATEFONTCHARACTERS
                                                              (fetch (CHARSETINFO CHARSETBITMAP)
                                                                 of CSINFO)
                                                              ROTATION)
                                  OFFSETS _ (\SFROTATECSINFOOFFSETS CSINFO ROTATION])

(\SFROTATEFONTCHARACTERS
  [LAMBDA (CHARBITMAP ROTATION)                          (* ; "Edited 22-Sep-87 10:38 by Snow")

(* ;;; "rotate a bitmap either 90 or 270 for fonts.")

    (CASE ROTATION
        (0 CHARBITMAP)
        (90 (ROTATE-BITMAP-LEFT CHARBITMAP))
        (180 (ROTATE-BITMAP (ROTATE-BITMAP CHARBITMAP)))
        (270 (ROTATE-BITMAP CHARBITMAP)))])

(\SFROTATECSINFOOFFSETS
  [LAMBDA (CSINFO ROTATION)                              (* gbn "15-Sep-85 14:36")
                                                             (* ; 
                                     "adjusts offsets in case where rotation turned things around.")
    (COND
       ((EQ ROTATION 270)
        (PROG ((OFFSETS (fetch (CHARSETINFO OFFSETS) of CSINFO))
               (WIDTHS (fetch (CHARSETINFO WIDTHS) of CSINFO))
               (BITMAPHEIGHT (BITMAPWIDTH (fetch (CHARSETINFO CHARSETBITMAP) of CSINFO)))
               NEWOFFSETS)
              (SETQ NEWOFFSETS (\CREATECSINFOELEMENT))
              [for CHARCODE from 0 to \MAXCHAR
                 do (\FSETOFFSET NEWOFFSETS CHARCODE (IDIFFERENCE BITMAPHEIGHT
                                                                (IPLUS (\FGETOFFSET OFFSETS CHARCODE)
                                                                       (\FGETWIDTH WIDTHS CHARCODE]
                                                             (* ; 
                                         "may be some problem with dummy character representation.")
              (RETURN NEWOFFSETS)))
       (T (fetch (CHARSETINFO OFFSETS) of CSINFO])
)
(DEFINEQ

(\SFMAKECOLOR
  [LAMBDA (BWCSINFO BACKCOLOR FORECOLOR BITSPERPIXEL)    (* kbr%: " 6-Feb-86 18:17")

    (* ;; "makes a csinfo that has a character bitmap that is colorized.")

    (PROG (CHARACTERBITMAP COLORCSINFO)
          [COND
             ((IMAGESTREAMP BITSPERPIXEL)
              (OR BACKCOLOR (SETQ BACKCOLOR (DSPBACKCOLOR NIL BITSPERPIXEL)))
              (OR FORECOLOR (SETQ FORECOLOR (DSPCOLOR NIL BITSPERPIXEL)))
              (SETQ BITSPERPIXEL (IMAGESTREAMTYPE BITSPERPIXEL]
          [SETQ BITSPERPIXEL (COND
                                ((NUMBERP BITSPERPIXEL)
                                 BITSPERPIXEL)
                                (T (\DISPLAYSTREAMTYPEBPP BITSPERPIXEL]
          (SETQ BACKCOLOR (COLORNUMBERP BACKCOLOR BITSPERPIXEL))
          (SETQ FORECOLOR (COLORNUMBERP FORECOLOR BITSPERPIXEL))
          (SETQ CHARACTERBITMAP (COLORIZEBITMAP (fetch (CHARSETINFO CHARSETBITMAP) of 
                                                                                             BWCSINFO
                                                       )
                                       BACKCOLOR FORECOLOR BITSPERPIXEL))
          (SETQ COLORCSINFO (create CHARSETINFO using BWCSINFO CHARSETBITMAP _ 
                                                          CHARACTERBITMAP))
          (RETURN COLORCSINFO])
)
(DEFINEQ

(FONTDESCRIPTOR.DEFPRINT
  [LAMBDA (FONT STREAM)                                      (* ; "Edited 10-Jul-2025 09:32 by rmk")
                                                             (* ; "Edited 14-Dec-2024 09:13 by rmk")
    (LET ((LOC (LOC FONT))
          (FACE (fetch (FONTDESCRIPTOR FONTFACE) of FONT)))

         (* ;; "Could lowercase the family, but maybe too dangerous if a BREAK on L-CASE.")

         (* ;; "Somehow flag the device too?")

         (CONS (CONCAT "{" (fetch (FONTDESCRIPTOR FONTFAMILY) of FONT)
                      (fetch (FONTDESCRIPTOR FONTSIZE) of FONT)
                      "-"
                      (SELECTQ (fetch (FONTFACE WEIGHT) of FACE)
                          (MEDIUM 'M)
                          (BOLD 'B)
                          (LIGHT 'L)
                          (fetch (FONTFACE WEIGHT) of FACE))
                      (SELECTQ (fetch (FONTFACE SLOPE) of FACE)
                          (ITALIC 'I)
                          (REGULAR 'R)
                          (fetch (FONTFACE SLOPE) of FACE))
                      (SELECTQ (fetch (FONTFACE EXPANSION) of FACE)
                          (REGULAR 'R)
                          (COMPRESSED 'C)
                          (EXPANDED 'E)
                          (fetch (FONTFACE EXPANSION) of FACE))
                      "/"
                      (OCTALSTRING (CAR LOC))
                      ","
                      (OCTALSTRING (CDR LOC))
                      "}"])

(FONTCLASS.DEFPRINT
  [LAMBDA (FONTCLASS STREAM)                                 (* ; "Edited 14-Dec-2024 16:51 by rmk")
    (LET ((LOC (LOC FONTCLASS)))
         (CONS (CONCAT "{" (OR (fetch (FONTCLASS FONTCLASSNAME) of FONTCLASS)
                               'FONTCLASS)
                      "/"
                      (OCTALSTRING (CAR LOC))
                      ","
                      (OCTALSTRING (CDR LOC))
                      "}"])
)

(/DECLAREDATATYPE 'FONTCLASS '(BYTE POINTER POINTER POINTER POINTER POINTER)
       '((FONTCLASS 0 (BITS . 7))
         (FONTCLASS 2 POINTER)
         (FONTCLASS 4 POINTER)
         (FONTCLASS 6 POINTER)
         (FONTCLASS 8 POINTER)
         (FONTCLASS 10 POINTER))
       '12)

(DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))

(/DECLAREDATATYPE 'FONTDESCRIPTOR
       '(POINTER FLAG POINTER POINTER POINTER WORD WORD WORD WORD SIGNEDWORD SIGNEDWORD SIGNEDWORD 
               SIGNEDWORD POINTER POINTER POINTER POINTER POINTER (BITS 8)
               WORD POINTER POINTER FLAG POINTER)
       '((FONTDESCRIPTOR 0 POINTER)
         (FONTDESCRIPTOR 0 (FLAGBITS . 0))
         (FONTDESCRIPTOR 2 POINTER)
         (FONTDESCRIPTOR 4 POINTER)
         (FONTDESCRIPTOR 6 POINTER)
         (FONTDESCRIPTOR 8 (BITS . 15))
         (FONTDESCRIPTOR 9 (BITS . 15))
         (FONTDESCRIPTOR 10 (BITS . 15))
         (FONTDESCRIPTOR 11 (BITS . 15))
         (FONTDESCRIPTOR 12 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 13 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 14 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 15 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 16 POINTER)
         (FONTDESCRIPTOR 18 POINTER)
         (FONTDESCRIPTOR 20 POINTER)
         (FONTDESCRIPTOR 22 POINTER)
         (FONTDESCRIPTOR 24 POINTER)
         (FONTDESCRIPTOR 26 (BITS . 7))
         (FONTDESCRIPTOR 27 (BITS . 15))
         (FONTDESCRIPTOR 28 POINTER)
         (FONTDESCRIPTOR 30 POINTER)
         (FONTDESCRIPTOR 30 (FLAGBITS . 0))
         (FONTDESCRIPTOR 32 POINTER))
       '34)

(DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))

(/DECLAREDATATYPE 'CHARSETINFO '(POINTER FLAG FLAG POINTER POINTER POINTER POINTER WORD WORD POINTER
                                       POINTER)
       '((CHARSETINFO 0 POINTER)
         (CHARSETINFO 0 (FLAGBITS . 0))
         (CHARSETINFO 0 (FLAGBITS . 16))
         (CHARSETINFO 2 POINTER)
         (CHARSETINFO 4 POINTER)
         (CHARSETINFO 6 POINTER)
         (CHARSETINFO 8 POINTER)
         (CHARSETINFO 10 (BITS . 15))
         (CHARSETINFO 11 (BITS . 15))
         (CHARSETINFO 12 POINTER)
         (CHARSETINFO 14 POINTER))
       '16)
(ADDTOVAR SYSTEMRECLST

(DATATYPE FONTCLASS ((PRETTYFONT# BYTE)
                     DISPLAYFD PRESSFD INTERPRESSFD OTHERFDS FONTCLASSNAME))

(DATATYPE FONTDESCRIPTOR ((FONTDEVICE POINTER)
                          (FONTCOMPLETEP FLAG)
                          (FONTFAMILY POINTER)
                          (FONTSIZE POINTER)
                          (FONTFACE POINTER)
                          (\SFAscent WORD)
                          (\SFDescent WORD)
                          (\SFHeight WORD)
                          (ROTATION WORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL SIGNEDWORD)
                          (NIL POINTER)
                          (NIL POINTER)
                          (FONTDEVICESPEC POINTER)
                          (OTHERDEVICEFONTPROPS POINTER)
                          (FONTSCALE POINTER)
                          (\SFFACECODE BITS 8)
                          (FONTAVGCHARWIDTH WORD)
                          (FONTCHARENCODING POINTER)
                          (FONTCHARSETVECTOR POINTER)
                          (FONTHASLEFTKERNS FLAG)
                          (FONTEXTRAFIELD2 POINTER)))

(DATATYPE CHARSETINFO (WIDTHS (CSSLUGP FLAG)
                             (CSCOMPLETEP FLAG)
                             OFFSETS IMAGEWIDTHS CHARSETBITMAP YWIDTHS (CHARSETASCENT WORD)
                             (CHARSETDESCENT WORD)
                             LEFTKERN CSINFOPROPS))
)

(RPAQ? \FONTSINCORE )

(RPAQ? \DEFAULTDEVICEFONTS )

(RPAQ? \UNITWIDTHSVECTOR )
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS \DEFAULTDEVICEFONTS \UNITWIDTHSVECTOR)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(\UNITWIDTHSVECTOR)
)
(* "FOLLOWING DEFINITIONS EXPORTED")
(DEFOPTIMIZER FONTPROP (&REST ARGS)
                       (SELECTQ (AND (EQ (CAADR ARGS)
                                         'QUOTE)
                                     (CADADR ARGS))
                           (ASCENT (LIST 'FONTASCENT (CAR ARGS)))
                           (DESCENT (LIST 'FONTDESCENT (CAR ARGS)))
                           (HEIGHT (LIST 'FONTHEIGHT (CAR ARGS)))
                           'IGNOREMACRO))

(* "END EXPORTED DEFINITIONS")

(DECLARE%: DONTCOPY 
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: EVAL@COMPILE

(DATATYPE FONTCLASS ((PRETTYFONT# BYTE)
                     DISPLAYFD PRESSFD INTERPRESSFD OTHERFDS FONTCLASSNAME)
                    (INIT (DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))))

(DATATYPE FONTDESCRIPTOR ((FONTDEVICE POINTER)
                          (FONTCOMPLETEP FLAG)
                          (FONTFAMILY POINTER)
                          (FONTSIZE POINTER)
                          (FONTFACE POINTER)
                          (\SFAscent WORD)
                          (\SFDescent WORD)
                          (\SFHeight WORD)
                          (ROTATION WORD)
                          (NIL SIGNEDWORD)

                          (* ;; "Was FBBOX.  The fields are NIL'ed out now because they became irrelevant when multiple charsets were introduced.  They remain as a place-holder in the layout pending a recompile of all referring functions.")

                          (NIL SIGNEDWORD)                   (* ; "Was FBBOY")
                          (NIL SIGNEDWORD)                   (* ; "Was FBBDX")
                          (NIL SIGNEDWORD)                   (* ; "Was FBBDY")
                          (NIL POINTER)                      (* ; "Was \SFLKerns")
                          (NIL POINTER)                      (* ; "Was \SFRWidths")
                          (FONTDEVICESPEC POINTER)           (* ; 
        "Holds the spec by which the font is known to the printing device, if coercion has been done")
                          (OTHERDEVICEFONTPROPS POINTER)     (* ; 
                                                 "For individual devices to hang special information")
                          (FONTSCALE POINTER)
                          (\SFFACECODE BITS 8)
                          (FONTAVGCHARWIDTH WORD)            (* ; 
                            "Set in FONTCREATE, used to fix up the linelength when DSPFONT is called")
                          (FONTCHARENCODING POINTER)         (* ; "Was FONTIMAGEWIDTHS: This is the image width, as opposed to the advanced width;  initial hack for accents, kerning.  Fields is referenced by FONTCREATE.")
                          (FONTCHARSETVECTOR POINTER)        (* ; "A 257-pointer block, with one pointer per 'character set' --each group of 256 character codes.  Each pointer is either NIL if there's no info for that charset, or is a CHARSETINFO, containing widths, char bitmap, etc for the characters in that charset. The last cell if not NIL is the %"slug%" charsetinfo that can be shared as the dummy entry for otherwise NIL charsets")
                          (FONTHASLEFTKERNS FLAG)            (* ; 
                                        "T if at least one character set has an entry for left kerns")
                          (FONTEXTRAFIELD2 POINTER))
                         FONTCHARSETVECTOR _ (\CREATEFONTCHARSETVECTOR)
                         (INIT (DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))))

(RECORD FONTFACE (WEIGHT SLOPE EXPANSION)
                 [ACCESSFNS ((COLOR (CDDDR DATUM)
                                    (RPLACD (CDDR DATUM)
                                           NEWVALUE))
                             (BACKCOLOR [COND
                                           ((CDDDR DATUM)
                                            (CAR (CDDDR DATUM]
                                    (PROGN [COND
                                              ((NULL (CDDDR DATUM))
                                               (RPLACD (CDDR DATUM)
                                                      (LIST NIL NIL]
                                           (RPLACA (CDDDR DATUM)
                                                  NEWVALUE)))
                             (FORECOLOR [COND
                                           ((CDDDR DATUM)
                                            (CADR (CDDDR DATUM]
                                    (PROGN [COND
                                              ((NULL (CDDDR DATUM))
                                               (RPLACD (CDDR DATUM)
                                                      (LIST NIL NIL]
                                           (RPLACA (CDR (CDDDR DATUM))
                                                  NEWVALUE]
                 WEIGHT _ 'MEDIUM SLOPE _ 'REGULAR EXPANSION _ 'REGULAR (TYPE? LISTP))

(DATATYPE CHARSETINFO (WIDTHS                                (* ; "The advance-width of each character, an array indexed by charcode.  Usually the same as the imagewidth, but can differ for accents, kerns kerns.  This is what should be used for stringwidth calculations.")
                             (CSSLUGP FLAG)                  (* ; "True if this is a slug charset")
                             (CSCOMPLETEP FLAG)              (* ; 
    "True if there is no further data to fill in any remaining slug-characters in a non-slug charset")
                             OFFSETS                         (* ; 
                              "Offset of each character into the image bitmap;  X value of left edge")
                             IMAGEWIDTHS                     (* ; "imagewidths is not automagically allocated since it is not always needed.  But at least some times the IMAGEWIDTHS and WIDTHS vectors are EQ in this case.")
                             CHARSETBITMAP                   (* ; 
                                         "Bitmap containing the character images, indexed by OFFSETS")
                             YWIDTHS
                             (CHARSETASCENT WORD)            (* ; 
                                                      "Max ascent for all characters in this CHARSET")
                             (CHARSETDESCENT WORD)           (* ; 
                                                     "Max descent for all characters in this CHARSET")
                             LEFTKERN CSINFOPROPS            (* ; "Alist of extra properties"))
                      WIDTHS _ (\CREATECSINFOELEMENT)
                      OFFSETS _ (\CREATECSINFOELEMENT))
)

(/DECLAREDATATYPE 'FONTCLASS '(BYTE POINTER POINTER POINTER POINTER POINTER)
       '((FONTCLASS 0 (BITS . 7))
         (FONTCLASS 2 POINTER)
         (FONTCLASS 4 POINTER)
         (FONTCLASS 6 POINTER)
         (FONTCLASS 8 POINTER)
         (FONTCLASS 10 POINTER))
       '12)

(DEFPRINT 'FONTCLASS (FUNCTION FONTCLASS.DEFPRINT))

(/DECLAREDATATYPE 'FONTDESCRIPTOR
       '(POINTER FLAG POINTER POINTER POINTER WORD WORD WORD WORD SIGNEDWORD SIGNEDWORD SIGNEDWORD 
               SIGNEDWORD POINTER POINTER POINTER POINTER POINTER (BITS 8)
               WORD POINTER POINTER FLAG POINTER)
       '((FONTDESCRIPTOR 0 POINTER)
         (FONTDESCRIPTOR 0 (FLAGBITS . 0))
         (FONTDESCRIPTOR 2 POINTER)
         (FONTDESCRIPTOR 4 POINTER)
         (FONTDESCRIPTOR 6 POINTER)
         (FONTDESCRIPTOR 8 (BITS . 15))
         (FONTDESCRIPTOR 9 (BITS . 15))
         (FONTDESCRIPTOR 10 (BITS . 15))
         (FONTDESCRIPTOR 11 (BITS . 15))
         (FONTDESCRIPTOR 12 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 13 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 14 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 15 (SIGNEDBITS . 15))
         (FONTDESCRIPTOR 16 POINTER)
         (FONTDESCRIPTOR 18 POINTER)
         (FONTDESCRIPTOR 20 POINTER)
         (FONTDESCRIPTOR 22 POINTER)
         (FONTDESCRIPTOR 24 POINTER)
         (FONTDESCRIPTOR 26 (BITS . 7))
         (FONTDESCRIPTOR 27 (BITS . 15))
         (FONTDESCRIPTOR 28 POINTER)
         (FONTDESCRIPTOR 30 POINTER)
         (FONTDESCRIPTOR 30 (FLAGBITS . 0))
         (FONTDESCRIPTOR 32 POINTER))
       '34)

(DEFPRINT 'FONTDESCRIPTOR (FUNCTION FONTDESCRIPTOR.DEFPRINT))

(/DECLAREDATATYPE 'CHARSETINFO '(POINTER FLAG FLAG POINTER POINTER POINTER POINTER WORD WORD POINTER
                                       POINTER)
       '((CHARSETINFO 0 POINTER)
         (CHARSETINFO 0 (FLAGBITS . 0))
         (CHARSETINFO 0 (FLAGBITS . 16))
         (CHARSETINFO 2 POINTER)
         (CHARSETINFO 4 POINTER)
         (CHARSETINFO 6 POINTER)
         (CHARSETINFO 8 POINTER)
         (CHARSETINFO 10 (BITS . 15))
         (CHARSETINFO 11 (BITS . 15))
         (CHARSETINFO 12 POINTER)
         (CHARSETINFO 14 POINTER))
       '16)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS FONTASCENT MACRO ((FONTSPEC)
                            (ffetch \SFAscent of (FONTCREATE FONTSPEC))))

(PUTPROPS FONTDESCENT MACRO ((FONTSPEC)
                             (ffetch \SFDescent of (FONTCREATE FONTSPEC))))

(PUTPROPS FONTHEIGHT MACRO ((FONTSPEC)
                            (ffetch \SFHeight of (FONTCREATE FONTSPEC))))

(PUTPROPS \FGETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE)
                              (\GETBASE OFFSETSBLOCK CHAR8CODE)))

(PUTPROPS \FSETOFFSET DMACRO ((OFFSETSBLOCK CHAR8CODE OFFSET)
                              (\PUTBASE OFFSETSBLOCK CHAR8CODE OFFSET)))

(PUTPROPS \FGETWIDTH DMACRO ((WIDTHSBLOCK CHAR8CODE)
                             (\GETBASE WIDTHSBLOCK CHAR8CODE)))

(PUTPROPS \FSETWIDTH DMACRO ((WIDTHSBLOCK CHAR8CODE VAL)
                             (\PUTBASE WIDTHSBLOCK CHAR8CODE VAL)))

(PUTPROPS \FGETCHARWIDTH MACRO (OPENLAMBDA (FONTDESC CHARCODE)
                                 (\FGETWIDTH (ffetch (CHARSETINFO WIDTHS) of (\INSURECHARSETINFO
                                                                              (\CHARSET CHARCODE)
                                                                              FONTDESC))
                                        (\CHAR8CODE CHARCODE))))

(PUTPROPS \FSETCHARWIDTH MACRO (OPENLAMBDA (FONTDESC CHARCODE WIDTH)
                                 (\FSETWIDTH (ffetch (CHARSETINFO WIDTHS) of (\GETCHARSETINFO
                                                                              (\CHARSET CHARCODE)
                                                                              FONTDESC))
                                        (\CHAR8CODE CHARCODE)
                                        WIDTH)))

(PUTPROPS \FGETIMAGEWIDTH MACRO ((IMAGEWIDTHSBLOCK CHAR8CODE)
                                 (\GETBASE IMAGEWIDTHSBLOCK CHAR8CODE)))

(PUTPROPS \FSETIMAGEWIDTH DMACRO ((WIDTHSBLOCK INDEX WIDTH)
                                  (\PUTBASE WIDTHSBLOCK INDEX WIDTH)))
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \XGETCHARSETINFO MACRO ((FONTDESC CHARSET)

                                  (* ;; 
                 "Temporary until other callers of \GETCHARSETINFO are changes to \INSURECHARSETINFO")

                                  (* ;; 
                          "Fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  ")

                                  (* ;; 
       "NOTE Current \GETCHARSETINFO takes the vector, not the font, as does current \SETCHARSETINFO")

                                  (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                         (UNFOLD CHARSET 2))))

(PUTPROPS \GETCHARSETINFO MACRO [(CHARSET FONTDESC)

                                 (* ;; "fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  If NIL, then creates the required charset, maybe a slug (with CSSLUGP T).")

                                 (OR (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                            (UNFOLD CHARSET 2))
                                     (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                                            CHARSET
                                            (\CREATECHARSET CHARSET FONTDESC])

(PUTPROPS \INSURECHARSETINFO MACRO [(CHARSET FONTDESC)

                                 (* ;; "fetches the charsetinfo for charset CHARSET in fontdescriptor FONTDESC.  If NIL, then creates the required charset, maybe a slug (with CSSLUGP T).")

                                    (OR (\GETBASEPTR (ffetch FONTCHARSETVECTOR of FONTDESC)
                                               (UNFOLD CHARSET 2))
                                        (\SETCHARSETINFO (ffetch FONTCHARSETVECTOR of FONTDESC)
                                               CHARSET
                                               (\CREATECHARSET CHARSET FONTDESC])

(PUTPROPS \CREATECSINFOELEMENT MACRO (NIL (\ALLOCBLOCK (FOLDHI (IPLUS \MAXTHINCHAR 3)
                                                              WORDSPERCELL))))

(PUTPROPS \CREATEFONTCHARSETVECTOR MACRO (NIL 

                                            (* ;; "Allocates a block for the character set records, including one extra slot to hold the common slug charsetinfo")

                                              (\ALLOCBLOCK (IPLUS 2 \MAXCHARSET)
                                                     T)))

(PUTPROPS CHARSETPROP MACRO [ARGS (if (CDDR ARGS)
                                      then `(PUTMULTI (fetch (CHARSETINFO CSINFOPROPS)
                                                         of ,(CAR ARGS))
                                                   ,(CADR ARGS)
                                                   ,(CADDR ARGS))
                                    else `(GETMULTI (fetch (CHARSETINFO CSINFOPROPS)
                                                       of ,(CAR ARGS))
                                                 ,(CADR ARGS])
)
(DECLARE%: EVAL@COMPILE 

(RPAQQ \MAXNSCHAR 65535)


(CONSTANTS (\MAXNSCHAR 65535))
)

(* "END EXPORTED DEFINITIONS")


(DECLARE%: EVAL@COMPILE 

(PUTPROPS INDIRECTCHARSETP MACRO [(CSINFO FONT CHARSET)

                                  (* ;; "An indirect points somewhere else")

                                  (LET ([SOURCE (CL:UNLESS (fetch (CHARSETINFO CSSLUGP) of CSINFO)
                                                    (CHARSETPROP CSINFO 'SOURCE))]
                                        (FONTSPEC (fetch (FONTDESCRIPTOR FONTDEVICESPEC) of FONT)))
                                       (NOT (AND SOURCE (EQ (pop SOURCE)
                                                            (pop FONTSPEC))
                                                 (EQ (pop SOURCE)
                                                     (pop FONTSPEC))
                                                 (EQUAL (pop SOURCE)
                                                        (pop FONTSPEC))
                                                 (EQ (pop SOURCE)
                                                     (pop FONTSPEC))
                                                 (EQ (pop SOURCE)
                                                     (pop FONTSPEC))
                                                 (EQ (pop SOURCE)
                                                     CHARSET])

(PUTPROPS MAKECSSOURCE MACRO ((FAMILY SIZE FACE ROTATION DEVICE CHARSET)
                                                             (* ; 
                                                     "Corresponds to order of \READCHARSET arguments")

                              (* ;; 
                             "If FAMILY is a font, the uses its properties, and SIZE is the charset.")

                              (CL:IF (type? FONTDESCRIPTOR FAMILY)
                                  (APPEND (fetch (FONTDESCRIPTOR FONTDEVICESPEC) of FAMILY)
                                         (CONS SIZE))
                                  (LIST FAMILY SIZE FACE ROTATION DEVICE CHARSET))))
)
)
(DEFINEQ

(\CREATEKERNELEMENT
  [LAMBDA NIL                                                (* ; "Edited  8-Jul-2025 22:33 by rmk")
                                                             (* ; "Edited 17-May-2025 09:36 by rmk")

    (* ;; "ARRAY not CL:MAKE-ARRAY for MAKEINIT.")

    (ARRAY (IPLUS \MAXTHINCHAR 3)
           'POINTER 0 0])

(\FSETLEFTKERN
  [LAMBDA (CSINFO INDEX KERNVALUE)                           (* ; "Edited  8-Jul-2025 22:50 by rmk")
                                                             (* ; "Edited 17-May-2025 09:18 by rmk")
    (CL:UNLESS (ARRAYP (ffetch (CHARSETINFO LEFTKERN) of CSINFO))
        (replace (CHARSETINFO LEFTKERN) of CSINFO with (\CREATEKERNELEMENT)))
    (SETA (fetch (CHARSETINFO LEFTKERN) of CSINFO)
          INDEX KERNVALUE])

(\FGETLEFTKERN
  [LAMBDA (FONT PREVCHARCODE CHARCODE)                       (* ; "Edited  8-Jul-2025 22:15 by rmk")
                                                             (* ; "Edited 22-May-2025 09:53 by rmk")
                                                             (* ; "Edited 18-May-2025 21:30 by rmk")
                                                             (* ; "Edited  1-May-2025 11:08 by rmk")
                                                             (* ; "Edited 19-Dec-2024 15:25 by rmk")

    (* ;; "Returns the kern information for CHARCODE in FONT, given that it is an immediate successor of PREVCHARCODE.  Returns 0 if no PREVCHARCODE/CHARCODE kerning is specified.  For now, assume that the kerning information is sparse for characters within a character set, stored as a 2-level alist.  ")

    (* ;; "If the kerning information for a character is already a FIXP, then it is an offset no matter what the preceding character might be.  This appears to be the way at least AC font files are set up.")

    (* ;; "ACFONTFILES STORE A SINGLE NUMBER.  LOGIC OF CODES IS UNCLEAR")

    (LET [(KERN (AND (fetch (FONTDESCRIPTOR FONTHASLEFTKERNS) of FONT)
                     (ELT (fetch (CHARSETINFO LEFTKERN) of (\INSURECHARSETINFO (\CHARSET PREVCHARCODE
                                                                                      )
                                                                  FONT))
                          (\CHAR8CODE PREVCHARCODE]
         (OR (FIXP KERN)
             (FGETMULTI (LISTP KERN)
                    CHARCODE)
             0])
)
(DEFINEQ

(\CREATEFONT
  [LAMBDA (FAMILY SIZE FACE ROTATION DEVICE CHARSET)         (* ; "Edited 24-Jul-2025 19:51 by rmk")
                                                             (* ; "Edited 20-May-2025 21:10 by rmk")

    (* ;; "Generic font creation.  Uses fontcreate method from device, build a fontdescriptor but doesn't call SETFONTDESCRIPTOR to install it.")

    (* ;; "\DEFAULTCHARSET is kind of foolish, since \AVGCHARWIDTH wants the width of A=0,101 and therefore forces charset 0.   (A may be some random character in Symbol, Math, but...).")

    (LET (FN FONT)
         (CL:WHEN (AND [SETQ FN (CADR (ASSOC 'FONTCREATE (CDR (ASSOC DEVICE IMAGESTREAMTYPES]
                       (SETQ FONT (APPLY* FN FAMILY SIZE FACE ROTATION DEVICE CHARSET)))
             (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONT with (\AVGCHARWIDTH FONT))
             FONT)])

(\CREATECHARSET
  [LAMBDA (CHARSET FONT NOSLUG?)                             (* ; "Edited 22-Jul-2025 22:48 by rmk")
                                                             (* ; "Edited  9-Jul-2025 11:12 by rmk")
                                                             (* ; "Edited 15-Jun-2025 14:50 by rmk")
                                                             (* ; "Edited 13-Jun-2025 20:00 by rmk")
                                                             (* ; "Edited 10-Jun-2025 13:55 by rmk")
                                                             (* ; "Edited  7-Jun-2025 15:10 by rmk")
                                                             (* ; "Edited 18-May-2025 21:40 by rmk")
                                                             (* ; "Edited 16-May-2025 21:37 by rmk")
                                                             (* ; "Edited 12-Jul-2022 14:37 by rmk")
                                                             (* ; "Edited  8-May-93 23:42 by rmk:")
                                                             (* ; "Edited  4-Dec-92 11:43 by jds")

    (* ;; "Creates and returns the CHARSETINFO for charset CHARSET in fontdesc FONT, installing it in fonts FONTCHARSETVECTOR")
                                                             (* ; 
    "NOSLUG?  means don't create an empty (slug) csinfo if the charset is not found, just return NIL")
    (CL:UNLESS (<= 0 CHARSET \MAXCHARSET)
           (\ILLEGAL.ARG CHARSET))
    (LET [(CSINFO (if (fetch (FONTDESCRIPTOR FONTCOMPLETEP) of FONT)
                      then (\XGETCHARSETINFO FONT CHARSET)
                    else (APPLY [CADR (ASSOC 'CREATECHARSET (CDR (ASSOC (fetch (FONTDESCRIPTOR 
                                                                                      FONTDEVICE)
                                                                           of FONT)
                                                                        IMAGESTREAMTYPES]
                                (APPEND (FONTPROP FONT 'DEVICESPEC)
                                       (LIST CHARSET FONT NOSLUG?]

         (* ;; "Create a descriptor of info for that charset. If we got one, the subfunction may have ignored NOSLUG?.  But if not, we store it in the vector so that we don't search later.  But we don't return a slug:  higher ups recognize NIL as a doesn't-exist error.  ")

         (CL:WHEN CSINFO (\INSTALLCHARSETINFO FONT CSINFO CHARSET))
         CSINFO])

(\INSTALLCHARSETINFO
  [LAMBDA (FONT CSINFO CHARSET)                              (* ; "Edited 25-May-2025 07:48 by rmk")
                                                             (* ; "Edited 23-May-2025 14:44 by rmk")
                                                             (* ; "Edited 12-Jul-2022 15:08 by rmk")
    (replace \SFAscent of FONT with (IMAX (fetch \SFAscent of FONT)
                                          (SIGNED (fetch CHARSETASCENT of CSINFO)
                                                 16)))
    (replace (FONTDESCRIPTOR \SFDescent) of FONT with (IMAX (fetch (FONTDESCRIPTOR \SFDescent)
                                                               of FONT)
                                                            (SIGNED (fetch (CHARSETINFO 
                                                                                  CHARSETDESCENT)
                                                                       of CSINFO)
                                                                   16)))
                                                             (* ; 
                                "jtm: height = ascent + descent, not (IMAX fontHeight charSetHeight)")
    (replace (FONTDESCRIPTOR \SFHeight) of FONT with (IPLUS (fetch (FONTDESCRIPTOR \SFAscent)
                                                               of FONT)
                                                            (ffetch (FONTDESCRIPTOR \SFDescent)
                                                               of FONT)))
    (\SETCHARSETINFO (fetch (FONTDESCRIPTOR FONTCHARSETVECTOR) of FONT)
           CHARSET CSINFO)

    (* ;; "\AVGCHARWIDTH has to be confused after the CSINFO is stuck in.")

    (replace (FONTDESCRIPTOR FONTAVGCHARWIDTH) of FONT with (\AVGCHARWIDTH FONT))
    (\INSTALLCHARSETINFO.CHARENCODING FONT CSINFO CHARSET)
    CSINFO])

(\INSTALLCHARSETINFO.CHARENCODING
  [LAMBDA (FONT CSINFO CHARSET)                              (* ; "Edited 12-Jul-2025 10:57 by rmk")
                                                             (* ; "Edited  9-Jul-2025 09:38 by rmk")
                                                             (* ; "Edited  6-Jul-2025 21:46 by rmk")
                                                             (* ; "Edited 25-May-2025 23:05 by rmk")
                                                             (* ; "Edited 24-May-2025 21:42 by rmk")

    (* ;; "The font charencoding is its charset 0 encoding.  All higher charsets are MCCS.")

    (CL:WHEN (AND (EQ CHARSET 0)
                  (NOT (fetch (CHARSETINFO CSSLUGP) of CSINFO)))
        (replace (FONTDESCRIPTOR FONTCHARENCODING) of FONT with (CHARSETPROP CSINFO 'CSCHARENCODING)))
    ])
)
(* "FOLLOWING DEFINITIONS EXPORTED")(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS DISPLAYFONTDIRECTORIES DISPLAYFONTEXTENSIONS DISPLAYGLYPHCOERCIONS DISPLAYFONTCOERCIONS)
)

(* "END EXPORTED DEFINITIONS")




(* ;; 
"Removed ((CLASSIC 36) (CLASSIC 24)) so that TIMESROMAN 36 BOLD boldifies rather than coercing to CLASSIC 24 BOLD."
)


(RPAQ? DISPLAYFONTCOERCIONS
       '(((HELVETICA 1)
          (HELVETICA 4))
         ((HELVETICA 2)
          (HELVETICA 4))
         ((MODERN 60)
          (MODERN 48))
         ((MODERN 96)
          (MODERN 72))
         ((MODERN 120)
          (MODERN 72))
         ((PALATINO 9)
          (PALATINO 12))
         ((PALATINO 8)
          (PALATINO 10))
         ((PALATINO 6)
          (PALATINO 10))
         ((TITAN 6)
          (TITAN 10))
         ((TITAN 9 (TITAN 10)))
         ((LPT)
          (AMTEX))))

(RPAQ? DISPLAYGLYPHCOERCIONS '(((GACHA)
                                (TERMINAL))
                               ((MODERN)
                                (CLASSIC))
                               ((TIMESROMAN)
                                (CLASSIC))
                               ((HELVETICA)
                                (MODERN))
                               ((TERMINAL)
                                (MODERN))))

(RPAQ? ADOBEDISPLAYFONTCOERCIONS
       '(((HELVETICABLACK 16)
          (HELVETICABLACK 18))
         ((SYMBOL)
          (ADOBESYMBOL))
         ((SYMBOL 11)
          (ADOBESYMBOL 10))
         ((AVANTGARDE-DEMI)
          (AVANTGARDE))
         ((AVANTGARDE-BOOK)
          (AVANTGARDE))
         ((NEWCENTURYSCHLBK)
          (CENTURYSCHOOLBOOK))
         ((BOOKMAN-LIGHT)
          (BOOKMAN))
         ((BOOKMAN-DEMI)
          (BOOKMAN))
         ((HELVETICA-NARROW)
          (HELVETICANARROW))
         ((HELVETICA 24)
          (ADOBEHELVETICA 24))))

(RPAQ? \DEFAULTCHARSET 0)



(* ; "MAPPING FOR DOS FILENAMES ")


(RPAQ? *DISPLAY-FONT-NAME-MAP*
       '((TIMESROMAN . TR)
         (HELVETICA . HV)
         (TIMESROMAND . TD)
         (HELVETICAD . HD)
         (MODERN . MD)
         (CLASSIC . CL)
         (GACHA . GC)
         (TITAN . TI)
         (LETTERGOTHIC . LG)
         (BOLDPS . BP)
         (TERMINAL . TM)
         (CLASSICTHIN . CT)
         (HIPPO . HP)
         (LOGO . LG)
         (MATH . MA)
         (OLDENGLISH . OE)
         (SYMBOL . SY)))
(DEFINEQ

(\FONTRESETCHARWIDTHS
  [LAMBDA (CSINFO FIRSTCHAR LASTCHAR)                    (* AJB " 6-Dec-85 14:42")
                                                             (* ; 
                                                     "sets the widths array from the offsets array")
    (PROG ((mincharcode FIRSTCHAR)
           (maxcharcode LASTCHAR)
           (offsets (fetch (CHARSETINFO OFFSETS) of CSINFO))
           (widths (fetch (CHARSETINFO WIDTHS) of CSINFO))
           left right charoffset dummycharoffset dummycharwidth)
          (SETQ dummycharoffset (\FGETOFFSET offsets (ADD1 maxcharcode)))
          (SETQ dummycharwidth (IDIFFERENCE (\FGETOFFSET offsets (IPLUS maxcharcode 2))
                                      dummycharoffset))
          [for charcode from 0 to \MAXCHAR
             do (COND
                       ((OR (ILESSP charcode mincharcode)
                            (IGREATERP charcode maxcharcode))
                        (\FSETOFFSET offsets charcode dummycharoffset)
                        (\FSETWIDTH widths charcode dummycharwidth))
                       (T (SETQ left (\FGETWIDTH offsets charcode))
                          (SETQ right (\FGETWIDTH offsets (ADD1 charcode)))
                          (COND
                             ((EQ left right)
                              (\FSETOFFSET offsets charcode dummycharoffset)
                              (\FSETWIDTH widths charcode dummycharwidth))
                             (T (\FSETWIDTH widths charcode (IDIFFERENCE right left]
          (\FSETWIDTH widths (ADD1 \MAXCHAR)
                 dummycharwidth)
          (\FSETOFFSET offsets (ADD1 \MAXCHAR)
                 dummycharoffset])
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS DISPLAYCHARSETFNS)
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(RPAQ? DISPLAYFONTDIRECTORIES NIL)


(ADDTOVAR DISPLAYCHARSETFNS (STRIKE STRIKEFONT.FILEP STRIKEFONT.GETCHARSET))
)
(DECLARE%: DONTEVAL@LOAD DOCOPY 

(ADDTOVAR DISPLAYFONTEXTENSIONS MEDLEYDISPLAYFONT DISPLAYFONT)
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(RPAQQ MAXCODE 255)

(RPAQQ DUMMYINDEX 256)


(CONSTANTS (MAXCODE 255)
       (DUMMYINDEX 256))
)
)
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \FGETCHARIMAGEWIDTH MACRO (OPENLAMBDA (FONT CHARCODE)
                                      (\FGETWIDTH (ffetch (CHARSETINFO IMAGEWIDTHS)
                                                     of (\INSURECHARSETINFO (\CHARSET CHARCODE)
                                                               FONT))
                                             (\CHAR8CODE CHARCODE))))

(PUTPROPS \SETCHARSETINFO MACRO ((CHARSETVECTOR CHARSET CSINFO)
                                 (\RPLPTR CHARSETVECTOR (UNFOLD CHARSET 2)
                                        CSINFO)))
)
(DECLARE%: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)

(PUTPROPS FONT FILETYPE :FAKE-COMPILE-FILE)
(DECLARE%: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA )

(ADDTOVAR NLAML )

(ADDTOVAR LAMA FONTCOPY)
)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (11262 20708 (CHARWIDTH 11272 . 12057) (CHARWIDTHY 12059 . 13532) (STRINGWIDTH 13534 . 
14627) (\CHARWIDTH.DISPLAY 14629 . 15042) (\STRINGWIDTH.DISPLAY 15044 . 15468) (\STRINGWIDTH.GENERIC 
15470 . 20706)) (20709 27229 (DEFAULTFONT 20719 . 22004) (FONTCLASS 22006 . 24168) (FONTCLASSUNPARSE 
24170 . 25069) (FONTCLASSCOMPONENT 25071 . 25659) (SETFONTCLASSCOMPONENT 25661 . 26103) (
GETFONTCLASSCOMPONENT 26105 . 27227)) (28959 53120 (FONTCREATE 28969 . 31552) (FONTCREATE1 31554 . 
33547) (FONTCREATE.SLUGFD 33549 . 35165) (\FONT.CHECKARGS 35167 . 41194) (\FONT.CHECKARGS1 41196 . 
45719) (\FONTCREATE1.NOFN 45721 . 45935) (FONTFILEP 45937 . 46716) (\READCHARSET 46718 . 50970) (
\COERCEFONTSPEC 50972 . 53118)) (53121 54300 (\COERCEFONTDESC 53131 . 54298)) (54951 60242 (
COMPLETE.FONT 54961 . 56942) (COMPLETEFONTP 56944 . 57459) (COMPLETE.CHARSET 57461 . 59628) (
PRUNEFONTSLUGS 59630 . 60240)) (60281 67749 (FONTASCENT 60291 . 60675) (FONTDESCENT 60677 . 61162) (
FONTHEIGHT 61164 . 61566) (FONTPROP 61568 . 67026) (\AVGCHARWIDTH 67028 . 67747)) (67796 68445 (
EDITCHAR 67806 . 68443)) (68491 80057 (GETCHARBITMAP 68501 . 69323) (PUTCHARBITMAP 69325 . 71402) (
\GETCHARBITMAP.CSINFO 71404 . 73311) (\PUTCHARBITMAP.CSINFO 73313 . 80055)) (80058 93233 (
MOVECHARBITMAP 80068 . 81962) (MOVEFONTCHARS 81964 . 87336) (\MOVEFONTCHAR 87338 . 90845) (
SLUGCHARP.DISPLAY 90847 . 91745) (\GETCHARINFO 91747 . 93231)) (94162 113415 (FONTFILES 94172 . 95641)
 (\FINDFONTFILE 95643 . 97360) (\FONTFILENAMES 97362 . 98236) (\FONTFILENAME 98238 . 102221) (
\FONTFILENAME.OLD 102223 . 105172) (\FONTFILENAME.NEW 105174 . 107431) (\FONTINFOFROMFILENAME 107433
 . 111134) (\FONTINFOFROMFILENAME.OLD 111136 . 113413)) (113682 148361 (FONTCOPY 113692 . 118755) (
FONTP 118757 . 119056) (FONTUNPARSE 119058 . 121622) (SETFONTDESCRIPTOR 121624 . 122870) (
\STREAMCHARWIDTH 122872 . 127036) (\UNITWIDTHSVECTOR 127038 . 127401) (\COERCECHARSET 127403 . 128857)
 (\BUILDSLUGCSINFO 128859 . 131615) (\FONTSYMBOL 131617 . 132267) (\DEVICESYMBOL 132269 . 133138) (
\FONTFACE 133140 . 140330) (\FONTFACE.COLOR 140332 . 147252) (SETFONTCHARENCODING 147254 . 148359)) (
148362 163750 (FONTSAVAILABLE 148372 . 150317) (FONTEXISTS? 150319 . 154810) (\FONTSAVAILABLE.INCORE 
154812 . 156360) (\SEARCHFONTFILES 156362 . 159390) (FLUSHFONTSINCORE 159392 . 160540) (MATCHFONTFACE 
160542 . 161357) (FINDFONTFILES 161359 . 163748)) (163843 172559 (\CREATEDISPLAYFONT 163853 . 165449) 
(\CREATECHARSET.DISPLAY 165451 . 171385) (\FONTEXISTS?.DISPLAY 171387 . 172557)) (172560 185761 (
STRIKEFONT.FILEP 172570 . 173458) (STRIKEFONT.GETCHARSET 173460 . 178295) (WRITESTRIKEFONTFILE 178297
 . 182301) (STRIKECSINFO 182303 . 185759)) (185792 197502 (MAKEBOLD.CHARSET 185802 . 187633) (
MAKEBOLD.CHAR 187635 . 188965) (MAKEITALIC.CHARSET 188967 . 190804) (MAKEITALIC.CHAR 190806 . 192839) 
(\SFMAKEBOLD 192841 . 194847) (\SFMAKEITALIC 194849 . 197500)) (197503 201208 (\SFMAKEROTATEDFONT 
197513 . 198914) (\SFROTATECSINFO 198916 . 199553) (\SFROTATEFONTCHARACTERS 199555 . 199935) (
\SFROTATECSINFOOFFSETS 199937 . 201206)) (201209 202590 (\SFMAKECOLOR 201219 . 202588)) (202591 204658
 (FONTDESCRIPTOR.DEFPRINT 202601 . 204180) (FONTCLASS.DEFPRINT 204182 . 204656)) (225140 227684 (
\CREATEKERNELEMENT 225150 . 225508) (\FSETLEFTKERN 225510 . 226001) (\FGETLEFTKERN 226003 . 227682)) (
227685 234183 (\CREATEFONT 227695 . 228604) (\CREATECHARSET 228606 . 231242) (\INSTALLCHARSETINFO 
231244 . 233270) (\INSTALLCHARSETINFO.CHARENCODING 233272 . 234181)) (236577 238329 (
\FONTRESETCHARWIDTHS 236587 . 238327)))))
STOP
