(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "XCL" BASE 10)
(FILECREATED " 4-Feb-2021 19:07:44" |{DSK}<home>larry>ilisp>medley>sources>MACHINEINDEPENDENT.;2| 77071  

      |changes| |to:|  (VARS MACHINEINDEPENDENTCOMS)

      |previous| |date:| "27-Feb-91 18:30:38" 
|{DSK}<home>larry>ilisp>medley>sources>MACHINEINDEPENDENT.;1|)


; Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989, 1990, 1991, 2021 by Venue & Xerox Corporation.  All rights reserved.
; The following program was created in 1983 but has not been published
; within the meaning of the copyright law, is furnished under license,
; and may not be used, copied and/or disclosed except in accordance
; with the terms of said license.

(PRETTYCOMPRINT MACHINEINDEPENDENTCOMS)

(RPAQQ MACHINEINDEPENDENTCOMS
       ((COMS                                                (* \; " \"File loader\"")
              (FNS LOAD? FILESLOAD DOFILESLOAD FINDFILE-WITH-EXTENSIONS READ-FILECREATED)
              (INITVARS (*COMPILED-EXTENSIONS* (LIST FASL.EXT COMPILE.EXT))))
        (COMS                                                (* \; 
                                                           "random machine-independent utilities")
              (FNS DMPHASH HASHOVERFLOW)
              (DECLARE\: EVAL@COMPILE DONTCOPY (MACROS HASHOVERFLOW.ARRAYTEST 
                                                      HASHOVERFLOW.UPDATEARRAY))
              (FNS BKBUFS CHANGENAME CHNGNM CLBUFS DEFINE FNS.PUTDEF EQMEMB EQUALN FNCHECK FNTYP1 
                   LCSKIP MAPRINT MKLIST NAMEFIELD NLIST PRINTBELLS PROMPTCHAR RAISEP READFILE 
                   READLINE REMPROPLIST RESETBUFS TAB UNSAVED1 WRITEFILE CLOSE-AND-MAYBE-DELETE 
                   UNSAFE.TO.MODIFY)
              (VARS UNSAFE.TO.MODIFY.FNS)
              (COMS                                          (* \; 
            "FILEDATE, for finding out the creation date of source files, from the compiled files.")
                    
                    (* |;;| "FASL isn't loaded when MACHINEINDEPENDENT is, so we have to fake the FASL checker for now.  It's defined in FASLOAD.")

                    (FNS FILEDATE)
                    (P (MOVD? 'NILL 'FASL-FILEDATE)))
              (P (MOVD? 'CL:FMAKUNBOUND 'UNDOABLY-FMAKUNBOUND))
                                                             (* \; 
                                                         "used in FNS.PUTDEF before CMLUNDO loaded")
              )
        (COMS                                                (* \; 
                   "Functions for retrieving and remembering FILEMAPs and file reader environments")
              (FNS FILEMAP \\PARSE-FILE-HEADER GET-ENVIRONMENT-AND-FILEMAP 
                   LOOKUP-ENVIRONMENT-AND-FILEMAP GET-FILEMAP-FROM-FILECREATED \\FILEMAP-HASHOVERFLOW
                   FLUSHFILEMAPS LISPSOURCEFILEP GETFILEMAP PUTFILEMAP UPDATEFILEMAP 
                   PRINT-READER-ENVIRONMENT)
              (INITVARS (*FILEMAP-LIMIT* 20)
                     (*FILEMAP-VERSIONS* 2)
                     (*FILEMAP-HASH* (HASHARRAY *FILEMAP-LIMIT* (FUNCTION \\FILEMAP-HASHOVERFLOW)
                                            (FUNCTION STRING-EQUAL-HASHBITS)
                                            (FUNCTION STRING.EQUAL))))
              (DECLARE\: EVAL@COMPILE DONTCOPY (RECORDS FILEMAPHASH)
                     (GLOBALVARS *FILEMAP-LIMIT* *FILEMAP-VERSIONS* *FILEMAP-HASH*)))
        (COMS (* * LVLPRINT)
              (FNS LVLPRINT LVLPRIN1 LVLPRIN2 LVLPRIN LVLPRIN0))
        (COMS                                                (* \; "used by PRINTOUT")
              (FNS FLUSHRIGHT PRINTPARA PRINTPARA1))
        (COMS                                                (* \; "SUBLIS and friends")
              (FNS SUBLIS SUBPAIR DSUBLIS))
        (COMS (* * CONSTANTS)
              (FNS CONSTANTOK)
              (P (MOVD? 'EVQ 'CONSTANT)
                 (MOVD? 'EVQ 'DEFERREDCONSTANT)
                 (MOVD? 'EVQ 'LOADTIMECONSTANT)))
        (COMS (* * SCRATCHLIST)
              (PROP MACRO SCRATCHLIST ADDTOSCRATCHLIST)
              (PROP INFO SCRATCHLIST))
        (GLOBALVARS SYSFILES LOADOPTIONS LISPXCOMS CLISPTRANFLG COMMENTFLG HISTSTR4 LISPXREADFN 
               REREADFLG HISTSTR0 CTRLUFLG NOLINKMESS PROMPTCHARFORMS PROMPT#FLG FILERDTBL SPELLINGS2
               USERWORDS BELLS CLISPARRAY)
        (FNS NLAMBDA.ARGS)
        (DECLARE\:
         DONTEVAL@LOAD DOCOPY                                (* \; 
                                                  "initialization of variables used in many places")
         (ADDVARS (CLISPARRAY)
                (CLISPFLG)
                (CTRLUFLG)
                (EDITCALLS)
                (EDITHISTORY)
                (EDITUNDOSAVES)
                (EDITUNDOSTATS)
                (GLOBALVARS)
                (LCASEFLG)
                (LISPXBUFS)
                (LISPXCOMS)
                (LISPXFNS)
                (LISPXHIST)
                (LISPXHISTORY)
                (LISPXPRINTFLG)
                (NOCLEARSTKLST)
                (NOFIXFNSLST)
                (NOFIXVARSLST)
                (P.A.STATS)
                (PROMPTCHARFORMS)
                (READBUF)
                (READBUFSOURCE)
                (REREADFLG)
                (RESETSTATE)
                (SPELLSTATS1))
         (INITVARS (CHCONLST '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL 
                                   NIL NIL NIL))
                (CHCONLST1 '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL
                                 NIL NIL))
                (CHCONLST2 '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL
                                 NIL NIL))
                (CLEARSTKLST T)
                (CLISPTRANFLG 'CLISP\ )
                (HISTSTR0 "<c.r.>")
                (HISTSTR2 "repeat")
                (HISTSTR3 "from event:")
                (HISTSTR4 "ignore")
                (LISPXREADFN 'READ)
                (USEMAPFLG T))
         (P (MAPC '((APPLY BLKAPPLY)
                    (SETTOPVAL SETATOMVAL)
                    (GETTOPVAL GETATOMVAL)
                    (APPLY* BLKAPPLY*)
                    (RPLACA FRPLACA)
                    (RPLACD FRPLACD)
                    (STKNTH FSTKNTH)
                    (STKNAME FSTKNAME)
                    (CHARACTER FCHARACTER)
                    (STKARG FSTKARG)
                    (CHCON DCHCON)
                    (UNPACK DUNPACK)
                    (ADDPROP /ADDPROP)
                    (ATTACH /ATTACH)
                    (DREMOVE /DREMOVE)
                    (DSUBST /DSUBST)
                    (NCONC /NCONC)
                    (NCONC1 /NCONC1)
                    (PUT /PUT)
                    (PUTPROP /PUTPROP)
                    (PUTD /PUTD)
                    (REMPROP /REMPROP)
                    (RPLACA /RPLACA)
                    (RPLACD /RPLACD)
                    (SET /SET)
                    (SETATOMVAL /SETATOMVAL)
                    (SETTOPVAL /SETTOPVAL)
                    (SETPROPLIST /SETPROPLIST)
                    (SET SAVESET)
                    (PRINT LISPXPRINT)
                    (PRIN1 LISPXPRIN1)
                    (PRIN2 LISPXPRIN2)
                    (SPACES LISPXSPACES)
                    (TAB LISPXTAB)
                    (TERPRI LISPXTERPRI)
                    (PRINT SHOWPRINT)
                    (PRIN2 SHOWPRIN2)
                    (PUTHASH /PUTHASH)
                    '*
                    (FNCLOSER /FNCLOSER)
                    (FNCLOSERA /FNCLOSERA)
                    (FNCLOSERD /FNCLOSERD)
                    (EVQ DELFILE)
                    (NILL SMASHFILECOMS)
                    (PUTASSOC /PUTASSOC)
                    (LISTPUT1 PUTL)
                    (NILL I.S.OPR)
                    (NILL RESETUNDO)
                    (NILL LISPXWATCH)
                    'ADDSTATS
                    (NILL FREEVARS)
                    'USEDFREE
                    (COPYBYTES COPYCHARS))
                  (FUNCTION (LAMBDA (X)
                                   (MOVD? (CAR X)
                                          (CADR X)))))
            (MAPC '((TIME PRIN1 LISPXPRIN1)
                    (TIME SPACES LISPXSPACES)
                    (TIME PRINT LISPXPRINT)
                    (DEFC PRINT LISPXPRINT)
                    (DEFC PUTD /PUTD)
                    (DEFC PUTPROP /PUTPROP)
                    (DOLINK FNCLOSERD /FNCLOSERD)
                    (DOLINK FNCLOSERA /FNCLOSERA)
                    (DEFLIST PUTPROP /PUTPROP)
                    (SAVEDEF1 PUTPROP /PUTPROP)
                    (MKSWAPBLOCK PUTD /PUTD))
                  (FUNCTION (LAMBDA (X)
                                   (AND (CCODEP (CAR X))
                                        (APPLY 'CHANGENAME X)))))
            (MAPC '((EVALQT (LAMBDA NIL (PROG (TEM)
                                              (RESETRESTORE NIL 'RESET)
                                              LP
                                              (PROMPTCHAR '_ T)
                                              (LISPX (LISPXREAD T T))
                                              (GO LP))))
                    (LISPX (LAMBDA (LISPXX)
                                  (PRINT (AND LISPXX (PROG (LISPXLINE LISPXHIST TEM)
                                                           (RETURN (COND ((AND (NLISTP LISPXX)
                                                                               (SETQ LISPXLINE
                                                                                     (READLINE T NIL
                                                                                            T)))
                                                                          (APPLY LISPXX (CAR 
                                                                                            LISPXLINE
                                                                                             )))
                                                                         (T (EVAL LISPXX))))))
                                         T T)))
                    (LISPXREAD (LAMBDA (FILE RDTBL)
                                      (COND (READBUF (PROG1 (CAR READBUF)
                                                         (SETQ READBUF (CDR READBUF))))
                                            (T (READ FILE RDTBL)))))
                    (LISPXREADP (LAMBDA (FLG)
                                       (COND ((AND READBUF (SETQ READBUF (LISPXREADBUF READBUF)))
                                              T)
                                             (T (READP T FLG)))))
                    (LISPXUNREAD (LAMBDA (LST)
                                        (SETQ READBUF (APPEND LST (CONS HISTSTR0 READBUF)))))
                    (LISPXREADBUF (LAMBDA (RDBUF)
                                         (PROG NIL LP (COND ((NLISTP RDBUF)
                                                             (RETURN NIL))
                                                            ((EQ (CAR RDBUF)
                                                                 HISTSTR0)
                                                             (SETQ RDBUF (CDR RDBUF))
                                                             (GO LP))
                                                            (T (RETURN RDBUF))))))
                    (LISPX/ (LAMBDA (X)
                                   X))
                    (LOWERCASE (LAMBDA (FLG)
                                      (PROG1 LCASEFLG
                                          (RAISE (NULL FLG))
                                          (RPAQ LCASEFLG FLG))))
                    (FILEPOS (LAMBDA (STR FILE)
                                    (PROG NIL LP (COND ((EQ (PEEKC FILE)
                                                            (NTHCHAR STR 1))
                                                        (RETURN T)))
                                          (READC FILE)
                                          (GO LP))))
                    (FILEPKGCOM (NLAMBDA NIL NIL)))
                  (FUNCTION (LAMBDA (L)
                                   (OR (GETD (CAR L))
                                       (PUTD (CAR L)
                                             (CADR L))))))))
        (DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS (ADDVARS (NLAMA RESETBUFS 
                                                                                      DMPHASH 
                                                                                      FILESLOAD)
                                                                             (NLAML FILEMAP)
                                                                             (LAMA READFILE NLIST)))
        (LOCALVARS . T)))



(* \; " \"File loader\"")

(DEFINEQ

(load?
(lambda (file ldflg printflg) (* |lmm| " 2-Sep-85 13:15") (|bind| full |until| (setq full (findfile file)) |do| (setq file (lisperror "FILE NOT FOUND" file t)) |finally| (return (|if| (fmemb full loadedfilelst) |then| full |else| (let* ((root (rootfilename full)) (dates (getprop root (quote filedates))) (fileprop (getprop root (quote file)))) (|if| (and dates (|if| (eq (filenamefield full (quote extension)) compile.ext) |then| (and (or (null fileprop) (fmemb (cdar fileprop) (quote (|Compiled| compiled)))) (equal (caar dates) (filedate full t))) |else| (and fileprop (eq (cdar fileprop) t) (or (eq (cdar dates) full) (equal (caar dates) (filedate full)))))) |then| full |else| (load full ldflg printflg)))))))
)

(filesload
(nlambda files (* |lmm| "10-Dec-84 17:23") (* |;;| "Calls to this are written on files by the FILES command.  This function does the load-time evaluation of the command.") (dofilesload (nlambda.args files)))
)

(dofilesload
(lambda (files) (declare (usedfree ldflg)) (* \; "Edited  4-May-88 14:23 by bvm") (* \; "does the work of FILESLOAD") (|for| file |inside| files |bind| dirs loadoptionsflg forcedext? noerrorflg word full (fn _ (quote load?)) (ext _ :compiled) |first| (cond ((boundp (quote ldflg)) (* |;;| "Under a load;  give priority to directory of currently loading file. ") (let ((inputname (fullname *standard-input*))) (|if| (and (neq inputname *standard-input*) (neq inputname t)) |then| (* \; "If reading from terminal or nameless stream, don't do this.") (setq dirs (cons (packfilename.string (quote version) nil (quote name) nil (quote extension) nil (quote body) inputname) (cons t directories))) (setq loadoptionsflg ldflg))))) |join| (cond ((or (litatom file) (stringp file)) (* \; "A file to do something with") (prog nil (cond ((and (eq fn (quote load?)) (getprop (rootfilename file) (quote filedates))) (* \; "Already loaded") (return))) lp (cond ((setq full (selectq ext (nil (* \; "No extension to guide us") (findfile file t dirs)) (:compiled (* \; "Look for some sort of compiled file, or failing that a source") (or (findfile-with-extensions file dirs *compiled-extensions*) (and (not forcedext?) (findfile file t dirs)))) (progn (* \; "Look for explicitly supplied extension") (findfile (packfilename.string (quote body) file (quote extension) ext) t dirs))))) (noerrorflg (return)) ((and (setq file (cl:cerror "Forget about loading ~A" "File ~A not found~@[ on~{ ~A~}~]" file dirs)) (or (litatom file) (stringp file))) (* \; "User RETURNed a new file name") (go lp)) (t (* \; "if proceed from ERROR, blow off loading this file") (return))) (return (list (selectq fn (checkimports (* \; "LOADOPTIONSFLG has a different meaning for imports") (checkimports full t) full) (load? (* \; "already weeded out the ones with filedates") (load full loadoptionsflg)) (cl:funcall fn full loadoptionsflg)))))) (t (|while| (listp file) |do| (selectq (car file) (loadcomp (setqq fn loadcomp?) (setq loadoptionsflg nil) (setq ext nil)) (loadfrom (setqq fn loadfrom) (setq ext nil)) (from (|pop| file) (setq dirs (mklist (cond ((or (eq (setq word (car file)) (quote valueof)) (cond ((and (eq word (quote value)) (eq (cadr file) (quote of))) (|pop| file) t))) (|pop| file) (eval (car file))) ((and (selcharq (chcon1 word) (({ <) nil) t) (boundp (setq word (pack* word (quote directories)))) (setq word (evalv word))) (* \; "KLUDGE: Turns, e.g., (FROM LISPUSERS) into (FROM VALUEOF LISPUSERSDIRECTORIES)") word) (t (car file)))))) (compiled (setq forcedext? t) (setq ext :compiled)) (load (setqq fn load?)) ((extension ext) (setq file (listp (cdr file))) (setq ext (car file))) ((source symbolic) (setq ext nil)) (import (setqq fn checkimports) (setq ext nil)) (noerror (setq noerrorflg t)) (cond ((fmemb (car file) loadoptions) (setq loadoptionsflg (car file))) (t (* \; "invalid option in FILESLOAD") nil))) (|pop| file)) nil))))
)

(findfile-with-extensions
(lambda (file dirlst extensions) (* \; "Edited  8-Dec-86 17:57 by bvm") (* |;;;| "Search for FILE on the directories contained in DIRLST, where NIL and T refer to the login and connected dirs, respectively.  On each directory, prefer files having extension found in EXTENSIONS in the indicated order.  If FILE already has an extension, EXTENSIONS is ignored; if FILE already has a host/dir, DIRLST is ignored.") (|if| file |then| (let ((fields (unpackfilename.string file)) dir&fields hasdirectory hasextension val) (|for| tail |on| fields |by| (cddr tail) |do| (selectq (car tail) (extension (setq hasextension t)) ((host device directory) (setq hasdirectory t)) nil)) (|if| hasdirectory |then| (* \; "Don't search dirs, just look where it says") (|if| hasextension |then| (infilep file) |else| (|for| ext |in| extensions |when| (setq val (infilep (packfilename.string (bquote (extension (\\\, ext) (\\\,@ fields)))))) |do| (return val))) |else| (|for| dir |inside| (|if| (null dirlst) |then| (* \; "If DIRLST is defaulted, always look first on connected dir.") (|if| directories |then| (cons t (remove t directories)) |else| t) |else| (* \; "use explicit DIRLST, ignoring connected dir unless it's on DIRECTORIES") dirlst) |when| (progn (setq dir&fields (selectq dir (nil (* \; "Login dir") (bquote (directory (\\\, (directoryname nil)) (\\\,@ fields)))) (t (* \; "Connected dir") fields) (bquote (directory (\\\, dir) (\\\,@ fields))))) (setq val (|if| hasextension |then| (infilep (packfilename.string dir&fields)) |else| (|for| ext |in| extensions |when| (setq val (infilep (packfilename.string (bquote (extension (\\\, ext) (\\\,@ dir&fields)))))) |do| (return val))))) |do| (return val))))))
)

(READ-FILECREATED
  (LAMBDA (STREAM)                                           (* \; 
                                                           "Edited 19-Sep-2020 20:39 by rmk:")

    (* |;;| "Reads the first FILECREATED expression on STREAM")

    (LET ((STARTPOS (GETFILEPTR STREAM)))
         (SETFILEPTR STREAM 0)
         (CL:MULTIPLE-VALUE-BIND (ENV FORM HERE)
                (\\PARSE-FILE-HEADER STREAM 'RETURN)
                (SETFILEPTR STREAM STARTPOS)
                FORM))))
)

(RPAQ? *COMPILED-EXTENSIONS* (LIST FASL.EXT COMPILE.EXT))



(* \; "random machine-independent utilities")

(DEFINEQ

(dmphash
(nlambda l (* |rmk:| " 6-Apr-84 14:30") (mapc l (function (lambda (arrayname) (declare (specvars arrayname)) (ersetq (prog ((a (evalv arrayname (quote dmphash))) ap) (print (list (quote rpaq) arrayname (cond ((listp a) (setq ap (car a)) (list (quote cons) (list (quote harray) (harraysize ap) (kwote (harrayprop ap (quote overflow)))) (kwote (cdr a)))) (t (list (quote hasharray) (harraysize a) (kwote (harrayprop ap (quote overflow)))))))) (maphash (or ap a) (function (lambda (val item) (print (list (quote puthash) (kwote item) (kwote val) arrayname)))))))))))
)

(HASHOVERFLOW
  (LAMBDA (HARRAY)                                       (* \; "Edited 26-Feb-91 13:16 by jds")

    (* |;;| "Should be called from PUTHASH on hash overflow, but for implementations where PUTHASH calls ERRORX directly, may be called from ERRORX2 when the offender is a listp.  HARRAY is guaranteed to be either HARRAYP or (LIST HARRAYP)")

    (PROG ((OLDARRAY (HASHOVERFLOW.ARRAYTEST HARRAY))
           NEWARRAY NEWSIZE OLDNUMKEYS OVACTION NEWOVFLW)
          (COND
             ((LISTP HARRAY)
              (SETQ OVACTION (CDR HARRAY))

              (* |;;| "Get OVERFLOW method from original HARRAY since it would erroneously be ERROR if we got the method from the coerced OLDARRAY")

              (SETQ NEWOVFLW 'ERROR))
             (T (SETQ OVACTION (SETQ NEWOVFLW (HARRAYPROP OLDARRAY 'OVERFLOW)))))
          (SETQ OLDNUMKEYS (HARRAYPROP OLDARRAY 'NUMKEYS))

     (* |;;| "Compute the new array size:")

          (SETQ NEWSIZE (SELECTQ OVACTION
                            (NIL 
                                 (* |;;| "SIZE*1.5 --- favor to bbn, since pdp-11 doesnt have floatng point, and LRSH on other systems might be faster than IQUOTIENT")

                                 (* |;;| 
                               "[32749 IS THE BIGGEST PRIME < 32765, THE LIMIT ON ARRAY SIZES]")

                                 (IMAX (+ OLDNUMKEYS 3)
                                       (IMIN 32749 (+ OLDNUMKEYS (LRSH (CL:1+ OLDNUMKEYS)
                                                                       1)))))
                            (ERROR (|do| (ERRORX (LIST 26 HARRAY))))
                            (|if| (FLOATP OVACTION)
                                |then| (IMAX (+ OLDNUMKEYS 3)
                                                 (IMIN 32760 (FIXR (FTIMES OLDNUMKEYS OVACTION))))
                              |elseif| (FIXP OVACTION)
                                |then| (IMAX (+ OLDNUMKEYS 3)
                                                 (IMIN 32749 (+ OLDNUMKEYS OVACTION)))
                              |elseif| (AND (FNTYP OVACTION)
                                                (NUMBERP (SETQ OVACTION (APPLY* OVACTION HARRAY))))
                                |then| (|if| (FLOATP OVACTION)
                                               |then|    (* \; 
                                         "recompute NUMKEYS since OVACTION might have removed keys")
                                                     (IMAX (+ (SETQ OLDNUMKEYS (HARRAYPROP
                                                                                OLDARRAY
                                                                                'NUMKEYS))
                                                              3)
                                                           (IMIN 32749 (FIXR (FTIMES OLDNUMKEYS 
                                                                                    OVACTION))))
                                             |else| OVACTION)
                              |else|                     (* \; "Default: multiply by 1.5")
                                    (SETQ OLDNUMKEYS (HARRAYPROP OLDARRAY 'NUMKEYS))
                                    (IMAX (+ OLDNUMKEYS 3)
                                          (IMIN 32749 (+ OLDNUMKEYS (LRSH (CL:1+ OLDNUMKEYS)
                                                                          1)))))))
          (SETQ NEWARRAY (REHASH OLDARRAY (HASHARRAY NEWSIZE NEWOVFLW (HARRAYPROP OLDARRAY
                                                                             'HASHBITSFN)
                                                 (HARRAYPROP OLDARRAY 'EQUIVFN))))
          (HASHOVERFLOW.UPDATEARRAY HARRAY NEWARRAY OLDARRAY)
          (RETURN HARRAY))))
)
(DECLARE\: EVAL@COMPILE DONTCOPY 
(DECLARE\: EVAL@COMPILE 

(PROGN (PUTPROPS HASHOVERFLOW.ARRAYTEST MACRO ((HARRAY)
                                                       (CAR (OR (LISTP HARRAY)
                                                                (ERRORX (LIST 27 HARRAY))))))
       (PUTPROPS HASHOVERFLOW.ARRAYTEST DMACRO ((HARRAY)
                                                        (\\DTEST HARRAY 'HARRAYP))))

(PROGN (PUTPROPS HASHOVERFLOW.UPDATEARRAY MACRO ((HARRAY NEWARRAY OLDARRAY)
                                                         (FRPLACA HARRAY NEWARRAY)))
       (PUTPROPS HASHOVERFLOW.UPDATEARRAY DMACRO ((HARRAY NEWARRAY OLDARRAY)
                                                          (\\COPYHARRAYP NEWARRAY OLDARRAY))))
)
)
(DEFINEQ

(bkbufs
(lambda (bufs id) (* dd\: " 6-Oct-81 15:34") (prog (l s) (cond ((nlistp bufs) (return)) (t (setq l (car bufs)) (setq s (cdr bufs)))) (cond ((readp t) (* |;;| "User types ahead before command causing buffer to be restored was executed.  In this case, his type-ahead would come BEFORE the restored buffer, when it should be after it, because the command causing the buffer to be restored had to have been given before the type-ahead.") (printbells) (dobe) (clearbuf t t) (bksysbuf s) (bksysbuf (sysbuf t)) (sysbuf)) (s (bksysbuf s))) (cond (l (and id (prin1 id t)) (* |;;| "ID will be suppressed by LISPX to prevent it being typed in middle of input.  Note that anything put back in SYSBUF will be printed (echoed) as it is read.") (prin1 l t) (bklinbuf l))) (return)))
)

(changename
(lambda (fn from to) (* |wt:| "18-SEP-78 21:29") (cond ((changename1 (getd fn) from to fn) (and filepkgflg (exprp fn) (markaschanged fn (quote fns))) fn)))
)

(chngnm
(lambda (fn old flg) (prog (new def x y z) (setq fn (fncheck fn nil t)) (* \; "No error, becuase maybe OLD isnt defined yet, e.g. BREAK ((FOO IN FUM)) where FOO not defined.") (setq old (or (fncheck old t t) old)) (setq def (getd (or (getp fn (quote advised)) (getp fn (quote broken)) fn))) (setq new (pack (list old (quote -in-) fn))) (cond (flg (and (null (stkpos new)) (/putd new)) (cond ((setq z (/dremove old (getp fn (quote nameschanged)))) (/put fn (quote nameschanged) z)) (t (/remprop fn (quote nameschanged)))) (/remprop new (quote alias)) (setq y old) (setq x new)) (t (setq y new) (setq x old) (cond ((and (memb old (getp fn (quote nameschanged))) (getd new) (getp new (quote alias))) (return new))))) (cond ((null def) (return (cons def (quote (|not| |defined|))))) ((null (resetvars ((nolinkmess t)) (return (changename1 def x y fn)))) (return (cons x (append (quote (|not| |found| |in|)) (list fn)))))) (cond ((null flg) (cond ((null (setq def (getd old))) (setq def (list (quote nlambda) (gensym))) (print (cons old (quote (|was| |undefined|))) t t))) (/putd new (saved old nil def old)) (/addprop fn (quote nameschanged) old) (/put new (quote alias) (cons fn old)))) (return y)))
)

(clbufs
(lambda (noclearflg notypeflg buf) (* \; "wt: 10-MAR-77 21 5") (* |;;| "NOCLEARFLG=T means CLEARBUF has already been done, and anything in the buffer now is type-ahead, e.g.  calls from EVALQT, and call from BREAK on control-h INTERRUPT.") (* |;;| "NOTYPEFLG=T means user should not be typing ahead.  If READP is T, warn him to stop and wait.  Occurs when CLBUFS is being done BEFORE some action, e.g.  DWIM interaction, loading SYSBUF for EXEC commands, etc.  as opposed to AFTER some action, e.g.  an error occurred.") (prog (lbuf sbuf) (cond (noclearflg (go skip)) ((and notypeflg (readp t)) (printbells) (dobe))) (clearbuf t t) (setq readbuf buf) skip (setq ctrluflg nil) (* \; "In case user control-e's or control-d's after typing control-u and changing his mind.") (setq lbuf (linbuf t)) (setq sbuf (sysbuf t)) (linbuf) (sysbuf) (cond ((strequal lbuf (quote "
")) (setq lbuf nil))) (return (cond ((or sbuf lbuf) (cons lbuf sbuf)))))))

(define
(lambda (x type-in) (* |mpl| "15-Jul-85 11:22") (mapcar x (function (lambda (x) (cond ((nlistp x) (error (quote "incorrect defining form") x))) (fns.putdef (car x) (quote fns) (cond ((null (cddr x)) (cadr x)) (t (cons (quote lambda) (cdr x)))) (|if| type-in |then| (quote defined) |else| (quote load)))))))
)

(fns.putdef
(lambda (name type definition reason) (* \; "Edited 20-Nov-87 14:24 by woz") (prog nil (|if| (or (and definition (nlistp definition)) (not (fmemb (car definition) lambdasplst))) |then| (error definition "Illegal function definition")) (selectq dfnflg ((nil t) (|if| (unsafe.to.modify name "redefine") |then| (error name " not redefined" t))) nil) (|if| (eq reason (quote defined)) |then| (* |;;| "woz: i think this test is wrong; what about CHANGED?  SEdit special cases FNS in sedit::completion, and calls FIXEDITDATE directly, but shouldn't have to.") (fixeditdate definition)) (if (and (hasdef name (quote functions)) (neq (car definition) (quote nlambda))) then (* \; "For a while, we can't prevent the use of both a DEFMACRO and NLAMBDA for the same name.") (deldef name (quote functions))) (cond ((or (null dfnflg) (eq dfnflg t)) (cond ((getd name) (virginfn name t) (* |;;| "((EQUAL DEFINITION (GETD NAME)) (RETURN NAME)) Used to be part of the following COND.  ripped out because editing out of the function cell wasn't completing fully.") (cond ((null dfnflg) (progn (* \; "if EXEC-FORMAT existed earlier, I'd use it") (lispxprin1 "New fns definition for " t) (lispxprin2 name t) (lispxprin1 ".
" t)) (savedef name))))) (cond (addspellflg (addspell name))) (undoably-setf (cl:symbol-function name) definition) (* |;;| "Removed:  (REMPROP NAME 'EXPR)  because it wasn't saving the definition where UNSAVEDEF could find it.")) (t (* \; "DFNFLG is PROP or ALLPROP.  However, treat anything else the same as PROP.") (and addspellflg (addspell name 0)) (cl:unless (eq definition (getd name)) (* |;;| "woz:  don't want to have an EXPR property if have the definition in the function cell, so be careful here.") (cl:when (and (or (null reason) (eq reason (quote changed))) (eq definition (getprop name (quote expr)))) (* |;;| "editing a definition out of the saved EXPR property, and since DFNFLG is PROP, let the user know not installed") (lispxprin1 "New fns definition for " t) (lispxprin2 name t) (lispxprin1 " (but not installed).
" t)) (/putprop name (quote expr) definition)))) (cond (filepkgflg (markaschanged name (quote fns) reason))) (return name)))
)

(eqmemb
(lambda (x y) (* |lmm:| 17 apr 75 305) (or (eq x y) (and (listp y) (fmemb x y) t))))

(equaln
(lambda (x y depth) (* |wt:| "12-JUN-80 10:57") (* |;;| "like EQUAL but stops, returning T, if depth of car recursion plus depth of cdr recursion ever exceeds DEPTH.") (cond ((eq x y)) ((nlistp x) (cond ((numberp x) (and (numberp y) (eqp x y))) ((stringp x) (strequal x y)) ((stackp x) (eqp x y)))) ((nlistp y) nil) ((and depth (ilessp depth 1)) (quote ?)) (t (selectq (equaln (car x) (car y) (and depth (setq depth (sub1 depth)))) (? (quote ?)) (t (equaln (cdr x) (cdr y) depth)) nil))))
)

(fncheck
(lambda (fn noerrorflg spellflg propflg tail) (* |bvm:| "30-OCT-83 21:59") (prog (x block block/fn) top (cond ((not (litatom fn)) (go error)) ((getd fn)) ((getp fn (quote expr)) (and (null propflg) (go error))) ((null dwimflg) (go error)) ((and (car (nlsetq (setq x (or (misspelled? fn 70 userwords spellflg tail (function getd)) (misspelled? fn 70 spellings2 spellflg tail))))) (neq x fn)) (setq fn x) (go top)) ((and (eq (systemtype) (quote d)) (|for| fl |in| (whereis fn) |thereis| (|for| file |inside| (or (getp fl (quote filegroup)) fl) |thereis| (setq block (|find| b |in| (filecomslst file (quote blocks)) |suchthat| (and (car x) (memb fn block)))))) (getd (setq block/fn (pack* (quote \\) (car block) (quote /) fn)))) (* |;;| "In Interlisp-D, get actual name of internal block fn.  This is a little odd, since in a truly block-compiled system you couldn't get at the subfns") (setq fn block/fn)) (t (go error))) (and addspellflg (addspell fn 0)) (return fn) error (cond (noerrorflg (return nil))) (setq fn (error fn (quote "not a function") (null (relstk (or (stkpos (quote load)) (stkpos (quote loadfrom))))))) (go top)))
)

(fntyp1
(lambda (x) (and clisparray (setq x (gethash x clisparray)) (fntyp x))))

(lcskip
(lambda (fn flg) (* |bvm:| "24-Oct-86 17:09") (* |;;| "Skip or copy FN, FLG T to copy") (prog (len la) (|if| (eq (peekccode) (charcode space)) |then| (cond ((eq (setq la (read)) (quote binary)) (return (binskip fn flg nil nil la))) ((setq len (getprop la (quote codereader))) (* \; "Peter's hook for interfacing byte compiler.") (return (apply* (cdr len) fn flg nil nil la))))) (error "Bad or incompatible compiled function" fn)))
)

(maprint
(lambda (lst file left right sep pfn lspxprntflg) (* |wt:| 15-sep-77 15 43) (resetvars ((lispxprintflg lspxprntflg)) (cond ((null pfn) (setq pfn (function lispxprin1)))) (cond ((null sep) (setq sep (quote \ )))) (cond (left (lispxprin1 left file))) (cond ((nlistp lst) (go exit))) lp (apply* pfn (car lst) file) (cond ((null (setq lst (cdr lst))) (go exit)) ((nlistp lst) (lispxprin1 (quote " . ") file) (apply* pfn lst file) (go exit))) (lispxprin1 sep file) (go lp) exit (cond (right (lispxprin1 right file)))))
)

(mklist
(lambda (x) (* |lmm:| 21 aug 75 428) (and x (or (listp x) (list x)))))

(namefield
(lambda (file suffixflg dirflg) (* \; "Edited  5-Dec-90 22:32 by nm") (* |;;| "IF SUFFIXFLG is T, returns name and suffix field, otherwise just NAMEFIELD") (let ((str (cond ((eq dirflg (quote only)) (unpackfilename.string file (quote directory))) ((eq suffixflg (quote only)) (unpackfilename.string file (quote extension))) ((and (null suffixflg) (null dirflg)) (unpackfilename.string file (quote name))) (t (* |;;| "The general case.  EXTENSION is fairly icky because UNPACKFILENAME.STRING behaves differently than UNPACKFILENAME, in that it returns a null string instead of NIL for extensionless files") (packfilename.string (quote directory) (and dirflg (unpackfilename.string file (quote directory))) (quote name) (unpackfilename.string file (quote name)) (quote extension) (and suffixflg (setq suffixflg (unpackfilename.string file (quote extension))) (> (nchars suffixflg) 0) suffixflg)))))) (* |;;| "Should not assume the case insensitive file system") (* \| "(if (NOT (U-CASEP STR)) then (SETQ STR (U-CASE STR)))") (mkatom str)))
)

(nlist
(lambda n (* |bvm:| "14-Feb-85 23:48") (prog (v (i n)) lp (cond ((eq i 0) (return v)) ((or v (arg n i)) (setq v (cons (arg n i) v)))) (setq i (sub1 i)) (go lp)))
)

(printbells
(lambda nil (* |wt:| 10-mar-77 21 15) (prin3 bells t)))

(promptchar
(lambda (id flg history) (declare (specvars id history promptstr)) (* |lmm| " 9-Jun-85 20:53") (* |;;| "First checks READBUF, and strips off any leading pseudo-carriage rettursn, and computes the new readbuf for repeated operations.  If following this, READBUF is not NIL, never prints ID.  Otherwise prints ID if FLG is T, or if READP is NIL.  FLG is T for calls from EVALQT and BREAK, NIL from editor.") (prog (n mod promptstr) (cond (flg (and readbuf (setq readbuf (lispxreadbuf readbuf)) (return nil)) (* \; "redoing an event")) ((lispxreadp) (* \; "LISPXREADP returns T if there is anything on this line, but returns NIL if just a c.r.") (return nil))) (cond ((and history prompt#flg) (setq promptstr (cond ((igreaterp (setq n (add1 (cadr history))) (setq mod (or (cadddr history) 100))) (* \; "This event is the roll-over event.") (idifference n mod)) (t n))))) (cond (promptcharforms (* |;;| "gives user a hook for operations to be performed each event, e.g.  monitoring functions, checking if typescript window is up etc.  also these forms can change what is printed by resetting promptstr and / or id") (mapc promptcharforms (function (lambda (x) (ersetq (eval x))))))) (and promptstr (prin2 promptstr t)) (and id (prin1 id t))))
)

(raisep
(lambda (ttbl) (* |wt:| 1-aug-77 14 15) (* |;;| "True if lisp is in mode where it raises lower case inputs to uppercase.") (cond ((raise nil ttbl) (raise t ttbl) t)))
)

(readfile
(cl:lambda (file &optional rdtbl (endtoken (quote stop)) package) (declare (globalvars loadparameters)) (* \; "Edited 20-Jan-87 16:22 by bvm:") (with-reader-environment *old-interlisp-read-environment* (resetlst (resetsave nil (list (quote closef?) (setq file (openstream file (quote input) nil nil loadparameters)))) (if (eq (skipseprcodes file) (charcode ";")) then (setq *readtable* cmlrdtbl) (setq *package* (cl:find-package "USER"))) (|if| rdtbl |then| (setq *readtable* (\\dtest rdtbl (quote readtablep)))) (|if| package |then| (setq *package* (\\dtest package (quote package)))) (let ((eoftoken "eof") env tem helpclock) (declare (specvars helpclock)) (cl:values (|until| (or (eq (setq tem (cl:read file nil eoftoken)) eoftoken) (eq tem endtoken)) |collect| (|if| (eq (car tem) (quote define-file-info)) |then| (* \; "have to eval this to get the reader environment right for the rest of the file") (set-reader-environment (setq env (\\do-define-file-info file (cdr tem))))) tem) env)))))
)

(readline
(lambda (rdtbl line lispxflg) (* ajb " 1-Aug-85 14:50") (declare (specvars line lispxflg spaceflg)) (prog ((fl t) tem spaceflg chrcode start) top (cond ((listp readbuf) (go lp2)) ((null (readp t)) (clearbuf t) (* |;;| "This is in case there is a c.r. in the single character buffer.  Note that if there were other atoms on the line terminated by a c.r., after readline finished, the c.r. would be gone.  Thus this check for consistency.") (return line))) lp (setq spaceflg nil) lp1 (cond ((syntaxp (setq chrcode (chcon1 (setq tem (peekc fl (or rdtbl t))))) (quote eol)) (* \; "C.R.") (readc fl) (cond ((and line spaceflg) (and (eq fl t) (prin1 (quote |...|) t)) (go lp)) (t (go out)))) ((or (syntaxp chrcode (quote rightparen) rdtbl) (syntaxp chrcode (quote rightbracket) rdtbl)) (read fl rdtbl) (and lispxflg (null (cdr line)) (setq line (nconc1 line nil))) (* |;;| "The `]' is treated as NIL if it is the only thing on the line when READLINE is called with LISPXFLG=T.  The reason for CDR is that LISPX calls readline giving it the initial atom on the line.") (go out)) ((and (eq chrcode (charcode space)) (syntaxp chrcode (quote sepr) rdtbl)) (* \; "SPACE the syntaxp check is to allow for space being a read macro") (setq spaceflg t) (readc fl) (go lp1))) (setq tem (cond ((or (eq lispxreadfn (quote read)) (imagestreamtypep t (quote text))) (* \; "So the call will be linked, so the user can break on read.") (* \; "TEXTSTREAMS must use READ") (read fl rdtbl)) (t (apply* lispxreadfn fl rdtbl)))) (* |;;| "The reason for not embedding the setq in the ncon1 is that the act of reading may change L, e.g.  via a ^W read macro.") (cond ((eq tem histstr4) (* |;;| "fo implemeing read macros that are for effect only.  ignore the value returned by read.  if we had soft interrupts from iowaits, we wouldnt needs this.") (go lp1))) (setq line (nconc1 line tem)) (cond ((syntaxp (setq tem (chcon1 (lastc fl))) (quote rightbracket) rdtbl) (* |;;| "The reason why readline is driven by the last character insead of doing a peekc before reding is that due to eadmacros, it is possible for several things to be read, e.g.  A B C '(FOO) terminated by square bracket should terminate the line.  However, it is not sufficient just to check whether the value read is a list or not since `()' and NIL must also be treated differently.") (go out)) ((null (syntaxp tem (quote rightparen) rdtbl)) (go lp)) ((and lispxflg (null spaceflg) (null (cddr line))) (* |;;| "A list terminates the line if if called from LISPX and is both the firt thing on a line and not preceded by a space.") (go out)) (t (and (eq fl t) (prin1 (quote |...|) t)) (go lp))) (go lp) out (cond ((and (listp line) ctrluflg) (* \; "User typed control-u during reading.") (setq ctrluflg nil) (cond ((null (nlsetq (edite line))) (* \; "Exited with a STOP.") (setq rereadflg (quote abort)))))) (cond (start (cond ((neq start (cadadr readbuf)) (shouldnt)) (t (* \; "the rplaca is to handle small numbers") (rplaca (cdadr readbuf) (setn start (getfileptr fl))))) (setfileptr fl -1))) (return line) lp2 (cond ((eq (car readbuf) histstr0) (setq readbuf (cdr readbuf)) (return line)) ((null (setq readbuf (lispxreadbuf readbuf))) (* |;;| "checks for things like HISTSTR2 etc.  this can occur if you redo an event contaiing a readline.  can also occur under a break if you call a function which calls readline, because break unreads stuff, leaving the `from event' tag on.") (go top))) (setq tem readbuf) (setq readbuf (cdr readbuf)) (setq line (nconc1 line (car tem))) (cond ((null readbuf) (* |;;| "really shouldnt happen, as there should be a `<c.r.>' marker.  however, in the case of a fix command, user might delete it.") (return line))) (go lp2)))
)

(remproplist
(lambda (atm props) (* \; "wt: 30-JUL-77 13 32") (prog (lst lst1 tem) (cond ((null (setq lst1 (setq lst (getproplist atm)))) (return nil))) lp (cond ((nlistp lst1) (go out)) ((not (fmemb (car lst1) props))) ((eq lst1 lst) (setq lst (cddr lst))) ((setq tem (cddr lst1)) (rplnode2 lst1 tem) (go lp)) (t (* \; "the last property, also not the first one.") (rplacd (nleft lst 1 lst1)) (go out))) (setq lst1 (cddr lst1)) (go lp) out (setproplist atm lst) (return)))
)

(resetbufs
(nlambda forms (* |lmm| " 9-APR-78 00:27") (declare (localvars . t)) (prog (($$bufs (progn (linbuf) (sysbuf) (clbufs nil t readbuf)))) (return (prog1 (apply (function progn) forms (quote internal)) (and $$bufs (bkbufs $$bufs))))))
)

(tab
(lambda (pos minspaces file) (prog (x) (cond ((not (igreaterp (iplus (setq x (position file)) (or (numberp minspaces) 1)) pos)) (spaces (idifference pos x) file)) ((eq minspaces t) (* \; "MINSPACES=T means space over to POS unless you are already beyond it.")) (t (terpri file) (spaces pos file)))))
)

(unsaved1
(lambda (fn typ) (* |bvm:| "29-Sep-86 23:24") (prog (def prop) top (cond ((not (litatom fn))) ((setq def (cond ((setq prop typ) (get fn typ)) ((get fn (setq prop (quote expr)))) ((get fn (setq prop (quote code)))) ((get fn (setq prop (quote subr)))))) (virginfn fn t) (/remprop fn prop) (cond ((neq dfnflg t) (savedef fn))) (/putd fn def t) (and addspellflg (addspell fn)) (return prop)) ((or (getd fn) (getproplist fn)) (* \; "Not a misspelling") (return (cond (typ (concat "(" typ " not found)")) (t "(nothing found)")))) ((setq prop (fncheck fn t)) (setq fn prop) (go top))) (error fn (quote "not a function"))))
)

(writefile
(lambda (x file) (* |bvm:| "30-Aug-86 16:45") (* |;;| "X is a list of expression (or an atom that evaluates to a list) X is written on FILE.  If X begins with a PRINTDATE expression, a new one is written.  Following the PRETTYDEF conventions, if FILE is listed, it is left open.  Otherwise a stop is printed and it is closed.") (with-reader-environment *old-interlisp-read-environment* (resetlst (prog (stream opened) (cond ((listp file) (setq file (car file)) (setq opened t))) (resetsave nil (list (function close-and-maybe-delete) (setq stream (openstream file (quote output))))) (resetsave (output stream)) (cond ((atom x) (setq x (eval x)))) (prin1 "
(PRIN1 (QUOTE \"
WRITEFILE OF ") (prin2 (setq file (fullname stream))) (prin1 " MADE BY ") (prin1 (username)) (prin1 " ON ") (prin1 (date)) (prin1 "
\")T)

") (|for| x1 |in| x |do| (printdef x1 nil (eq (car (listp x1)) (quote defineq))) (terpri)) (|if| (null opened) |then| (endfile)) (return file)))))
)

(close-and-maybe-delete
(lambda (stream) (* \; "Edited 19-Mar-87 16:43 by jrb:") (* |;;;| "For use in RESETSAVE.  Closes STREAM, and if happened under error, deletes the file") (|if| (openp stream) |then| (setq stream (closef stream))) (and resetstate (delfile stream)))
)

(unsafe.to.modify
(lambda (fn option) (* |lmm| "31-Jul-85 02:06") (|if| (fmemb fn unsafe.to.modify.fns) |then| (printout t "Warning: " fn " may be unsafe to " (or option "modify") " -- continue? ") (|if| (eq (|if| (getd (quote askuser)) |then| (askuser dwimwait (quote n)) |else| (read t)) (quote y)) |then| nil |else| t)))
)
)

(RPAQQ UNSAFE.TO.MODIFY.FNS
       (/PUT /PUTD /REMPROP ADDCHAR ADDCHAR ADDSPELL ADVISEWDS ALLOCSTRING APPLY APPLY ASSOC 
             AWAIT.EVENT BITBLT.ERASE BITMAPCOPY BITMAPCREATE BKBITBLT BLOCK BLOCK BLTCHAR BLTCHAR 
             BLTSHADE BREAK BREAK0 BREAK1 CHARSET CHCON1 CLEAR.LINE? CLOCK CLOCKDIFFERENCE CLOSEW 
             CONCAT CREATEW CURSOR CURSORHOTSPOT DELETETO DO.CRLF DRAWLINE DSPBACKUP 
             DSPCLIPPINGREGION DSPCLIPPINGREGION DSPCREATE DSPDESTINATION DSPFILL DSPFONT 
             DSPLEFTMARGIN DSPRIGHTMARGIN DSPSCROLL DSPSOURCETYPE DSPXOFFSET DSPXPOSITION 
             DSPYPOSITION EQLENGTH EQP EQUAL ERASE.TO.END.OF.LINE ERASE.TO.END.OF.PAGE ERRORMESS1 
             ERRORSET EVAL EVALQT EXPRP FASSOC FILENAMEFIELD FIXR FLIPCURSOR FLAST FMEMB GENSYM 
             GETHASH GETMOUSESTATE GETPROP GETSTREAM GETWINDOWUSERPROP HELP HISTORYSAVE IDATE 
             IMAGESTREAMTYPEP IMOD INIT.CURSOR INTEGERLENGTH INTERRUPTABLE INTERSECTREGIONS 
             IREMAINDER LAST LASTC LISPX LISPX/ LISPXFIND LISPXFIND1 LISPXPRINT LISPXPUT LISPXPUT 
             LISPXREAD LISPXREADBUF LISPXUNREAD LISTGET LISTPUT MEMB MKATOM MKSTRING 
             MONITOR.AWAIT.EVENT MOVETOUPPERLEFT NOTIFY.EVENT NTH NTHCHARCODE OBTAIN.MONITORLOCK 
             OPENW OPENWP OVERFLOW? PACK* PAGEHEIGHT PRIN1 PRIN1 PRIN2 PRIN2 PRIN3 PRIN3 PRINT PRINT
             PRINTCCODE PRINTLEVEL PROGN PROMPTCHAR PUTWINDOWPROP QUOTE READ CL:READ READLINE 
             READLINE READP REALSTKNTH REGIONP RELEASE.PUP RELSTK RESETRESTORE RESHOWTITLE RETFROM 
             RPLCHARCODE RPLSTRING SETCURSOR SETTERMTABLE SHOWPRIN2 SHOWPRINT SHOWWFRAME SHOWWTITLE 
             SKIPSEPRS SPACES STKPOS STREAMP SUBATOM SUBSTRING SYNTAXP TERPRI TIMEREXPIRED? 
             TIMEREXPIRED? TOTOPW TTBIN TTBITWIDTH TTCRLF TTDELETELINE TTSKREAD TTWAITFORINPUT 
             TTWAITFORINPUT TTYDISPLAYSTREAM TTYIN TTYIN.CLEANUP TTYIN.FINISH TTYIN.READ TTYIN.SETUP
             TTYIN1 TTYIN1RESTART TTYINREAD TYPENAME UNBREAK0 UNDOSAVE UNPACKFILENAME.STRING WFROMDS
             WINDOW.MOUSE.HANDLER))



(* \; "FILEDATE, for finding out the creation date of source files, from the compiled files.")




(* |;;| 
"FASL isn't loaded when MACHINEINDEPENDENT is, so we have to fake the FASL checker for now.  It's defined in FASLOAD."
)

(DEFINEQ

(filedate
(lambda (file cflg) (* \; "Edited 17-Feb-89 11:26 by jds") (* \; "CFLG IS T FOR COMPILED FILES") (cond (file (car (nlsetq (resetlst (prog (stream oldptr value) (cond ((setq stream (openp file (quote input))) (setq oldptr (getfileptr stream))) (t (* \; "OPENSTREAM used instead of INFILEP to allow for error correction.") (resetsave nil (list (quote closef) (setq stream (openstream file (quote input))))))) (* |;;| "This code used to have some gross kludgery for checking file dates of grouped files during the loadup procedure, now gone -bvm") (cond ((randaccessp stream) (setfileptr stream 0) (cond ((setq value (fasl-filedate stream cflg)) (* |;;| " Aha, a Dfasl file") (* |;;| " Having decided it's a DFASL, FASL-FILEDATE returned the date, and it's in VALUE already.")) (t (* \; "Any other filetype") (setfileptr stream 0) (cl:multiple-value-bind (env form) (\\parse-file-header stream (quote return)) (cond ((and cflg (listp form)) (* \; "First expression is for compiled file, next one is its source") (setq form (with-reader-environment env (read stream))))) (cond ((eq (car (listp form)) (quote filecreated)) (setq value (car (listp (cdr form))))))))))) (cond (oldptr (setfileptr stream oldptr))) (return value))))))))
)
)

(MOVD? 'NILL 'FASL-FILEDATE)

(MOVD? 'CL:FMAKUNBOUND 'UNDOABLY-FMAKUNBOUND)



(* \; "used in FNS.PUTDEF before CMLUNDO loaded")




(* \; "Functions for retrieving and remembering FILEMAPs and file reader environments")

(DEFINEQ

(filemap
(nlambda (filemap) (* |bvm:| "27-Aug-86 23:41") (* |;;;| "Called by the FILEMAP expression at the end of every standard Interlisp file") (declare (usedfree filecreatedlst)) (* \; "FILECREATEDLST bound in LOAD or LOADFNS and set by FILECREATED") (putfilemap (fullname (getstream nil (quote input))) filemap filecreatedlst nil t))
)

(\\parse-file-header
(lambda (stream filecreatedfn returnform initialenv) (* |bvm:| " 8-Sep-86 12:37") (* |;;;| "Parses the stuff at front of STREAM, which is assumed positioned at zero, and returns as its first value a reader environment for the file, or NIL if this is not a Lisp source file.  If a FILECREATED expression is found, then calls FILECREATEDFN with the file pointer positioned immediately after the symbol FILECREATED, and returns the fn's value as its second value.  FILECREATEDFN = RETURN returns the entire FILECREATED expression.   Finally, in the case where no FILECREATED expression was found, returns as second value the actual first expression if RETURNFORM is true (this is needed for callers that don't want to lose when the stream is non-randaccess).

The first expression on the file is read in the current reader environment.  Usually this wants to be IL.") (with-reader-environment (or initialenv *old-interlisp-read-environment*) (selcharq (skipseprcodes stream) (";" (* \; "Assume is common lisp file") *common-lisp-read-environment*) ("(" (* \; "Start of Lisp expression, could be either DEFINE-FILE-INFO or FILECREATED") (prog (env firstsym result here) top (setq here (getfileptr stream)) (readccode stream) (setq firstsym (and (syntaxp (skipseprcodes stream) (quote other)) (ratom stream))) (cond ((and (eq firstsym (quote define-file-info)) (null env)) (setq env (\\do-define-file-info stream (cl:read-delimited-list (charcode ")") stream))) (cond ((and filecreatedfn (eq (skipseprcodes stream) (charcode "("))) (set-reader-environment env) (go top)) (t (* |;;| "Odd case--a DEFINE-FILE-INFO expression but no FILECREATED afterwards or caller doesn't want to see it") (return (cl:values env nil here)))))) (|if| (eq firstsym (quote filecreated)) |then| (or env (setq env *old-interlisp-read-environment*)) (setq result (selectq filecreatedfn (return (cons (quote filecreated) (cl:read-delimited-list (charcode ")") stream))) (nil nil) (cl:funcall filecreatedfn stream))) |elseif| returnform |then| (setq result (cl:read-delimited-list (charcode ")") stream))) (return (cl:values env result here)))) nil)))
)

(get-environment-and-filemap
(lambda (stream dontcache) (* |bvm:| "26-Sep-86 11:39") (* |;;| "Returns three values: the stream's reader environment, its filemap, either obtained from the file itself, or from its property list, and the byte location where the FILECREATED expression starts.") (let ((full (cond ((streamp stream) (fullname stream)) (t stream))) mapentry map env oldpos) (setq mapentry (gethash full *filemap-hash*)) (cond ((and mapentry (or (setq map (|fetch| fmfilemap |of| mapentry)) (null usemapflg))) (* |;;| "Have all we need.  Return the map only if USEMAPFLG is true or the map was obtained by scanning the file") (|replace| fmrecent? |of| mapentry |with| t) (cl:values (|fetch| fmenvironment |of| mapentry) (and map (or usemapflg (not (|fetch| fmfromfile? |of| mapentry))) map) (|fetch| fmfilecreatedloc |of| mapentry) (|fetch| fmfilecreatedlst |of| mapentry))) ((or (not (setq stream (openp stream (quote input)))) (not (randaccessp stream))) (* \; "Out of luck") nil) (t (* \; "Have to read file") (setq oldpos (getfileptr stream)) (setfileptr stream 0) (cl:multiple-value-bind (env newmap fclocation) (\\parse-file-header stream (cond ((and (null map) usemapflg) (function get-filemap-from-filecreated)))) (setfileptr stream oldpos) (cond ((and newmap (not dontcache)) (putfilemap full newmap nil env t fclocation))) (cl:values env (or newmap map) fclocation))))))
)

(lookup-environment-and-filemap
(lambda (full rootnamep) (* \; "Edited  4-May-88 15:30 by bvm") (* |;;| "Returns four values: the file's reader environment, its filemap, either obtained from the file itself, or from its property list, the byte location where the FILECREATED expression starts, and the FILECREATEDLST of the file (used by ADDFILE).  Unlike GET-ENVIRONMENT-AND-FILEMAP, this function merely looks up cached info. If ROOTNAMEP is true, then FULLNAME is actually a root name, and we want to look up the most recent.") (let ((highest-version -1) mapentry) (|if| rootnamep |then| (maphash *filemap-hash* (function (lambda (entry key) (let (v) (|if| (and (strpos full key nil nil nil nil uppercasearray) (string-equal full (rootfilename key)) (igreaterp (setq v (or (filenamefield key (quote version)) 0)) highest-version)) |then| (setq mapentry entry) (setq highest-version v)))))) |else| (setq mapentry (gethash full *filemap-hash*))) (|if| mapentry |then| (|replace| fmrecent? |of| mapentry |with| t) (cl:values (|fetch| fmenvironment |of| mapentry) (|fetch| fmfilemap |of| mapentry) (|fetch| fmfilecreatedloc |of| mapentry) (|fetch| fmfilecreatedlst |of| mapentry)))))
)

(get-filemap-from-filecreated
(lambda (stream) (* |bvm:| "29-Aug-86 15:06") (* |;;| "get map from address shown in FILECREATED expression, which is of form (FILECREATED file date mapaddr)") (skread stream) (skread stream) (car (nlsetq (let ((mapaddr (read stream))) (cond ((and (fixp mapaddr) (lessp mapaddr (geteofptr stream)) (progn (setfileptr stream mapaddr) (eq (skipseprcodes stream) (charcode "("))) (eq (car (setq mapaddr (read stream))) (quote filemap))) (cadr mapaddr)))))))
)

(\\filemap-hashoverflow
(lambda (harray) (* |bvm:| "26-Sep-86 12:11") (* |;;;| "Called when *FILEMAP-HASH* overflows.  Trim back old entries") (let ((numentries (harrayprop harray (quote numkeys))) entries) (|if| (> numentries *filemap-limit*) |then| (maphash harray (function (lambda (val key) (* \; "Gather up contents of table") (let ((root (|fetch| fmrootname |of| val)) tem) (|if| (not (setq tem (fassoc root entries))) |then| (|push| entries (setq tem (list root)))) (|push| (cdr tem) (cons (|if| (cdr (|fetch| fmfilecreatedlst |of| val)) |then| (* \; "compiled file, don't keep if there is no other reason to") 0 |else| (filenamefield key (quote version))) (cons key val))))))) (* |;;| "each element of ENTRIES is (root . versions), where each version is (vers# fullname . hashvalue)") (|for| group |in| entries |bind| onfilelst pair nflush dates |do| (setq onfilelst (memb (car group) filelst)) (setq nflush (- (length (cdr group)) *filemap-versions*)) (|for| tail |on| (progn (* \; "Sort files by increasing version") (sort (cdr group) t)) |as| i |from| 1 |do| (setq pair (cdar tail)) (|if| (and (<= i nflush) (or (null (setq dates (get (car group) (quote filedates)))) (not (string.equal (cdar dates) (car pair))))) |then| (* |;;| "flush old versions until we have gotten down to limit.  The STRING.EQUAL test is because the \"current version\" of a file might have a lower version number (being on a different directory) than the highest version you have looked at anywhere") (remhash (car pair) harray) (|add| numentries -1) |elseif| (|fetch| fmrecent? |of| (cdr pair)) |then| (* \; "spare recently touched files, but clear the flag") (|replace| fmrecent? |of| (cdr pair) |with| nil) |elseif| (or (not onfilelst) (cdr tail)) |then| (* \; "trim maps not looked at recently, but spare the highest version of anything on filelst") (remhash (car pair) harray) (|add| numentries -1)))) (* |;;| "finally say how big to rehash the array.  Normally we want it not to change size.") (imax *filemap-limit* (fixr (ftimes numentries 1.2))))))
)

(flushfilemaps
(lambda (rootname) (* |bvm:| "26-Sep-86 11:37") (|if| (eq rootname t) |then| (clrhash *filemap-hash*) |else| (maphash *filemap-hash* (function (lambda (me fullname) (|if| (string-equal (|fetch| fmrootname |of| me) rootname) |then| (remhash fullname *filemap-hash*)))))) rootname)
)

(lispsourcefilep
(lambda (file) (* |bvm:| "29-Sep-86 23:15") (* |;;;| "If the first few characters of FILE `look like' those output by MAKEFILE then return the alleged address in the file of its FILEMAP expression.") (resetlst (|if| (not (streamp file)) |then| (resetsave nil (list (quote closef) (setq file (openstream file (quote input)))))) (|if| (randaccessp file) |then| (let ((here (getfileptr file))) (prog1 (cl:multiple-value-bind (env map) (\\parse-file-header file (function (lambda (stream) (* \; "Pointed now right after the FILECREATED expression") (car (nlsetq (skread stream) (skread stream) (fixp (read stream))))))) map) (setfileptr file here))))))
)

(getfilemap
(lambda (stream fl) (* |bvm:| "27-Aug-86 15:48") (* |;;;| "Value is map for STREAM either obtained from the file itself, or from its property list.  STREAM is presumed open.  FL is (NAMEFIELD STREAM T)") (and usemapflg (cl:multiple-value-bind (env map) (get-environment-and-filemap stream) map)))
)

(putfilemap
(lambda (file filemap filcreatedlst env fromfile? fclocation) (* |bvm:| "26-Sep-86 11:51") (* \; "Called from: LOAD LOADFNS PRETTYDEF FILEMAP") (* |;;| "As far as I can tell, the only use for FILCREATEDLST is to tell ADDFILE in LOADFNS that the file is a compiled file") (|if| (null filemap) |then| (remhash file *filemap-hash*) |elseif| buildmapflg |then| (let* ((oldentry (gethash file *filemap-hash*)) (newentry (|create| filemaphash |using| oldentry fmfromfile? _ fromfile? fmrecent? _ t))) (|if| (null oldentry) |then| (|replace| fmrootname |of| newentry |with| (rootfilename file (cdr filcreatedlst)))) (|if| env |then| (|replace| fmenvironment |of| newentry |with| env) |elseif| (null oldentry) |then| (|replace| fmenvironment |of| newentry |with| (make-reader-environment))) (|if| (listp filemap) |then| (|replace| fmfilemap |of| newentry |with| filemap)) (|if| fclocation |then| (|replace| fmfilecreatedloc |of| newentry |with| fclocation)) (|if| filcreatedlst |then| (|replace| fmfilecreatedlst |of| newentry |with| filcreatedlst)) (puthash file newentry *filemap-hash*))))
)

(updatefilemap
(lambda (stream filemap) (* |bvm:| "24-Oct-86 17:15") (* |;;;| "Writes new FILEMAP on file currently open as STREAM.  If we return T, the stream has been closed.

This has little hope of working any more.") (|if| nil |then| (* \; "This has little hope of working any more") (let ((declarestring (concat "(DECLARE: DONTCOPY
  " "(FILEMAP")) filemaplocadr tem filemapadr filemaploclen fullname) (setfileptr stream 0) (skipseprs stream) (* \; "Could be some font shifts or other garbage") (readc stream) (* \; "Skip paren or bracket") (|if| (and (eq (ratom stream) (quote filecreated)) (progn (skread stream) (* \; "Date") (skread stream) (* \; "Name") (|do| (cond ((eq (setq tem (readccode stream)) (charcode space)) (* \; "found a space") (return t)) ((not (syntaxp tem (quote seprchar))) (* \; "no spaces, lose") (return))))) (fixp (setq filemapadr (progn (* \; "skip over seprs") (setq filemaplocadr (getfileptr stream)) (* \; "Address of first character of file-map location") (prog1 (ratom stream) (setq filemaploclen (idifference (getfileptr stream) filemaplocadr)))))) (setq filemapadr (or (ffilepos declarestring stream (fix (times filemapadr 0.9))) (ffilepos declarestring stream 0))) (eq (progn (skread stream) (ratom stream)) (quote stop)) (ileq (nchars filemapadr t) filemaploclen)) |then| (* |;;| "normally, this will be called so that we are positioned at the filemap.  --- check for (FILECREATED & & number --) first to avoid searching compiled files for filemap.") (setq fullname (closef stream)) (|if| (setq stream (car (nlsetq (openstream fullname (quote both) (quote old) nil (quote (don\'t.change.date)))))) |then| (resetlst (resetsave nil (list (quote closef) stream)) (setfileptr stream filemapadr) (prin3 "(DECLARE: DONTCOPY
  " stream) (setq filemapadr (getfileptr stream)) (prin3 "(FILEMAP " stream) (position stream (constant (nchars "(FILEMAP "))) (let ((*print-radix* 10)) (prin2 filemap stream)) (prin1 "))" stream) (terpri stream) (print (quote stop) stream) (setfileptr stream filemaplocadr) (printnum (list (quote fix) filemaploclen) filemapadr stream) (cond ((neq dfnflg t) (prin3 "****rewrote file map for " t) (print fullname t t))))) t))))
)

(print-reader-environment
(lambda (env stream) (* |bvm:| "24-Oct-86 15:53") (* |;;;| "If ENV is not the old default interlisp reader environment, writes a DEFINE-FILE-INFO expression on STREAM that will produce this environment when the file is loaded.") (|if| (not (equal-reader-environment env *old-interlisp-read-environment*)) |then| (let ((*package* *interlisp-package*) (*print-base* 10) pkg) (print (cons (quote define-file-info) (or (|fetch| respec |of| env) (bquote ((\\\,@ (and (setq pkg (|fetch| repackage |of| env)) (bquote (:package (\\\, (cl:package-name pkg)))))) :readtable (\\\, (readtableprop (|fetch| rereadtable |of| env) (quote name))) :base (\\\, (|fetch| rebase |of| env)))))) stream filerdtbl))))
)
)

(RPAQ? *FILEMAP-LIMIT* 20)

(RPAQ? *FILEMAP-VERSIONS* 2)

(RPAQ? *FILEMAP-HASH* (HASHARRAY *FILEMAP-LIMIT* (FUNCTION \\FILEMAP-HASHOVERFLOW)
                                 (FUNCTION STRING-EQUAL-HASHBITS)
                                 (FUNCTION STRING.EQUAL)))
(DECLARE\: EVAL@COMPILE DONTCOPY 
(DECLARE\: EVAL@COMPILE

(RECORD FILEMAPHASH (FMENVIRONMENT FMROOTNAME FMFROMFILE? FMRECENT? FMFILECREATEDLOC 
                               FMFILECREATEDLST . FMFILEMAP))
)

(DECLARE\: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS *FILEMAP-LIMIT* *FILEMAP-VERSIONS* *FILEMAP-HASH*)
)
)
(* * LVLPRINT)

(DEFINEQ

(lvlprint
(lambda (x file carlvl cdrlvl tail) (* |wt:| 12-may-76 22 6) (lvlprin2 x file carlvl cdrlvl tail) (terpri file) x)
)

(lvlprin1
(lambda (x file carlvl cdrlvl tail) (declare (specvars file prin2flg)) (prog (prin2flg) (lvlprin x carlvl cdrlvl tail) (return x)))
)

(lvlprin2
(lambda (x file carlvl cdrlvl tail) (declare (specvars file prin2flg)) (* |wt:| 12-may-76 22 6) (prog ((prin2flg t)) (lvlprin x carlvl cdrlvl tail) (return x)))
)

(lvlprin
(lambda (x carlvl cdrlvl tail) (* \; "Edited 10-Nov-87 13:10 by jds") (* \; "wt: 12-MAY-76 22 23") (cond ((nlistp x) (cond ((and tail (eq x (cdr (last tail))) (not (memb x tail))) (prin1 (quote "...  . ") file) (cond (prin2flg (prin2 x file t)) (t (prin1 x file))) (* |;;| "We use standard system read table for printing on grounds that even if this is going to a file, user is only dumping it with bpnt to look at it, not to read it back in.") (prin1 ")" file)) (prin2flg (prin2 x file t)) (t (prin1 x file)))) (t (prin1 (cond ((and tail (tailp x tail)) (* \; "Tail") (quote "... ")) (t "(")) file) (lvlprin0 x carlvl cdrlvl) (prin1 ")" file))))
)

(lvlprin0
(lambda (x carlvl cdrlvl) (* \; "Edited 10-Nov-87 13:11 by jds") (* \; "LVLPRIN0 is like subprint.  it prints the interior segment of a list") (and (eq (car x) clisptranflg) (setq x (cddr x))) (prog ((cdrlvl0 cdrlvl)) (go lp1) lp (cond ((null (setq x (cdr x))) (return)) ((nlistp x) (prin1 (quote " . ") file) (cond (prin2flg (prin2 x file t)) (t (prin1 x file))) (return)) (t (spaces 1 file))) lp1 (cond ((eq cdrlvl 0) (prin1 "--" file) (return)) ((nlistp (car x)) (cond (prin2flg (prin2 (car x) file t t)) (t (prin1 (car x) file)))) ((or (eq carlvl 0) (and cdrlvl0 (eq (sub1 cdrlvl0) 0))) (* \; "the reason for the second check is that why bother to recurse only to print (--).  & is better") (prin1 (quote &) file)) ((and (eq file t) (superprinteq (caar x) commentflg) **comment**flg) (prin1 **comment**flg file)) (t (prin1 (quote \() file) (lvlprin0 (car x) (and carlvl (iplus carlvl (cond ((minusp carlvl) 1) (t -1)))) (and cdrlvl0 (sub1 cdrlvl0))) (prin1 (quote \)) file))) (and cdrlvl (setq cdrlvl (sub1 cdrlvl))) (go lp)))
)
)



(* \; "used by PRINTOUT")

(DEFINEQ

(flushright
(lambda (pos x min p2flag centerflag file) (* |lmm| "10-Feb-86 12:10") (* |;;| "Right-flushes X at position POS.  If P2FLAG, uses PRIN2-pname;  if CENTERFLAG, centers X between current position and POS") (setq pos (idifference (cond ((minusp pos) (idifference (position file) pos)) ((zerop pos) (linelength nil file)) (t pos)) (nchars x p2flag))) (cond (centerflag (setq pos (quotient (iplus pos (position file)) 2)))) (tab pos min file) (cond (p2flag (prin2 x file)) (t (prin1 x file))))
)

(printpara
(lambda (lmarg rmarg list p2flag parenflag file) (* |rmk:| "22-MAY-81 13:45") (* |;;| "Prints LIST in paragraph format.  The first line starts at the current line position, but all subsequent lines begin at LMARG (0 is the left margin, NIL is the current POSITION, negative LMARG is (POSITION) + LMARG).  Printing is with PRIN2 if P2FLAG, otherwise PRIN1.  The right margin is at column RMARG if RMARG is positive, (LINELENGTH NIL FILE) minus RMARG for RMARG LEQ 0") (declare (specvars lmarg rmarg p2flag file)) (cond ((null lmarg) (setq lmarg (position file))) ((minusp lmarg) (setq lmarg (idifference (position file) lmarg)))) (cond ((ileq rmarg 0) (setq rmarg (iplus rmarg (linelength nil file))))) (position file (printpara1 list (position file) (cond (parenflag 1) (t 0)) (cond (parenflag 1) (t 0)))))
)

(printpara1
(lambda (list pos opencount closecount) (* |wt:| " 9-SEP-78 09:54") (* |;;| "PRIN3 and PRIN4 are used here, so we don't have to set and unset LINELENGTH.  We keep our own idea of the current line position in POS, which is returned as the value of PRINTPARA1.  OPENCOUNT is the number of open parens that must precede the first non-list we print, CLOSECOUNT is the number of close parens that should follow the last non-list we print.  They are passed as arguments so that their numbers can be taken into account in deciding whether a non-list fits on the line or not.") (prog ($$val l len (cc 0)) $$lp (setq l (car (or (listp list) (go $$out)))) (* \; "POS is the correct column position at the end of each iteration") (cond ((nlistp (cdr list)) (setq cc closecount))) (* \; "The last iteration.  Now we really want to use CLOSECOUNT, so we move it to CC.") (cond ((listp l) (setq pos (printpara1 l pos (add1 opencount) (add1 cc))) (setq opencount 0) (* \; "The lower call printed the open and closed parens, including the ones for this level, if any.") (setq cc 0)) (t (cond ((ilessp rmarg (iplus opencount cc (setq pos (iplus pos (setq len (nchars l p2flag)))))) (terpri file) (* \; "TAB wouldn't work, cause POSITION doesn't know where we are.") (rptq lmarg (prin3 (quote \ ) file)) (setq pos (iplus lmarg len)))) (cond ((igreaterp opencount 0) (rptq opencount (prin3 (quote \() file)) (setq pos (iplus pos opencount)) (setq opencount 0))) (cond (p2flag (prin4 l file)) (t (prin3 l file))))) (cond ((and (igreaterp rmarg (add1 pos)) (listp (cdr list))) (prin3 (quote \ ) file) (setq pos (add1 pos)))) $$iterate (setq list (cdr list)) (go $$lp) $$out (rptq cc (cond ((ilessp rmarg (setq pos (add1 pos))) (terpri file) (* \; "We do the closes one-by-one, in case they won't fit on a line with only 1 atom") (rptq lmarg (prin3 (quote \ ) file)) (prin3 (quote \)) file) (setq pos (add1 lmarg))) (t (prin3 (quote \)) file)))) (return $$val)) pos)
)
)



(* \; "SUBLIS and friends")

(DEFINEQ

(sublis
(lambda (alst expr flg) (cond ((listp expr) ((lambda (d a) (cond ((or (neq a (car expr)) (neq d (cdr expr)) flg) (cons a d)) (t expr))) (and (cdr expr) (sublis alst (cdr expr) flg)) (sublis alst (car expr) flg))) (t (let ((y (fassoc expr alst))) (cond (y (cond (flg (copy (cdr y))) (t (cdr y)))) (t expr))))))
)

(subpair
(lambda (old new expr flg) (* |lmm| "25-FEB-82 15:29") (cond ((listp expr) ((lambda (d a) (cond ((or (neq a (car expr)) (neq d (cdr expr)) flg) (cons a d)) (t expr))) (and (cdr expr) (subpair old new (cdr expr) flg)) (subpair old new (car expr) flg))) (t (prog nil lp (return (cond ((null old) expr) ((nlistp old) (cond ((eq expr old) (cond (flg (copy new)) (t new))) (t expr))) ((eq expr (car old)) (cond (flg (copy (car new))) (t (car new)))) (t (setq old (cdr old)) (setq new (cdr new)) (go lp))))))))
)

(dsublis
(lambda (alst expr flg) (cond ((nlistp expr) (sublis alst expr flg)) (t (let ((a (dsublis alst (car expr) flg))) (or (eq a (car expr)) (rplaca expr a))) (let ((d (dsublis alst (cdr expr) flg))) (or (eq d (cdr expr)) (rplacd expr d))) expr)))
)
)
(* * CONSTANTS)

(DEFINEQ

(constantok
(lambda (x depth) (* |lmm| " 1-OCT-78 22:03") (or depth (setq depth 100)) (cond ((or (smallp x) (stringp x) (floatp x)) depth) ((fixp x) (and (not (smallp (iplus x))) depth)) ((litatom x) (and (igreaterp (nchars x) 0) depth)) ((listp x) (and (setq depth (constantok (car x) (sub1 depth))) (constantok (cdr x) depth)))))
)
)

(MOVD? 'EVQ 'CONSTANT)

(MOVD? 'EVQ 'DEFERREDCONSTANT)

(MOVD? 'EVQ 'LOADTIMECONSTANT)
(* * SCRATCHLIST)


(PUTPROPS SCRATCHLIST MACRO ((SCRATCHLIST . FORMS)
                                     ((LAMBDA (!SCRATCHLIST !SCRATCHTAIL)
                                        (DECLARE (SPECVARS !SCRATCHLIST !SCRATCHTAIL))
                                        (SETQ !SCRATCHTAIL !SCRATCHLIST)
                                        (PROGN . FORMS)
                                        (COND
                                           ((EQ !SCRATCHTAIL !SCRATCHLIST)
                                            NIL)
                                           (T (PROG ((L2 (CDR !SCRATCHLIST)))
                                                    (RPLACD !SCRATCHLIST (PROG1 (CDR !SCRATCHTAIL)
                                                                                (RPLACD !SCRATCHTAIL
                                                                                       NIL)))
                                                    (FRPLACD (FLAST !SCRATCHLIST)
                                                           L2)
                                                    (RETURN L2)))))
                                      (OR (LISTP SCRATCHLIST)
                                          (CONS))
                                      NIL)))

(PUTPROPS ADDTOSCRATCHLIST MACRO ((VALUE)
                                          (FRPLACA (SETQ !SCRATCHTAIL (OR (LISTP (CDR !SCRATCHTAIL))
                                                                          (CDR (FRPLACD !SCRATCHTAIL
                                                                                      (CONS)))))
                                                 VALUE)))

(PUTPROPS SCRATCHLIST INFO EVAL)
(DECLARE\: DOEVAL@COMPILE DONTCOPY

(GLOBALVARS SYSFILES LOADOPTIONS LISPXCOMS CLISPTRANFLG COMMENTFLG HISTSTR4 LISPXREADFN REREADFLG 
       HISTSTR0 CTRLUFLG NOLINKMESS PROMPTCHARFORMS PROMPT#FLG FILERDTBL SPELLINGS2 USERWORDS BELLS 
       CLISPARRAY)
)
(DEFINEQ

(nlambda.args
(lambda (x) (* |bvm:| "26-Apr-86 16:41") (* |;;;| "Standard function to take argument to NLAMBDA function, e.g. BREAK, and check to see if accidentally quoted.") (* |;;;| "Handles both BREAK 'FOO as a command and (BREAK 'FOO 'BAR).  In the former case, X is (QUOTE FOO), in the latter it is ((QUOTE FOO) (QUOTE BAR)).") (cond ((nlistp x) (and x (list x))) ((and (eq (car x) (quote quote)) (listp (cdr x)))) ((and (listp (car x)) (eq (caar x) (quote quote))) (cons (cadr (car x)) (nlambda.args (cdr x)))) (t x)))
)
)
(DECLARE\: DONTEVAL@LOAD DOCOPY 

(ADDTOVAR CLISPARRAY )

(ADDTOVAR CLISPFLG )

(ADDTOVAR CTRLUFLG )

(ADDTOVAR EDITCALLS )

(ADDTOVAR EDITHISTORY )

(ADDTOVAR EDITUNDOSAVES )

(ADDTOVAR EDITUNDOSTATS )

(ADDTOVAR GLOBALVARS )

(ADDTOVAR LCASEFLG )

(ADDTOVAR LISPXBUFS )

(ADDTOVAR LISPXCOMS )

(ADDTOVAR LISPXFNS )

(ADDTOVAR LISPXHIST )

(ADDTOVAR LISPXHISTORY )

(ADDTOVAR LISPXPRINTFLG )

(ADDTOVAR NOCLEARSTKLST )

(ADDTOVAR NOFIXFNSLST )

(ADDTOVAR NOFIXVARSLST )

(ADDTOVAR P.A.STATS )

(ADDTOVAR PROMPTCHARFORMS )

(ADDTOVAR READBUF )

(ADDTOVAR READBUFSOURCE )

(ADDTOVAR REREADFLG )

(ADDTOVAR RESETSTATE )

(ADDTOVAR SPELLSTATS1 )


(RPAQ? CHCONLST '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL
                          ))

(RPAQ? CHCONLST1 '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL 
                           NIL))

(RPAQ? CHCONLST2 '(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL 
                           NIL))

(RPAQ? CLEARSTKLST T)

(RPAQ? CLISPTRANFLG 'CLISP\ )

(RPAQ? HISTSTR0 "<c.r.>")

(RPAQ? HISTSTR2 "repeat")

(RPAQ? HISTSTR3 "from event:")

(RPAQ? HISTSTR4 "ignore")

(RPAQ? LISPXREADFN 'READ)

(RPAQ? USEMAPFLG T)


(MAPC '((APPLY BLKAPPLY)
        (SETTOPVAL SETATOMVAL)
        (GETTOPVAL GETATOMVAL)
        (APPLY* BLKAPPLY*)
        (RPLACA FRPLACA)
        (RPLACD FRPLACD)
        (STKNTH FSTKNTH)
        (STKNAME FSTKNAME)
        (CHARACTER FCHARACTER)
        (STKARG FSTKARG)
        (CHCON DCHCON)
        (UNPACK DUNPACK)
        (ADDPROP /ADDPROP)
        (ATTACH /ATTACH)
        (DREMOVE /DREMOVE)
        (DSUBST /DSUBST)
        (NCONC /NCONC)
        (NCONC1 /NCONC1)
        (PUT /PUT)
        (PUTPROP /PUTPROP)
        (PUTD /PUTD)
        (REMPROP /REMPROP)
        (RPLACA /RPLACA)
        (RPLACD /RPLACD)
        (SET /SET)
        (SETATOMVAL /SETATOMVAL)
        (SETTOPVAL /SETTOPVAL)
        (SETPROPLIST /SETPROPLIST)
        (SET SAVESET)
        (PRINT LISPXPRINT)
        (PRIN1 LISPXPRIN1)
        (PRIN2 LISPXPRIN2)
        (SPACES LISPXSPACES)
        (TAB LISPXTAB)
        (TERPRI LISPXTERPRI)
        (PRINT SHOWPRINT)
        (PRIN2 SHOWPRIN2)
        (PUTHASH /PUTHASH)
        '*
        (FNCLOSER /FNCLOSER)
        (FNCLOSERA /FNCLOSERA)
        (FNCLOSERD /FNCLOSERD)
        (EVQ DELFILE)
        (NILL SMASHFILECOMS)
        (PUTASSOC /PUTASSOC)
        (LISTPUT1 PUTL)
        (NILL I.S.OPR)
        (NILL RESETUNDO)
        (NILL LISPXWATCH)
        'ADDSTATS
        (NILL FREEVARS)
        'USEDFREE
        (COPYBYTES COPYCHARS))
      (FUNCTION (LAMBDA (X)
                  (MOVD? (CAR X)
                         (CADR X)))))

(MAPC '((TIME PRIN1 LISPXPRIN1)
        (TIME SPACES LISPXSPACES)
        (TIME PRINT LISPXPRINT)
        (DEFC PRINT LISPXPRINT)
        (DEFC PUTD /PUTD)
        (DEFC PUTPROP /PUTPROP)
        (DOLINK FNCLOSERD /FNCLOSERD)
        (DOLINK FNCLOSERA /FNCLOSERA)
        (DEFLIST PUTPROP /PUTPROP)
        (SAVEDEF1 PUTPROP /PUTPROP)
        (MKSWAPBLOCK PUTD /PUTD))
      (FUNCTION (LAMBDA (X)
                  (AND (CCODEP (CAR X))
                       (APPLY 'CHANGENAME X)))))

(MAPC '((EVALQT (LAMBDA NIL
                  (PROG (TEM)
                        (RESETRESTORE NIL 'RESET)
                    LP  (PROMPTCHAR '_ T)
                        (LISPX (LISPXREAD T T))
                        (GO LP))))
        (LISPX (LAMBDA (LISPXX)
                 (PRINT (AND LISPXX (PROG (LISPXLINE LISPXHIST TEM)
                                          (RETURN (COND
                                                     ((AND (NLISTP LISPXX)
                                                           (SETQ LISPXLINE (READLINE T NIL T)))
                                                      (APPLY LISPXX (CAR LISPXLINE)))
                                                     (T (EVAL LISPXX))))))
                        T T)))
        (LISPXREAD (LAMBDA (FILE RDTBL)
                     (COND
                        (READBUF (PROG1 (CAR READBUF)
                                     (SETQ READBUF (CDR READBUF))))
                        (T (READ FILE RDTBL)))))
        (LISPXREADP (LAMBDA (FLG)
                      (COND
                         ((AND READBUF (SETQ READBUF (LISPXREADBUF READBUF)))
                          T)
                         (T (READP T FLG)))))
        (LISPXUNREAD (LAMBDA (LST)
                       (SETQ READBUF (APPEND LST (CONS HISTSTR0 READBUF)))))
        (LISPXREADBUF (LAMBDA (RDBUF)
                        (PROG NIL
                          LP  (COND
                                 ((NLISTP RDBUF)
                                  (RETURN NIL))
                                 ((EQ (CAR RDBUF)
                                      HISTSTR0)
                                  (SETQ RDBUF (CDR RDBUF))
                                  (GO LP))
                                 (T (RETURN RDBUF))))))
        (LISPX/ (LAMBDA (X)
                  X))
        (LOWERCASE (LAMBDA (FLG)
                     (PROG1 LCASEFLG
                         (RAISE (NULL FLG))
                         (RPAQ LCASEFLG FLG))))
        (FILEPOS (LAMBDA (STR FILE)
                   (PROG NIL
                     LP  (COND
                            ((EQ (PEEKC FILE)
                                 (NTHCHAR STR 1))
                             (RETURN T)))
                         (READC FILE)
                         (GO LP))))
        (FILEPKGCOM (NLAMBDA NIL NIL)))
      (FUNCTION (LAMBDA (L)
                  (OR (GETD (CAR L))
                      (PUTD (CAR L)
                            (CADR L))))))
)
(DECLARE\: DONTEVAL@LOAD DOEVAL@COMPILE DONTCOPY COMPILERVARS 

(ADDTOVAR NLAMA RESETBUFS DMPHASH FILESLOAD)

(ADDTOVAR NLAML FILEMAP)

(ADDTOVAR LAMA READFILE NLIST)
)
(DECLARE\: DOEVAL@COMPILE DONTCOPY

(LOCALVARS . T)
)
(PUTPROPS MACHINEINDEPENDENT COPYRIGHT ("Venue & Xerox Corporation" T 1983 1984 1985 1986 1987 1988 
1989 1990 1991 2021))
(DECLARE\: DONTCOPY
  (FILEMAP (NIL (12991 19140 (LOAD? 13001 . 13728) (FILESLOAD 13730 . 13954) (DOFILESLOAD 13956 . 16893)
 (FINDFILE-WITH-EXTENSIONS 16895 . 18625) (READ-FILECREATED 18627 . 19138)) (19258 23713 (DMPHASH 
19268 . 19846) (HASHOVERFLOW 19848 . 23711)) (24515 43785 (BKBUFS 24525 . 25306) (CHANGENAME 25308 . 
25481) (CHNGNM 25483 . 26693) (CLBUFS 26695 . 27647) (DEFINE 27649 . 27969) (FNS.PUTDEF 27971 . 30151)
 (EQMEMB 30153 . 30249) (EQUALN 30251 . 30753) (FNCHECK 30755 . 31900) (FNTYP1 31902 . 31986) (LCSKIP 
31988 . 32432) (MAPRINT 32434 . 32962) (MKLIST 32964 . 33046) (NAMEFIELD 33048 . 34102) (NLIST 34104
 . 34278) (PRINTBELLS 34280 . 34351) (PROMPTCHAR 34353 . 35609) (RAISEP 35611 . 35791) (READFILE 35793
 . 36804) (READLINE 36806 . 40522) (REMPROPLIST 40524 . 41003) (RESETBUFS 41005 . 41252) (TAB 41254 . 
41564) (UNSAVED1 41566 . 42197) (WRITEFILE 42199 . 43174) (CLOSE-AND-MAYBE-DELETE 43176 . 43452) (
UNSAFE.TO.MODIFY 43454 . 43783)) (46112 47367 (FILEDATE 46122 . 47365)) (47599 60551 (FILEMAP 47609 . 
47952) (\\PARSE-FILE-HEADER 47954 . 50101) (GET-ENVIRONMENT-AND-FILEMAP 50103 . 51499) (
LOOKUP-ENVIRONMENT-AND-FILEMAP 51501 . 52689) (GET-FILEMAP-FROM-FILECREATED 52691 . 53181) (
\\FILEMAP-HASHOVERFLOW 53183 . 55231) (FLUSHFILEMAPS 55233 . 55533) (LISPSOURCEFILEP 55535 . 56206) (
GETFILEMAP 56208 . 56522) (PUTFILEMAP 56524 . 57625) (UPDATEFILEMAP 57627 . 59821) (
PRINT-READER-ENVIRONMENT 59823 . 60549)) (61169 63349 (LVLPRINT 61179 . 61309) (LVLPRIN1 61311 . 61458
) (LVLPRIN2 61460 . 61636) (LVLPRIN 61638 . 62299) (LVLPRIN0 62301 . 63347)) (63384 66691 (FLUSHRIGHT 
63394 . 63900) (PRINTPARA 63902 . 64725) (PRINTPARA1 64727 . 66689)) (66728 67842 (SUBLIS 66738 . 
67061) (SUBPAIR 67063 . 67582) (DSUBLIS 67584 . 67840)) (67865 68214 (CONSTANTOK 67875 . 68212)) (
70300 70843 (NLAMBDA.ARGS 70310 . 70841)))))
STOP
