(DEFINE-FILE-INFO PACKAGE "INTERLISP" READTABLE "INTERLISP" BASE 10)

(FILECREATED "26-Apr-2022 13:48:20" {DSK}<Users>kaplan>Local>medley3.5>my-medley>sources>NEWUPF.;13 31770  

      :CHANGES-TO (MACROS \UPF.EXTRACT \UPF.DIRTYPE)
                  (FNS UPF \UPF.DIRECTORY)
                  (VARS NEWUPFCOMS)

      :PREVIOUS-DATE "25-Apr-2022 20:59:21" 
{DSK}<Users>kaplan>Local>medley3.5>my-medley>sources>NEWUPF.;4)


(PRETTYCOMPRINT NEWUPFCOMS)

(RPAQQ NEWUPFCOMS
       [(FNS UPF \UPF.DIRECTORY)
        [DECLARE%: EVAL@COMPILE DONTCOPY (MACROS \UPF.EXTRACT \UPF.DIRTYPE)
               (CONSTANTS (FILENAMECODES (CHARCODE (%: < > / %. ; ! %')))
                      (MINFILENAMECODE (APPLY (FUNCTION IMIN)
                                              FILENAMECODES))
                      (MAXFILENAMECODE (APPLY (FUNCTION IMAX)
                                              FILENAMECODES]
        (COMS 
              (* ;; "Debugging")

              
              (* ;; "DOTTEDNAMES:  mismatch intended")

              
              (* ;; "RETURNFAILS:  mismatch with DIRFLG=RETURN, DIRECTORY and SUBDIRECTORY are swapped.  But original doesn't agree with its own complete analaysis.")

              (VARS DOTTEDNAMES TESTS RETURNFAILS)
              (FNS TRY TRYALL DT)
              (P (MOVD? 'UNPACKFILENAME.STRING 'OUPF])
(DEFINEQ

(UPF
  [LAMBDA (FILE ONEFIELDFLG DIRFLG OSTYPE PACKFLG CLFLG)     (* ; "Edited 26-Apr-2022 13:48 by rmk")
                                                             (* ; "Edited 24-Apr-2022 14:11 by rmk")

    (* ;; "")

    (* ;; 
    "Given a string or atom  representation of a file name, unpack it into its component parts.")

    (* ;; "From the front, the host and device are unmistakable:")

    (* ;; "     host is marked with  { } [ ] or ( ); if no closer, then the whole thing is host")

    (* ;; "     device follows host until first colon; no device if directory bracket comes first  (originally:  Only / or > could be in the device")

    (* ;; "Fom the back, version and extension are unmistakable:")

    (* ;; "     version is preceded by last ;  Version can't contain directory brackets  (but can contain dots??)")

    (* ;; "     extension is preceded by last . (not following a version ;)")

    (* ;; "Then the directory and name fight it out in the middle:")

    (* ;; 
    "     If there is < or / anywhere else but no closing / or >, then the whole thing is a name  ")

    (* ;; 
    "     If it begins with < or / but  no closing / or >, then directory is < and the rest is name")

    (* ;; "")

    (* ;; "     If there is at least one / or > then the last one ends the directory, anything before is possibly a relative or subdirectory.  Anything after is a name")
                                                             (* ; "")

    (* ;; "              (Rationale:  Those are not sub-directory brackets)")

    (* ;; 
    "Leading < duplicates  are discarded.  But internal  << duplicates are retained (abc<<xyz) ")

    (* ;; "")

    (* ;; "Strategy:")

    (* ;; "Peel off the host, since that may control a later pattern.  Then 2 phases:  A single left-to-right parse of the string to find the component positions, and a separate phase to assemble the value. ")

    (* ;; 
 "The component positions include the identifying punctuation marks,  those are stripped at the end.")

    (* ;; "")

    (PROG NIL
          (COND
             ((NULL FILE)
              (RETURN NIL))
             ((OR (STRINGP FILE)
                  (LITATOM FILE)))
             ((NUMBERP FILE)
              (SETQ FILE (MKSTRING FILE)))
             ((TYPEP FILE 'PATHNAME)
              (RETURN (UNPACKPATHNAME.STRING FILE ONEFIELDFLG DIRFLG PACKFLG)))
             [(STREAMP FILE)                                 (* ; 
                                                 "For streams, use full name.  If anonymous, fake it")
              (SETQ FILE (OR (ffetch FULLFILENAME of FILE)
                             (RETURN (CL:IF ONEFIELDFLG
                                         (AND (EQ ONEFIELDFLG 'NAME)
                                              FILE)
                                         (LIST 'NAME FILE))]
             (T (\ILLEGAL.ARG FILE)))

     (* ;; 
 "Parse the string to find marker positions. The format (parens mean optional, [ ] group, | disjoins")

     (* ;; "           ({host})  (device :)  ( ([<|>])  (directory >) )   (name)  (. (extension))   (; (version))")

     (* ;; "      where:  if the directory field begins with < or > but doesn't end later in >, directory is the < or >")

     (* ;; 
 "                      name doesn't contain <, >, or ;,    May begin with . (differs from original)")

     (* ;; "                      extension doesn't contain . and version doesn't contain ")

     (* ;; "")

     (* ;; "NOTE: We use FILE's block coordinate system for all the markers, using ORIGIN to reconstruct indexes for FILE substrings at the end.")

          (RETURN
           (FOR C HOST HOSTENDCHAR STARTPOS DEVICESTART DEVICEEND DIRSTART DIREND DIRBRKSTART 
                DIRBRKEND DIRDIRTY NAMESTART NAMEEND EXTENSIONSTART EXTENSIONEND VERSIONSTART 
                VERSIONEND ORIGIN (HOSTEND _ -1) INPNAME FILE
              FIRST (SETQ ORIGIN (SUB1 $$OFFSET))            (* ; 
                                                        "So we can reconstruct the proper substrings")

                    (* ;; "Host: { for Medley, [ for some arpanet, ( proposed for Xerox.  If the host doesn't end its the whole string")

                    (CL:WHEN [SETQ HOSTENDCHAR (CADR (ASSOC (CHCON1 FILE)
                                                            (CHARCODE (({ })
                                                                       (%( %))
                                                                       (%[ %]]
                        [SETQ HOSTEND (FOR CH INPNAME FILE FIRST (ADD $$OFFSET 1) 
                                                             (* ; "Skip the first")
                                         DO (IF (EQ CH HOSTENDCHAR)
                                                THEN (RETURN $$OFFSET)
                                              ELSEIF (EQ CH (CHARCODE %'))
                                                THEN (ADD $$OFFSET 1))
                                         FINALLY 

                                               (* ;; "The %"bracket%" is just past the end")

                                               (RETURN (ADD1 $$END]
                        (SETQ HOST (SUBSTRING FILE 2 (IDIFFERENCE (SUB1 HOSTEND)
                                                            ORIGIN)))
                                                             (* ; "Needed for GETHOSTINFO")
                        (CL:WHEN (IGEQ HOSTEND $$END)        (* ; "Only a host")
                            (GO RETURNVALUE))) 

                    (* ;; "")

                    (* ;; "STARTPOS starts after host, is updated after device for directory or name")

                    (SETQ $$OFFSET (ADD1 HOSTEND))
                    (SETQ STARTPOS $$OFFSET) WHEN (AND (IGEQ C MINFILENAMECODE)
                                                       (ILEQ C MAXFILENAMECODE))
              DO 
                 (* ;; "Test interval because SELCHARQ doesn't compile as a dispatch.")

                 (SELCHARQ C
                      (%:                                    (* ; 
                                             "Device ends on the first colon before any other marker")
                          (CL:UNLESS (OR DEVICESTART DIRSTART NAMESTART EXTENSIONSTART VERSIONSTART)
                              (SETQ DEVICESTART STARTPOS)
                              (SETQ DEVICEEND $$OFFSET)
                              (SETQ STARTPOS (ADD1 $$OFFSET))))
                      (< (CL:UNLESS (OR EXTENSIONSTART VERSIONSTART)
                                                             (* ; 
                                 "Ordinary character if already started directory or in an extension")
                             (IF DIRSTART
                                 THEN 
                                      (* ;; "DIRECTORY advances over initial duplicate brackets (but DIRSTART could be a subdirectory character instead)")

                                      (CL:WHEN [AND (EQ DIRSTART (SUB1 $$OFFSET))
                                                    (FMEMB (\GETBASECHAR $$FATP $$BASE (SUB1 $$OFFSET
                                                                                             ))
                                                           (CHARCODE (> / <]
                                             (SETQ DIRSTART $$OFFSET))
                               ELSE (SETQ DIRSTART STARTPOS) 

                                    (* ;; 
                                "DIRSTART updates for duplicates, but NAME may want all the brackets")

                                    (SETQ DIRBRKSTART STARTPOS))
                             [SETQ NAMESTART (SETQ NAMEEND (SETQ EXTENSIONSTART (SETQ VERSIONSTART 
                                                                                 NIL]))
                      ((> /)                                 (* ; "Preceding string is for sure a directory that maybe ends here (unless we're already in an extension")
                           (IF DIRSTART
                               THEN 
                                    (* ;; 
           "Advance over initial duplicate brackets (but DIRSTART could be a subdirectory character)")

                                    (CL:WHEN [AND (EQ DIRSTART (SUB1 $$OFFSET))
                                                  (FMEMB (\GETBASECHAR $$FATP $$BASE (SUB1 $$OFFSET))
                                                         (CHARCODE (> / <]
                                           (SETQ DIRSTART $$OFFSET))
                             ELSE (SETQ DIRSTART STARTPOS)
                                  (SETQ DIRBRKSTART STARTPOS))
                           (IF DIREND
                               THEN (CL:UNLESS (EQ DIREND (SUB1 $$OFFSET))
                                        (CL:WHEN [OR (EQ (\GETBASECHAR $$FATP $$BASE DIREND)
                                                         (CHARCODE /))
                                                     (FMEMB (\GETBASECHAR $$FATP $$BASE (ADD1 DIREND)
                                                                   )
                                                            (CHARCODE (> /]

                                            (* ;; 
                "Previous end may have started an internal duplicate run that needs to be cleaned up")

                                            (SETQ DIRDIRTY T))
                                        (SETQ DIREND $$OFFSET))
                             ELSE 
                                  (* ;; 
                 "If this is the last bracket, it will be thrown out so it doesn't matter if it is /")

                                  (SETQ DIREND $$OFFSET))

                           (* ;; "NAME keeps duplicatges, may want all the brackets.")

                           (SETQ DIRBRKEND $$OFFSET)

                           (* ;; "Toss all prior guesses")

                           [SETQ NAMESTART (SETQ NAMEEND (SETQ EXTENSIONSTART (SETQ VERSIONSTART NIL])
                      (%. (CL:UNLESS NAMESTART
                              (SETQ NAMESTART (IF DIREND
                                                  THEN (ADD1 DIRBRKEND)
                                                ELSE STARTPOS)))
                          (CL:UNLESS (EQ NAMESTART $$OFFSET) (* ; 
                                                            "Allow  . in first NAME position :  .git")
                              (SETQ NAMEEND (SUB1 $$OFFSET))
                              (SETQ EXTENSIONSTART $$OFFSET)))
                      ((; !)                                 (* ; "! was a Xerox IFS version marker")
                           (CL:WHEN [AND (EQ C (CHARCODE !))
                                         (FMEMB OSTYPE '(T NIL]
                               (SETQ OSTYPE (GETHOSTINFO HOST 'OSTYPE)))
                           (CL:WHEN (OR (EQ OSTYPE 'TOPS20)
                                        (EQ C (CHARCODE ;)))

                               (* ;; "Not sure about x;1;2  Old behavior is NAME=x, VERSION=1;2")

                               (* ;; 
  "If take out the UNLESS:  NAME=x;1, VERSION=2.  I.e. move the previous version to an earlier field")

                               (CL:UNLESS VERSIONSTART
                                   (CL:WHEN VERSIONSTART
                                       (CL:UNLESS EXTENSIONSTART (SETQ NAMEEND VERSIONSTART))
                                       (SETQ EXTENSIONSTART NIL))
                                                             (* ; 
                                                             "Starting a version, close up preceders")
                                   (CL:UNLESS NAMESTART      (* ; "We haven't seen a directory")
                                       (SETQ NAMESTART (IF DIREND
                                                           THEN (ADD1 DIRBRKEND)
                                                         ELSE STARTPOS)))
                                   (CL:IF EXTENSIONSTART
                                       (SETQ EXTENSIONEND (SUB1 $$OFFSET))
                                       (SETQ NAMEEND (SUB1 $$OFFSET)))
                                   (SETQ VERSIONSTART $$OFFSET))))
                      (%' 
                          (* ;; 
           "Quote the next character (if there is one:  original returns empty string in this case).")

                          (* ;; "But this is odd:  Shouldn't quotes be removed from our value, and reinserted by PACKFILENAME ? Do devices know about our quoting conventions? What about back-slash quoting?")

                          (ADD $$OFFSET 1))
                      NIL)
              FINALLY 

                    (* ;; "Adjudicate directory and name.  Empty NAME uses DIRBRKSTART and DIRBRKEND, since names retain duplicate brackets.")

                    (IF DIREND
                        THEN 
                             (* ;; 
                             "NAME is squeezed between directory and extension, version, or end. ")

                             (CL:UNLESS NAMESTART
                                 (CL:WHEN (OR NAMEEND (ILESSP DIRBRKEND $$END))
                                     (SETQ NAMESTART (ADD1 DIRBRKEND))))
                      ELSEIF DIRSTART
                        THEN                                 (* ; "DIR ran off the end")
                             (IF (FMEMB (\GETBASECHAR $$FATP $$BASE DIRSTART)
                                        (CHARCODE (< /)))
                                 THEN (SETQ DIREND DIRSTART) (* ; "<aaa  -> DIR <  NAME aaa")
                                      (CL:UNLESS (EQ DIRSTART $$END)
                                          (SETQ NAMESTART (ADD1 DIRBRKSTART)))
                               ELSE (SETQ NAMESTART DIRBRKSTART) 
                                                             (* ; "aaaa<xxx --> NAME aaa<xxx")
                                    (SETQ DIRSTART NIL))
                      ELSEIF (ILEQ STARTPOS $$END)
                        THEN 
                             (* ;; "Host/device were not exhaustive")

                             (SETQ NAMESTART STARTPOS)) 

                    (* ;; "")

                    (* ;; " DIRFLG is RETURN on calls (\UPFDirectoryNameP CL:USER-HOMEDIR-PATHNAME) where FILE is known to have no more than a directory, but the directory might not end with / or > (e.g. %"{DSK}/Users/kaplan%".  If we don't do something, %"kaplan%" would be seen as the NAME.  ")

                    (CL:WHEN [AND (EQ DIRFLG 'RETURN)
                                  (NOT (FMEMB (\GETBASECHAR $$FATP $$BASE $$END)
                                              (CHARCODE (> / <]
                        (SETQ DIRSTART STARTPOS)
                        (SETQ DIREND (ADD1 $$END))
                        (SETQ DIRDIRTY T)
                        (SETQ NAMESTART (SETQ EXTENSIONSTART (SETQ VERSIONSTART NIL)))) 

                    (* ;; 
         "Construct the return value.  DIRFLG=FIELD on calls from FILENAMEFIELD, with a ONEFIELDFLG.")

                    (* ;; "Fields are interrogated backwards so no need to reverse")

                    RETURNVALUE
                    (RETURN (FOR F FVAL
                               INSIDE (OR ONEFIELDFLG
                                          '(VERSION EXTENSION NAME RELATIVEDIRECTORY SUBDIRECTORY 
                                                  DIRECTORY DEVICE HOST))
                               WHEN (SETQ FVAL (SELECTQ F
                                                   (HOST HOST)
                                                   (DEVICE (CL:WHEN DEVICESTART

                                                               (* ;; 
                                              "Unless CLFLG, include the colon so NIL: works as atom")

                                                               (\UPF.EXTRACT DEVICESTART
                                                                      (CL:IF CLFLG
                                                                          (SUB1 DEVICEEND)
                                                                          DEVICEEND))))
                                                   (DIRECTORY 
                                                              (* ;; 
                                                             "Subtypes move up to DIRECTORY if FIELD")

                                                              (CL:WHEN
                                                               [AND DIRSTART
                                                                    (OR (EQ 'DIRECTORY (\UPF.DIRTYPE
                                                                                        DIRSTART))
                                                                        (EQ DIRFLG 'FIELD]
                                                               (\UPF.DIRECTORY FILE DIRSTART DIREND 
                                                                      DIRDIRTY ORIGIN)))
                                                   ((SUBDIRECTORY RELATIVEDIRECTORY) 
                                                        (CL:WHEN (AND DIRSTART (EQ F (\UPF.DIRTYPE
                                                                                      DIRSTART))
                                                                      (NEQ DIRFLG 'FIELD))
                                                               (\UPF.DIRECTORY FILE DIRSTART DIREND 
                                                                      DIRDIRTY ORIGIN)))
                                                   (NAME (CL:WHEN NAMESTART
                                                             (OR (\UPF.EXTRACT NAMESTART
                                                                        (OR NAMEEND $$END))
                                                                 "")))
                                                   (EXTENSION (CL:WHEN EXTENSIONSTART
                                                                  (OR (\UPF.EXTRACT (ADD1 
                                                                                       EXTENSIONSTART
                                                                                          )
                                                                             (OR EXTENSIONEND $$END))
                                                                      "")))
                                                   (VERSION (CL:WHEN VERSIONSTART
                                                                (OR (\UPF.EXTRACT (ADD1 VERSIONSTART)
                                                                           $$END)
                                                                    "")))
                                                   NIL))
                               DO (CL:WHEN PACKFLG
                                      (SETQ FVAL (CL:UNLESS (EQ 0 (NCHARS FVAL))

                                                     (* ;; "Empty string goes to NIL, not empty atom")

                                                     (MKATOM FVAL))))
                                  (CL:WHEN ONEFIELDFLG (RETURN FVAL))
                                  (PUSH $$VAL F FVAL])

(\UPF.DIRECTORY
  [LAMBDA (FILE DIRSTART DIREND DIRDIRTY ORIGIN)             (* ; "Edited 26-Apr-2022 12:45 by rmk")
                                                             (* ; "Edited 23-Apr-2022 17:09 by rmk")

    (* ;; "Relative directory {abc}<foo or {abc}< with no >, subdirectory >foo or > with no host or device (DIRSTART=1).  ")

    (* ;; "Advance DIRSTART through initial duplicates")

    (LET
     ((BRACKET (SELCHARQ (NTHCHARCODE FILE (IDIFFERENCE DIRSTART ORIGIN))
                    ((< /) 
                         "<")
                    (> ">")
                    NIL)))
     (IF (EQ DIREND DIRSTART)
         THEN 
              (* ;; "If EQ, the directory is just the bracket, the rest is the name")

              BRACKET
       ELSE
       (CL:WHEN BRACKET                                      (* ; "Skip the < or /")
           (ADD DIRSTART 1)) 

       (* ;; 
       "Convert / to >, remove all  // /> >> duplicate sequences (keep the first, skip the others)")

       (IF DIRDIRTY
           THEN (FOR C DEST DESTBASE (DESTPOS _ -1) INPNAME FILE
                   FIRST (SETQ DEST (ALLOCSTRING (ADD1 (IDIFFERENCE DIREND DIRSTART))
                                           NIL NIL $$FATP))
                         (SETQ DESTBASE (FETCH (STRINGP BASE) OF DEST)) 

                         (* ;; "Look just at the directory substring")

                         (SETQ $$OFFSET DIRSTART)
                         (SETQ $$END DIREND)
                   DO (ADD DESTPOS 1)
                      (SELCHARQ C
                           ((> /) 
                                (\PUTBASECHAR $$FATP DESTBASE DESTPOS (CHARCODE >))

                                (* ;; "Advance past duplicates")

                                (CL:UNLESS (EQ $$OFFSET $$END)
                                    [SETQ $$OFFSET
                                     (SUB1 (FIND I FROM (ADD1 $$OFFSET)
                                              SUCHTHAT (NOT (FMEMB (\GETBASECHAR $$FATP $$BASE I)
                                                                   (CHARCODE (> /]))
                           (\PUTBASECHAR $$FATP DESTBASE DESTPOS C))
                   FINALLY (REPLACE (STRINGP LENGTH) OF DEST WITH DESTPOS)
                         (RETURN DEST))
         ELSE (\UPF.EXTRACT DIRSTART (SUB1 DIREND])
)
(DECLARE%: EVAL@COMPILE DONTCOPY 
(DECLARE%: EVAL@COMPILE 

(PUTPROPS \UPF.EXTRACT MACRO ((STARTOFFSET ENDOFFSET)
                              (SUBSTRING FILE (IDIFFERENCE STARTOFFSET ORIGIN)
                                     (IDIFFERENCE ENDOFFSET ORIGIN))))

(PUTPROPS \UPF.DIRTYPE MACRO [(DIRSTART)                     (* ; "Edited 20-Apr-2022 20:14 by rmk")
                              (SELCHARQ (\GETBASECHAR $$FATP $$BASE DIRSTART)
                                   ((< > /)                  (* ; "Seems to match the old version")
                                        'DIRECTORY)
                                   (CL:IF (EQ STARTPOS (ADD1 ORIGIN))
                                       'SUBDIRECTORY
                                       'RELATIVEDIRECTORY)])
)

(DECLARE%: EVAL@COMPILE 

(RPAQ FILENAMECODES (CHARCODE (%: < > / %. ; ! %')))

(RPAQ MINFILENAMECODE (APPLY (FUNCTION IMIN)
                             FILENAMECODES))

(RPAQ MAXFILENAMECODE (APPLY (FUNCTION IMAX)
                             FILENAMECODES))


(CONSTANTS (FILENAMECODES (CHARCODE (%: < > / %. ; ! %')))
       (MINFILENAMECODE (APPLY (FUNCTION IMIN)
                               FILENAMECODES))
       (MAXFILENAMECODE (APPLY (FUNCTION IMAX)
                               FILENAMECODES)))
)
)



(* ;; "Debugging")




(* ;; "DOTTEDNAMES:  mismatch intended")




(* ;; 
"RETURNFAILS:  mismatch with DIRFLG=RETURN, DIRECTORY and SUBDIRECTORY are swapped.  But original doesn't agree with its own complete analaysis."
)


(RPAQQ DOTTEDNAMES (".x" ">.git" "x.y.100"))

(RPAQQ TESTS
       ("*,;" "*.*;*" "*.;" "*.;*" "///abc/x" "/abc.x" "<" "<<<abc" "<<<abc>" "<<<abc>>" "<<<abc>x" 
              "<<abc" "<<xyz>>>zz" "<<xyz>>>zzz/" "<<xyz>>zz" "<<xyz>zz" "<ABC>" "<XYZ>aa" "<a.b>" 
              "<a;b>" "<ab;c" "<ab>" "<abc" "<abc*." "<abc.x" "<abc.x;1" "<abc;x" "<abc<<<x" 
              "<abc<xyz<foo" "<abc<xyz>qrs" "<abc>" "<abc>;1" "<abc>xyz" "<abc>xyz>foo" "<xxx" 
              "<xy>>zz" "<xyz>>>zzz/" ">" ">>>abc/x" ">abc" ">abc;1" ">abc>" ">abc>xyz>foo" ">xxx" 
              "A.B.C" "XXX<yyy" "a;b" "a;b/d" "a;b;c" "a;b;c;d" "aa" "aa;" "aa;NEWEST" "aa;newest" 
              "aaa" "aaa/bbb" "aaa/bbb/" "aaa/xyz;x;m" "aaa<bbb" "aaa<bbb/" "aaa<xyz>" "aaa>bbb>" 
              "aaa>xyz.e;m;n" "aaa>xyz>qrs" "abc" "abc...c" "abc///XYZ//" "abc/d" "abc/xyz" 
              "abc/xyz.qrs" "abc/xyz.qrs;2" "abc:x<qrs>z" "abc<<<XYZ//" "abc<x" "abc<xyz" 
              "abc<xyz>qq" "abc<xyzqq" "abc>;1" "abc>qr.x" "abc>xy" "abc>xyz" "abc>xyz;2" 
              "dev:aaa>xyz>qrs" "foo:" "foo:aaa<xyz" "foo:aaa<xyz>" "foo:x<qrs>z" "foo<a:B>" "s;n;b"
              "x.y.z;w" "x.y;z" "x;y" "x<abc<xyz>qrs" "x<abc<z" "x<abc>z" "xxx<yyy" "xxx<yyy>" 
              "xxx<yyy>zzz" "xxx>yyy" "xxx>yyy>" "{ABC}" "{ABC}XXX:" "{DSK}" "{DSK}*.;*" "{DSK}...<a"
              "{DSK}<a" "{DSK}xxx<a" "{DSK}xxx<xxx>yyy" "{DSK}xxx>xxx" "{DSK}xxx>yyy" 
              "{HOST}foo:x<qrs>z" "{HOST}x<qrs>z" "{abc}" "{dsk}foo:aaa>b>.c.e.g;f" 
              "{dsk}foo:aaa>b>.c.e;f" "{dsk}foo:aaa>b>c.e;f" "{eris}abc>" "{host}abc/xyz;2" 
              "{host}abc>xyz;2" "{x}abc<xyz>qq" "{x}abc<xyzqq" "<abc<xyz>abc" "<abc<xyz>qrs" 
              "<abc<xyz>"))

(RPAQQ RETURNFAILS (">" ">>>abc/x" ">abc" ">abc;1" ">abc>" ">abc>xyz>foo" ">xxx" ">" ">>>abc/x" 
                        ">abc" ">abc;1" ">abc>" ">abc>xyz>foo" ">xxx"))
(DEFINEQ

(TRY
  [LAMBDA (FILE ONEFIELDFLG DIRFLG)                          (* ; "Edited 25-Apr-2022 14:15 by rmk")
                                                             (* ; "Edited 24-Apr-2022 08:45 by rmk")
                                                             (* ; "Edited 21-Apr-2022 15:36 by rmk")
    (CL:WHEN (LISTP (CAR (LISTP FILE)))
        (SETQ FILE (CAR FILE)))
    (LET (ORIG NEW)
         (CL:WHEN (LISTP FILE)
             (SETQ ONEFIELDFLG (CADR FILE))
             (SETQ DIRFLG (CADDR FILE))
             (SETQ FILE (CAR FILE)))
         (SETQ ORIG (OUPF FILE ONEFIELDFLG DIRFLG))
         (SETQ NEW (UPF FILE ONEFIELDFLG DIRFLG))
         (LIST (LIST FILE ONEFIELDFLG DIRFLG)
               (AND (EQUAL ORIG NEW)
                    '=)
               ORIG NEW])

(TRYALL
  [LAMBDA (FILES ALLFLAG ONEFIELDFLG DIRFLG)                 (* ; "Edited 21-Apr-2022 17:56 by rmk")
                                                             (* ; "Edited  2-Apr-2022 23:50 by rmk")
                                                             (* ; "Edited 31-Mar-2022 22:57 by rmk")
    (CL:WHEN (LISTP FILES)
        (SETQ FILES (FOR F IN FILES COLLECT (CL:IF (LISTP (CAR (LISTP F)))
                                                (CAR F)
                                                F))))
    (FOR FILE INFO (SAME _ 0)
         (DIFF _ 0) IN FILES EACHTIME (SETQ INFO (TRY FILE ONEFIELDFLG DIRFLG))
                                   (CL:IF (CADR INFO)
                                       (ADD SAME 1)
                                       (ADD DIFF 1)) UNLESS (AND (CADR INFO)
                                                                 (NOT ALLFLAG))
       COLLECT (PRINTOUT T .P2 (CAAR INFO)
                      31)
             (IF (CADR INFO)
                 THEN (PRINTOUT T "  = " .P2 (CADDR INFO))
                      (CL:WHEN (OR (CADAR INFO)
                                   (CADDAR INFO))
                          (PRINTOUT T 60 (CADAR INFO)
                                 %,,
                                 (CADDAR INFO))
                          (TERPRI T))
               ELSE (PRINTOUT T " ~= " -2 "old: " .P2 (CADDR INFO))
                    (CL:WHEN (OR (CADAR INFO)
                                 (CADDAR INFO))
                        (PRINTOUT T 60 (CADAR INFO)
                               %,,
                               (CADDAR INFO))
                        (TERPRI T))
                    (PRINTOUT T 37 "new: " .P2 (CADDDR INFO)
                           T))
             INFO FINALLY (PRINTOUT T SAME " matches, " DIFF " mismatches" T])

(DT
  [LAMBDA (STRINGS ALLFLAG)                                  (* ; "Edited 21-Apr-2022 17:53 by rmk")
                                                             (* ; "Edited 19-Apr-2022 20:55 by rmk")

    (* ;; "Tests the DIRFLG options on STRINGS.  If an element of STRINGS is a list, it is assumed to be a (STRING ONEFIELD DIRFLG), STRING is extracted.")

    (SETQ STRINGS (FOR S INSIDE STRINGS COLLECT (CL:IF (LISTP S)
                                                    (CAR S)
                                                    S)))
    [AND NIL (FOR ONEFIELD IN '(NAME DIRECTORY SUBDIRECTORY RELATIVEDIRECTORY)
                JOIN (FOR DIR ORIG NEW SAME IN '(FIELD RETURN)
                        JOIN (PRINTOUT T T "ONEFIELDFLG = " ONEFIELD -3 "DIRFLG = " DIR T T)
                             (TRYALL STRINGS ALLFLAG ONEFIELD DIR))
                FINALLY (FOR INFO SAME (DIFF _ 0) IN $$VAL DO (CL:IF (CADR INFO)
                                                                  (ADD SAME 1)
                                                                  (ADD DIFF 1))
                           FINALLY (SETQ SAME (IDIFFERENCE (LENGTH STRINGS)
                                                     DIFF))
                                 (PRINTOUT T T "Overall:  " SAME " matched, " DIFF " mismatched" T]
    (TRYALL (FOR S IN STRINGS JOIN (FOR ONEFIELD IN '(NAME DIRECTORY SUBDIRECTORY RELATIVEDIRECTORY)
                                      JOIN (FOR DIR IN '(FIELD RETURN)
                                              COLLECT (LIST S ONEFIELD DIR])
)

(MOVD? 'UNPACKFILENAME.STRING 'OUPF)
(DECLARE%: DONTCOPY
  (FILEMAP (NIL (1368 23782 (UPF 1378 . 21311) (\UPF.DIRECTORY 21313 . 23780)) (27253 31709 (TRY 27263
 . 28081) (TRYALL 28083 . 30000) (DT 30002 . 31707)))))
STOP
