(DEFINE-FILE-INFO PACKAGE (DEFPACKAGE "SEDIT" (USE "LISP" "XCL")) READTABLE "XCL" BASE 10)

(il:filecreated "28-Nov-2021 12:48:26" il:|{DSK}<home>larry>medley>sources>SEDIT-TOPLEVEL.;1| 40792  

      il:|changes| il:|to:|  (il:fns markaschangedfn)

      il:|previous| il:|date:| "28-Nov-2021 12:25:17" 
il:|{DSK}<home>larry>medley>sources>SEDIT-TOPLEVEL.;9|)


; Copyright (c) 1986-1988, 1990-1991 by Venue & Xerox Corporation.

(il:prettycomprint il:sedit-toplevelcoms)

(il:rpaqq il:sedit-toplevelcoms
          ((il:prop il:filetype il:sedit-toplevel)
           (il:prop il:makefile-environment il:sedit-toplevel)
           (il:localvars . t)
           (il:declare\: il:dontcopy il:doeval@compile (il:files il:sedit-decls))
           (il:initvars contexts regions)
           (il:vars (il:*display-editor* 'sedit))
           (il:fns sedit reset get-window-region save-window-region)
           (il:fns get-context disintegrate-context awake-command-process awake-me markaschangedfn 
                  new-function-body)
           (il:functions query-throw-away-changes set-options set-props start-process)
           (il:coms 

                  (il:* il:|;;| 
       "THESE CAN ALL BE NUKED WITH THE NEW EDIT INTERFACE AND A DETACHED TTY/EDITOR (WOZ 1/25/91)")

                  (il:prop (il:|Definition-for-EDITL| il:|Definition-for-EDITE| 
                                  il:|Definition-for-EDITDATE|)
                         sedit)
                  (il:fns sedite seditl fn-changed prop-changed proplst-changed var-changed 
                         alist-completion completion props-completion ttyfn 
                         locate-node-from-editchain)
                  
                  (il:* il:|;;| "Mess around with the tty editor's TTY: command by defining a hook and then making TTY: a macro which calls the hook.")

                  (il:functions smart-ttyfn)
                  (il:p (pushnew '(il:tty\: nil (il:e (smart-ttyfn)
                                                      t))
                               il:editmacros :test #'il:equal)))
           (il:fns pretty-print map-font)
           
           (il:* il:|;;| "these guys allow you to print and read structures with broken atoms and gaps.  just a convenience for the loser who forgets to get them out of his code.")

           (il:functions make-broken-atom print-broken-atom make-gap print-gap)
           (il:p (il:defprint 'broken-atom 'print-broken-atom)
                 (il:defprint 'gap 'print-gap))))

(il:putprops il:sedit-toplevel il:filetype :compile-file)

(il:putprops il:sedit-toplevel il:makefile-environment (:readtable "XCL" :package
                                                                      (defpackage "SEDIT"
                                                                             (:use "LISP" "XCL"))))
(il:declare\: il:doeval@compile il:dontcopy

(il:localvars . t)
)
(il:declare\: il:dontcopy il:doeval@compile 

(il:filesload il:sedit-decls)
)

(il:rpaq? contexts nil)

(il:rpaq? regions nil)

(il:rpaqq il:*display-editor* sedit)
(il:defineq

(sedit
  (il:lambda (structure props options)                       (il:* il:\; 
                                                           "Edited 25-Jan-91 13:51 by woz")
    (or structure (il:setq structure basic-gap))
    (let* ((name (il:listget props :name))
           (type (or (il:listget props :type)
                     :expression))
           (context (get-context structure name type))
           (window (il:|fetch| display-window il:|of| context)))
          (set-props context props)
          (set-options context options)
          (cond
             ((null window)

              (il:* il:|;;| "this is a new context, needs to be setup from scratch")

              (start-process context name)
              context)
             ((and (il:openwp window)
                   (il:processp (il:windowprop window 'il:process)))

              (il:* il:|;;| "open and active")

              (il:totopw window)
              (when (or (not (eq t (il:|fetch| (edit-context changed-structure?) il:|of|
                                                                                     context)))
                        (query-throw-away-changes name options))

                  (il:* il:|;;| 
"there are no changes on this edit, or user said throw away changes, so we will restart this edit.")

                  (il:|replace| changed-structure? il:|of| context il:|with| structure)
                  (il:restart.process (il:windowprop window 'il:process))
                  context))
             ((il:openwp (il:windowprop window 'il:iconwindow))

              (il:* il:|;;| "shrunk")

              (il:|replace| changed-structure? il:|of| context il:|with| structure)
              (il:expandw window)
              context)
             (t 
                (il:* il:|;;| "found a dead context.  get rid of it and try again.")

                (disintegrate-context context)
                (sedit structure props options))))))

(reset
  (il:lambda nil                                             (il:* il:\; 
                                                           "Edited 10-Jul-87 08:35 by DCB")
    (cond
       (contexts (il:error "Can't reset SEdit while there are open SEdit windows"))
       (t (create-environments)
          (reset-formats)
          t))))

(get-window-region
  (il:lambda (context reason name type)                      (il:* il:\; 
                                                           "Edited 19-Nov-87 10:18 by DCB")

(il:* il:|;;;| "called to get a region for this sedit window.  should return the region for the sedit including the prompt window.  context is being built and needs a window.  the context will have at least the name (IconTitle) and type (EditType) of the object being edited, and can be used as desired to map between contexts and windows.  If reason is :CREATE, then this function must return a region.  If :EXPAND, then this algorithm returns a region from the stack only if SEDIT.KEEP.WINDOW.REGION is nil, otherwise it returns NIL, telling the window system not to reshape on expansion.")

    (when (or (eq reason :create)
              (not keep-window-region))
        (or (il:pop regions)
            (progn (il:|printout| il:promptwindow t "Select region for SEdit window.")
                   (il:getregion 30 20))))))

(save-window-region
  (il:lambda (context reason name type region)               (il:* il:\; 
                                                           "Edited 23-Nov-87 17:46 by DCB")

(il:* il:|;;;| "Release this sedit windows region to be used again.  If we're shrinking, KEEP-WINDOW-REGION determines whether to release the region or not.  If an icon is being closed, don't release the region because it was handled appropriately when the window as shrunk.   remember, we're maintaining regions including the prompt window height, so use WINDOWREGION to get the whole region.")

    (when (or (eq reason :close)
              (and (eq reason :shrink)
                   (not keep-window-region)))
        (il:|push| regions (or region (il:windowregion (il:|fetch| display-window
                                                              il:|of| context)))))))
)
(il:defineq

(get-context
  (il:lambda (structure name type search-only?)              (il:* il:\; 
                                                           "Edited  5-Dec-90 13:00 by woz")

(il:* il:|;;;| "we've been asked to get the edit context for a new edit.  if a context matching this description (same name and same type, or  EQ structure) already exists, we'll return it rather than creating a new one.  Also, if SEARCH-ONLY? is true then don't create a new one, just return NIL if not found.")

    (il:|bind| window il:|for| context il:|in| contexts
       il:|when| (or (and name (equal name (il:|fetch| icon-title il:|of| context))
                              (eq type (il:|fetch| edit-type il:|of| context)))
                         (and structure (il:|type?| edit-node (il:|fetch| root il:|of|
                                                                                       context))
                              (eq structure (il:|fetch| structure
                                               il:|of| (subnode 1 (il:|fetch| root
                                                                         il:|of| context))))))
       il:|do| 

             (il:* il:|;;| "we found a context that matches,  return it.")

             (return context)
       il:|finally| 

             (il:* il:|;;| 
           "this is a new editing task, so make an appropriate context and get it started")

             (if search-only?
                 (return nil)
                 (let ((context (il:|create| edit-context
                                       completion-event il:_ (il:create.event (il:concat editor-name
                                                                                     name))
                                       root il:_ structure
                                       icon-title il:_ name
                                       edit-type il:_ type)))
                      (push context contexts)
                      (return context))))))

(disintegrate-context
  (il:lambda (context)                                       (il:* il:\; 
                                                           "Edited  5-Dec-90 17:45 by woz")

(il:* il:|;;;| "terminate this edit context.  we mark it as dead, remove it from the active edits list, smash the connections between the context and the window")

    (when context
        (il:notify.event (il:|fetch| completion-event il:|of| context))
        (il:|replace| context-lock il:|of| context il:|with| 'dead)
        (il:windowprop (il:|fetch| display-window il:|of| context)
               'edit-context nil)
        (il:|replace| display-window il:|of| context il:|with| nil)
        (il:setq contexts (il:dremove context contexts)))))

(awake-command-process
  (il:lambda (context command)                               (il:* il:\; 
                                                           "Edited  5-Dec-90 16:52 by woz")

    (il:* il:|;;| "if this context has a process associated with it, and the process is currently stuck waiting for input, unstick it so that it can look around and (presumably) notice some important change in its environment.  This is also called when someone in another process, such as a command menu or a window menu operation, wants to tell the command process to execute the command.  Note that under a few circumstances this function will be called by a running command in the sedit process.  For example, the complete-and-close command calls il:closew which calls sedit's closefn which tries to wake up the sedit to let it know the window was closed.  In this case, awake-command-porcess will result in a no-op because sedit has a command running, and therefore cannot be woken up.  COMMAND is a command form which will be used as the value returned from GETKEY in SEDIT1.  COMMAND should be of the form (<fn> <normalize?> <extra args>), so that <fn> will be applied to the context, the charcode invokeing the command (NIL in this case), and the extra args.  After the command runs the window will scroll to normalize the caret if <normalize?> is T.  If COMMAND is NIL then the SEdit will just update the window.")

    (let ((process (il:windowprop (il:|fetch| display-window il:|of| context)
                          'il:process)))
         (when (il:processp process)
             (il:process.apply process 'awake-me (list command))))))

(awake-me
  (il:lambda (result)                                        (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")

    (il:* il:|;;| "this rather ugly little function checks to see if it's being called under getkey (presumably by PROCESS.APPLY from awake.command.process) and if so forces the getkey to return result")

    (let ((stack-frame (il:stkpos 'getkey)))
         (when stack-frame (il:retfrom stack-frame result t)))))

(markaschangedfn
  (il:lambda (name type reason)                              (il:* il:\; 
                                                           "Edited 28-Nov-2021 12:14 by larry")
                                                             (il:* il:\; 
                                                           "Edited  3-Apr-91 15:42 by jds")

(il:* il:|;;;| "When a managed object is changed, we must check if we have an open edit on it.  If so, calling SEdit again, with the fresh definition, will  force the update.  This is fairly tricky, though.  Markaschanged is called as a result of editing a managed definition, so this markaschangedfn could be running in the sedit process under the completion-fn half way through completion.  IDEALLY in this case we could say \"i know it changed, i just changed it!\" and ignore this call.  BUT FOR NOW (1/14/91) since the manager can change the definition on completion (editdates, for one), we have to notify SEdit.  Since calling editdef will restart the sedit process, the completion-fn will not finish, so do the verify-structure here.")

    (let* ((form (il:processprop (il:this.process)
                        'il:form))
           context)
          (cond
             ((and (eq (car form)
                       'sedit1)
                   (il:|type?| edit-context (setq context (cadadr form)))
                   (eq name (il:|fetch| icon-title il:|of| context))
                   (eq type (il:|fetch| edit-type il:|of| context)))

              (il:* il:|;;| "we're running under the edit that is completing")

              (unless *ignore-changes-on-completion*
                  (verify-structure context nil (il:getdef name type nil '(il:edit il:nocopy)))))
             ((get-context nil name type t)

              (il:* il:|;;| "found a matching context elsewhere")

              (il:resetform (il:editmode 'il:sedit\:sedit)
                     (il:editdef name type nil nil '(:dontwait))))))))

(new-function-body
  (il:lambda (dummy-body)                                    (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")
    (if (il:neq (il:editmode)
               'sedit)
        (il:copy dummy-body)
        (list 'il:lambda args-gap body-gap))))
)

(defun query-throw-away-changes (name options)

(il:* il:|;;;| "this gets called when sedit is restarting because it got called again, but the structure doesn't match and changes have been made.  should we throw away the changes and restart with the new structure, or not restart and keep the changes?  ask the user.")

   (if (il:eqmemb :display options)
       (il:menu (il:|create| il:menu
                       il:items il:_ '(("Throw away changes and restart with new structure" t)
                                       ("Keep changes and don't restart with new structure" nil))
                       il:title il:_ (format nil "An edit session with changes already exists for ~S"
                                            name)))
       (if (eq 'il:y (il:askuser nil nil (format nil "An edit session with changes already exists for ~S.  Throw away changes and restart with new structure? "
                                                name)))
           t)))

(defun set-options (context options)

(il:* il:|;;;| "set up the OPTIONS provided in the call to SEDIT for this context.  Most of these options do not require immediate action.  Rather, they control how some command or interaction will work later, so we just store the option list in the context.  Most of these options are really edit-interface options, not sedit options.  We stash them so that when the *edit-fn* is called under M-O, it will be handed the same options that this edit was started with")

   (il:|replace| (edit-context edit-options) il:|of| context il:|with|
                                                                     (if (listp options)
                                                                         options
                                                                         (list options))))

(defun set-props (context props)

(il:* il:|;;;| "go through the PROPS list supplied in the call to SEDIT and store the info in the context.  The :NAME and :TYPE props are already handled, because get-context uses this information to find an appropriate context.  Grab the current values of the variables that determine reading and printing, and save them in a profile in the context, so that later changes to the globals don't affect existing contexts. ")

   (il:|replace| (edit-context completion-fn) il:|of| context il:|with|
                                                                      (or (il:listget props 
                                                                                 :completion-fn)
                                                                          #'null))
   (il:|replace| (edit-context root-changed-fn) il:|of| context
      il:|with| (or (il:listget props :root-changed-fn)
                        #'null))
   (il:|replace| (edit-context environment) il:|of| context il:|with| (or (il:listget
                                                                                       props 
                                                                                       :environment)
                                                                                      
                                                                                lisp-edit-environment
                                                                                      ))
   (il:|replace| (edit-context profile) il:|of| context il:|with|
                                                                (or (il:listget props :profile)
                                                                    (save-profile (copy-profile
                                                                                   "READ-PRINT"))))
   (il:|replace| (edit-context eval-in-process) il:|of| context
      il:|with| (or (il:listget props :eval-in-process)
                        (eval-in-process)))
   (il:|replace| (edit-context eval-fn) il:|of| context il:|with|
                                                                (or (il:listget props :eval-fn)
                                                                    (xcl::profile-entry-value
                                                                     '*eval-function*)))
   (when (il:listget props :select-structure)
       (il:|replace| (edit-context find-candidate) il:|of| context
          il:|with| (cons (il:listget props :select-structure)
                              (or (il:listget props :select-instance)
                                  1)))))

(defun start-process (context)

(il:* il:|;;;| "the context is ready.  start the sedit process.  the rest of the initialization will happen in the sedit process, and the completion-event will be notified (by SEDIT1) when the sedit is initialized.")

   (let ((name (il:|fetch| (edit-context icon-title) il:|of| context))
         (event (il:|fetch| (edit-context completion-event) il:|of| context)))
        (il:add.process (list 'sedit1 (il:kwote context))
               'il:name
               (if name
                   (il:concat editor-name " " name)
                   editor-name))
        (il:|until| (eq event (il:await.event event)))))



(il:* il:|;;| 
"THESE CAN ALL BE NUKED WITH THE NEW EDIT INTERFACE AND A DETACHED TTY/EDITOR (WOZ 1/25/91)")


(il:putprops sedit il:|Definition-for-EDITL| seditl)

(il:putprops sedit il:|Definition-for-EDITE| sedite)

(il:putprops sedit il:|Definition-for-EDITDATE| il:tty/editdate)
(il:defineq

(sedite
  (il:lambda (expr coms atom type ifchangedfn options)       (il:* il:\; 
                                                           "Edited 10-Jul-91 19:04 by jds")

(il:* il:|;;;| "Convert call to EDITE into sedit format (structure props options).  The completion-fn is determined based on TYPE, since the file manager isn't very consistent about IL:PROPLST and IL:ALIST.  Since EDITE is supposed to wait for completion, create a completion event which is notified by the completion-fn.  Also, if the top cons is changed, try to smash the completed structure into EXPR to provide eqness.")

(il:* il:|;;;| "IDEALLY: this whole mess wouldn't exist- if il:putdef could handle il:proplst, etc, then completion could simply call putdef, not special case as it does here.")

    (let* ((event (il:create.event "SEDITE Completion"))
           (new-expr)
           (completion-fn
            (or (and il:filepkgflg
                     (il:selectq type
                           (il:proplst (let ((old-props (il:append (il:getproplist atom))))
                                            #'(lambda (context structure changed?)
                                                     (funcall #'props-completion context structure 
                                                            changed? atom ifchangedfn old-props)
                                                     (setq new-expr structure)
                                                     (il:notify.event event))))
                           (il:vars (when (il:eqmemb 'il:alist (il:getprop atom 'il:vartype))
                                        (let ((old-val (il:mapcar (il:function car)
                                                              (il:evalv atom))))
                                             #'(lambda (context structure changed?)
                                                      (funcall #'alist-completion context structure 
                                                             changed? atom ifchangedfn old-val)
                                                      (setq new-expr structure)
                                                      (il:notify.event event)))))
                           nil))
                (and atom type #'(lambda (context structure changed?)
                                        (funcall #'completion context structure changed? atom type 
                                               ifchangedfn)
                                        (setq new-expr structure)
                                        (il:notify.event event)))
                #'(lambda (context structure changed?)
                         (setq new-expr structure)
                         (il:notify.event event))))
           (root-changed-fn (il:selectq type
                                  (il:proplst (list (il:function proplst-changed)
                                                    atom))
                                  (il:vars (list (il:function var-changed)
                                                 atom))
                                  (il:fns (list (il:function fn-changed)
                                                atom))
                                  nil)))
          (cond
             (coms (il:tty/edite expr coms atom type ifchangedfn options))
             (t (when (and il:filepkgflg (or il:clisparray (progn (il:clisptran (cons)
                                                                         (cons))
                                                                  il:clisparray)))
                    (il:selectq type
                          (il:proplst (il:|for| x il:|in| (il:getproplist atom)
                                         il:|unless| (or (il:nlistp x)
                                                             (il:gethash x il:clisparray))
                                         il:|do| (il:puthash x (cons (car x)
                                                                         (cdr x))
                                                            il:clisparray)))
                          (il:vars (when (il:eqmemb 'il:alist (il:getprop atom 'il:vartype))
                                       (il:|for| x il:|in| (il:evalv atom)
                                          il:|unless| (or (il:nlistp x)
                                                              (il:gethash x il:clisparray))
                                          il:|do| (il:puthash x (cons (car x)
                                                                          (cdr x))
                                                             il:clisparray))))
                          nil))
                (sedit expr (list :name atom :type type :completion-fn completion-fn 
                                      :root-changed-fn root-changed-fn)
                       options)
                (unless (il:eqmemb :dontwait options)
                    (il:|until| (eq event (il:await.event event))))

                (il:* il:|;;| "EDITE is for side effects (but we return the correct structure anyway.  If the user replaced the top cons, smash the new structure into it.  Have to copy the new structure in this case because, if the user wrapped the top cons, smashing into it will result in a circular list.  Additionally, if there is an sedit root-changed-fn, assume the caller handled the root change then, and eqness is not necessary.")

                (if (or (eq new-expr expr)
                        root-changed-fn
                        (not (consp expr))
                        (not (consp new-expr)))
                    new-expr
                    (il:rplnode2 expr (copy-tree new-expr))))))))

(seditl
  (il:lambda (editexpr editcoms atom message editchanges)    (il:* il:\; 
                                                           "Edited 25-Jan-91 13:45 by woz")
    (declare (special type))

(il:* il:|;;;| "this is SEdit's definition for  EDITL.  if there are no COMS (normal case) we start an interactive SEdit.  otherwise, we run the TTY editor to execute the coms, and arrange to start an SEdit if it stops for input.")

    (cond
       (editcoms 

              (il:* il:|;;| "used to push stuff on il:editmacros, now we bind il:ttyeditfn")

              (il:* il:|;;| "(il:resetvar il:editmacros (cons '(il:tty\\: nil (il:e (ttyfn il:atm type) t)) il:editmacros) (il:tty/editl editexpr editcoms atom message editchanges))")

              (let ((il:ttyeditfn #'(lambda nil (ttyfn atom type))))
                   (declare (special il:ttyeditfn))
                   (il:tty/editl editexpr editcoms atom message editchanges)))
       (t (sedit (car editexpr)
                 (list :name atom :type (and (boundp 'type)
                                             type)))
          editexpr))))

(fn-changed
  (il:lambda (structure atom)                                (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")
    (cond
       ((not (il:ccodep (il:getd atom)))
        (il:putd atom structure))
       ((il:listp (il:getprop atom 'il:expr))
        (il:putprop atom 'il:expr structure))
       (t (il:shouldnt "where did this come from?")))))

(prop-changed
  (il:lambda (structure atom)                                (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")
    (il:putprop atom 'il:expr structure)))

(proplst-changed
  (il:lambda (structure atom)                                (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")
    (il:setproplist atom structure)))

(var-changed
  (il:lambda (structure atom)                                (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")
    (set atom structure)))

(alist-completion
  (il:lambda (context structure changed? atom ifchangedfn old-keys)
                                                             (il:* il:\; 
                                                           "Edited 18-Jan-88 15:43 by woz")
    (when (eq changed? t)

        (il:* il:|;;| "don't do anything if changed is NIL or :ABORT ")

        (let (found-change old-value)
             (il:for x il:in old-keys il:unless (il:assoc x structure)
                il:do (il:markaschanged (list atom x)
                                 'il:alists nil)
                      (il:setq found-change t))
             (il:for x il:in structure il:when (and (il:listp x)
                                                                (not (and il:clisparray
                                                                          (il:setq old-value
                                                                           (il:gethash x 
                                                                                  il:clisparray))
                                                                          (eq (car x)
                                                                              (car old-value))
                                                                          (eq (cdr x)
                                                                              (cdr old-value)))))
                il:do (il:puthash x nil il:clisparray)
                      (il:markaschanged (list atom (car x))
                             'il:alists nil)
                      (il:setq found-change t))
             (when (not found-change)
                 (completion context structure changed? atom 'il:alists ifchangedfn))))))

(completion
  (il:lambda (context structure changed? atom type ifchangedfn)
                                                             (il:* il:\; 
                                                           "Edited 18-Jan-88 15:40 by woz")
    (cond
       ((or (not changed?)
            (eq changed? :abort)))
       ((eq type 'il:fns)
        (il:fixeditdate structure)
        (il:putdef atom type structure)

        (il:* il:|;;| "(if  (CCODEP (GETD atom)) then (if (NEQ structure (GETPROP atom (QUOTE EXPR))) then (SHOULDNT 'where did this come from?') else (if (OR (EQ DFNFLG (QUOTE PROP)) (EQ DFNFLG (QUOTE ALLPROP))) then (SETQ message ' NOT unsaved.') else (UNSAVEDEF atom) (SETQ message ' unsaved.')) (if (OPENWP (fetch DisplayWindow of context)) then (printout (get.prompt.window context) atom message) else (* ;  'window was closed.  msg in promptwindow.') (printout PROMPTWINDOW T atom message))) else (if (NEQ structure (GETD atom)) then (if (NULL (GETD atom)) then (PUTD atom structure) else (SHOULDNT 'where did this come from?'))))")

        )
       (ifchangedfn 

              (il:* il:|;;| "this is a bit wrong:  the doc for edite says the ifchangedfn gets called with the last arg NIL if the editor is aborted.  But we don't call the ifchangedfn at all if the user did an abort command.  The idea is that ABORT is implemented as \"don't install even if changes we're made\"")

              (funcall ifchangedfn atom structure type t))
       ((il:neq type 'il:proplst)
        (il:markaschanged atom type)))
    (when (and (il:litatom atom)
               il:addspellflg)
          (il:addspell atom))))

(props-completion
  (il:lambda (context structure changed? atom ifchangedfn oldprops)
                                                             (il:* il:\; 
                                                           "Edited 20-Apr-88 11:39 by woz")
    (when (eq changed? t)

        (il:* il:|;;| "don't do anything if changed? is NIL or :ABORT")

        (il:bind old-value found-one il:for new-prop il:on (il:getproplist atom)
           il:by (cddr new-prop)
           il:unless (il:for old-prop il:on oldprops il:by (cddr old-prop)
                            il:when (eq (car old-prop)
                                            (car new-prop))
                            il:do (return (and (eq (cadr old-prop)
                                                       (cadr new-prop))
                                                   (or (il:nlistp (cadr old-prop))
                                                       (and il:clisparray (il:setq old-value
                                                                           (il:gethash (cadr new-prop
                                                                                             )
                                                                                  il:clisparray))
                                                            (eq (caadr new-prop)
                                                                (car old-value))
                                                            (eq (cdadr new-prop)
                                                                (cdr old-value))
                                                            (or (il:puthash (cadr new-prop)
                                                                       nil il:clisparray)
                                                                t))))))
           il:do (il:markaschanged (list atom (car new-prop))
                            'il:props nil)
                 (il:setq found-one t)))))

(ttyfn
  (il:lambda (atm type)                                      (il:* il:\; 
                                                           "Edited 21-Jan-91 12:02 by woz")
    (declare (special il:l il:editchanges))

    (il:* il:|;;| "this is a replacement for the TTY editor's TTY: command, which starts an SEdit process to do interactive editing for a while.  it uses the TTY editor's edit chain to determine the initial selection in the structure, and scrolls the window to make sure the selection's visible.  it then waits until the user signals that they've done enough editing (usually by closing or shrinking the window)")

    (let* ((edit-changes il:editchanges)
           (event (il:create.event "SEdit TTYFN Completion"))
           (completion-fn #'(lambda (context structure changed?)
                                   (when (eq changed? t)
                                       (rplaca (cdr edit-changes)
                                              t))
                                   (il:notify.event event)))
           (context (sedit (car (last il:l))
                           (list :name atm :type type :completion-fn completion-fn)))
           node)
          (il:with.monitor (il:|fetch| context-lock il:|of| context)
              (when (il:setq node (locate-node-from-editchain il:l (il:|fetch| root
                                                                          il:|of| context)))
                  (selection-down context)
                  (select-node context node)
                  (set-point-nowhere (il:|fetch| caret-point il:|of| context))
                  (normalize-selection context)
                  (selection-up context)))

          (il:* il:|;;| "let the user do their editing, then signal completion, before we return")

          (il:|until| (eq event (il:await.event event))))))

(locate-node-from-editchain
  (il:lambda (chain root)                                    (il:* il:\; 
                                                           "Edited 17-Nov-87 11:27 by DCB")

(il:* il:|;;;| "when SEdit is called under the TTY editor, it gets an edit chain to determine the initial selection.  this process finds the node that editchain refers to (or returns NIL if no such node exists)")

    (if (null chain)
        root
        (il:for subnode il:in (cdr (il:fetch sub-nodes il:of (
                                                                         locate-node-from-editchain
                                                                              (cdr chain)
                                                                              root)))
           il:thereis (eq (il:fetch structure il:of subnode)
                              (car chain))))))
)



(il:* il:|;;| 
"Mess around with the tty editor's TTY: command by defining a hook and then making TTY: a macro which calls the hook."
)


(defun smart-ttyfn ()

(il:* il:|;;;| "This is a replacement for the TTY editor's TTY: command, which is supposed to start up a TTY editor.  We first check to see if we're ")

   (declare (special il:l il:ttyeditfn))
   (if (and (boundp 'il:ttyeditfn)
            il:ttyeditfn)
       (funcall il:ttyeditfn)
       (il:editl0 il:l nil 'il:tty\: 'il:tty\:)))

(pushnew '(il:tty\: nil (il:e (smart-ttyfn)
                              t))
       il:editmacros :test #'il:equal)
(il:defineq

(pretty-print
  (il:lambda (structure stream right-margin)                 (il:* il:\; 
                                                           "Edited  7-Jul-87 12:59 by DCB")

(il:* il:|;;;| "with just a little hacking, SEdit can be used to prettyprint functions onto TEdit streams.  we make up a slightly weird context, and run the parser and linearizer each once.  stream is actually the textobj of the tedit stream.  note that right.margin is in micas (since that's the unit that interpress font widths are expressed in)")

    (or (boundp 'pretty-print-env)
        (create-pretty-print-env))
    (let ((context (il:create edit-context
                          display-window il:_ stream
                          environment il:_ pretty-print-env
                          current-x il:_ 0
                          comment-width il:_ (il:fixr (il:times 200 il:micasperpt))
                          comment-separation il:_ (il:fixr (il:times 30 il:micasperpt))))
          (root (il:create edit-node
                       node-type il:_ type-root
                       sub-nodes il:_ (list 0)
                       start-x il:_ 0
                       depth il:_ 0)))
         (il:replace current-node il:of context il:with root)
         (parse structure context)
         (compute-all-formats context nil)
         (linearize (subnode 1 root)
                context
                (il:fixr right-margin)))))

(map-font
  (il:lambda (font env)                                      (il:* il:\; 
                                                           "Edited 17-Nov-87 10:43 by DCB")

    (il:* il:|;;| "this is called when using the prettyprint environment, under output.string.  we have to map the font into something acceptable to TEDIT.INSERT (since interpress fonts confuse it)")

    (cond
       ((eq font (il:fetch default-font il:of env))
        il:defaultfont)
       ((eq font (il:fetch keyword-font il:of env))
        il:clispfont)
       ((eq font (il:fetch italic-font il:of env))
        il:italicfont)
       ((eq font (il:fetch comment-font il:of env))
        il:commentfont)
       ((eq font (il:fetch broken-atom-font il:of env))
        il:boldfont)
       (t (il:shouldnt "unexpected font!")))))
)



(il:* il:|;;| 
"these guys allow you to print and read structures with broken atoms and gaps.  just a convenience for the loser who forgets to get them out of his code."
)


(defun make-broken-atom (string)
   (il:|create| broken-atom
          atom-chars il:_ string))

(defun print-broken-atom (broken-atom stream x)
   (format stream "#.(~S ~S)" 'make-broken-atom (il:|fetch| atom-chars il:|of| broken-atom))
   t)

(defun make-gap (item)
   (il:|create| gap
          linear-item il:_ item))

(defun print-gap (gap stream x)
   (format stream "#.(~S '~S)" 'make-gap (il:|fetch| linear-item il:|of| gap))
   t)

(il:defprint 'broken-atom 'print-broken-atom)

(il:defprint 'gap 'print-gap)
(il:putprops il:sedit-toplevel il:copyright ("Venue & Xerox Corporation" 1986 1987 1988 1990 1991))
(il:declare\: il:dontcopy
  (il:filemap (nil (3132 7490 (sedit 3145 . 5200) (reset 5202 . 5554) (get-window-region 5556 . 6590) (
save-window-region 6592 . 7488)) (7491 14922 (get-context 7504 . 9593) (disintegrate-context 9595 . 
10390) (awake-command-process 10392 . 12054) (awake-me 12056 . 12563) (markaschangedfn 12565 . 14593) 
(new-function-body 14595 . 14920)) (14924 15907 (query-throw-away-changes 14924 . 15907)) (15909 16767
 (set-options 15909 . 16767)) (16769 19529 (set-props 16769 . 19529)) (19531 20206 (start-process 
19531 . 20206)) (20522 36939 (sedite 20535 . 26312) (seditl 26314 . 27466) (fn-changed 27468 . 27890) 
(prop-changed 27892 . 28126) (proplst-changed 28128 . 28360) (var-changed 28362 . 28579) (
alist-completion 28581 . 30379) (completion 30381 . 32032) (props-completion 32034 . 34085) (ttyfn 
34087 . 35994) (locate-node-from-editchain 35996 . 36937)) (37085 37454 (smart-ttyfn 37085 . 37454)) (
37577 39924 (pretty-print 37590 . 39053) (map-font 39055 . 39922)) (40106 40209 (make-broken-atom 
40106 . 40209)) (40211 40369 (print-broken-atom 40211 . 40369)) (40371 40455 (make-gap 40371 . 40455))
 (40457 40585 (print-gap 40457 . 40585)))))
il:stop
