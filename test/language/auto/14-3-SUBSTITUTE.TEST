;; Function To Be Tested: substitute
;;
;; Source:        CLtL    Section 14.3: Modifying Sequences        Page: 255
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: Sept. 24 ,1986
;;
;; Last Update:   Sept. 24 ,1986
;;
;; Filed As:      {eris}<lispcore>cml>test>14-3-substitute.test
;;
;;
;; Syntax:                substitute  NEWITEM OLDITEM SEQUENCE &KEY :FROM-END :TEST :TEST-NOT :START :END :COUNT :KEY
;;
;; Function Description:  The result is a sequence of the same kind as the argument SEQUENCE that has the same elements except that
;;					those in the subsequence delemited by  :START and :END and satisfying the test have been replaced by newitem.
;;
;; Argument(s):           NEWITEM     -
;;					OLDITEM     -			
;;					SEQUENCE    -
;;					:TEST       - a function which takes two arguments
;;					:TEST-NOT   - a function which takes two arguments
;;					:FROM-END   - nil or non-nil
;;					:START :END - integer indices into the SEQUENCE, with :START <= :END
;;					:COUNT      - 
;;					:KEY        - a function of one argument that will extract from an element the part
;;							    to be tested in place of the whole element.
;;
;; Returns:               a sequence    
;;

(do-test "test substitute - test cases copied from page 256 of CLtL"
	(and	(equal (substitute 9 4 '(1 2 4 1 3 4 5)) '(1 2 9 1 3 9 5))
		(equal (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 ) '(1 2 9 1 3 4 5))
		(equal (substitute 9 4 '(1 2 4 1 3 4 5) :count 1 :from-end t) '(1 2 4 1 3 9 5))
		(equal (substitute 9 3 '(1 2 4 1 3 4 5) :test #'>) '(9 9 4 9 3 4 5))
	)
)

(do-test "test substitute 0"
	(let ((a '(3 2 1 10 3 3 9 2 1 3 10 13 30 3) ))
		(and (equal (substitute 8 3 a) '(8 2 1 10 8 8 9 2 1 8 10 13 30 8))
			(equal (substitute 8 3 a :start 5) '(3 2 1 10 3 8 9 2 1 8 10 13 30 8))
			(equal (substitute 8 3 a :end 9) '(8 2 1 10 8 8 9 2 1 3 10 13 30 3) )
			(equal (substitute 100 10 a :start 1 :end 10) '(3 2 1 100 3 3 9 2 1 3 10 13 30 3) )
			(equal (substitute 200 20 a ) '(3 2 1 10 3 3 9 2 1 3 10 13 30 3) )
			(equal a '(3 2 1 10 3 3 9 2 1 3 10 13 30 3) )
		)
	)
)

(do-test "test substitute 1"
	(let ((a "abdefgbcdefegAbcDabGecba"))
		(and (equal (substitute #\* #\a a :count 2) "*bdefgbcdefegAbcD*bGecba")
			(equal (substitute #\* #\a a :count 2 :from-end t) "abdefgbcdefegAbcD*bGecb*")
			(equal (substitute #\% #\b a :count 3) "a%defg%cdefegA%cDabGecba")
			(equal (substitute #\% #\b a :count 3 :from-end t) "abdefgbcdefegA%cDa%Gec%a")
		)	
	)
)

(do-test "test substitute 2"
	(let ((a (vector  'x 'y 1 0 'a 'z 3 6 'm 'n 5 9 '(d w 2 4) 'b 'a 7 7 't 'u 9 0) )  )
		(and (equalp (substitute "!" 6 a :test #'(lambda (x y) (and (numberp y) (< x y))) )
				   (vector 'x 'y 1 0 'a 'z 3 6 'm 'n 5 "!" '(d w 2 4) 'b 'a "!" "!" 't 'u "!" 0) ) 
			
			(equalp (substitute '(11 22) 'dummy a :test #'(lambda (x y) (and (numberp y) (oddp y)))  )
				   (vector 'x 'y '(11 22) 0 'a 'z '(11 22) 6 'm 'n '(11 22) '(11 22) '(d w 2 4) 'b 'a '(11 22) '(11 22) 't 'u '(11 22)  0) )

			(equalp (substitute 99 9.0 a :test #'equalp)
				   (vector  'x 'y 1 0 'a 'z 3 6 'm 'n 5 99 '(d w 2 4) 'b 'a 7 7 't 'u 99 0) )

			(equalp (substitute "nlist" 'list a :test-not #'(lambda (x y) (typep y x)) :start 10 :end 15)
				   (vector 'x 'y 1 0 'a 'z 3 6 'm 'n "nlist" "nlist" '(d w 2 4) "nlist" "nlist" 7 7 't 'u 9 0) )

			(equalp a (vector  'x 'y 1 0 'a 'z 3 6 'm 'n 5 9 '(d w 2 4) 'b 'a 7 7 't 'u 9 0) )
		)
	)
)

(do-test "test substitute 3"
	(let ((a '( (1 2 4 8) ( 5 3 1 2) (-9 2 4) (0 8 9 1) (-7 0 1) (2 2 4 4 6) (3 1 4 2))  ))
		(and (equal (substitute 'same '(2 4) a :key #'(lambda (x) (subseq x 1 3))  :test #'equal)
				  '(same ( 5 3 1 2) same (0 8 9 1) (-7 0 1) same (3 1 4 2)) )

			(equal (substitute 'fun 2 a :test #'> :key #'second)
				  '((1 2 4 8) ( 5 3 1 2) (-9 2 4) (0 8 9 1) fun (2 2 4 4 6) fun)  )

			(equal (substitute 'foo 4 a :test #'= :key #'caddr)
				  '(foo ( 5 3 1 2) foo (0 8 9 1) (-7 0 1) foo foo)  )

			(equal a '( (1 2 4 8) ( 5 3 1 2) (-9 2 4) (0 8 9 1) (-7 0 1) (2 2 4 4 6) (3 1 4 2))  )
		)
	)
)

(do-test "test substitute 4"
	(let ((a '( (1 2 3) (-4  3 1) (3 5 -4) (6 2 -1) (4 -5 -3) (-4 2 1) (0 0 -2) (2 2 -4) (3 1 -4))  ))
		(and	(equal (substitute "@" 'dummy a :from-end t :start 1 :end 8 :test #'(lambda (x y) (plusp y)) :count 4 :key #'third)
				  '((1 2 3) "@" (3 5 -4) (6 2 -1) (4 -5 -3) "@" (0 0 -2) (2 2 -4) (3 1 -4))  )

			(equal (substitute "?" 2 a :from-end t  :end 8  :count 3 :key #'caddr :test #'(lambda (x y) (>= (+ x y) 0))  )
				  '((1 2 3) (-4  3 1) (3 5 -4) "?"  (4 -5 -3) "?" "?"  (2 2 -4) (3 1 -4))  )

			(equal (substitute "@" 2 a :end 8  :count 3 :key #'caddr :test #'(lambda (x y) (>= (+ x y) 0))  )
				  '("@" "@"  (3 5 -4) "@"  (4 -5 -3) (-4 2 1) (0 0 -2) (2 2 -4) (3 1 -4))  )
		)
	)
)
STOP




