;; Function To Be Tested: mismatch
;;
;; Source:        CLtL    Section 14.4 Searching sequences for items        Page: 257
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: Sept. 30 ,1986
;;
;; Last Update:   Sept. 30 ,1986
;;
;; Filed As:      {eris}<lispcore>cml>test>14-4-mismatch.test
;;
;;
;; Syntax:                mismatch SEQUENCE1 SEQUENCE2 &KEY :FROM-END :TEST :TEST-NOT :KEY :START1 :END1 :START2 :END2
;;
;; Function Description: The specified subsequences of SEQUENCE1 and SEQUENCE2 are compared element-wise.  If they are
;;					of equal length and match in every element, the result is nil.  Otherwise the result is a non-
;;					negative integer.  This result is the index within SEQUENCE1 of the leftmost position at which the 
;;					two subsequences fial to match;of, if one subsequence is shorter than a matching prefix of the
;;					other, the result is the index relative to 	sequence1 beyond the last position tested.  If a 
;;					non-nil :from-end keyword argument is given, then one plus the index of the rightmost position
;;					in which the sequences differ is returned.
;;
;;
;; Argument(s):           SEQUENCE1 SEQUENCE2  -
;;					:FROM-END            - nil or non-nil
;;					:TEST     :TEST-NOT  - fuctions of two arguments
;;					:KEY                 - a function of one argument which will extract from an element the part to be
;;									   tested in place of the whole element.
;;					:START1   :START2    - non-negative integers
;;					:END1     :END2      - non-negative integers
;;
;; Returns:               a non-negative integer or nil    
;;

(do-test "test mismatch 0"
	(and (eq (mismatch #*101000001111010101111101110 #*101000001111010101111101110) nil)
		(eq (mismatch "this is a string this is a string this is ...  "  "this is a string this is a string this is ...  ") nil)
		(eq (mismatch (vector 8 7 3 'a 'b (+ 3 4) (list 2 4 6 7 3 5) "lkj") (vector 8 7 3 'a 'b 7 '(2 4  6 7 3 5) "lkj")
				   :test #'equal) nil)
		(eq (mismatch '( (1 2 3 . 4) (a b ( c d)) (10 20 33 44)) '( (1 2 3 . 4) (a b ( c d)) (10 20 33 44)) :test #'equal) nil)
	)
)

(do-test "test mismatch 1"
	(let ((a "negative integer.  This result is the index within SEQUENCE1 of the leftmost position at which the two subsequences" ))
		;;
		;;   0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234
		;;		     1         2         3         4         5         6         7         8         9         0         1
		;;
	  (and
		(= (mismatch "negative integer.  Thi" a ) 22)
		(= (mismatch "negative integer,  Thi" a ) 16)
		(= (mismatch a "SEQUENCE2" :start1 51 :test #'char=) 59)
		(= (mismatch a "SEQUENCE1" :start1 51 :test #'char=) 60)
		(= (mismatch "SEQUENCE1" a :start2 51 :test #'char=)  9)
		(= (mismatch a " subsequences" :from-end t :test #'char=) 102)
		(= (mismatch "rightmost position" a :start1 4 :end1 10 :start2 71 :end2 80 :test #'char=) 10)
		(= (mismatch a "rightmost position" :start2 4 :end2 10 :start1 71 :end1 80 :test #'char=) 77)
		(= (mismatch a "This result is the index within" :start1 2 :end1 50 :from-end t :test #'char=) 19)
		(= (mismatch a "This result is the index within" :start1 2 :end1 49 :from-end t :test #'char=) 49)
		(= (mismatch "This result is the index within" a :start2 2 :end2 49 :from-end t :test #'char=) 31)
	  )
	)
)

(do-test "test mismatch 2"
	(let ((a '( #c(1 2) #c(2 4) #c(-3 20) #c(-2 -2) #c(0 0) #c(3 7) #c(-1 -9) #c(4 -5) #c(-3 3) #c(1 3) #c(1 1))  ))
		;;
		;;        0        1       2          3       4       5        6         7        8        9      10
		;;
		(and (eq (mismatch a (copy-seq a) :test #'equal) nil)
			(= (mismatch  '(#c(10 0) #c(-3 7) #c(-11 -9) #c(40 -5)) a :start2 4 :key #'imagpart) 4)

			(= (mismatch  a '(#c(10 0) #c(-3 7) #c(-11 -9) #c(40 -5)) :end1 8 :from-end t :key #'imagpart) 4)

			(= (mismatch  a '(#c(3 10) #c(-4 30) #c(-1 -10))          :start1 7 :key #'realpart :test #'>) 10)

			(= (mismatch  '(#c(-2 -2) #c(4 -5) #c(-8 0)) a            :from-end t :key #'realpart
														 :test-not #'(lambda (x y) (= (signum x) (signum y)))) 2)

			(= (mismatch  '(#c(-2 -2) #c(4 -5) #c(-8 0)) a            :from-end t :key #'realpart :end2 10 
														 :test-not #'(lambda (x y) (= (signum x) (signum y)))) 0)

			(= (mismatch  a '(#c(-2 -2) #c(4 -5) #c(-8 0))            :from-end t :key #'realpart :end1 10  
														 :test-not #'(lambda (x y) (= (signum x) (signum y)))) 7)
			
			(eq (mismatch  a '(#c(0 10) #c(3 7) #c(-1 -9) #c(4 -55))  :start2 1 :end2 3 :start1 5 :end1 7 :test #'equal) nil)
		)
	)
)
STOP

		