;;
;; Function To Be Tested: defvar
;;
;; Source:        CLtL p. 68 
;; Chapter 5: program structure       Section 3.2: Declaring global variables and named constants
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date:  Nov. 7, 86
;;
;; Last Update:   Nov. 7, 86 
;;
;; Filed As:      {eris}<lispcore>cml>test>5-3-2-defvar.test
;;
;;
;; Syntax: defvar NAME [INITIAL-VALUE [DOCUMENTATION]]               
;;
;; Function Description: defvar is the recommended way to declare the use of a special variable in a program
;;					(defvar variable) proclaims variable to be special, and my perform other system-dependent 
;;					bookkeeping actions. If a second "argument" is supplied, (defvar variable initial-value)
;;					then variable is initialized to the result of evaluating the form initial-value unless it 
;;					already has a value. The initial-value form is not evaluated unless it is used. defvar also 
;;					provides a good place to put a comment describing the meaning of the variable.  The value 
;;					returned is the name declared.
;;					
;;
;; Argument(s):  name - a variable
;;			  initial-value - a lisp form
;;			  documentation - a string        	
;;
;; Returns: NAME             
;;

(do-test "test defvar - test case copied from page 68 of CLtL"
		(makunbound '*visible-window-defv1*)
		(defvar *visible-window-defv1* 0 "Number of window-defv1 at least partially visible on the screen")
		(and (zerop *visible-window-defv1*)
			(equal (documentation '*visible-window-defv1* 'variable) 
				  "Number of window-defv1 at least partially visible on the screen")
			(setq *visible-window-defv1* 1)
			(defvar *visible-window-defv1* 0)
			(= *visible-window-defv1* 1) ; initial value should not take effect since var is already defined
		)
)

(do-test "test defvar - defvar proclaims variable to be a special 0"
	(= 	
		 (catch 'cat 
				(defvar *defv2* (gcd 10 12))
				(let ( (*defv2* (lcm 10 12)) )
					(throw 'cat (locally (declare (special *defv2*)) (1+ *defv2*)))
				))
		  61))

(do-test-group ( "test defvar - defvar proclaims variable to be a special 1"
		:before (progn 
					(defvar *defv3* 789)
					(defun foo ()
						(let ( (y 100))
							(defun fun  () (let ((y 20)) (fun1) ))
							(defun fun1 () y)
							(fun)  ))

					(defun foo2 ()
						(let ()
							(defun fun  () (let ((*defv3* 20)) (fun1) ))
							(defun fun1 () (locally (declare (special *defv3*)) *defv3*) )
							(fun)  ))
			   ))
	(do-test "test defvar - defvar proclaims variable to be a special 1"
		(and 
			(= (foo) 100)
			(= (foo2) 20)
			(= *defv3* 789)
		)
	)
)


(do-test  "test defvar - The initial-value form is not evaluated unless the variable is used."

	(let ((k 0)) 
		(progn (proclaim '(special *reshaped-window-defv8*))
			  (setq *reshaped-window-defv8* 7)
			  (defvar *reshaped-window-defv8* (incf k))
			  (equal (list *reshaped-window-defv8* k) '(7 0))
		)
	)
)

(do-test "test defvar - with documentation"
		
  (progn

	(defvar *shrinked-window-defv12* (cos 0) "number of shrinked window-defv12")
	(equal (list (documentation '*shrinked-window-defv12* 'variable)
			   (1+ *shrinked-window-defv12*)
			   (documentation '*shrinked-window-defv12* 'variable) )
		 '("number of shrinked window-defv12" 2.0 "number of shrinked window-defv12") )
  )
)

(do-test "test defvar - the value returned by defvar is the name declared"
	(and
		(eq (defvar var1 1) 'var1)
		(eq (defvar var3 3 "str3") 'var3)
	)
)
STOP
