;; Function To Be Tested: subtypep
;; Subtypep not implemented 19 September
;;
;; Source:        CLtL p. 72
;;
;; Chapter 6: Predicates		Section 2-1: General Type Predicates
;;
;; Created By:    Greg Nuyens and Peter Reidy
;;
;; Creation Date: 17 September 86
;;
;; Last Update:   15 December 86
;;
;; Filed As:      {eris}<lispcore>cml>test>6-2-1-subtypep.test
;;
;; Syntax: sybtypep type1 type2
;;            
;; Function Description: Tells if type1 is a subtype of type2.
;;
;; Argument(s): type1, type2 - any valid cml types 
;;
;; Returns: two values, the result of the test and the degree of certainty.  T T indicates that type1 is definitely a subtype of type2.  NIL T indicates that it definitely isn't.  NIL NIL indicates that the function could not determine the relation between the types.            
;;
(do-test-group subtypep-group
	:before
	(progn
		(test-defun subtest (type1 type2 expected-result expected-certainty)
			(let ((vals-list (multiple-value-list (subtypep type1 type2))))
				(and	(eq expected-result (car vals-list))
					(eq expected-certainty (cadr vals-list))
					(= 2 (length vals-list))
				)  ; and
			)  ; let
		)  ; test-defun
		(deftype arbitrary () '(or simple-vector compiled-function))
	)  ; progn
;;
	(do-test "every type is subtypep itself"
		(every #'(lambda (type) (subtest type type t t))
			'(arbitrary atom bignum bit bit-vector character common compiled-function complex cons double-float fixnum float function hash-table integer keyword list long-float null number package pathname  ratio rational readtable sequence short-float simple-array simple-bit-vector simple-string simple-vector single-float standard-char stream string string-char symbol t vector)
		)  ; every
	)  ; do-test
;;
	(do-test "subtypep: proper subtypes are subtypes"
		(and
;; Try some standard types.
			(every #'(lambda (type) (subtest type type t t))
				'(integer fixnum number atom t)
			)
			(every #'(lambda (type) (subtest type type t t))
				'(bit-vector vector array sequence t)
			)
;; It doesn't work in reverse.
			(notany #'(lambda (type) (subtest type type nil t))
				'(atom number fixnum integer)
			)
		)
	)
;;
	(do-test "subtypep with a user-defined OR types"
		(and
			(subtest 'simple-vector 'arbitrary t t)
			(subtest 'arbitrary 'simple-vector nil t)
;; Not sure what's supposed to happen here.
			(subtest 'arbitrary '(or vector function) t t)
		)  ; AND
	)  ; do-test proper-subtypep-test
;;
	(do-test "subtypep with AND types"
		(and
			(subtest 'float '(and symbol float) nil t)
			(subtest '(and symbol float) 'float t t)

		)
	)
;;
	(do-test "subtypep with defstruct"
		(defstruct t-super a)
		(defstruct (t-root (:include t-super)) b)

		(deftype deft-root () 't-root)
		(deftype deft-super () 't-super)
		(and
			(subtest 't-root 't-super t t)
			(subtest 't-super 't-root nil t)
			(subtest 'nil 't-super t t)
			(subtest 't-root 'nil nil t)
			
			(subtest 'deft-root 't-super t t)
			(subtest 't-root 'deft-super t t )
			(subtest 'deft-root 'deft-super t t)
		)
	)
;;
	(do-test "subtypep with null intersection"
	;; and-t-float-t-super has a null intersection, so nothing should ever be a subtype of it.
		(deftype and-t-float-t-super () '(and float t-super))
		(deftype and-t-float-t-root () '(and float t-root))
		(and					
			(subtest 't-super 'and-t-float-t-super nil t)
			(subtest 'float 'and-t-float-t-super nil t)
			(subtest 't-root 'and-t-float-t-super nil t)
			(subtest 'deft-root 'and-t-float-t-super nil t)
			(subtest 'deft-super 'and-t-float-t-super nil t)
	;; on the other hand, it can be detected as the subtype of many things
			(subtest 'and-t-float-t-super 't-super t t)
			(subtest 'and-t-float-t-super 'float  t t)
			(subtest 'and-t-float-t-super 't-root  nil nil)
			(subtest 'and-t-float-t-super 'deft-root  nil nil)
			(subtest 'and-t-float-t-super 'deft-super  t t)
			(subtest 'and-t-float-t-root  't-super t t)
			(subtest 'and-t-float-t-root  't-root t t)
			(subtest 'and-t-float-t-root  'deft-super t t)			
		) ; and
	)
;;
	(do-test "subtypep with unknown disjunct"
		(deftype t-unknown () '(satisfies god-knows-what-partial-recursive-function))
		(and
			(subtest '(or (satisfies gkwprf) float) 'float nil nil)
			(subtest '(or t-unknown float) 'float nil nil )
			(subtest '(or float t-unknown) 'float nil nil)
			(subtest '(or t-unknown float) 't-unknown nil nil)
			(subtest '(or float t-unknown) 't-unknown nil nil)
		)
	)
;;
	(do-test "subtypep with non-subtypep disjunct"
		(and
			;; if we know that some disjunct is not a subtype, then the union isn't either.
			(subtest '(or t-root float) 'float nil t)
			;; however, if both disjuncts are known to be sub-types, then it is known to be true
			(subtest '(or float float) 'float t t)
			;; if none is known, we still aren't sure since the union may be a partition of the first type.
			(subtest 'float '(or t-unknown (satisfies gkwprf)) nil nil)
			(subtest 'float '(or float t-unknown) t t)
			(subtest 'float '(or t-unknown float) t t)
		)
	)
;;
	(do-test "subtypep with arrays"
		(and
			(subtest '(simple-array t ) '(array t ) t t)
			(subtest '(simple-array t ) '(simple-array t ) t t)
			
			(subtest '(simple-string 10) 'array t t )
			(subtest 'array '(simple-string *) nil t)
			
			(every #'(lambda (type) (subtest type 'array t t)) '(simple-string simple-bit-vector simple-vector string bit-vector (vector t) vector simple-array))
		)
	)
;;
	(do-test "subtypep with assorted types"
		(and
			(subtest '(integer 0 5) '(integer -1 5) t t )
			(subtest '(float 0.0 3.0) '(number -132412341234 13212341234) t t)
			(subtest '(number -132412341234 13212341234) '(float 0.0 3.0) nil t)
			(subtest 'fixnum 'integer t t )
			(subtest 'fixnum '(number 0 3) nil t)
			(subtest 'fixnum 'number t t)
			(subtest 'fixnum '(number 0 3) nil t)
			(subtest 'fixnum '(number 0 *) nil t)
			(subtest 'bignum 'number t t)
			(subtest '(float 3.0 4.0) '(float 2.9 4.1) t t )
			(subtest '(float 3.0 4.0) 'number t t)
			(subtest 'complex '(number * *) t t )
			(subtest 'ratio 'rational t t )
			(subtest 'string-char 'character t t)
			(subtest 'character 'string-char nil t)
			(subtest 'standard-char 'character t t)
			(subtest 'hash-table 'readtable nil t)
			(subtest 'random-state 'common t t)
			(subtest 'common 'random-state nil t)
			(and (deftype unknown () '(satisfies something-or-other))
			     (subtest 'unknown 'stream nil nil)
			     (subtest 'stream 'unknown nil nil))
			(subtest 'function 'compiled-function nil t)
		)
	)
)  ; do-test-group
STOP

