;; Function To Be Tested: arrayp
;;
;; Source:        CLtL p. 76
;;
;; Chapter 6: Predicates		Section 2-2: Specific Data Type Predicates
;;
;; Created By:    Peter Reidy
;;
;; Creation Date: 26 September 86
;;
;; Last Update: Feb 4, 1987 Jim Blum - fixed to run on the SUN
;;
;; Filed As:      {eris}<lispcore>cml>test>6-2-2-arrayp.test
;;
;; Syntax: arrayp object
;;            
;; Function Description: Returns non-nil iff object is an array, and NIL otherwise.
;;
;; Argument(s):	object any cml object 
;;
;; Returns:  non-nil or NIL            
;;
(do-test-group arrayp-group
	:before
	(progn
		(test-defun arrayptest (object &optional (expected-value nil))
			"See if the predicate is true or false of object, depending on expected-value; see if (arrayp object) <=> (typep object 'array) for any object; see that an array's dimensions are non-nil."
			(let ((val (arrayp object)))
				(and
					(cond
						(expected-value val)
						(t (null nil))
					)  ; cond
					;; Equivalent to typep...array
					(eq val (typep object 'array))
		;; If it's an array, functions on arrays won't break.
					(cond
						(expected-value
						;;Each dimension of object (as counted by (array-rank object) should return a non-nil value to (array-dimension object dimension).  Acknowledgements to Karin Sye.
						 (and  
						 	(mapcar #'(lambda (rank) (array-dimension object rank)) (do ((rank 0 (1+ rank)) (y nil (append y (list rank)))) ((= rank (array-rank object)) y)))
		;; More thanks to Karin.
							(mapcar #'(lambda (func) (funcall func object)) (list #'array-rank #'array-dimensions #'array-total-size))
						 )  ; and
						)  ; expected-value
		;; Non-arrays get this one for free.
						(t t)
					)  ; cond
		 			)  ; and
			)  ; let
		)  ; test-defun
		(test-setq type-examples (list
				(make-array '(3 3) :displaced-to (make-array '(4 3))) ; array
				(gentemp)			; atom
				(1- most-negative-fixnum) ; bignum
				0				; bit
				'#*1001			; bit-vector
				#\backspace		; character
				'common			; common
				#'cons			; compiled-function
				#c( 6/7 3.00)		; complex
				'( a b c . d)		; cons
				5.00				; double-float
				(random most-positive-fixnum) ; fixnum
				(coerce most-negative-fixnum 'float) ; float
				#'(lambda nil nil)	; function
				(make-hash-table)	; hash-table
				4761				; integer
				:mot-de-clef		; keyword
				'(list)			; list
				37e5				; long-float
				t				; nil
				(eq 1 2)			; null
				3.1415926535897932384d0 ; number
				(car(list-all-packages))	; package
				(pathname nil)			; pathname
				*random-state*		; random state				
				27/60				; ratio
				5				; rational
				(copy-readtable)	; readtable
				'(A 'B "C")		; sequence
				6.25				; short-float
				(make-array '(2 2))	; simple-array
				'#*1001			; simple-bit-vector
				"twine"			; simple-string
				(make-array 50 :initial-element 0) ; simple-vector
				.001				; single-float
				#\*				; standard-char
				(make-synonym-stream nil) ; stream
				(make-array 20 :element-type 'string-char :initial-element #\0) ; string
				#\.				; string-char
				(gentemp)			; symbol
				(not (equal 2 3))	; t
				'#( 5 4 3 2 1)		; vector
			)  ; list
			types '(array atom bignum bit bit-vector character common  compiled-function complex cons float fixnum float function hash-table integer keyword list float t null number package pathname random-state ratio rational readtable sequence short-float simple-array simple-bit-vector simple-string simple-vector single-float standard-char stream string string-char symbol t vector)
		)  ; test-setq
	)  ; progn
;;
	(do-test arrayp-with-arrays-of-all-types-test
	;; See that an array of any element type is an array
		(every #'(lambda (object) (arrayptest object t))
			(mapcar	#'(lambda (type element)
				(make-array (list (1+ (random 5)) (1+ (random 5)) (1+ (random 5))) :element-type type :initial-element element)
				)  ; lambda
			types type-examples
			)  ; mapcar
		)  ; every
	)  ; do-test arrayp-with-arrays-of-all-types-test
;;
	(do-test arrayp-with-strings-test 
	;; Every string is an array
		(every #'(lambda (object) (arrayptest object t))
			(list
				"array atom bignum bit bit-vector character  compiled-function complex cons double-float fixnum   hash-table integer keyword list long-float null number  pathname random-state ratio rational readtable sequence short-float simple-array simple-bit-vector simple-string simple-vector single-float standard-char stream string string-char symbol t vector"
				(symbol-name '|array atom bignum bit bit-vector character  compiled-function complex cons double-float fixnum   hash-table integer keyword list |)
				(make-string (random 100) :initial-element #\backspace)
			)  ; list
		)  ; every
	)   ; do-test arrayp-with-strings-test 
;;		
	(do-test arrayp-with-symbols-test
	;; No symbol is an array.
		(every 'arrayptest
			(list	
				(make-symbol "(make-array 20)")
				(make-symbol (make-string 20 :initial-element #\Newline))
				(aref (make-array '(2 2 2) :element-type 'symbol :initial-contents '(((a b)(c d))((e f)(g h)))) (random 2)(random 2)(random 2))
			)  ; list
		)  ; every
	)  ; do-test arrayp-with-symbols-test
;;
	(do-test arrayp-with-lists-test
	;; No list is an array.
		(every 'arrayptest
			(list	
				(list (list 1 2 3) (list 4 5 6) (list 7 8 9))
				(aref (make-array '(2 2 2) :initial-contents '((((list 1 2) (list 3 4))((list 5 6) (list 7 8)))(((list 9 10) (list 11 12))((list 13 14) (list 15 16))))) (random 2)(random 2)(random 2))
				'(make-array 20)
			)  ; list
		)  ; every
	)  ; do-test arrayp-with-lists-test
)  ; do-test-group
STOP


