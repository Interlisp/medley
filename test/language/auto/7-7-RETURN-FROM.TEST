;; Function To Be Tested: return-from
;;
;; Source:        CLtL    Section 7-7-Blocks and Exits        Page: 120
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: Oct. 13 ,1986
;;
;; Last Update:   Oct. 13 ,1986
;;
;; Filed As:      {eris}<lispcore>cml>test>7-7-return-from.test
;;
;;
;; Syntax:                return-from NAME [RESULT]
;;
;; Function Description:  return-from is used to return from a block or from such constructs as do and prog that
;;				     implicitly establish a block.  The name is not evaluated and must be a symbol.  A block
;;					construct with the same name must lexically enclose the occurrence of return-from ; 
;;					whatever the evaluation of result produces is immediately returned from the block.
;;
;; Argument(s):           NAME   - a smbol
;;					RESULT -  a lisp form
;;
;; Returns:               anything   
;;


(do-test "test return-from for BLOCK -  the name is not evaluated and must be a symbol"
	(and
		(=      (block abc 		(return-from abc 2)) 2)
		(=      (block |m & m| 	(return-from |m & m| 20)) 20)
		(eq     (block nil  		(return-from nil t)) t)
		(eq     (block t    		(return-from t 'hi)) 'hi)
		(equal  (block first\ name  (return-from first\ name '(first name))) '(first name))
		(equalp (block 3.14159\s0   (return-from 3.14159\s0 #\p)) #\P)
	)
)

(do-test "test return-from for BLOCK - whatever the evaluation of result produces is immediately returned from the block"
  (let (a)
	(and 
		(=		(block blk			2 (return-from blk 11) 22 33 44) 11)
		(eq       (block blk 		2 (return-from blk ) 22 33 44) nil)
		(= 		(block |abc|         (setq a 0) (incf a 2) (return-from |abc| a) (incf a 3)) 2) 
		(equal	(block \@			(setq a nil) (push 11 a) (push 22 a) (return-from \@ a) (push 33 a)) '(22 11))
	)
  )
)

(do-test "test return-from for BLOCK - be sure multiple-values are returned properly"
	(and
		(equal 	(multiple-value-list (block blk1 (return-from blk1 (values 1 2 3 4 5)))) '(1 2 3 4 5))
		(equal 	(multiple-value-list (block blk2 (return-from blk2 (values-list '(5 4 3 2 1))))) '(5 4 3 2 1))
	)
) 

(do-test "test return-from for BLOCK - nested return-forms"
	(macrolet ((fun (x)
			 `(cons 0 (block blk0 (return-from blk0 (cons 1 (block blk1 (return-from blk1 
			  (cons 2 (block blk2 (return-from blk2 (cons 3 (block blk3 (return-from blk3 
			  (cons 4 (block blk4  (return-from ,x 9)))))))))))))))  ))
		     (and
				(equal (fun blk0) '(0 . 9))
				(equal (fun blk1) '(0 1 . 9))
				(equal (fun blk2) '(0 1 2 . 9))
				(equal (fun blk3) '(0 1 2 3 . 9))
				(equal (fun blk4) '(0 1 2 3 4 . 9))
			)
	)
)

(do-test "test return-from for DO"
		(and 	(equal (multiple-value-list 
						(do (( a 0 (1+ a)) (b nil (append b (list a))))
							((= a 10) nil)
							(if (= (length b) 5) (return-from nil (values-list b)))))
				  '(0 1 2 3 4))

			(equal  (multiple-value-list 
						(do (( a 0 (1+ a)) (b nil (append b (list a))))
							((= a 10) (values-list b))))
				  '(0 1 2 3 4 5 6 7 8 9))
		)
)

(do-test "test return-from for DO*"
		(and 	(equal (multiple-value-list 
						(do* (( a 0 (1+ a)) (b nil (append b (list a))))
							((= a 10) nil)
							(if (= (length b) 5) (return-from nil (values-list b)))))
				  '(1 2 3 4 5))

			(equal  (multiple-value-list 
						(do* (( a 0 (1+ a)) (b nil (append b (list a))))
							((= a 10) (values-list b))))
				  '(1 2 3 4 5 6 7 8 9 10))
		)
)

(do-test "test return-from for DOLIST"
	(let (a b)
		(and
			(equal (multiple-value-list 
						(dolist  (y '(1 2 3 4 5 6)) (push y a) (when (= y 4) (return-from nil (values-list a))))) 
				  '(4 3 2 1))

			(equal (dolist (y '(0 a b 3 d e 7 g h 8 ) b) (if (numberp y) (setq b (cons y b))))
				  '(8 7 3 0))
		)
	)
)

(do-test "test return-from for DOTIMES"
	(let ((a 0) (b 20))
		(and
			(= (dotimes (x 10) (incf a x)  (unless (< a  10) (return-from nil a))) 10)
			(= (dotimes (x 8 b)  (decf b x) ) -8)
		)
	)
)
	
(do-test "test return-from for PROG"
	(and
		(equal (prog ((a 1) (b 2) (c 3) (d 4)) (return-from nil (list a b d c))) '(1 2 4 3))
		(equal (prog () (return-from nil (concatenate 'string "asd" "qwe" "zxc"))) "asdqwezxc")
	)
)

(do-test "test return-from for PROG*"
	(and
		(equal (prog* ((a 1) (b 2) (c (+ a b)) (d (- a b))) (return-from nil (list a b d c))) '(1 2 -1 3))
		(equal (prog* () (return-from nil (concatenate 'string "asd" "qwe" "zxc"))) "asdqwezxc")
	)
)

;; [Masinter]  4-Sep-86
;; at AAAI, James Meehan of Cognitive Systems mentioned that this definition of TAGBODY uncovered a serious bug in 
;; the Lucid Common Lisp compiler. Can anyone turn this into a test case for return-from?
;;
(do-test-group ( "test return-from for macro defined TAGBODY-GO"
			  :before (test-defmacro  
						tagbody1 (&rest rest)
  							(labels
  							 ((parse (tail &aux (rest (member-if #'atom (cdr tail))))
       							(if tail (cons (cons (gensym) (ldiff tail rest)) (parse rest)))))
  							 (let ((name (gensym))
       							 (bodies (parse (cons (gensym) rest))))
   							 `(block ,name
    							  (macrolet ((go1 (tag)
                 							  `(return-from ,(car (find tag ',bodies :key 'cadr))
																				nil)))
       							 (labels
          								,(maplist
           								 #'(lambda (tail)
             									`(,(caar tail) ()
                  									,@(reduce #'(lambda (body tag)
                                									 `((block ,(car tag) ,@body)
                                   									(return-from ,name (,(car tag)))))
                           					 				bodies
                           									:initial-value
                            									`(,@(cddar tail)
                              									,(if (cdr tail)
                                 									 `(return-from ,(caadr tail) nil)
						   									 `(return-from ,name nil) )))))
           									 bodies)
           									(,(caar bodies))))))))  )
	(do-test "test return-from in tagbody1 0"
		 (let (a)
			(eq (tagbody1 
						 t1 (setq a (cons "t1" a))  (go1 t33) 
						 t2 (setq a (cons "t2" a))
						 (go1 done)
					t33   t3 (setq a (cons "t3" a))
						 t4 (setq a (cons "t4" a))
						 t5 (setq a (cons "t5" a))  (go1 t77)
						 t6 (setq a (cons "t6" a))
					t7   t77 (setq a (cons "t7" a))
						 t8 (setq a (cons "t8" a))
						 t9 (setq a (cons "t9" a))
						 t10 (setq a (cons "t10" a)) (go1 t2)
						done (setq a (cons "done !!" a))  )  nil)
			
			(equal a '("done !!" "t2" "t10" "t9" "t8" "t7" "t5" "t4" "t3" "t1"))
		)
	)

	(do-test "test return-from in tagbody1 1"

		(flet ((fun (items elt)
			   (let (a)
					(tagbody1 (catch 'stuff
								(mapcar #'(lambda (x) (if (numberp x) x 
														(progn (push x a) (go1 lose))))
							    			items)
							)
						lose
							(nconc a '(is not a number))
					)
				(equal a (append (list elt) '(is not a number)))  
			  )
		 	))
		 	(and (fun '(1 2 3 #\q) #\q)
			 	(fun '(10 20 "st" "fre") "st")
		 	)
		)
	)
)

STOP
				


