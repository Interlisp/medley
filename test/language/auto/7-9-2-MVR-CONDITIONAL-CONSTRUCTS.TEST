;; Functions To Be Tested: IF, AND, OR, and COND
;;
;; Source:     CLtL    
;; Section 	7.9.2: Rules Governing the Passing of Multiple Values
;; Page: 		137-138
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: August 5,1986
;;
;; Last Update:   August 5,1986
;;
;; Filed As:      {eris}<lispcore>cml>test>7-9-2-mvr-conditional-constructs.test
;;
;;
;; Syntax:                [not applicable]
;;
;; Description: It is often the case that the value of a special form or macro call is defined to be the value of one of
;;			its subforms.  For example, the value of a COND is the value of the last form in the selected clause.
;;			In most such cases, if the subform produces multiple values, then the original form will also produce 
;;			all of those values.  This passing back of multiple values of course has no effect unless eventually one
;;			of the special forms for receiving multiple values is reached.
;;			To be explicit, multiple values can result from a special form under precisely these circumstances: 
;;
;;
;; Conditional constructs
;;
;; . IF passes back multiple values from whichever subform is selected (the  THEN form or the ELSE form).
;; . AND  and OR pass back multiple values from the last subform but not from subforms other than the last
;; . COND passes back multiple values from the last subform of the implicit PROGN of the selected clause. if, however,
;;   the clause selected is a singleton clause, then only a single value (the non-nil predicate value) is returned.  This is
;;   true even if the singleton clause is the last clause of the COND.  It is not permitted to treat a final clause (x)
;;   as being the same as (t x) for this reason; the latter passes back multiple values from the form x.
;;
(do-test "test IF - forms *do* return multiple values when they *should* "
	(and	(equal (multiple-value-list (if nil nil (values 3 -5 7 -9))) '(3 -5 7 -9))
		(equal (multiple-value-list (if t (values 2 -6 40 9) (values 9 40 -6 2))) '(2 -6 40 9))
		(equal (multiple-value-list (if (evenp (values 3 8))
									(floor 3 8) (floor 8 3))) '(2 2))
		(equal (multiple-value-list (if (zerop (1- -1)) (if (evenp 33) (values 7 8 9) (values 17 18 19))
											(if (oddp 157) (values -9 -8 -7) (values -4 -3 -2))))
			 '(-9 -8 -7))
	)
)
(do-test "test IF - forms *don't* return multiple values when they *shouldn't* "
	(and (eq (if nil nil t) 't)
		(eq (if t (values 3) 55) 3)
		(equal (if 'non-nil '(foo) '(bar)) '(foo))
		(equalp (if () 2.1 3.0) 3)
	)
)
(do-test "test IF - exactly one value is used, if forms are passed as an argument to a function call"
	(prog2	(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	(eq    (foo (if t (values 'a 'b 'c) 99)) 'a)
				(equal (foo (if nil 10 (values "pot" "cup" "brush"))) "pot")
				(eq    (foo (if t (values-list '(30 300 3000 30000)))) 30)
				(equal (foo (if t (values-list '( (neck . body) (rosette . sound-hole) (metal . plastic))))) '(neck . body))
			)
	)
)
(do-test "test IF - use MULTIPLE-VALUE-LIST for receiving multiple vlaues"
	(and (equal (multiple-value-list (if nil nil (values #\1 #\2 #\3 #\4))) '(#\1 #\2 #\3 #\4))
		(equal (multiple-value-list (if t (values 'value0 '(value1) '((value2)) 'value3) (values 9 40 -6 2))) 
			  '(value0 (value1) ((value2)) value3))
	)
)
(do-test "test IF - when exactly 'n' multiple values are expected, test for n-1, n,and n+1 numbers of values wanted"
	(and (equal ( multiple-value-bind (x y) (if t (values 10 20 30)) (list x y)) '(10 20))
		(equal ( multiple-value-bind (x y z) (if t (values 10 20 30)) (list x y z)) '(10 20 30))
		(equal ( multiple-value-bind (x y z q) (if t (values 10 20 30)) (list x y z q)) '(10 20 30 nil))
	)
)
(do-test "test IF - when forms are used for effect"
	(and	(eq (progn (if t nil (floor 5 3)) 'prognn) 'prognn)
		(equal (progn (if t (truncate 30 4)) 'end-of-IF) 'end-of-IF)
	)
)

(do-test "test AND - forms *do* return multiple values when they *should* "

	(and 	(equal (multiple-value-list (and 1 2 3 (values 11 22 33))) '(11 22 33))
		(equal (multiple-value-list (and 11 (values 'a 'b 'c 'd) (values 'e 'f 'g 'h 'i))) '(e f g h i))
		(equal (multiple-value-list (and 'foo1 'foo2 'foo3 t (truncate 123 10))) '(12 3))
		(equal (multiple-value-list (and (>= 2 1) (= 2.0 2) (< 1 90) (floor 43 3))) '(14 1))
	)
)
(do-test "test AND - forms *don't* return multiple values when they *shouldn't* "

	(and (equal (and 1 2 3 4 5 6) 6)
		(equal (and (member 'a '(d a n c e)) (= 3 (car '(3 6 9)))) t)
		(equal (and (evenp 10) (oddp 33) (zerop 0) (cons (floor 4 3) nil)) '(1))
		(equal (and 'a 'b 2 3 () 4 5 'c 'd) ())
	)
) 
(do-test "test AND - exactly one value is used, if forms are passed as an argument to a function call"
	(prog2	(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and (eq (foo (and  (values 11 22 33 44))) 11)
				(eq (foo (and  1 3 6 7 (truncate 50 3))) 16)
				(equal (foo (and "star" "moon" "sun" (values "tree" "rock" "grass"))) "tree")
				(equal (foo (and '(1 (2)) '((3) 4) (values-list '((5 (6)) (7 . 8))))) '(5 (6)))
			)
	)
)
(do-test "test AND - when exactly 'n' multiple values are expected, test for n-1, n,and n+1 numbers of values wanted"

	(and (equal (multiple-value-bind (x y z) (and 1 3 4 5 (values 5 4 3 2)) (list x y z)) '(5 4 3))
		(equal (multiple-value-bind (x y z p) (and 1 3 4 5 (values 5 4 3 2)) (list x y z p)) '(5 4 3 2))
		(equal (multiple-value-bind (x y z p q) (and 1 3 4 5 (values 5 4 3 2)) (list x y z p q)) '(5 4 3 2 nil))
	)
)
(do-test "test AND - when forms are used for effect"
	(and (eq    (and (floor 4 2) (ceiling 8 3) (+ 2 3.4) (1- 34)) 33)
		(equal (and (values-list (list "a" "b" "c")) "end of AND") "end of AND")
	)
)

(do-test "test OR - forms *do* return multiple values when they *should* "

	(and	
		(equal (multiple-value-list (or (values 'foo1 'foo2 'foo3 'foo4))) '(foo1 foo2 foo3 foo4))
		(equal (multiple-value-list (or nil nil (ffloor 10 3))) '(3.0 1))
		(equal (multiple-value-list (or () () (fceiling  9.5))) '(10.0 -0.5))
		(equal (multiple-value-list (or nil (not t) (values-list '(the house was ransacked))))
			 '(the house was ransacked))
		
	)
)
(do-test "test OR - forms *don't* return multiple values when they *shouldn't* "

	(and	;;  OR won't pass back multiple values from subforms which is not the last one
		;;
		(equal (multiple-value-list (or () (cdr '(1)) (truncate 234 100) 99)) '(2))
		(equal (multiple-value-list (or (null 'a) (listp 'a) (values-list '(atom a)) (endp '(())) )) '(atom))
		(equal (multiple-value-list (or (progn (setq a 120 b 8) (floor a b)) (ceiling a b) (* a b))) '(15))
		;;
		(equal (or 'foo) 'foo)
		(eq    (or (member 'z '(a b c)) (values (floor 34 11))) 3)
		(equal (or (null '(())) (cons (floor 45 10) nil) (endp ())) '(4))
		(eq    (or (intersection '(1) '(2)) (cdr '(2)) (eq 2 2.0)) nil)
	)
)
(do-test "test OR - exactly one value is used, if forms are passed as an argument to a function call"

	(prog2	(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and (eq    (foo (or (values 1 2 3 4  54))) 1)
				(equal (foo (or (truncate 10000 999) (* 10000 999) (+ 10000 999))) 10)
				(equal (foo (or (tailp '(a) '(b a c)) (values-list '("Mozart" "Beethoven" "Bach")) (find #\q "quit")))
					  "Mozart")
				(equal (list (floor 57 7)) '(8))
			)
	)
)
(do-test "test OR - when exactly 'n' multiple values are expected, test for n-1, n,and n+1 numbers of values wanted"

	(and (equal ( multiple-value-bind (w x y z) (or (zerop (1- 2)) (values 10 20 30 40 50 )) (list w x y z)) 
			 '(10 20 30 40))
		(equal ( multiple-value-bind (v w x y z) (or (zerop (1- 2)) (values 10 20 30 40 50 )) (list v w x y z)) 
			 '(10 20 30 40 50))
		(equal  ( multiple-value-bind (u v w x y z) (or (zerop (1- 2)) (values 10 20 30 40 50 )) (list u v w x y z)) 
			 '(10 20 30 40 50 nil))
	)
)
(do-test "test OR - when forms are used for effect"
	(and (equal (progn (setq a 10) (or (and (decf a 3) nil) (floor a 2)) (list a)) '(7))
		(equal (progn (or (truncate 200 45) (floor 200 35)) "end-of-or") "end-of-or")
	)
)

(do-test "test COND - forms *do* return multiple values when they *should* "
	(and (equal (multiple-value-list 	(cond ( (= 1 3) 13)
									 ( (= 2 2.0) (values 2 2.0 22.0 220))
									 ( t 'true)))
			 '(2 2.0 22.0 220))
		(equal (multiple-value-list 	(cond ( nil 'fail1)
									 ( (and nil t) 'fail2)
									 ( (or nil t) (values "transfer" "repeat" "* #"))))
			 '("transfer" "repeat" "* #"))
		(equal (multiple-value-list	(cond ( (equal #\a #\A) (values 'char 'equal))
									 ( (equal 2.0 2) (values 'number 'equal))
									 (t  (values 'pick-up 'sta.speed 'hold 'forward))))
			 '(pick-up sta.speed hold forward))
	)
)
(do-test "test COND - forms *don't* return multiple values when they *shouldn't* "	

	(and	(equal (multiple-value-list	(cond ( (equal #\a #\A) (values 'char 'equal))
									 ( (equal 2.0 2) (values 'number 'equal))
									 ( (values 'pick-up 'sta.speed 'hold 'forward))))
			 '(pick-up ))
		(equal (multiple-value-list    (cond ( () 10)
									 ((floor 100 9))
									 (t (* 100 9))))
			  '(11))
		(equal (multiple-value-list    (cond ( (values 9 8) 77)
									 ('non-nil   'true)))
			  '(77))
		(equal (multiple-value-list    (cond ( (= 2 3) (values 2 3))
									 ( (= 4 5) (values 4 5))
									 ( (> 5 9) (values 5 9))))
			  '(()))
	)
)
(do-test "test COND - exactly one value is used, if forms are passed as an argument to a function call"

	(prog2	
		(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
		(and (eq    (foo  (cond ( (= 1 3) 13)
					        ( (= 2 2.0) (values 2 2.0 22.0 220))
				             ( t 'true)))
				  2) 
			(equal (foo (cond ( nil 'fail1)
					        ( (and nil t) 'fail2)
					        ( (or nil t) (values "transfer" "repeat" "* #"))))
				  "transfer") 
			(equal  (identity (cond (nil) (t (values-list '(time and tide wait for no one))) (last '(2 3))))
				   'time)
			(equal (list (cond (t (values (floor 8 3) (floor 9 4)))) 3 8 )
				   '(2 3 8))
		)
	)
)
(do-test "test COND - when exactly 'n' multiple values are expected, test for n-1, n,and n+1 numbers of values wanted"
	(and (equal (multiple-value-bind (a b c) (cond (nil 'dummy1)
										 ((= #5r110 30) (values (truncate 99 8) (truncate 88 77)
													 	    (truncate 77 2) (truncate 44 3))))
									(list a b c))
			'(12 1 38))
		(equal (multiple-value-bind (a b c d) (cond (nil 'dummy1)
										 ((= #5r110 30) (values (truncate 99 8) (truncate 88 77)
													 	    (truncate 77 2) (truncate 44 3))))
									(list a b c d))
			'(12 1 38 14))
		(equal (multiple-value-bind (a b c d e) (cond (nil 'dummy1)
										 ((= #5r110 30) (values (truncate 99 8) (truncate 88 77)
													 	    (truncate 77 2) (truncate 44 3))))
									(list a b c d e))
			'(12 1 38 14 nil))
	)
)
(do-test "test COND - when forms are used for effect"
	(and (equal (progn (setq a 5 b 20) (cond ((= 5.0 (gcd a b)) (values (incf a 3) (incf b 2))) (t nil)) (list a b))
			 '(8 22))
		(equal (progn (setf a "dance" b "music" c nil d nil)
				    (multiple-value-bind (c d) (cond ((find #\s a) (values a  b))
				          						 ((find #\u b) (values  b  a))
											 (t (values "????" " !!!!!")))
			  								(concatenate 'string d c))
			  )
			   "dancemusic")
	)
)
STOP