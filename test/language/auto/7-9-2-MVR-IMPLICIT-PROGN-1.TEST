;; Functions To Be Tested:  DEFUN , DEFMACRO, EVAL-WHEN, PROGV, LET , LET* , MULTIPLE-VALUE-BIND
;;
;; Source:     CLtL    
;; Section 	7.9.2: Rules Governing the Passing of Multiple Values
;; Page: 		137
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: August 7,1986
;;
;; Last Update:  Feb 5, 1987 Jim Blum - many changes to make this pass on
;;				the SUN
;; Filed As:      {eris}<lispcore>cml>test>7-9-2-MVR-IMPLICIT-PROGN-1.test
;;
;;
;;
;; Description: It is often the case that the value of a special form or macro call is defined to be the value of one of
;;			its subforms.  For example, the value of a COND is the value of the last form in the selected clause.
;;			In most such cases, if the subform produces multiple values, then the original form will also produce 
;;			all of those values.  This passing back of multiple values of course has no effect unless eventually one
;;			of the special forms for receiving multiple values is reached.
;;			To be explicit, multiple values can result from a special form under precisely these circumstances: 
;;
;;
;;
;; Implicit PROGN contexts
;;
;; . The special form PROGN passes backs multiple values resulting from evaluation of the last subform. Other situations
;;   referred to as "implicit progn," where several forms are evaluated and the results of all but the last form are
;;   discarded, also pass back multiple values from the last form.  These situations include the body of a lambda-expression,
;;   in particular those constructed by DEFUN, DEFMACRO, and DEFTYPE.  Also included are bodies of the constructs EVAL-WHEN,
;;   PROGV, LET, LET*, WHEN, UNLESS, BLOCK, MULTIPLE-VALUE-BIND, and CATCH, as well as clauses in such conditional constructs
;;   as CASE,TYPECASE,ECASE,ETYPECASE, CCASE, and CTYPECASE.
;;
;;
(do-test "test DEFUN - forms *do* return multiple values when they *should* "

	(and (defun fun1 () (values 1 2 3 4 5 6 7 8 9 10))
				(equal (multiple-value-list (fun1)) '(1 2 3 4 5 6 7 8 9 10))

			(defun fun2 (x) (values-list (list 1 2 3 4 5 6 7 8 9 10 11 12 131 14 15 x))
				(equal (multiple-value-list (fun2 888)) '( 1 2 3 4 5 6 7 8 9 10 11 12 131 14 15 888)))

		(defun fun3 (x y &rest z) (values x y z (decode-float 16.0)))
				(equal (multiple-value-list (fun3 10 20 "mvr")) '(10 20 ("mvr") .5 ))

		(defun fun4 (x &optional (y 99) &rest z ) (values (floor x y) z (list x y) )
				(equal (multiple-value-list (fun4 98 100 'm 39 'n 38)) '(0 (m 39 n 38)  (98 100))))
	)
)

(do-test "test DEFUN - forms *don't* return multiple values when they *shouldn't* "

	(and (defun fun1 () (cond (nil (floor 4 2)) ((ffloor 4 2)) ))
				(equal (multiple-value-list (fun1)) '(2.0))

		(defun fun2 (x &optional (y 2) (z 30.0)) (values (list x (expt x y) (decode-float z))))
				(equal (multiple-value-list (fun2 8 )) '((8 64 .9375))  )
	
		(defun fun3 (x y z) (or nil () (values (* y z) (+ y z)) (- y z)))
				(equal (multiple-value-list (fun3 2 4 6)) '(24))

			(defun fun4 (&rest z) (values-list (list z)))
				(equal (multiple-value-list (fun4 'software 'quality 'assurance)) '((software quality assurance)))
	)
)

(do-test "test DEFUN - exactly one value is used, if forms are passed as an argument to a function call"
  
			(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	(eql (foo (progn (defun fun () (decode-float -8.0))
							    (fun)))
					  .5)
				(equalp  (foo (progn (defun fun1 (x y z) (and (values x y z)))
							      (fun1 #\a #\b #\c)))
						#\A)
				(equal   (cons (progn (defun fun2 (w x y z) (or (values-list (list w x y z))) )
								  (fun2 "a" "b" "c" "d") ) nil)
						'("a")) 
				(equal   (find (progn (defun fun1 (x y z) (and (values x y z)))
							      (fun1 #\z #\b #\c)) "lazy")
						#\z)
			)
  
)

(do-test "test DEFUN - when exactly 'n' multiple values are expected, test for n-1, n,and n+1 numbers of values wanted"

	(defun fun () (values-list '(zebar monkey dragon deer rabit snake bird turtle sqirrel elephant)))
	(and (equal ( multiple-value-bind (a b c d e f g h i) (fun) (list a b c d e f g h i) ) 
			 '(zebar monkey dragon deer rabit snake bird turtle sqirrel))
		(equal ( multiple-value-bind (a b c d e f g h i j) (fun) (list a b c d e f g h i j) ) 
			 '(zebar monkey dragon deer rabit snake bird turtle sqirrel elephant))
		(equal ( multiple-value-bind (a b c d e f g h i j k) (fun) (list a b c d e f g h i j k) ) 
			 '(zebar monkey dragon deer rabit snake bird turtle sqirrel elephant nil))
	)
  
)

(do-test "test DEFUN - when forms are used for effect"
	(and (eq (progn  (defun fun (&key a b) (values a b)) 
				  (multiple-value-setq (c d) (fun :a 3 :b 6))
				  (+ c d))
			9)
		(equal (progn  (defun fun1 (a &optional (b 30) &rest rest &key c d) (values a b rest c d))
				     (multiple-value-bind (s t1 u v w x y z) (fun1 10 11 :d 14 :c 13) (list s t1 u v w x y z)))
			  '(10 11 (:d 14 :c 13) 13 14 nil nil nil ))
	)
)

(do-test "test DEFMACRO - forms *do* return multiple values when they *should* "

	(and 	(defmacro mac () `(ftruncate 7.5))
		(equal (multiple-value-list (mac)) '(7.0 .5))  
		
		(defmacro mac (w x y z) (list 'values w x y z  ))
		(equal (multiple-value-list (mac 1 2 3 4))
					  '(1 2 3 4))  

		(defmacro mac () `(block bar (return-from bar (values #o111 #b1111 #x-11))))
		(equal (multiple-value-bind (a b c d e) (mac) (list a b c d e))  '(73 15 -17 nil nil))  

		(defmacro mac (m n o) `((lambda (a b &rest c) (values-list (list a b c)))  ,m ,n ,o))
		(equal (multiple-value-list (mac (complex 3 4) (realpart #c(3 4)) (imagpart #c(3 4)) ))
					  '(#c(3 4) 3 (4))  ) 
	)
)

(do-test "test DEFMACRO - exactly one value is used, if forms are passed as an argument to a function call"
 (defmacro mac1 () `(ftruncate 7.5)) 
(defmacro mac2 (w x y z) (list  'values w x y z  ))
(defmacro mac3 () `(block bar (return-from bar (values #o111 #b1111 #x-11))))
(defmacro mac4 (m n o) `((lambda (a b &rest c) (values-list (list a b c)))  ,m ,n ,o))
(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	(=     (foo (progn  (mac1) )) 
					  7.0)
				(equal (foo (progn 
							    (mac2 (find #\a "chiao") ( expt #c(2 -2) 2) #b-1010 '|good earth|))) 
					  #\a)
				(equal (cons (progn 
								(mac3) ) nil)
					  '(73))
				(equal (identity (progn 
							  	    (mac4 (complex 3 4) (realpart #c(3 4)) (imagpart #c(3 4)) )) )
					  #c(3 4))
			)
  
)

(do-test "test EVAL-WHEN - forms *do* return multiple values when they *should* "

	(and (equal (multiple-value-list (eval-when (eval) (values 1 2 3 4))) '(1 2 3 4))
		(equal (multiple-value-list (eval-when (eval) (floor -8.0)))  '(-8 .0))
		(equal (multiple-value-list (eval-when (eval) (values-list '(Morning has broken just like)))) 
			 '(Morning has broken just like) )
		(equal (multiple-value-list (eval-when (eval) (decode-float 16.0))) '(.5 5 1.0))
	)
)

(do-test "test EVAL-WHEN - exactly one value is used, if forms are passed as an argument to a function call"

			(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	(=  (foo (eval-when (eval) (values 1 2 3 4)))  1)
				(=  (foo (eval-when (eval) (floor -8.0))) -8)
				(eq (foo (eval-when (eval) (values-list '(Morning has broken just like)))) 'Morning)
				(=  (foo (eval-when (eval) (decode-float 16.0))) .5)
			)
  
)


(do-test "test PROGV - forms *do* return multiple values when they *should* "

	(and (equal (multiple-value-list (progn  (setq aa 'a bb 'b a 0 b 1)
									(progv (list aa bb) (list 88 99 111) (values a b))  ))
			 '(88 99))

		(equal (multiple-value-list (progn 	(setq foo 'f bar 'b rah  'r f nil b nil r nil)
									(progv (list foo bar rah) '(to all those who) (values-list (list foo bar rah f b r))) ))
			 '(f b r to all those))

		(equal (multiple-value-list (let () (setq foo 'oo bar 'ar rah 'ah)
									(progv (cons foo (cons bar (cons rah nil))) '(#c(1 -1) #c(2 -2) #c(3 -3))
										  (values (* oo ah) (+ ah ar) (- ar oo) (list foo bar rah))) ))
			 '( #c(0 -6) #c(5 -5) #c(1 -1) (oo ar ah)) )

		(equal (multiple-value-list (progn	(defun fun (a b) (progv (list a b) '(prince frog) 
												 	   (values a b (symbol-value a) (symbol-value b) )))
									(setq foo 'f bar 'b f nil b nil)
									(fun foo bar)  ))
			 '( f b prince frog))
	)
)

(do-test "test PROGV - exactly one value is used, if forms are passed as an argument to a function call"

			(defun fool (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	(prog2 (setq aa 'a bb 'b a 0 b 1)
					  (= (fool (progv (list aa bb) (list 88 99 111) (values a b))  )  88) )

				(prog2 (setq foo 'f bar 'b rah  'r f nil b nil r nil)
					  (eq (fool (progv (list foo bar rah) '(to all those who) (values-list (list foo bar rah f b r))) )
						 'f) )

				(prog2  (setq foo 'oo bar 'ar rah 'ah)
					   (= (fool (progv (cons foo (cons bar (cons rah nil))) '(#c(1 -1) #c(2 -2) #c(3 -3))
										  (values (* oo ah) (+ ah ar) (- ar oo) (list foo bar rah)))  )
					   #c(0 -6) ))

				(progn   (defun fun (a b) (progv (list a b) '(prince frog) 
												 	   (values a b (symbol-value a) (symbol-value b) )))
					    (setq foo 'f bar 'b f nil b nil)
					    ( eq (fool (fun foo bar)) 'f ) )
			)
  
)
				
		
							 

(do-test "test LET - forms *do* return multiple values when they *should* "

	(and (equal (multiple-value-list 
				(let ()	(values-list (make-list (1- multiple-values-limit) :initial-element 'rah))))
			  (append (make-list (- multiple-values-limit 31) :initial-element 'rah)
					(make-list 30 :initial-element 'rah)) )
		
		(equal (multiple-value-list 
				(let ((size 80))	(values-list (make-list size :initial-element 'rah))))
			  (append (make-list (- 80 30) :initial-element 'rah)
					(make-list 30 :initial-element 'rah)) )

		(equal (multiple-value-list (let ((a 100.9) (b 3)) (values (fround a) (fround b) (decode-float (float b)))))
			  '(101.0 3.0 .75))
		
		(equal (multiple-value-list (let ((a 100) (b 50) (c -30)) 
								  (multiple-value-call #'values (floor a 3) (floor b 30) (floor c 2))))
			  '(33 1 1 20 -15 0))
	)
)

(do-test "test LET - forms *don't* return multiple values when they *shouldn't* "

	
		(and 	(equal (let ((a "a") (b "b") (c "c")) (cond (nil 'atom) ((values-list (list a b c )))))
				  "a")
			(equal (let () (setq a '(2) b '(4))
						(or nil () (values a b) t 'non-nil))
				 '(2)) 
			(equal (cons (let () (fceiling 39 7)) nil)
				  '(6.0))
		)
)

(do-test "test LET* - forms *do* return multiple values when they *should* "

	(and 
		(equal (multiple-value-list 
				(let* ((size 80))	(values-list (make-list size :initial-element 'rah))))
			  (append (make-list (- 80 30) :initial-element 'rah)
					(make-list 30 :initial-element 'rah)) )

		(equal (multiple-value-list (let* ((a 100.9) (b 3)) (values (fround a) (fround b) (decode-float (float b)))))
			  '(101.0 3.0 .75))
		
		(equal (multiple-value-list (let* ((a 100) (b 50) (c -30)) 
								  (multiple-value-call #'values (floor a 3) (floor b 30) (floor c 2))))
			  '(33 1 1 20 -15 0))
	)
)

(do-test "test LET* - forms *don't* return multiple values when they *shouldn't* "

	
		(and 	(equal (let* ((a "a") (b "b") (c "c")) (cond (nil 'atom) ((values-list (list a b c )))))
				  "a")
			(equal (let* () (setq a '(2) b '(4))
						(or nil () (values a b) t 'non-nil))
				 '(2)) 
			(eq    (let* 	(x (y 2) (z 9))
						(values (values x y z)))
				  ())
			(equal (cons (let* () (fceiling 39 7)) nil)
				  '(6.0))
		)
)

(do-test "test MULTIPLE-VALUE-BIND - forms *do* return multiple values when they *should* "

	(and 	(equal (multiple-value-list 
					(multiple-value-bind () nil (values-list (make-list 20))))
			 (append (make-list 10) (make-list 10)))
		
		(equal (multiple-value-list
					(multiple-value-bind (a b c d) (decode-float -10.0) (values a b c d)))
			  '(.625 4  -1.0 nil))
		
		(equal (multiple-value-list
					(multiple-value-bind (a b c d e f) 
						(values-list '(dopey sneezy sleepy bashful grouchy doc witch))
						(values a b c d e f)  ))
			  '(dopey sneezy sleepy bashful grouchy doc ))
		
		(equal (multiple-value-list
					(multiple-value-bind () (values-list '(sleepy sneezy doc snow white witch))
									(values-list '(blue sky red apple squirrel rabbit broom dwarf))))
			  '(blue sky red apple squirrel rabbit broom dwarf))
	)
)

(do-test "test MULTIPLE-VALUE-BIND - forms *don't* return multiple values when they *shouldn't* "

	(and (eq		(multiple-value-bind (a b c) (decode-float 300.0)) ())
		(eql		(multiple-value-bind (m n o) (decode-float -6.0) (prog1 (values o n m) m n)) -1.0)
		(eql		(multiple-value-bind () t (values (decode-float (float #o-10)))) .5)
		(eq 		(multiple-value-bind (a b) (values 'dopey 'jumpy) 
							(cond ((values-list (list b a)))))
				'jumpy)
	)
)
STOP

 

				


				

