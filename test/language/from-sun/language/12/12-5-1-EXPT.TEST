;; Function To Be Tested: EXPT
;;
;; Source: Guy L Steele's CLTL
;; Section: 12.5.1 Exponential and Logarithmic Functions
;; Page: 203
;;
;; Created By:    Kelly Roach
;;
;; Creation Date: July 12,1986
;;
;; Last Update:   July 21, 1986, masinter, make it not require exact results
;;
;; Filed As:      {ERIS}<LISPCORE>CML>TEST>12-5-1-EXPT.TEST
;;
;;
;; Syntax:        (EXPT BASE-NUMBER POWER-NUMBER)
;;
;; Function Description:
;; Returns BASE-NUMBER raised to the power POWER-NUMBER.
;; If the BASE-NUMBER is of type RATIONAL and the POWER-NUMBER is
;; an integer,
;; the calculation will be exact and the result will be of type RATIONAL;
;; otherwise a floating-point approximation may result.
;; 
;; When POWER-NUMBER is 0 (a zero of type integer),
;; then the result is always the value one in the type of BASE-NUMBER,
;; even if the BASE-NUMBER is zero (of any type).  That is:
;; 
;;     (EXPT X 0) = (COERCE 1 (TYPE-OF X))
;;     
;; If the POWER-NUMBER is a zero of any other data type,
;; then the result is also the value one, in the type of the arguments
;; after the application of the contagion rules, with one exception:
;; it is an error if BASE-NUMBER is zero when the POWER-NUMBER
;; is a zero not of type integer.
;; 
;; Implementations of EXPT are permitted to use different algorithms
;; for the cases of a rational POWER-NUMBER and a floating-point
;; POWER-NUMBER; the motivation is that in many cases greater accuracy
;; can be achieved for the case of a rational POWER-NUMBER.
;; For example, (EXPT PI 16) and (EXPT PI 16.0) may yield
;; slightly different results if the first case is computed by repeated squaring
;; and the second by the use of logarithms.  Similarly, an implementation
;; might choose to compute (EXPT X 3/2) as if it had
;; been written (SQRT (EXPT X 3)), perhaps producing a more accurate
;; result than would (EXPT X 1.5).  It is left to the implementor
;; to determine the best strategies.
;; 
;; The result of EXPT can be a complex number, even when neither argument
;; is complex, if BASE-NUMBER is negative and POWER-NUMBER
;; is not an integer.  The result is always the principal complex value.
;; Note that (EXPT -8 1/3) is not permitted to return -2;
;; while -2 is indeed one of the cube roots of -8, it is
;; not the principal cube root, which is a complex number
;; approximately equal to #C(0.5 1.73205).
;; 
;; Argument(s):   BASE-NUMBER - a number
;;                POWER-NUMBER - a number
;;
;; Returns:       a number
;;



(do-test expt-test
         (flet ((closep (x y) (< (abs (- x y)) (* .00001 (/ (+ (abs x) (abs y)) 2)))))
		(and (= (expt 1233 0) 1)
              (= (expt 0 5) 0)
              (closep (expt 28.8 0) 1)
              (closep (expt -2 9) -512)
              (closep (expt 3 4) 81)
              (closep (expt 2 -1) 0.5)
              (closep (expt 10000 0.25) 10.0)
              (closep (expt (/ 3 4) 2) 0.5625))))

STOP
