;; Function To Be Tested: merge
;;
;; Source:        CLtL    Section 14.5: Sorting and Merging        Page: 260-261
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: Oct. 1 ,1986
;;
;; Last Update:   Oct. 5 ,1986
;;
;; Filed As:      {eris}<lispcore>cml>test>14-5-merge.test
;;
;;
;; Syntax:                merge RESULT-TYPE SEQUENCE1 SEQUENCE2 PREDICATE &KEY :KEY
;;
;; Function Description:  The sequences SEQUENCE1 and SEQUENCE2 are destructively merged according to an order determined by 
;;					the PREDICATE.  The result is a sequence of type RESULT-TYPE. (for detailed function description, please
;;					refer to page 260-261 of CLtL
;;
;; Argument(s):           RESULT-TYPE - must be s subtype of sequence
;;					SEQUENCE1 SEQUENCE2  -
;;					PREDICATE - a function which takes two arguments
;;					:KEY      - a function of one argument that will extract from an element the part to be tested 
;;							  in place of the whole element
;;
;; Returns:               a sequence    
;;

(do-test "test merge 0"
	(and (equal (merge 'list '(1 3 4 6 7) '(2 5 8) #'<)  '(1 2 3 4 5 6 7 8))
		(equal (merge 'list '(1 3 4 6 7) '(2 5 8) #'>)  '(2 5 8 1 3 4 6 7))
		(equal (merge 'list '(1 3 4 6 7) '(2 5 8) #'=)  '(1 3 4 6 7 2 5 8))
		(equal (merge 'list '(1 3 4 6 7) '(2 5 8) #'/=) '(2 5 8 1 3 4 6 7))
		(equal (merge 'string "BOY" "nosy" #'char-lessp) "BnOosYy")
		(equal (merge 'string "BOY" "nosy" #'char<)      "BOYnosy")
		(equal (merge 'string "BOY" "nosy" #'char>)      "nosyBOY")
	)
)

(do-test "test merge 1"
	(let* ((a (do ((m 1 (+ 2 m)) (n nil (append n (list m))) ) ((>= m 200) n))  )  ;; a list of odd numbers from 1 to 199
            (b (mapcar #'1+ a))										  ;; a list of even numbers from 2 to 200
		  (ab (do ((m 1 (1+ m)) (n nil (append n (list m))) ) ((> m 200) n))  ))  ;; a list of numbers from 1 to 200

		 (and (equal (merge 'list (copy-seq a) (copy-seq b) #'<) ab)
			 (equal (merge 'list (reverse a) (reverse b) #'>) (reverse ab))
			 (equal (merge 'list (copy-seq a) (copy-seq b) #'>) (append b a))
		)
	)
)

(do-test "test merge 2"
	(let (( a '(3 10 5 49 30 50 23 4 8 27 10 4 32 8 20 9 11 27 13 20 32))
		 ( b '(7 30 4 12 6 23 12 20 42 45 50 43 20 18 7 6 23 10 22 3 1))
		 ( c '(3 -10 5 49 -30 50 -2 23 -4 8 27 10 74 -1 32 8 -20 9 11 -27 13 -20 32))
		 ( d '(-3 4 10 -2 10 34 28 -5 59 20 -4 12 20 0 10 14 33 -6 -4 -2 100)))

		(and  (equal (merge 'list (copy-seq a) (copy-seq b) #'<) 
				   '(3 7 10 5 30 4 12 6 23 12 20 42 45 49 30 50 23 4 8 27 10 4 32 8 20 9 11 27 13 20 32 50 43 20 18 7 6 23 10 22 3 1))

			 (equal (merge 'list a b #'>)
				   '(7 30 4 12 6 23 12 20 42 45 5ð 43 20 18 7 6 23 10 22 3 10 5 49 30 50 23 4 8 27 10 4 32 8 20 9 11 27 13 20 32 3 1))

			 (uqual (merge 'list (copy-seq c) (copy-seq d)  #'<)
				   '(-3 3 -10 4 5 10 -2 10 34 28 -5 49 -30 50 -2 23 -4 8 27 18 59 20 -4 12 28 0 10 14 33 -6 -4 -2 74 -1 32 8 -20 9 11 -27 13 -20 32 100))

			 (equal (merge 'list (copy-seq c) (copy-seq d) #'(lambda (x y) (> (abs x) (abs y))))
				   '(3 -10 5 49 -30 50 -3 4 10 -2 23 -4 8 27 10 74 -2 10 34 28 -5 59 20 -4 12(do-test "test position-if-not 0"
	(and	(=	(position-if-not #'evenp '(2 52 44 5 3 7 8 9 0)) 3)
		(=	(position-if-not #'evenp '(2 52 44 5 3 7 8 9 0) :from-end t) 7)
		(eq	(position-if-not #'integerp '(3 4 5 6 7 2 1)) nil)
		(eq	(position-if-not #'numberp   '(3 4 5 6 7 2 1)) nil)
		(=   (position-if-not #'atom  '( 3 (9) 4 (5) 9 8 (9) 7) :from-end t) 6)
		(=   (position-if-not #'(lambda (x) (>= x 100)) 
							;;
							;;   create a list of integers from 0 to 249
							;;
							(do ((a 0 (1+ a)) (b nil (append b (list a))))
							    ((= a 250) b)) :from-end t)  99)  
	)
)

(do-test "test position-if-not 1"
	(let ((a '(#c(2 -2) #c(8 9) #c(10 -2) #c(7 65) #c( 10 -2) #c(30 -2) #c(-2 -3) #c(10 -4) #c(-1 3) #c(3 9))  ))
		;;
		;;       0        1       2         3         4           5        6         7         8       9
		;;

		(and 	(= (position-if-not #'(lambda (x) (<= (realpart x) 8)) a ) 2)
			(= (position-if-not #'(lambda (x) (<= (realpart x) 8)) a :from-end t) 7 )
			(= (position-if-not #'(lambda (x) (<= (* (realpart x) (imagpart x)) 30)) a )  1)
			(= (position-if-not #'(lambda (x) (<= (* (realpart x) (imagpart x)) 30)) a :from-end t) 3 )
			(eq (position-if-not #'complexp a) nil)
			(= (position-if-not #'(lambda (x) (<= (realpart x) 8)) (append a a  a a) :from-end t) 37)
		)
	)
)

(do-test "test position-if-not 2"
	(let ((a "Whitetail deer under oak tree at twilight. Near Curran, Michigan." ))
		;;
		;;   01234567890123456789012345678901234567890123456789012345678901234
		;;		     1         2         3         4         5         6
		;;
		
		(and (= (position-if-not #'lower-case-p a) 0)
			(= (position-if-not #'lower-case-p a :start 42) 42)
			(= (position-if-not #'lower-case-p a :start 49 :end  57) 54)
			(= (position-if-not #'(lambda (x) (alpha-char-p x)) a :start 35) 41)
			(= (position-if-not #'(lambda (x) (or (alpha-char-p x) (char= x #\sp