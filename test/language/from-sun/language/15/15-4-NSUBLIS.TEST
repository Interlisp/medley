;; Function To Be Tested: NSUBLIS
;;
;; Source: Guy L Steele's CLTL
;; Section: 15.4 Substitution of Expressions
;; Page: 274
;;
;; Created By:    Karin M. Sye
;;
;; Creation Date: Aug. 15, 1986
;;
;; Last Update:   Aug. 15, 1986
;;
;; Filed As:      {ERIS}<LISPCORE>CML>TEST>15-4-NSUBLIS.TEST
;;
;;
;; Syntax:        (NSUBLIS ALIST TREE &KEY TEST TEST-NOT KEY)
;;
;; Function Description:
;; NSUBLIS makes substitutions for objects in a tree (a structure of conses). The first argument to NSUBLIS is an 
;; association list.  The second argument is the tree in which substitutions are to be made, as for SUBST.
;; NSUBLIS looks at all subtrees and leaves of the tree; if a subtree or leaf appears as a key in the association
;; list (that is, the key and the subtree or leaf satisfy the test), it is replaced by the object it is associated
;; with.  This operation is non-destructive.  In effct, NSUBLIS can perform several SUBST operations simultaneously.
;; NNSUBLIS is like NSUBLIS but destructively modifieds the relevant parts of the tree.
;;
;; Argument(s):   LIST - an association list
;;                TREE - a tree
;;                TEST - a function
;;                TEST-NOT - a function
;;                KEY - a function
;;
;; Returns:       a tree
;;

(do-test "test nsublis - test cases copied from page 274 of CLtL"
  (and (equal (nsublis '( (x . 100) (z . zprime) )
                       '(plus x (minus g z x p) 4 . x))
              '(plus 100 (minus g zprime 100 p) 4 . 100) )

       (equal (nsublis '(((+ x y) . (- x y))  ((- x y) . (+ x y)))
                       '(* (/ (+ x y) (+ x p)) (- x y)) :test #'equal)
              '(* (/ (- x y) (+ x p)) (+ x y))  )))

(do-test "test nsublis 1"
  (and (prog2 (setq a '(>= (* x y) (+ x y) (- x y) (/ x y) ))
              (equal (nsublis '( (x . xx) (y . yy) )  a)
                     '(>= (* xx yy) (+ xx yy) (- xx yy) (/ xx yy)) ))
       (prog2 (setq a '(1 2 (2 3 4) ((3) 4) 5 6 ( 6 4 2 1)))
              (equal (nsublis '( (2 . 3) (3 . 6) (6 . 1)) a)
                     '(1 3 (3 6 4) ((6) 4) 5 1 (1 4 3 1)) ))
       (prog2 (setq a '( (#\a #\b) #\c ((#\d)) #\e))
              (equal (nsublis '((nil . 7)) a)
                     '( (#\a #\b . 7) #\c ((#\d . 7) . 7) #\e . 7)))
       (prog2 (setq a '())
              (equal (nsublis '(( nil . "empty list")) a) "empty list"))))

(do-test "test nsublis - with :TEST keyword"
  (and (prog2 (setq a '(1 2.0 3 (4.0) (5 6.0 (7.0)) (8 ((9.0)) 10)))
              (equal (nsublis '((1 . 3.0) (3.0 . 5.0) (5.0 . 7.0) (7 . 9.0) (9 . 1.0))
                              a :test #'equalp)
                     '(3.0 2.0 5.0 (4.0) (7.0 6.0 (9.0)) (8 ((1.0)) 10))))
       (prog2 (setq a '( "I" "buy" ("coke") (("lime")) "plus" ("lemon" . "banana")))
              (equal (nsublis '((#\i . "apricot") (#\e . "opium") (#\a . "coffee"))
                              a :test #'(lambda (n m) (and (stringp n) (find m n))))
                     '("I" "buy" ("opium") (("apricot")) "plus" ("opium" . "coffee"))))
       (prog2 (setq a '( ((( park . place) (small . talk) (small . 80)))
                         (park . play) ( (small . 72) ) (park . small)))
              (equal (nsublis '(((park . play) . (pool . swim))
                                ( (small . talk) . (public . speech)))
                              a :test #'equal)
                     '(((( park . place) (public . speech) (small . 80)))
                       (pool . swim) ( (small . 72) ) (park . small)) ))
       (prog2 (setq a '(2 5 7 13 27))
              (equal (nsublis '( (dummy . "star"))
                              a :test #'(lambda (y x) (and (listp y) (evenp (first y))))) 
                     "star"))))

(do-test "test nsublis - with :TEST-NOT keyword"
  (and (prog2 (setq a '(78 65 (45 ((66) 23) 121) 8 100))
              (equal (nsublis '(( 30 . "<= 30") (50 . "<= 50") (80 . "<= 80"))
                              a :test-not #'(lambda (y x) (or (listp y) (> y x))))
                     '("<= 80" "<= 80" ("<= 50" (("<= 80") "<= 30") 121) "<= 30" 100)))
       (prog2 (setq a '(1 2.0 3 (4.0) (5 6.0 (7.0)) (8 ((9.0)) 10)))
              (equal (nsublis '(((4.0) . foo)  ((9.0) . bar))
                              a :test-not #'(lambda (y x) (not (equalp x y))))
                     '(1 2.0 3 foo (5 6.0 (7.0)) (8 (bar) 10))))
       (prog2 (setq a '((John 250) (Susan 78) (Henry 140) (Kelly 115) (Mark 350)))
              (equal (nsublis '( ((Edward  200) . (Tom 214))) a :test-not #'equal)
                     '(Tom 214)))))

(do-test "test nsublis - with :KEY keyword"
  (and (prog2 (setq a '( (a b c) (1 2 3) (#\q #\w #\e) ("a" "b" "c")))
              (equal (nsublis '((b . bb) (#\w . #\p) ("b" . "bb"))
                              a :test #'equal
                              :key #'(lambda (k) (if (listp k) (second k) )))
                     '(bb (1 2 3) #\p "bb")))
       (prog2 (setq a '( (1 2 3 4) (2 3) (8 9 0 12) (1)))
              (equal (nsublis '( ( (4) . four) (  (12) . twelve))
                              a :test #'equal
                              :key #'(lambda (x) (if (listp x) (last x) '(3))))
                     '(four (2 3) twelve (1))))))

STOP
