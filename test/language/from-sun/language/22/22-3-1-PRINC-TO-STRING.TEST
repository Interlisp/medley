;; Function To Be Tested: princ-to-string
;;
;; Source:        CLtL p. 383
;;
;; Chapter 22: Input/Output		Section 3.1: Output to Character Streams
;;
;; Created By:    Peter Reidy
;;
;; Creation Date: 7 December 86
;;
;; Last Update:
;;
;; Filed As:      {eris}<lispcore>cml>test>22-3-1-princ-to-string.test
;;
;; Syntax: princ-to-string object
;;            
;; Function Description: outputs object as a string without escape characters or quotation marks.
;;
;; Argument(s):	object - a cml object
;;
;; Returns: a string containing the representation of object			 
;;
(do-test-group
	(princ-to-string-group
	:before
		(progn
			(test-setq examples (list
				(make-array '(3 5) :adjustable t) ; array
				'100.88 ; atom
				(1+ most-positive-fixnum) ; bignum
				1 ; bit
				(make-array 3 :element-type 'bit :fill-pointer 2) ; bit-vector
				#\newline ; character
				(car (list-all-packages)) ; common
				#'cons ; compiled-function
				#c(3 3) ; complex
				'(1 . 2) ; cons
				1.00 ; double-float
				#'(lambda nil 100) ; function
				(make-hash-table) ; hash-table
				100000 ; integer
				:skate ; keyword
				(cons nil nil) ; list
				2.25 ; long-float
	;;					nothing for type NIL
				nil ; null
				.4761 ; number
				*package* ; package
				*default-pathname-defaults*
				(make-random-state)
				3/4 ; ratio, rational
				(copy-readtable)
				"sequence"					
				3.33 ; short-float
				"simple array"
				(make-array 10) ; simple-vector
				.5 ; single-float
				#\5 ; standard-char
				*standard-input* ; stream
				(make-array 5 :element-type 'string-char :adjustable t) ; string
				#\  ; string-char
				'\A\ bcd\E  ; symbol
				nil ; t
				"vector"
				)  ; list
			)  ; test-setq
			(test-defun find-escape (object)
			"Look for a escape-characters in a string: at least one #\\ or  two #\|'s, at the start and end, or else #\"'s at the start and end." 
				(or
					(position #\\ object)
					(and
						(eq 0 (position #\| object))
						(eq 0 (position #\| (reverse object)))
					)  ; and
					(and
						(eq 0 (position #\" object))
						(eq 0 (position #\" (reverse object)))
					)  ; and
				)  ; or
			)  ; test-defun find-escape
			(test-defun compare (object)
			"Compare prin1-to-string with princ-to-string for a given object (symbol or string).  See that the first representation contains escape characters and the second doesn't."
				(and
					(find-escape (prin1-to-string object))
					(not (find-escape (princ-to-string object)))
				)
			)
			(test-defun princtest (object)
			"See that the output of princ-to-string for a given object is a string and, unless the object is a character, that is contains no escape characters."
				(let ((obstring (princ-to-string object)))
					(and
						(stringp obstring)
						(cond
							((not (typep object 'character))
								(not (find-escape obstring))
							)
						;; Characters get this for free.
						(t t)
						)  ; cond
					)  ; and
				)  ; let
			) ; test-defun
		)  ; progn
	)  ; princ-to-string-group
	(do-test "prin1-to-string all types"
	;; Princ-to-string an example of each of the standard types; see that it contains no escape characters.
		(every 'princtest examples)
	)  ; do-test "princ-to-string all types"
;;
	(do-test "compare prin1-to-string with princ-to-string"
		(every 'compare (list '|A
String with Upper and
Lower
Case and Linefeeds| '\123 "this is a string" (make-array (1+ (random 20)) :element-type 'string-char :initial-element #\t) 'ab\c '\a\ \b\ \c)
		)
	)  ; do-test "compare princ-to-string with princ-to-string"
)  ; do-test-group
STOP

