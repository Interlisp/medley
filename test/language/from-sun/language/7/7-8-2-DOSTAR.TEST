;; Function To Be Tested: do*
;;
;; Source:        Steele's book    
;;                Section 7.8: Iteration        
;;                Page: 122
;;
;; Created By:    Bob Bane
;;	             Henry Cate III
;;
;; Creation Date: June 26,1986
;;
;; Last Update:   June 26,1986
;;                October 20,1986 HC3/ docuemented
;;                October 27,1986 HC3/ broke into several tests 
;;			  Feb 5, 1987 Jim Blum - same changes as in "do.test" 
;;
;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-2-dostar.TEST
;;
;;
;; Syntax:        (do* {(var [init [step]])}*) (end-test {result}*)
;;                 {declaration}* {tag | statement}*)
;;
;;
;; Function Description:
;;     The initial variables are each evaluated and then bound.  
;;     Then the end-test is checked to see if can terminate.  
;;     If ok, the forms in result are evaluated, and the value of
;;     the last one is returned  If suppose to go on, loop thru
;;     the body, update the variables and start over again.
;;     The difference between DO and DO* is here DO* does the
;;     first evaluation and binds it, and then does the second
;;     evaluation and so on. 
;; 
;; 
;; 
;; Argument(s):   KEYFORM - evaluated to build a key object
;;                TYPE - a type(s) against which match keyform
;;                FORM - what is evaluated.
;;
;; Returns:       value(s) of the last evaluated form of 
;;                the selected clause
;;




;;  The first section is similar to DO

(do-test "test the simple stuff"
    (let ((x nil))
    (and
       ; do* some simple tests...
       (do* nil ((return T)))
       (catch 'looptag (do* nil ((throw 'looptag T))))
       (eq (do* nil ((return))) nil)
       (do* nil (T . (T)) nil)
       (eq (do* nil (T)) nil)
       (do* nil (T nil nil T))
       (null (do* ((x '(a b c d) (cdr x))) ((null x))))
    )))


(do-test "test returning for termination"
       ; first check can return a symbol, then a number
    (let ((sideffect nil) (x nil) (foo '(1 2 3 4)))
    (and
       (eq (do* ((x '(a b c d) (cdr x)))
              ((null x) 'nope)
              (if (eq (car x) 'c) (return 'right)
                  (setq sideffect (car x))))
           'right)
       (eq sideffect 'b)
       (eq (do* nil ((null foo) (return 1013))
             (push (pop foo) sideffect))
          1013)
       (equal sideffect '(4 3 2 1 . b))
    )))


(do-test "test returning mutiple-values"
       ; return two symbols, then three characters
    (let ((x nil))
    (and
       (equal (multiple-value-list
           (do* ((x '(a b c d) (cdr x)))
              ((null (cddr x)) (values (car x) (cadr x)))))
         '(c d))
       (equal (multiple-value-list
           (do* nil (T (values '#\y '#\9 '#\q)) nil))
          '(#\y #\9 #\q))
    )))


(do-test "test can go out of do*"
    (let ((sideffect nil) (x nil))
    (and
       (null (tagbody
          (do* ((x '(a b c d) (cdr x))) ((null x) 'nope)
            (if (eq (car x) 'c)
                (progn (setq sideffect (cons 'right x))
				   (go dotag))
                (setq sideffect (car x))))
            dotag))
       (equal sideffect '(right c d))
    )))


(do-test "test can throw a value out of do*"
    (let ((x nil))
    (and
       (equal (catch 'looptag
          (do* ((x '("a" "small" "little" "string") (cdr x)))
             ((null x) 'nope)
             (if (equal (car x) "little")
                (throw 'looptag "have a nice day"))))
          "have a nice day")
    )))


(do-test "use several different functions to stop"
    (let ((x nil))
    (and
       (equal (do* ((x '(1 2 3 4 5) (cdr x)))
            ((> (car x) 3) (car x)))
          4)
       (equal (do* ((x '(1 b "Hi" '(a b c)) (cdr x)))
            ((stringp (car x)) (car x)))
          "Hi")
       (equal (do* ((x '(1 b "Hi" '(a b c)) (cdr x)))
            ((if (symbolp (car x)) T) (car x)))
          'b)
    )))


;; Do some serial testing
;; this is different in DO


(do-test "test serial evaluation setting initial values"
    (let ((x nil))
    (and
       (do* ((x '(a b c d)) (y (cdr x)))
          (nil)
          (return (and (equal x '(a b c d)) (equal y '(b c d)))))
       (do* ((x '(a b c d)) (y (cdr x)))
          (T (and (equal x '(a b c d)) (equal y '(b c d)))))
    )))


(do-test "test serial evaluation for incrementing values"
    (let ((x nil))
       (eq (do* ((x 1 (+ x 1)) (y 2 (+ x 2)))
              ((> x 5) y))  
          8) 
    ))


(do-test "test both parallel setting and incrementing"
    (let ((sideffect nil) (x nil) (y nil))
    (and
       (eq (do* ((x '(a b c d e f) (cdr y))
          (y (cdr x) (cdr x)))
          ((or (null x) (null y)) 'done)
          (push (cons (car x) (car y)) sideffect))
         'done)
       (equal sideffect '((e . f)(c . d) (a . b)))
    )))

STOP
