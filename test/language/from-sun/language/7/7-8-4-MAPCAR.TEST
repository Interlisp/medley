;; Function To Be Tested: MAPCAR
;;
;; Source: Guy L Steele's CLTL
;; Section: 7.8-4 Mapping
;; Page: 128
;;
;; Created By:    Karin M. Sye,Kelly Roach
;;
;; Creation Date: June 27,1986
;;
;; Last Update:   June 27,1986
;;
;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-4-MAPCAR.TEST
;;
;;
;; Syntax:        (MAPCAR FUNCTION LIST &REST MORE-LISTS)
;;
;; Function Description:
;; For each these mapping functions,
;; the first argument is a function and the rest must be lists.
;; The function must take as many arguments as there are lists.
;; 
;; MAPCAR operates on successive elements of the lists.
;; First the function is applied to the CAR of each list,
;; then to the CADR of each list, and so on.
;; (Ideally all the lists are the same length; if not,
;; the iteration terminates when the shortest list runs out,
;; and excess elements in other lists are ignored.)
;; The value returned by MAPCAR is a list of the
;; results of the successive calls to the function.
;; For example:
;; 
;;     (MAPCAR #'ABS '(3 -4 2 -5 -6)) => (3 4 2 5 6)
;;     (MAPCAR #'CONS '(A B C) '(1 2 3)) => ((A . 1) (B . 2) (C . 3))
;;     
;; 
;; MAPLIST is like MAPCAR except that the function is applied to
;; the list and successive cdr's of that list rather than to successive
;; elements of the list.
;; For example:
;; 
;;     (MAPLIST #'(LAMBDA (X) (CONS 'FOO X))
;;     	 '(A B C D))
;; 
;;       => ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
;;     (MAPLIST #'(LAMBDA (X) (IF (MEMBER (CAR X) (CDR X)) 0 1)))
;;     	 '(A B A C D B C))
;;        => (0 0 1 0 1 1 1)
;;        ;An entry is 1 if the corresponding element of the input
;;        ;  list was the last instance of that element in the input list.
;;     
;; 
;; MAPL and MAPC are like MAPLIST and MAPCAR
;; respectively, except that they do not accumulate the results
;; of calling the function.
;; Compatibility note: In all Lisp systems since Lisp 1.5,
;; MAPL has been called MAP.  In the chapter on sequences

;; it is explained why this was a bad choice.  Here the name MAP
;; is used for the far more useful generic sequence mapper,
;; in closer accordance to the computer science literature,
;; especially the growing body of papers on functional programming.
;; These functions are used when the function is being called merely for its
;; side effects, rather than its returned values.
;; The value returned by MAPL or MAPC is the second argument,
;; that is, the first sequence argument.
;; 
;; MAPCAN and MAPCON are like MAPCAR and MAPLIST respectively,
;; except that they combine the results of
;; the function using function NCONC instead of LIST.  That is,
;; 
;;     (MAPCON F X1 ... XN)
;;        = (APPLY #'NCONC (MAPLIST F X1 ... XN))
;;     
;; and similarly for the relationship between MAPCAN and MAPCAR.
;; Conceptually, these functions allow the mapped function to return
;; a variable number of items to be put into the output list.
;; This is particularly useful for effectively returning zero or one item:
;; 
;;     (MAPCAN #'(LAMBDA (X) (AND (NUMBERP X) (LIST X)))
;;     	'(A 1 B C 3 4 D 5))
;; 
;;       => (1 3 4 5)
;;     
;; In this case the function serves as a filter; this is a standard Lisp
;; idiom using MAPCAN.
;; (The function function REMOVE-IF-NOT might have been useful in this
;; particular context, however.)
;; Remember that NCONC is a destructive operation, and therefore
;; so are MAPCAN and MAPCON; the lists returned by the FUNCTION
;; are altered in order to concatenate them.
;; 
;; Sometimes a DO or a straightforward recursion is preferable to a
;; mapping operation;  however, the mapping functions should be used wherever they
;; naturally apply because this increases the clarity of the code. 
;; 
;; The functional argument to a mapping function must be acceptable
;; to APPLY; it cannot be a macro or the name of a special form.
;; Of course, there is nothing wrong with using a function that has 
;; and  parameters as the functional argument.
;; 
;; Argument(s):   FUNCTION - a function
;;                LIST - a pure list
;;                MORE-LISTS - a pure list
;;
;; Returns:       a pure list
;;


;;
;;(do-test "test mapcar0 - syntax checking"
;;    (not (or (nlsetq (mapcar #'+))
;;             (nlsetq (mapcar #'- '(1 2 3) 4 5 6))
;;             (nlsetq (mapcar #'* 'a 'b 'c 'd (list 3 6 9)))
;;             (nlsetq (mapcar #'car (+ 2 3) (char-code #\a) (cons 1 2)))
;;             (prog1  nil (makunbound 'fun))
;;            (nlsetq (mapcar #'fun '(1)))
;;            (nlsetq (mapcar 'm 'n 'o 'p))
;;            (nlsetq (mapcar #'progn '(1 2))))))

(do-test "test mapcar1 - test cases copied from p128 of CLtL"
    (and (equal (mapcar #'abs '(3 -4 2 -5 -6)) '(3 4 2 5 6))
         (equal (mapcar #'cons '(a b c) '(1 2 3)) '((a . 1) (b . 2) (c . 3)))))

(do-test "test mapcar2 - sqrt & gcd"
    (and (equal (mapcar #'sqrt (list 10000 400 9 144  169 81 121 #31r100 #27r100 #17r10000)) 
                              '(100.0 20.0 3.0 12.0 13.0 9.0 11.0 31.0 27.0 289.0))
         (equal (mapcar #'gcd '(10 3 9) '(20 9 45) '(30 27 54)) '(10 3 9))))

(do-test "test mapcar3 - max & append"
    (and (equal (mapcar #'max '(10 20 30 40 50) '(1 200 3 49 5)) '(10 200 30 49 50))
         (equal (mapcar #'append  '((2 4 6) (1 3 5)) '((12 14 16) (11 13 15)))
                '((2 4 6 12 14 16)(1 3 5 11 13 15)))))


(do-test "test mapcar4 - subst & list & null"
    (and (equal (mapcar #'subst '(hat ball pink) '(chair pen blue) 
                                '((this is my chair) (that is your pen) (blue is a nice color)))
               '((this is my hat) (that is your ball) (pink is a nice color)))

         (equal (mapcar #'list '(1) '(2) `(,(+ 1 2)) (list 4) (cons 5 nil) (car '((6))) '(7) '(8) (cdr '(nil 9))
                               '(10) '(11) (list (- 14 2)) (progn '(13)) `(,#14r10) (union '(15) nil))
                '((1 2 3 4 5 6 7 8 9 10 11 12 13 14 15)))
         (equal (mapcar #'null (list t nil 'non-nil '()))  '(nil t nil t))))



(do-test "test mapcar5 - lambda list"
    (equal (mapcar #'(lambda (fn1 fn2 fn3) 
                                  (let ((x 10) (y 20))
                                       (list (funcall fn1 x y)
                                             (funcall fn2 x y)
                                             (funcall fn3 x y))))  '(+ - *) '(gcd >= cons) '(list eq min))
              '((30 10 (10 20)) (-10 nil nil) (200 (10 . 20) 10))))


 (do-test "test mapcar6 - tests with different length of lists" 
         (and (equal (mapcar #'>= '(8 20 93) '(87 -40 900 -2) '(2 81 90)) '(nil nil nil))
              (equal (mapcar #'expt '(2 4 6) '(1)) '(2))
              (eq    (mapcar #'+ '(1 2 3) '()) nil)))

STOP
