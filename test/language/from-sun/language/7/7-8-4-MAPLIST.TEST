;; Function To Be Tested: MAPLIST
;;
;; Source: Guy L Steele's CLTL
;; Section: 7.8-4 Mapping
;; Page: 128
;;
;; Created By:    Karin M. Sye, Kelly Roach
;;
;; Creation Date: June 27,1986
;;
;; Last Update:   June 27,1986
;;
;; Filed As:      {ERIS}<LISPCORE>CML>TEST>7-8-4-MAPLIST.TEST
;;
;;
;; Syntax:        (MAPLIST FUNCTION LIST &REST MORE-LISTS)
;;
;; Function Description:
;; For each these mapping functions,
;; the first argument is a function and the rest must be lists.
;; The function must take as many arguments as there are lists.
;; 
;; MAPCAR operates on successive elements of the lists.
;; First the function is applied to the CAR of each list,
;; then to the CADR of each list, and so on.
;; (Ideally all the lists are the same length; if not,
;; the iteration terminates when the shortest list runs out,
;; and excess elements in other lists are ignored.)
;; The value returned by MAPCAR is a list of the
;; results of the successive calls to the function.
;; For example:
;; 
;;     (MAPCAR #'ABS '(3 -4 2 -5 -6)) => (3 4 2 5 6)
;;     (MAPCAR #'CONS '(A B C) '(1 2 3)) => ((A . 1) (B . 2) (C . 3))
;;     
;; 
;; MAPLIST is like MAPCAR except that the function is applied to
;; the list and successive cdr's of that list rather than to successive
;; elements of the list.
;; For example:
;; 
;;     (MAPLIST #'(LAMBDA (X) (CONS 'FOO X))
;;     	 '(A B C D))
;; 
;;       => ((FOO A B C D) (FOO B C D) (FOO C D) (FOO D))
;;     (MAPLIST #'(LAMBDA (X) (IF (MEMBER (CAR X) (CDR X)) 0 1)))
;;     	 '(A B A C D B C))
;;        => (0 0 1 0 1 1 1)
;;        ;An entry is 1 if the corresponding element of the input
;;        ;  list was the last instance of that element in the input list.
;;     
;; 
;; MAPL and MAPC are like MAPLIST and MAPCAR
;; respectively, except that they do not accumulate the results
;; of calling the function.
;; Compatibility note: In all Lisp systems since Lisp 1.5,
;; MAPL has been called MAP.  In the chapter on sequences
;;
;; it is explained why this was a bad choice.  Here the name MAP
;; is used for the far more useful generic sequence mapper,
;; in closer accordance to the computer science literature,
;; especially the growing body of papers on functional programming.
;; These functions are used when the function is being called merely for its
;; side effects, rather than its returned values.
;; The value returned by MAPL or MAPC is the second argument,
;; that is, the first sequence argument.
;; 
;; MAPCAN and MAPCON are like MAPCAR and MAPLIST respectively,
;; except that they combine the results of
;; the function using function NCONC instead of LIST.  That is,
;; 
;;     (MAPCON F X1 ... XN)
;;        = (APPLY #'NCONC (MAPLIST F X1 ... XN))
;;     
;; and similarly for the relationship between MAPCAN and MAPCAR.
;; Conceptually, these functions allow the mapped function to return
;; a variable number of items to be put into the output list.
;; This is particularly useful for effectively returning zero or one item:
;; 
;;     (MAPCAN #'(LAMBDA (X) (AND (NUMBERP X) (LIST X)))
;;     	'(A 1 B C 3 4 D 5))
;; 
;;       => (1 3 4 5)
;;     
;; In this case the function serves as a filter; this is a standard Lisp
;; idiom using MAPCAN.
;; (The function function REMOVE-IF-NOT might have been useful in this
;; particular context, however.)
;; Remember that NCONC is a destructive operation, and therefore
;; so are MAPCAN and MAPCON; the lists returned by the FUNCTION
;; are altered in order to concatenate them.
;; 
;; Sometimes a DO or a straightforward recursion is preferable to a
;; mapping operation;  however, the mapping functions should be used wherever they
;; naturally apply because this increases the clarity of the code. 
;; 
;; The functional argument to a mapping function must be acceptable
;; to APPLY; it cannot be a macro or the name of a special form.
;; Of course, there is nothing wrong with using a function that has 
;; and  parameters as the functional argument.
;; 
;; Argument(s):   FUNCTION - a function
;;                LIST - a pure list
;;                MORE-LISTS - a pure list
;;
;; Returns:       a pure list
;;
(do-test "test maplist1 - test cases from page 129 of CLtL"
    (and (equal (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
               '((foo a b c d) (foo b c d) (foo c d) (foo d)))
         (equal (maplist #'(lambda (x) (if (member (car x) (cdr x)) 0 1)) '(a b a c d b c))
               '(0 0 1 0 1 1 1))))

(do-test "test maplist2 - append & first & butlast"
    (and (equal (maplist #'append (list 1 2 3 4) (cons 5 (cons 6 (cons 7 (cons 8 nil)))))
               '((1 2 3 4 5 6 7 8) (2 3 4 6 7 8) (3 4 7 8) (4 8)))
         (equal (maplist #'first '('x 'e 'r 'o 'x )) '('x 'e 'r 'o 'x))
         (equal (maplist #'butlast '(1 2 3 4 5 6 7 8)) 
               '((1 2 3 4 5 6 7) (2 3 4 5 6 7) (3 4 5 6 7) (4 5 6 7) (5 6 7) (6 7) (7) nil))))

(do-test "test maplist3 - list-length "
    (and (setq long-list (maplist #'list-length (make-list 50)))
         (= (apply #'+ long-list) (/ (* 50 51) 2))))

(do-test "test maplist4 - lambda function"
    (equal (maplist #'(lambda (x y z) (append (reverse x) (reverse y) (reverse z)))
                           `(a c e) `(b a k) `(l o p))
                  '((e c a k a b p o l) (e c k a p o) (e k p))))

(do-test "test maplist5 - tests for different length of lists"
    (and (equal (maplist #'(lambda (x y) (+ (list-length x) (list-length y))) '(1 2) '(2 3 4)) '(5 3))
         (eq    (maplist #'list `(a b c) nil)  nil)
         (equal (maplist #'cons `(a b c) `(d e)) '(((a b c) d e) ((b c) e)))))

STOP
