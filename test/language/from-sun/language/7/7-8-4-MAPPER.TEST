(do-test mapcar
	(let (sideffect)
	(and

; Simple stuff first
	(equal (mapcar #'abs '(3 -4 2 -5 -6)) '(3 4 2 5 6))
; Two lists
	(equal (mapcar #'cons '(a b c) '(1 2 3)) '((a . 1) (b . 2) (c . 3)))
; Two lists of uneven lengths
	(equal (mapcar #'cons '(a b c) '(1 2 3 4)) '((a . 1) (b . 2) (c . 3)))
; And the other way, just in case
	(equal (mapcar #'cons '(a b c d) '(1 2 3)) '((a . 1) (b . 2) (c . 3)))
; Test of (go) out of mapcar
	(null (tagbody (mapcar #'(lambda (x)
						(if (eq x 'c) (go mapcartag) (push x sideffect)))
					  '(a b c d))
				mapcartag))
	(equal sideffect '(b a))
)))

(do-test mapc
	(let (sideffect)
	(and

; Simple stuff first
	(progn (setq sideffect nil)
	(equal (mapc #'(lambda (x) (push (abs x) sideffect)) '(3 -4 2 -5 -6))
		 '(3 -4 2 -5 -6))
	)
	(equal sideffect '(6 5 2 4 3))
; Two lists
	(progn (setq sideffect nil)
	(equal (mapc #'(lambda (x y) (push (cons x y) sideffect))
			    '(a b c) '(1 2 3))
		  '(a b c))
	)
	(equal sideffect '((c . 3) (b . 2) (a . 1)))
; Two lists of uneven lengths
	(progn (setq sideffect nil)
	(equal (mapc #'(lambda (x y) (push (cons x y) sideffect))
			    '(a b c) '(1 2 3 4))
		  '(a b c))
	)
; And the other way, just in case
	(progn (setq sideffect nil)
	(equal (mapc #'(lambda (x y) (push (cons x y) sideffect))
			    '(a b c d) '(1 2 3))
		  '(a b c d))
	)
	(equal sideffect '((c . 3) (b . 2) (a . 1)))
; Testing (go) out of mapc
	(progn (setq sideffect nil)
	(null (tagbody (mapc #'(lambda (x)
						(if (eq x 'c) (go mapctag) (push x sideffect)))
					  '(a b c d))
				mapctag))
	)
)))

(do-test maplist
	(let (sideffect)
	(and

; Simple stuff first
	(equal (maplist #'(lambda (x) (cons 'foo x)) '(a b c d))
		 '((foo a b c d) (foo b c d) (foo c d) (foo d)))
; Two lists
	(equal (maplist #'cons '(a b c) '(d e f))
		 '(((a b c) d e f) ((b c) e f) ((c) f)))
; Two lists of uneven lengths
	(equal (maplist #'cons '(a b c) '(d e f g))
		 '(((a b c) d e f g) ((b c) e f g) ((c) f g)))
; Two lists of uneven lengths the other way
	(equal (maplist #'cons '(a b c foo) '(d e f))
		 '(((a b c foo) d e f) ((b c foo) e f) ((c foo) f)))
; Testing (go) out of maplist
	(null (tagbody (maplist #'(lambda (x)
						(if (eq (car x) 'c)
						    (go maplisttag) (push x sideffect)))
					  '(a b c d))
				maplisttag))
	(equal sideffect '((b c d) (a b c d)))

)))

(do-test mapl
	(let (sideffect)
	(and

; Simple stuff first
	(equal (mapl #'(lambda (x) (push (cons 'foo x) sideffect)) '(a b c d))
		 '(a b c d))
	(equal sideffect '((foo d) (foo c d) (foo b c d) (foo a b c d)))
; Two lists
	(progn (setq sideffect nil)
	(equal (mapl #'(lambda (x y) (push (cons x y) sideffect))
				'(a b c) '(d e f))
		'(a b c))
	)
	(equal sideffect '(((c) f) ((b c) e f) ((a b c) d e f)))
; Two lists of uneven lengths
	(progn (setq sideffect nil)
	(equal (mapl #'(lambda (x y) (push (cons x y) sideffect))
				'(a b c) '(d e f g))
		 '(a b c))
	)
	(equal sideffect '(((c) f g) ((b c) e f g) ((a b c) d e f g)))

; Two lists of uneven lengths the other way
	(progn (setq sideffect nil)
	(equal (mapl #'(lambda (x y) (push (cons x y) sideffect))
				'(a b c foo) '(d e f))
		 '(a b c foo))
	)
	(equal sideffect '(((c foo) f) ((b c foo) e f) ((a b c foo) d e f)))
; Testing (go) out of mapl
	(progn (setq sideffect nil)
	(null (tagbody (mapl #'(lambda (x)
						(if (eq (car x) 'c)
						    (go mapltag) (push x sideffect)))
					  '(a b c d))
				mapltag))
	)
	(equal sideffect '((b c d) (a b c d)))
)))

(do-test mapcan
	(let (sideffect)
	(and

; Simple stuff first
	(equal (mapcan #'(lambda (x) (list (abs x))) '(3 -4 2 -5 -6)) '(3 4 2 5 6))
; Two lists
	(equal (mapcan #'(lambda (x y) (list (cons x y))) '(a b c) '(1 2 3))
				'((a . 1) (b . 2) (c . 3)))
; Two lists of uneven lengths
	(equal (mapcan #'(lambda (x y) (list (cons x y))) '(a b c) '(1 2 3 4))
				'((a . 1) (b . 2) (c . 3)))
; And the other way, just in case
	(equal (mapcan #'(lambda (x y) (list (cons x y))) '(a b c d) '(1 2 3))
				'((a . 1) (b . 2) (c . 3)))
; Testing (go) out of mapcan
	(null (tagbody (mapcan #'(lambda (x)
						(if (eq x 'c)
						    (go mapcantag)
						    (progn (push x sideffect)
								 (list x))))
					  '(a b c d))
				mapcantag))
	(equal sideffect '(b a))
)))

(do-test mapcon
	(let (sideffect)
	(and

; Simple stuff first
	(equal (mapcon #'(lambda (x) (list (cons 'foo x))) '(a b c d))
		 '((foo a b c d) (foo b c d) (foo c d) (foo d)))
; Two lists
	(equal (mapcon #'(lambda (x y) (list (cons x y))) '(a b c) '(d e f))
		 '(((a b c) d e f) ((b c) e f) ((c) f)))
; Two lists of uneven lengths
	(equal (mapcon #'(lambda (x y) (list (cons x y))) '(a b c) '(d e f g))
		 '(((a b c) d e f g) ((b c) e f g) ((c) f g)))
; Two lists of uneven lengths the other way
	(equal (mapcon #'(lambda (x y) (list (cons x y))) '(a b c foo) '(d e f))
		 '(((a b c foo) d e f) ((b c foo) e f) ((c foo) f)))
; Testing (go) out of mapcon
	(null (tagbody (mapcon #'(lambda (x)
						(if (eq (car x) 'c)
						    (go mapcontag)
						    (progn (push (car x) sideffect)
								 (list x))))
					  '(a b c d))
				mapcontag))
	(equal sideffect '(b a))
)))
STOP
