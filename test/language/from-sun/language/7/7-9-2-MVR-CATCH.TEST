;;
;; funtion to be tested - catch
;;
(do-test "test CATCH - forms *do* return multiple values when they *should* "

	(and (equal (multiple-value-list  (catch 'moderato (setq a 2 b 4 d 6) (values (+ a b) (* a d)) )) 
			  '(6 12))

		(equal (multiple-value-list (catch 'adagio 
									(cond ((= #b10 #o3) (throw 'adagio1 (values 1 2 3)))
										 ((= #b10000 #x10) (throw 'adagio (values 11 22 33)))
										  (t               (throw 'adagio2 (values 0 -1 -2)))  )))
			  '(11 22 33))

		(equal (multiple-value-list (progn	(defun fun ()  (declare (special var)) 
											     (rplacd (last var) '(fun-1))
												(fun1)
												(rplacd (last var) '(fun-2))  )

									(defun fun1 ()	(declare (special var))
												(rplacd (last var) '(fun1-1))
												(throw 'trill (values var (list-length var)))
												(rplacd (last var) '(fun1-2))  )

									(defun fun0 (var) 	(declare (special var))
													(catch 'trill   (rplacd (last var) '(hi))
																(fun)
																(rplacd (last var) '(bye))  ))
									(setq buf `(hello))
									(fun0 buf)
									
							   )
			  )
			  '( (hello hi fun-1 fun1-1) 4) )
	)
)

(do-test "test CATCH - exactly one value is used, if forms are passed as an argument to a function call"
  (prog2	
			(defun foo (x) (and (equal (list x) (multiple-value-list x)) x))
			(and	 (eq (foo (catch 'summer (values 'swim 'hike 'watermelon))) 'swim)
				 (=  (foo (catch  'moderato (setq a 2 b 4 d 6) (values (+ a b) (* a d)) )) 6)
				 (equal (cons (catch 'poco  (if t (throw 'poco (values-list '((1 . 2) (3 . 4))) ))) nil) '((1 . 2)))
			)
  )
)
STOP

											