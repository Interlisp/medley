;; Regression tests for the new compiler

;; This tests not only the break-free compilation of the function, but also that
;; the cleanup forms are evaluated in the correct order wrt the body.
(do-test "AR 7335: Compiler errors on WITH-OPEN-FILE in effect context"
	(let* ((test-fn '(lambda (name)
					(let (x)
					   (when name
						(with-open-file (s name :direction :output :if-exists :new-version)
							(setq x (il:openp s))))
					   x)))
	       (compiler-result (compile nil test-fn)))
	   (and (compiled-function-p compiler-result)
	        (funcall compiler-result "{Core}Foo"))))

(do-test "AR 7338: Eliminated :CONS function without arguments breaks compiler"
	(let* ((test-fn '(lambda (x)
					(let ((a (gensym)))
					   (list x))))
	       (compiler-result (compile nil test-fn)))
	   (and (compiled-function-p compiler-result)
	        (equal '(1) (funcall test-fn 1)))))

(do-test "AR 7339: Substitution into final statement of PROGN breaks compiler"
	(let* ((test-fn '(lambda (x)
					(let* ((a x)
					       (b a))
					   (setq x 7)
					   (list b))))
	       (compiler-result (compile nil test-fn)))
	   (and (compiled-function-p compiler-result)
	        (equal '(1) (funcall test-fn 1)))))

(do-test "AR 7519: Compiler breaks on nested CATCHes"
	(let* ((test-fn '(lambda (f g)
	                    (catch 'one
	                       (catch 'two
	                          (let ((y (funcall f)))
	                             (funcall g #'(lambda nil
	                                             (case y
	                                                (one (throw 'one (list y)))
	                                                (two (throw 'two (list (list y))))
	                                                (t y)))))))))
	       (compiler-result (compile nil test-fn)))
	   (and (compiled-function-p compiler-result)
	        (equal 'zero    (funcall test-fn #'(lambda () 'zero) 'funcall))
	        (equal '(one)   (funcall test-fn #'(lambda () 'one)  'funcall))
	        (equal '((two)) (funcall test-fn #'(lambda () 'two)  'funcall)))))


;;; This test is pretty hard to do.  It wants to see if the :FILE-MANAGER-FORMAT keyword
;;; is recognized by the compiler.  The only way to do that is to see if it works.  We make
;;; a file that should, in the course of its compilation, push 1, 2 and 3 onto a list, ONLY
;;; if the file is being interpreted as a normal Common Lisp file.  We compile it saying
;;; ":file-manager-format nil" so as to override the compiler's normal inclination to treat
;;; files beginning with an open paren as File Manager files.  If we get the list we expect
;;; at the end, it must have recognized our use of the new keyword.

(do-test "AR 7378: Compiler documentation says :FILE-MANAGER-FORMAT ..."
	(progn
	   (with-open-file (s "{Core}AR7378.lisp" :direction :output)
	      (princ "(eval-when (compile) (push 1 *foo*))
	              (defun foo () (eval-when (compile) (push 2 *foo*)) 5)
	              (eval-when (compile) (push 3 *foo*))" s))
	   (let ((user::*foo* nil))
	      (declare (special user::*foo*))
	      
	      (compile-file "{Core}AR7378.lisp" :file-manager-format nil)
	      (equal user::*foo* '(3 2 1)))))


;; There was a bug in the fix to AR 7341 that caused the tagbody below not to notice that
;; any substitutions had taken place within the progn.  This led to a break.

(do-test "Test for bug in fix to AR 7341: Compiler runs forever by reordering uselessly"
	(let* ((test-fn '(lambda (y)
					(let* ((a y)
					       (b a))
					   (tagbody tag (progn (setq y b) nil))))))
	   (compiled-function-p (compile nil test-fn))))


(do-test "AR 7621: COMPILE returns non-compiled code sometimes"
	(let* ((test-fn '(lambda ()
					(foo #'(lambda (&optional a (b (bar a))) (list a b))))))
	   (compiled-function-p (compile nil test-fn))))


(do-test "AR 7754: In compiled hard-entry functions, closed-over required args are lost"
	(let* ((test-fn '(lambda (a b &rest c)
	                     (catch 1
	                        (catch 2
	                           (list a b c)))))
	       (compiled-fn (compile nil test-fn)))
	   (and (compiled-function-p compiled-fn)
	        (equal '(1 2 (3 4 5 6)) (funcall compiled-fn 1 2 3 4 5 6)))))


(do-test "AR 8016: Compiler shouldn't substitute side-effects into IF's"
     (let* ((test-fn '(lambda (x y)
                          (let* ((a (pop x))
                                 (b (if y x a)))
                             b)))
            (compiled-fn (compile nil test-fn)))
	   (and (compiled-function-p compiled-fn)
	        (equal '(2 3) (funcall compiled-fn '(1 2 3) t))
	        (equal 1      (funcall compiled-fn '(1 2 3) nil)))))


;; This qualifies as a hairy test.  We want to see if the right set of type-fixups
;; is being generated by the assembler.  Thus, we (temporarily) redefine the function
;; D-ASSEM:INTERN-DCODE to squirrel away the type-fixups list for us.

(do-test "AR 8167: Assembler allocates too little storage sometimes"
     (let* ((test-fn '(lambda (a b)
                         (foo #'(lambda () (+ (incf a) (incf b))))
                         (loop
                            (let (c d)
                               (foo #'(lambda () (+ (incf c) (incf d))))))))
            (intern-dcode-fn (symbol-function 'd-assem:intern-dcode))
            (type-fixups :foo))
        
        ;; Redefine D-ASSEM:INTERN-DCODE for a moment, just long enough to compile
        ;; the test function.
        (unwind-protect (progn (setf (symbol-function 'd-assem:intern-dcode)
                                     #'(lambda (dcode)
                                            (when (eq :foo type-fixups)
                                               (setq type-fixups
                                                     (d-assem::dcode-type-fixups dcode)))
                                            (funcall intern-dcode-fn dcode)))
                               (compile nil test-fn))

           ;;Well, that's done, so restore the old definition.
           (setf (symbol-function 'd-assem:intern-dcode)
                 intern-dcode-fn))

        ;; Now we can check that the right set of types are being used.
        (null (set-exclusive-or '(il:compiled-closure il:\\ptrhunk2 il:\\ptrhunk4)
                                (mapcar #'cadr type-fixups)))))


;; NOTE: This test fails by running forever, so it should probably be the last
;;       one in this file.
(do-test "AR 7341: Compiler runs forever by reordering uselessly"
	(let* ((test-fn '(lambda (y)
					(let* ((a (funcall y))
					       b
					       c)
					   (setq b #'(lambda (x) (+ x a)))
					   (setq c 10)
					   (funcall b c))))
	       (compiler-result (compile nil test-fn)))
	   (and (compiled-function-p compiler-result)
	        (= 17 (funcall test-fn #'(lambda () 7))))))

